Description: handle 128-bit values when native support for 128-bit integers not available
Origin: https://github.com/boostorg/atomic/commit/e04ffeb523edb6ac2c3f980878787a4112a4495c.patch
Forwarded: no
Reviewed-by: Steve Robbins <smr@debian.org>
 Note that only Parts 1 and 5 of the original patch are used as the other parts are unrelated
 fixes to Windows and ARM compilation, and to test files that aren't failing.
 Applied the two patches manually because of source tree reorganization following Boost 1.55.
 The patch is part of a commit to upstream master and thus should be already part of Boost 1.56.



--- boost1.55-1.55.0+dfsg.orig/boost/atomic/detail/cas128strong.hpp
+++ boost1.55-1.55.0+dfsg/boost/atomic/detail/cas128strong.hpp
@@ -196,15 +196,17 @@
 
 public:
     BOOST_DEFAULTED_FUNCTION(base_atomic(void), {})
-    explicit base_atomic(value_type const& v) BOOST_NOEXCEPT : v_(0)
+    explicit base_atomic(value_type const& v) BOOST_NOEXCEPT
     {
+        memset(&v_, 0, sizeof(v_));
         memcpy(&v_, &v, sizeof(value_type));
     }
 
     void
     store(value_type const& value, memory_order order = memory_order_seq_cst) volatile BOOST_NOEXCEPT
     {
-        storage_type value_s = 0;
+        storage_type value_s;
+        memset(&value_s, 0, sizeof(value_s));
         memcpy(&value_s, &value, sizeof(value_type));
         platform_fence_before_store(order);
         platform_store128(value_s, &v_);
@@ -247,7 +249,9 @@
         memory_order success_order,
         memory_order failure_order) volatile BOOST_NOEXCEPT
     {
-        storage_type expected_s = 0, desired_s = 0;
+        storage_type expected_s, desired_s;
+        memset(&expected_s, 0, sizeof(expected_s));
+        memset(&desired_s, 0, sizeof(desired_s));
         memcpy(&expected_s, &expected, sizeof(value_type));
         memcpy(&desired_s, &desired, sizeof(value_type));
 
--- boost1.55-1.55.0+dfsg.orig/boost/atomic/detail/gcc-atomic.hpp
+++ boost1.55-1.55.0+dfsg/boost/atomic/detail/gcc-atomic.hpp
@@ -958,14 +958,16 @@
 
 public:
     BOOST_DEFAULTED_FUNCTION(base_atomic(void), {})
-    explicit base_atomic(value_type const& v) BOOST_NOEXCEPT : v_(0)
+    explicit base_atomic(value_type const& v) BOOST_NOEXCEPT
     {
+        memset(&v_, 0, sizeof(v_));
         memcpy(&v_, &v, sizeof(value_type));
     }
 
     void store(value_type const& v, memory_order order = memory_order_seq_cst) volatile BOOST_NOEXCEPT
     {
-        storage_type tmp = 0;
+        storage_type tmp;
+        memset(&tmp, 0, sizeof(tmp));
         memcpy(&tmp, &v, sizeof(value_type));
         __atomic_store_n(&v_, tmp, atomics::detail::convert_memory_order_to_gcc(order));
     }
@@ -980,7 +982,8 @@
 
     value_type exchange(value_type const& v, memory_order order = memory_order_seq_cst) volatile BOOST_NOEXCEPT
     {
-        storage_type tmp = 0;
+        storage_type tmp;
+        memset(&tmp, 0, sizeof(tmp));
         memcpy(&tmp, &v, sizeof(value_type));
         tmp = __atomic_exchange_n(&v_, tmp, atomics::detail::convert_memory_order_to_gcc(order));
         value_type res;
@@ -994,7 +997,9 @@
         memory_order success_order,
         memory_order failure_order) volatile BOOST_NOEXCEPT
     {
-        storage_type expected_s = 0, desired_s = 0;
+        storage_type expected_s, desired_s;
+        memset(&expected_s, 0, sizeof(expected_s));
+        memset(&desired_s, 0, sizeof(desired_s));
         memcpy(&expected_s, &expected, sizeof(value_type));
         memcpy(&desired_s, &desired, sizeof(value_type));
         const bool success = __atomic_compare_exchange_n(&v_, &expected_s, desired_s, false,
@@ -1010,7 +1015,9 @@
         memory_order success_order,
         memory_order failure_order) volatile BOOST_NOEXCEPT
     {
-        storage_type expected_s = 0, desired_s = 0;
+        storage_type expected_s, desired_s;
+        memset(&expected_s, 0, sizeof(expected_s));
+        memset(&desired_s, 0, sizeof(desired_s));
         memcpy(&expected_s, &expected, sizeof(value_type));
         memcpy(&desired_s, &desired, sizeof(value_type));
         const bool success = __atomic_compare_exchange_n(&v_, &expected_s, desired_s, true,
