Description: finish null pointer checks
 Apply contributed patches to layout engine.
Author: Laszlo Boszormenyi (GCS) <gcs@debian.org>
Origin: upstream, https://ssl.icu-project.org/trac/changeset/37086
Reviewed-By: srl, bae, mschoene
Forwarded: not-needed
Last-Update: 2015-07-17

---

--- icu-52.1.orig/source/layout/ContextualSubstSubtables.cpp
+++ icu-52.1/source/layout/ContextualSubstSubtables.cpp
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2015 - All Rights Reserved
  *
  */
 
@@ -466,6 +466,12 @@ le_uint32 ChainingContextualSubstitution
                 const ChainSubClassRuleTable *chainSubClassRuleTable =
                     (const ChainSubClassRuleTable *) ((char *) chainSubClassSetTable + chainSubClassRuleTableOffset);
                 le_uint16 backtrackGlyphCount = SWAPW(chainSubClassRuleTable->backtrackGlyphCount);
+
+                // TODO: Ticket #11557 - enable this check, originally from ticket #11525.
+                //       Depends on other, more extensive, changes.
+                // LEReferenceToArrayOf<le_uint16>   backtrackClassArray(base, success, chainSubClassRuleTable->backtrackClassArray, backtrackGlyphCount);
+                if( LE_FAILURE(success) ) { return 0; }
+
                 le_uint16 inputGlyphCount = SWAPW(chainSubClassRuleTable->backtrackClassArray[backtrackGlyphCount]) - 1;
                 const le_uint16 *inputClassArray = &chainSubClassRuleTable->backtrackClassArray[backtrackGlyphCount + 1];
                 le_uint16 lookaheadGlyphCount = SWAPW(inputClassArray[inputGlyphCount]);
--- icu-52.1.orig/source/layout/CursiveAttachmentSubtables.cpp
+++ icu-52.1/source/layout/CursiveAttachmentSubtables.cpp
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright IBM Corp. 1998 - 2013 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998 - 2015 - All Rights Reserved
  *
  */
 
@@ -23,7 +23,7 @@ le_uint32 CursiveAttachmentSubtable::pro
     LEReferenceToArrayOf<EntryExitRecord>
         entryExitRecordsArrayRef(base, success, entryExitRecords, coverageIndex);
 
-    if (coverageIndex < 0 || coverageIndex >= eeCount) {
+    if (coverageIndex < 0 || coverageIndex >= eeCount || LE_FAILURE(success)) {
         glyphIterator->setCursiveGlyph();
         return 0;
     }
--- icu-52.1.orig/source/layout/LETableReference.h
+++ icu-52.1/source/layout/LETableReference.h
@@ -1,7 +1,7 @@
 /*
  * -*- c++ -*-
  *
- * (C) Copyright IBM Corp. and others 2013 - All Rights Reserved
+ * (C) Copyright IBM Corp. and others 2015 - All Rights Reserved
  *
  * Range checking
  *
@@ -313,7 +313,12 @@ LE_TRACE_TR("INFO: new RTAO")
   const T *getAliasRAW() const { LE_DEBUG_TR("getAliasRAW<>"); return (const T*)fStart; }
 
   const T& getObject(le_uint32 i, LEErrorCode &success) const {
-    return *getAlias(i,success);
+      const T *ret = getAlias(i, success);
+      if (LE_FAILURE(success) || ret==NULL) {
+          return *(new T(0));
+      } else {
+          return *ret;
+     }
   }
   
   const T& operator()(le_uint32 i, LEErrorCode &success) const {
--- icu-52.1.orig/source/layout/MultipleSubstSubtables.cpp
+++ icu-52.1/source/layout/MultipleSubstSubtables.cpp
@@ -1,6 +1,6 @@
 /*
  *
- * (C) Copyright IBM Corp. 1998-2013 - All Rights Reserved
+ * (C) Copyright IBM Corp. 1998-2015 - All Rights Reserved
  *
  */
 
@@ -38,6 +38,9 @@ le_uint32 MultipleSubstitutionSubtable::
     LEReferenceToArrayOf<Offset>
         sequenceTableOffsetArrayRef(base, success, sequenceTableOffsetArray, seqCount);
 
+    if (LE_FAILURE(success)) {
+        return 0;
+    }
     if (coverageIndex >= 0 && coverageIndex < seqCount) {
         Offset sequenceTableOffset = SWAPW(sequenceTableOffsetArray[coverageIndex]);
         const SequenceTable *sequenceTable = (const SequenceTable *) ((char *) this + sequenceTableOffset);
