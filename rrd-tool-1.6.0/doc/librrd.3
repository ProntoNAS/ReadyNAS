.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "librrd 3"
.TH librrd 3 "2016-04-19" "1.6.0" "rrdtool"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
librrd \- RRD library functions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBlibrrd\fR contains most of the functionality in \fBRRDTool\fR.  The command
line utilities and language bindings are often just wrappers around the
code contained in \fBlibrrd\fR.
.PP
This manual page documents the \fBlibrrd\fR \s-1API.\s0
.PP
\&\fB\s-1NOTE:\s0\fR This document is a work in progress, and should be considered
incomplete as long as this warning persists.  For more information about
the \fBlibrrd\fR functions, always consult the source code.
.SH "CORE FUNCTIONS"
.IX Header "CORE FUNCTIONS"
.IP "\fBrrd_dump_cb_r(char *filename, int opt_header, rrd_output_callback_t cb, void *user)\fR" 4
.IX Item "rrd_dump_cb_r(char *filename, int opt_header, rrd_output_callback_t cb, void *user)"
In some situations it is necessary to get the output of \f(CW\*(C`rrd_dump\*(C'\fR without
writing it to a file or the standard output. In such cases an application
can ask \fBrrd_dump_cb_r\fR to call an user-defined function each time there
is output to be stored somewhere. This can be used, to e.g. directly feed
an \s-1XML\s0 parser with the dumped output or transfer the resulting string
in memory.
.Sp
The arguments for \fBrrd_dump_cb_r\fR are the same as for \fBrrd_dump_opt_r\fR
except that the output filename parameter is replaced by the user-defined
callback function and an additional parameter for the callback function
that is passed untouched, i.e. to store information about the callback state
needed for the user-defined callback to function properly.
.Sp
Recent versions of \fBrrd_dump_opt_r\fR internally use this callback mechanism
to write their output to the file provided by the user.
.Sp
.Vb 7
\&    size_t rrd_dump_opt_cb_fileout(
\&        const void *data,
\&        size_t len,
\&        void *user)
\&    {
\&        return fwrite(data, 1, len, (FILE *)user);
\&    }
.Ve
.Sp
The associated call for \fBrrd_dump_cb_r\fR looks like
.Sp
.Vb 2
\&    res = rrd_dump_cb_r(filename, opt_header,
\&        rrd_dump_opt_cb_fileout, (void *)out_file);
.Ve
.Sp
where the last parameter specifies the file handle \fBrrd_dump_opt_cb_fileout\fR
should write to. There's no specific condition for the callback to detect
when it is called for the first time, nor for the last time. If you require
this for initialization and cleanup you should do those tasks before and
after calling \fBrrd_dump_cr_r\fR respectively.
.IP "\fBrrd_fetch_cb_register(rrd_fetch_cb_t c)\fR" 4
.IX Item "rrd_fetch_cb_register(rrd_fetch_cb_t c)"
If your data does not reside in rrd files, but you would like to draw charts using the
rrd_graph functionality, you can supply your own rrd_fetch function and register it using
the \fBrrd_fetch_cb_register\fR function.
.Sp
The argument signature and api must be the same of the callback function must be aequivalent to the on of \fBrrd_fetch_fn\fR in 
\&\fIrrd_fetch.c\fR.
.Sp
To activate the callback function you can use the pseudo filename \fIcb//\fR\fIfree_form_text\fR.
.Sp
Note that rrdtool graph will not ask the same rrd for data twice. It determines this by building a key out of the
values supplied to the fetch function. If the values are the same, the previous answer will be used.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
.IP "\fB\f(BIrrd_random()\fB\fR" 4
.IX Item "rrd_random()"
Generates random numbers just like \fIrandom()\fR.  This further ensures that
the random number generator is seeded exactly once per process.
.IP "\fBrrd_strtodbl\fR" 4
.IX Item "rrd_strtodbl"
an rrd aware string to double converter which sets rrd_error in if there is a problem
and uses the return code exclusively for conversion status reporting.
.IP "\fBrrd_strtod\fR" 4
.IX Item "rrd_strtod"
works like normal strtod, but it is locale independent (and thread safe)
.IP "\fBrrd_snprintf\fR" 4
.IX Item "rrd_snprintf"
works  like normal snprintf but it is locale independent (and thread safe)
.IP "\fBrrd_add_ptr(void ***dest, size_t *dest_size, void *src)\fR" 4
.IX Item "rrd_add_ptr(void ***dest, size_t *dest_size, void *src)"
Dynamically resize the array pointed to by \f(CW\*(C`dest\*(C'\fR.  \f(CW\*(C`dest_size\*(C'\fR is a
pointer to the current size of \f(CW\*(C`dest\*(C'\fR.  Upon successful \fIrealloc()\fR, the
\&\f(CW\*(C`dest_size\*(C'\fR is incremented by 1 and the \f(CW\*(C`src\*(C'\fR pointer is stored at the
end of the new \f(CW\*(C`dest\*(C'\fR.  Returns 1 on success, 0 on failure.
.Sp
.Vb 5
\&    type **arr = NULL;
\&    type *elem = "whatever";
\&    size_t arr_size = 0;
\&    if (!rrd_add_ptr(&arr, &arr_size, elem))
\&        handle_failure();
.Ve
.IP "\fBrrd_add_ptr_chunk(void ***dest, size_t *dest_size, void *src, size_t *alloc, size_t chunk)\fR" 4
.IX Item "rrd_add_ptr_chunk(void ***dest, size_t *dest_size, void *src, size_t *alloc, size_t chunk)"
Like \f(CW\*(C`rrd_add_ptr\*(C'\fR, except the destination is allocated in chunks of
\&\f(CW\*(C`chunk\*(C'\fR.  \f(CW\*(C`alloc\*(C'\fR points to the number of entries allocated, whereas
\&\f(CW\*(C`dest_size\*(C'\fR points to the number of valid pointers.  If more pointers are
needed, \f(CW\*(C`chunk\*(C'\fR pointers are allocated and \f(CW\*(C`alloc\*(C'\fR is increased
accordingly.  \f(CW\*(C`alloc\*(C'\fR must be >= \f(CW\*(C`dest_size\*(C'\fR.
.Sp
This method improves performance on hosts with expensive \f(CW\*(C`realloc()\*(C'\fR.
.IP "\fBrrd_add_strdup(char ***dest, size_t *dest_size, char *src)\fR" 4
.IX Item "rrd_add_strdup(char ***dest, size_t *dest_size, char *src)"
Like \f(CW\*(C`rrd_add_ptr\*(C'\fR, except adds a \f(CW\*(C`strdup\*(C'\fR of the source string.
.Sp
.Vb 5
\&    char **arr = NULL;
\&    size_t arr_size = NULL;
\&    char *str  = "example text";
\&    if (!rrd_add_strdup(&arr, &arr_size, str))
\&        handle_failure();
.Ve
.IP "\fBrrd_add_strdup_chunk(char ***dest, size_t *dest_size, char *src, size_t *alloc, size_t chunk)\fR" 4
.IX Item "rrd_add_strdup_chunk(char ***dest, size_t *dest_size, char *src, size_t *alloc, size_t chunk)"
Like \f(CW\*(C`rrd_add_strdup\*(C'\fR, except the destination is allocated in chunks of
\&\f(CW\*(C`chunk\*(C'\fR.  \f(CW\*(C`alloc\*(C'\fR points to the number of entries allocated, whereas
\&\f(CW\*(C`dest_size\*(C'\fR points to the number of valid pointers.  If more pointers are
needed, \f(CW\*(C`chunk\*(C'\fR pointers are allocated and \f(CW\*(C`alloc\*(C'\fR is increased
accordingly.  \f(CW\*(C`alloc\*(C'\fR must be >= \f(CW\*(C`dest_size\*(C'\fR.
.IP "\fBrrd_free_ptrs(void ***src, size_t *cnt)\fR" 4
.IX Item "rrd_free_ptrs(void ***src, size_t *cnt)"
Free an array of pointers allocated by \f(CW\*(C`rrd_add_ptr\*(C'\fR or
\&\f(CW\*(C`rrd_add_strdup\*(C'\fR.  Also frees the array pointer itself.  On return, the
source pointer will be \s-1NULL\s0 and the count will be zero.
.Sp
.Vb 3
\&    /* created as above */
\&    rrd_free_ptrs(&arr, &arr_size);
\&    /* here, arr == NULL && arr_size == 0 */
.Ve
.IP "\fBrrd_mkdir_p(const char *pathname, mode_t mode)\fR" 4
.IX Item "rrd_mkdir_p(const char *pathname, mode_t mode)"
Create the directory named \f(CW\*(C`pathname\*(C'\fR including all of its parent
directories (similar to \f(CW\*(C`mkdir \-p\*(C'\fR on the command line \- see \fImkdir\fR\|(1) for
more information). The argument \f(CW\*(C`mode\*(C'\fR specifies the permissions to use. It
is modified by the process's \f(CW\*(C`umask\*(C'\fR. See \fImkdir\fR\|(2) for more details.
.Sp
The function returns 0 on success, a negative value else. In case of an error,
\&\f(CW\*(C`errno\*(C'\fR is set accordingly. Aside from the errors documented in \fImkdir\fR\|(2),
the function may fail with the following errors:
.RS 4
.IP "\fB\s-1EINVAL\s0\fR" 4
.IX Item "EINVAL"
\&\f(CW\*(C`pathname\*(C'\fR is \f(CW\*(C`NULL\*(C'\fR or the empty string.
.IP "\fB\s-1ENOMEM\s0\fR" 4
.IX Item "ENOMEM"
Insufficient memory was available.
.IP "\fBany error returned by \f(BIstat\fB\|(2)\fR" 4
.IX Item "any error returned by stat"
.RE
.RS 4
.Sp
In contrast to \fImkdir\fR\|(2), the function does \fBnot\fR fail if \f(CW\*(C`pathname\*(C'\fR
already exists and is a directory.
.RE
.IP "\fBrrd_scaled_duration (const char * token, unsigned long divisor, unsigned long * valuep)\fR" 4
.IX Item "rrd_scaled_duration (const char * token, unsigned long divisor, unsigned long * valuep)"
Parse a token in a context where it contains a count (of seconds or
\&\s-1PDP\s0 instances), or a duration that can be converted to a count by
representing the duration in seconds and dividing by some scaling
factor.  For example, if a user would natively express a 3 day archive
of samples collected every 2 minutes, the sample interval can be
represented by \f(CW\*(C`2m\*(C'\fR instead of \f(CW120\fR, and the archive duration by
\&\f(CW\*(C`3d\*(C'\fR (to be divided by 120) instead of \f(CW2160\fR (3*24*60*60 / 120).
See more examples in \*(L"\s-1STEP, HEARTBEAT,\s0 and Rows As Durations\*(R" in rrdcreate.
.Sp
\&\f(CW\*(C`token\*(C'\fR must be a number with an optional single-character suffix
encoding the scaling factor:
.RS 4
.ie n .IP """s""" 4
.el .IP "\f(CWs\fR" 4
.IX Item "s"
indicates seconds
.ie n .IP """m""" 4
.el .IP "\f(CWm\fR" 4
.IX Item "m"
indicates minutes.  The value is multiplied by 60.
.ie n .IP """h""" 4
.el .IP "\f(CWh\fR" 4
.IX Item "h"
indicates hours.  The value is multiplied by 3600 (or \f(CW\*(C`60m\*(C'\fR).
.ie n .IP """d""" 4
.el .IP "\f(CWd\fR" 4
.IX Item "d"
indicates days.  The value is multiplied by 86400 (or \f(CW\*(C`24h\*(C'\fR).
.ie n .IP """w""" 4
.el .IP "\f(CWw\fR" 4
.IX Item "w"
indicates weeks.  The value is multiplied by 604800 (or \f(CW\*(C`7d\*(C'\fR).
.ie n .IP """M""" 4
.el .IP "\f(CWM\fR" 4
.IX Item "M"
indicates months.  The value is multiplied by 2678400 (or \f(CW\*(C`31d\*(C'\fR).
(Note this factor accommodates the maximum number of days in a month.)
.ie n .IP """y""" 4
.el .IP "\f(CWy\fR" 4
.IX Item "y"
indicates years.  The value is multiplied by 31622400 (or \f(CW\*(C`366d\*(C'\fR).
(Note this factor accommodates leap years.)
.RE
.RS 4
.Sp
\&\f(CW\*(C`divisor\*(C'\fR is a positive value representing the duration in seconds of
an interval that the desired result counts.
.Sp
\&\f(CW\*(C`valuep\*(C'\fR is a pointer to where the decoded value will be stored if
the conversion is successful.
.Sp
The initial characters of \f(CW\*(C`token\*(C'\fR must be the base\-10 representation
of a positive integer, or the conversion fails.
.Sp
If the remainder \f(CW\*(C`token\*(C'\fR is empty (no suffix), it is a count and no
scaling is performed.
.Sp
If \f(CW\*(C`token\*(C'\fR has one of the suffixes above, the count is multiplied to
convert it to a duration in seconds.  The resulting number of seconds
is divided by \f(CW\*(C`divisor\*(C'\fR to produce a count of intervals each of
duration \f(CW\*(C`divisor\*(C'\fR seconds.  If division would produce a remainder
(e.g., \f(CW\*(C`5m\*(C'\fR (300 seconds) divided by \f(CW\*(C`90s\*(C'\fR), the conversion is
invalid.
.Sp
If \f(CW\*(C`token\*(C'\fR has unrecognized trailing characters the conversion fails.
.Sp
The function returns a null pointer if the conversion was successful
and \f(CW\*(C`valuep\*(C'\fR has been updated to the scaled value.  On failure, it
returns a text diagnostic suitable for use in user error messages.
.RE
.SH "CLIENT FUNCTIONS"
.IX Header "CLIENT FUNCTIONS"
The following functions are used to connected to an rrdcached instance,
either via a unix or inet address, and create, update, or gather statistics
about a specified \s-1RRD\s0 database file.
.PP
All of the following functions are specified in the \f(CW\*(C`rrd_client.h\*(C'\fR
header file.
.IP "\fBrrdc_connect(const char *daemon_addr\fR" 4
.IX Item "rrdc_connect(const char *daemon_addr"
Connect to a running rrdcached instance, specified via \f(CW\*(C`daemon_addr\*(C'\fR.
.IP "\fBrrdc_is_connected(const char *daemon_addr)\fR" 4
.IX Item "rrdc_is_connected(const char *daemon_addr)"
Return a boolean int to determine if the client is connected to the
rrdcache daemon specified by the \f(CW\*(C`daemon_addr\*(C'\fR parameter.
.IP "\fBrrdc_is_any_connected\fR" 4
.IX Item "rrdc_is_any_connected"
Return a boolean int if any daemon connections are connected.
.IP "\fBrrdc_disconnect\fR" 4
.IX Item "rrdc_disconnect"
Disconnect gracefully from all present daemon connections.
.IP "\fBrrdc_update(const char *filename, int values_num, const char * const *values)\fR" 4
.IX Item "rrdc_update(const char *filename, int values_num, const char * const *values)"
Update the \s-1RRD \s0\f(CW\*(C`filename\*(C'\fR via the rrdcached. Where \f(CW\*(C`values_num\*(C'\fR
is the number of values to update and \f(CW\*(C`values\*(C'\fR are the new values to add.
.IP "\fBrrdc_info(const char *filename)\fR" 4
.IX Item "rrdc_info(const char *filename)"
Grab rrd info of the \s-1RRD \s0\f(CW\*(C`filename\*(C'\fR from the connected cache daemon.
This function returns an rrd_info_t structure of the following format:
.Sp
.Vb 4
\&    typedef struct rrd_blob_t {
\&        unsigned long size; /* size of the blob */
\&        unsigned char *ptr; /* pointer */
\&    } rrd_blob_t;
\&
\&    typedef enum rrd_info_type { RD_I_VAL = 0,
\&        RD_I_CNT,
\&        RD_I_STR,
\&        RD_I_INT,
\&        RD_I_BLO
\&    } rrd_info_type_t;
\&
\&    typedef union rrd_infoval {
\&        unsigned long u_cnt;
\&        rrd_value_t u_val;
\&        char     *u_str;
\&        int       u_int;
\&        rrd_blob_t u_blo;
\&    } rrd_infoval_t;
\&
\&    typedef struct rrd_info_t {
\&        char     *key;
\&        rrd_info_type_t type;
\&        rrd_infoval_t value;
\&        struct rrd_info_t *next;
\&    } rrd_info_t;
.Ve
.IP "\fBrrdc_last(const char *filename)\fR" 4
.IX Item "rrdc_last(const char *filename)"
Grab the unix epoch of the last time \s-1RRD \s0\f(CW\*(C`filename\*(C'\fR was updated.
.IP "\fBrrdc_first(const char *filename, int rraindex)\fR" 4
.IX Item "rrdc_first(const char *filename, int rraindex)"
Get the first value of the first sample of the \s-1RRD \s0\f(CW\*(C`filename\*(C'\fR,
of the \f(CW\*(C`rraindex\*(C'\fR \s-1RRA \s0(Round Robin Archive) index number.
The \s-1RRA\s0 index number can be determined by pulling the rrd_info_t
off the \s-1RRD.\s0
.IP "\fBrrdc_create(const char *filename, unsigned long pdp_step, time_t last_up, int no_overwrite, int argc, const char **argv)\fR" 4
.IX Item "rrdc_create(const char *filename, unsigned long pdp_step, time_t last_up, int no_overwrite, int argc, const char **argv)"
Create \s-1RRD\s0 database of path \f(CW\*(C`filename\*(C'\fR.
The \s-1RRD\s0 will have a step size of \f(CW\*(C`pfp_step\*(C'\fR, the unix epoch timestamp to
start collecting data from. The number of data sources and RRAs \f(CW\*(C`argc\*(C'\fR and
the definitions of the data sources and RRAs \f(CW\*(C`argv\*(C'\fR. Lastly whether or
not to overwrite an existing \s-1RRD\s0 if one is found with the same
filename; \f(CW\*(C`no_overwrite\*(C'\fR.
.IP "\fBrrdc_create_r2(const char *filename, unsigned long pdp_step, time_t last_up, int no_overwrite, const char **sources, const char *template, int argc, const char **argv)\fR" 4
.IX Item "rrdc_create_r2(const char *filename, unsigned long pdp_step, time_t last_up, int no_overwrite, const char **sources, const char *template, int argc, const char **argv)"
Create and \s-1RRD\s0 database in the daemon. \fBrrdc_create_r2\fR has the same
parameters as \fBrrdc_create\fR with two added parameters of; \f(CW\*(C`sources\*(C'\fR
and \f(CW\*(C`template\*(C'\fR.
.Sp
where \f(CW\*(C`template\*(C'\fR is the file path to a \s-1RRD\s0 file template, with, the
form defined in \fBrrdcreate\fR(1),
.Sp
The \f(CW\*(C`sources\*(C'\fR parameter defines series of file paths with data defined,
to prefill the \s-1RRD\s0 with. See \fBrrdcreate\fR(1) for more details.
.IP "\fBrrdc_flush(const char *filename)\fR" 4
.IX Item "rrdc_flush(const char *filename)"
flush the currently \s-1RRD\s0 cached in the daemon specified via \f(CW\*(C`filename\*(C'\fR.
.IP "\fBrrdc_forget(const char *filename)\fR" 4
.IX Item "rrdc_forget(const char *filename)"
Drop the cached data for the \s-1RRD\s0 file specified via \f(CW\*(C`filename\*(C'\fR.
.IP "\fBrrdc_flush_if_daemon(const char *daemon_addr, const char *filename)\fR" 4
.IX Item "rrdc_flush_if_daemon(const char *daemon_addr, const char *filename)"
Flush the specified \s-1RRD\s0 given by \f(CW\*(C`filename\*(C'\fR only if the daemon
\&\f(CW\*(C`daemon_addr\*(C'\fR is up and connected.
.IP "\fBrrdc_fetch(const char *filename, const char *cf, time_t *ret_start, time_t *ret_end, unsigned long *ret_step, unsigned long *ret_ds_num, char ***ret_ds_names, rrd_value_t **ret_data)\fR" 4
.IX Item "rrdc_fetch(const char *filename, const char *cf, time_t *ret_start, time_t *ret_end, unsigned long *ret_step, unsigned long *ret_ds_num, char ***ret_ds_names, rrd_value_t **ret_data)"
Perform a fetch operation on the specified \s-1RRD\s0 Database given be \f(CW\*(C`filename\*(C'\fR,
where \f(CW\*(C`cf\*(C'\fR is the consolidation function, \f(CW\*(C`ret_start\*(C'\fR is the start time
given by unix epoch, \f(CW\*(C`ret_end\*(C'\fR is the endtime. \f(CW\*(C`ret_step\*(C'\fR is the step size
in seconds, \f(CW\*(C`ret_ds_num\*(C'\fR the number of data sources in the \s-1RRD, \s0\f(CW\*(C`ret_ds_names\*(C'\fR
the names of the data sources, and a pointer to an rrd_value_t object to shlep the
data.
.IP "\fBrrdc_stats_get(rrdc_stats_t **ret_stats)\fR" 4
.IX Item "rrdc_stats_get(rrdc_stats_t **ret_stats)"
Get stats from the connected daemon, via a linked list of the following structure:
.Sp
.Vb 10
\&    struct rrdc_stats_s {
\&        const char *name;
\&        uint16_t type;
\&        #define RRDC_STATS_TYPE_GAUGE   0x0001
\&        #define RRDC_STATS_TYPE_COUNTER 0x0002
\&        uint16_t flags;
\&        union {
\&            uint64_t counter;
\&            double   gauge;
\&        } value;
\&        struct rrdc_stats_s *next;
\&    };
\&    typedef struct rrdc_stats_s rrdc_stats_t;
.Ve
.IP "\fBrrdc_stats_free(rrdc_stats_t *ret_stats)\fR" 4
.IX Item "rrdc_stats_free(rrdc_stats_t *ret_stats)"
Free the stats struct allocated via \fBrrdc_stats_get\fR.
.SS "\s-1SEE ALSO\s0"
.IX Subsection "SEE ALSO"
.RS 4
\&\fBrrcached\fR(1) \fBrrdfetch\fR(1) \fBrrdinfo\fR(1) \fBrrdlast\fR(1) \fBrrdcreate\fR(1) \fBrrdupdate\fR(1) \fBrrdlast\fR(1)
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
\&\s-1RRD\s0 Contributors <rrd\-developers@lists.oetiker.ch>
