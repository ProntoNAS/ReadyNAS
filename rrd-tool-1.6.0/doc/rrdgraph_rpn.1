.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "RRDGRAPH_RPN 1"
.TH RRDGRAPH_RPN 1 "2016-04-19" "1.6.0" "rrdtool"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
rrdgraph_rpn \- About RPN Math in rrdtool graph
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fI\s-1RPN\s0 expression\fR:=\fIvname\fR|\fIoperator\fR|\fIvalue\fR[,\fI\s-1RPN\s0 expression\fR]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
If you have ever used a traditional \s-1HP\s0 calculator you already know
\&\fB\s-1RPN\s0\fR (Reverse Polish Notation).
The idea behind \fB\s-1RPN\s0\fR is that you have a stack and push
your data onto this stack. Whenever you execute an operation, it
takes as many elements from the stack as needed. Pushing is done
implicitly, so whenever you specify a number or a variable, it gets
pushed onto the stack automatically.
.PP
At the end of the calculation there should be one and only one value left on
the stack.  This is the outcome of the function and this is what is put into
the \fIvname\fR.  For \fB\s-1CDEF\s0\fR instructions, the stack is processed for each
data point on the graph. \fB\s-1VDEF\s0\fR instructions work on an entire data set in
one run. Note, that currently \fB\s-1VDEF\s0\fR instructions only support a limited
list of functions.
.PP
Example: \f(CW\*(C`VDEF:maximum=mydata,MAXIMUM\*(C'\fR
.PP
This will set variable \*(L"maximum\*(R" which you now can use in the rest
of your \s-1RRD\s0 script.
.PP
Example: \f(CW\*(C`CDEF:mydatabits=mydata,8,*\*(C'\fR
.PP
This means:  push variable \fImydata\fR, push the number 8, execute
the operator \fI*\fR. The operator needs two elements and uses those
to return one value.  This value is then stored in \fImydatabits\fR.
As you may have guessed, this instruction means nothing more than
\&\fImydatabits = mydata * 8\fR.  The real power of \fB\s-1RPN\s0\fR lies in the
fact that it is always clear in which order to process the input.
For expressions like \f(CW\*(C`a = b + 3 * 5\*(C'\fR you need to multiply 3 with
5 first before you add \fIb\fR to get \fIa\fR. However, with parentheses
you could change this order: \f(CW\*(C`a = (b + 3) * 5\*(C'\fR. In \fB\s-1RPN\s0\fR, you
would do \f(CW\*(C`a = b, 3, +, 5, *\*(C'\fR without the need for parentheses.
.SH "OPERATORS"
.IX Header "OPERATORS"
.IP "Boolean operators" 4
.IX Item "Boolean operators"
\&\fB\s-1LT, LE, GT, GE, EQ, NE\s0\fR
.Sp
Less than, Less or equal, Greater than, Greater or equal, Equal, Not equal
all pop two elements from the stack, compare them for the selected condition
and return 1 for true or 0 for false. Comparing an \fIunknown\fR or an
\&\fIinfinite\fR value will result in \fIunknown\fR returned ... which will also be
treated as false by the \fB\s-1IF\s0\fR call.
.Sp
\&\fB\s-1UN, ISINF\s0\fR
.Sp
Pop one element from the stack, compare this to \fIunknown\fR respectively
to \fIpositive or negative infinity\fR. Returns 1 for true or 0 for false.
.Sp
\&\fIthen\fR,\fIelse\fR,\fIcondition\fR,\fB\s-1IF\s0\fR
.Sp
Pops three elements from the stack.  If the element popped last is 0
(false), the value popped first is pushed back onto the stack,
otherwise the value popped second is pushed back. This does, indeed,
mean that any value other than 0 is considered to be true.
.Sp
Example: \f(CW\*(C`A,B,C,IF\*(C'\fR should be read as \f(CW\*(C`if (A) then (B) else (C)\*(C'\fR
.Sp

.IP "Comparing values" 4
.IX Item "Comparing values"
\&\fB\s-1MIN, MAX\s0\fR
.Sp
Pops two elements from the stack and returns the smaller or larger,
respectively.  Note that \fIinfinite\fR is larger than anything else.
If one of the input numbers is \fIunknown\fR then the result of the operation will be
\&\fIunknown\fR too.
.Sp
\&\fB\s-1MINNAN, MAXNAN\s0\fR
.Sp
NAN-safe version of \s-1MIN\s0 and \s-1MAX.\s0 If one of the input numbers is \fIunknown\fR
then the result of the operation will be the other one. If both are
\&\fIunknown\fR, then the result of the operation is \fIunknown\fR.
.Sp
\&\fIlower-limit\fR,\fIupper-limit\fR,\fB\s-1LIMIT\s0\fR
.Sp
Pops two elements from the stack and uses them to define a range.
Then it pops another element and if it falls inside the range, it
is pushed back. If not, an \fIunknown\fR is pushed.
.Sp
The range defined includes the two boundaries (so: a number equal
to one of the boundaries will be pushed back). If any of the three
numbers involved is either \fIunknown\fR or \fIinfinite\fR this function
will always return an \fIunknown\fR
.Sp
Example: \f(CW\*(C`CDEF:a=alpha,0,100,LIMIT\*(C'\fR will return \fIunknown\fR if
alpha is lower than 0 or if it is higher than 100.
.Sp

.IP "Arithmetics" 4
.IX Item "Arithmetics"
\&\fB+, \-, *, /, %\fR
.Sp
Add, subtract, multiply, divide, modulo
.Sp
\&\fB\s-1ADDNAN\s0\fR
.Sp
NAN-safe addition. If one parameter is \s-1NAN/UNKNOWN\s0 it'll be treated as
zero. If both parameters are \s-1NAN/UNKNOWN, NAN/UNKNOWN\s0 will be returned.
.Sp
\&\fIvalue\fR,\fIpower\fR,\fB\s-1POW\s0\fR
.Sp
Raise \fIvalue\fR to the power of \fIpower\fR.
.Sp
\&\fB\s-1SIN, COS, LOG, EXP, SQRT\s0\fR
.Sp
Sine and cosine (input in radians), log and exp (natural logarithm),
square root.
.Sp
\&\fB\s-1ATAN\s0\fR
.Sp
Arctangent (output in radians).
.Sp
\&\fB\s-1ATAN2\s0\fR
.Sp
Arctangent of y,x components (output in radians).
This pops one element from the stack, the x (cosine) component, and then
a second, which is the y (sine) component.
It then pushes the arctangent of their ratio, resolving the ambiguity between
quadrants.
.Sp
Example: \f(CW\*(C`CDEF:angle=Y,X,ATAN2,RAD2DEG\*(C'\fR will convert \f(CW\*(C`X,Y\*(C'\fR
components into an angle in degrees.
.Sp
\&\fB\s-1FLOOR, CEIL\s0\fR
.Sp
Round down or up to the nearest integer.
.Sp
\&\fB\s-1DEG2RAD, RAD2DEG\s0\fR
.Sp
Convert angle in degrees to radians, or radians to degrees.
.Sp
\&\fB\s-1ABS\s0\fR
.Sp
Take the absolute value.
.IP "Set Operations" 4
.IX Item "Set Operations"
\&\fIcount\fR,\fB\s-1SORT\s0\fR
.Sp
Pop one element from the stack.  This is the \fIcount\fR of items to be sorted.  The top \fIcount\fR of the remaining elements are then sorted
from the smallest to the largest, in place on the stack.
.Sp
.Vb 1
\&   4,3,22.1,1,4,SORT \-> 1,3,4,22.1
.Ve
.Sp
\&\fIcount\fR,\fB\s-1REV\s0\fR
.Sp
Reverse the number
.Sp
Example: \f(CW\*(C`CDEF:x=v1,v2,v3,v4,v5,v6,6,SORT,POP,5,REV,POP,+,+,+,4,/\*(C'\fR will
compute the average of the values v1 to v6 after removing the smallest and
largest.
.Sp
\&\fIcount\fR,\fB\s-1AVG\s0\fR
.Sp
Pop one element (\fIcount\fR) from the stack. Now pop \fIcount\fR elements and build the
average, ignoring all \s-1UNKNOWN\s0 values in the process.
.Sp
Example: \f(CW\*(C`CDEF:x=a,b,c,d,4,AVG\*(C'\fR
.Sp
\&\fIcount\fR,\fB\s-1SMIN\s0\fR and
\&\fIcount\fR,\fB\s-1SMAX\s0\fR
.Sp
Pop one element (\fIcount\fR) from the stack. Now pop \fIcount\fR elements and push the minimum/maximum back onto the stack.
.Sp
Example: \f(CW\*(C`CDEF:x=a,b,c,d,4,AVG\*(C'\fR
.Sp
\&\fIcount\fR,\fB\s-1MEDIAN\s0\fR
.Sp
pop one element (\fIcount\fR) from the stack. Now pop \fIcount\fR elements and find
the median, ignoring all \s-1UNKNOWN\s0 values in the process. If there are an even
number of non-UNKNOWN values, the average of the middle two will be pushed on
the stack.
.Sp
Example: \f(CW\*(C`CDEF:x=a,b,c,d,4,MEDIAN\*(C'\fR
.Sp
\&\fIcount\fR,\fB\s-1STDEV\s0\fR
.Sp
pop one element (\fIcount\fR) from the stack. Now pop \fIcount\fR elements and calculate the standard deviation over these values (ignoring any \s-1NAN\s0 values). Push the result back on to the stack.
.Sp
Example: \f(CW\*(C`CDEF:x=a,b,c,d,4,STDEV\*(C'\fR
.Sp
\&\fIpercent\fR,\fIcount\fR,\fB\s-1PERCENT\s0\fR
.Sp
pop two elements (\fIcount\fR,\fIpercent\fR) from the stack. Now pop \fIcount\fR element, order them by size
(while the smalles elements are \-INF, the largest are \s-1INF\s0 and NaN is larger than \-INF but smaller
than anything else. No pick the element from the ordered list where \fIpercent\fR of the elements
are equal then the one picked. Push the result back on to the stack.
.Sp
Example: \f(CW\*(C`CDEF:x=a,b,c,d,95,4,PERCENT\*(C'\fR
.Sp
\&\fIcount\fR,\fB\s-1TREND, TRENDNAN\s0\fR
.Sp
Create a \*(L"sliding window\*(R" average of another data series.
.Sp
Usage:
CDEF:smoothed=x,1800,TREND
.Sp
This will create a half-hour (1800 second) sliding window average of x.  The
average is essentially computed as shown here:
.Sp
.Vb 8
\&                 +\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\->
\&                                                     now
\&                       delay     t0
\&                 <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                         delay       t1
\&                     <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                              delay      t2
\&                         <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&
\&
\&     Value at sample (t0) will be the average between (t0\-delay) and (t0)
\&     Value at sample (t1) will be the average between (t1\-delay) and (t1)
\&     Value at sample (t2) will be the average between (t2\-delay) and (t2)
.Ve
.Sp
\&\s-1TRENDNAN\s0 is \- in contrast to \s-1TREND \-\s0 NAN-safe. If you use \s-1TREND\s0 and one
source value is \s-1NAN\s0 the complete sliding window is affected. The \s-1TRENDNAN\s0
operation ignores all NAN-values in a sliding window and computes the
average of the remaining values.
.Sp
\&\fB\s-1PREDICT, PREDICTSIGMA, PREDICTPERC\s0\fR
.Sp
Create a \*(L"sliding window\*(R" average/sigma/percentil of another data series,
that also shifts the data series by given amounts of time as well
.Sp
Usage \- explicit stating shifts:
\&\f(CW\*(C`CDEF:predict=<shift n>,...,<shift 1>,n,<window>,x,PREDICT\*(C'\fR
\&\f(CW\*(C`CDEF:sigma=<shift n>,...,<shift 1>,n,<window>,x,PREDICTSIGMA\*(C'\fR
\&\f(CW\*(C`CDEF:perc=<shift n>,...,<shift 1>,n,<window>,<percentil>,x,PREDICTPERC\*(C'\fR
.Sp
Usage \- shifts defined as a base shift and a number of time this is applied
\&\f(CW\*(C`CDEF:predict=<shift multiplier>,\-n,<window>,x,PREDICT\*(C'\fR
\&\f(CW\*(C`CDEF:sigma=<shift multiplier>,\-n,<window>,x,PREDICTSIGMA\*(C'\fR
\&\f(CW\*(C`CDEF:sigma=<shift multiplier>,\-n,<window>,<percentil>,x,PREDICTPERC\*(C'\fR
.Sp
Example:
CDEF:predict=172800,86400,2,1800,x,PREDICT
.Sp
This will create a half-hour (1800 second) sliding window average/sigma of x, that
average is essentially computed as shown here:
.Sp
.Vb 10
\& +\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\-!\-\-\->
\&                                                                     now
\&                                                  shift 1        t0
\&                                         <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                               window
\&                         <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                                       shift 2
\&                 <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&       window
\& <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                                                      shift 1        t1
\&                                             <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                                   window
\&                             <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&                                            shift 2
\&                     <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&           window
\&     <\-\-\-\-\-\-\-\-\-\-\-\-\-\-\->
\&
\& Value at sample (t0) will be the average between (t0\-shift1\-window) and (t0\-shift1)
\&                                      and between (t0\-shift2\-window) and (t0\-shift2)
\& Value at sample (t1) will be the average between (t1\-shift1\-window) and (t1\-shift1)
\&                                      and between (t1\-shift2\-window) and (t1\-shift2)
.Ve
.Sp
The function is by design NAN-safe.
This also allows for extrapolation into the future (say a few days)
\&\- you may need to define the data series whit the optional start= parameter, so that
the source data series has enough data to provide prediction also at the beginning of a graph...
.Sp
The percentile can be between [\-100:+100].
The positive percentiles interpolates between values while the negative will take the closest.
.Sp
Example: you run 7 shifts with a window of 1800seconds. Assuming that the rrd-file
has a step size of 300 seconds this means we have to do the percentile calculation
based on a max of 42 distinct values (less if you got \s-1NAN\s0). that means that in the
best case you get a step rate between values of 2.4 percent.
so if you ask for the 99th percentile, then you would need to look at the 41.59th
value. As we only have integers, either the 41st or the 42nd value.
.Sp
With the positive percentile a linear interpolation between the 2 values is done
to get the effective value.
.Sp
The negative returns the closest value distance wise \- so in the above case 42nd value,
which is effectively returning the Percentile100 or the max of the previous 7 days in the window.
.Sp
Here an example, that will create a 10 day graph that also shows the
prediction 3 days into the future with its uncertainty value (as defined by avg+\-4*sigma)
This also shows if the prediction is exceeded at a certain point.
.Sp
.Vb 10
\&    rrdtool graph image.png \-\-imgformat=PNG \e
\&    \-\-start=\-7days \-\-end=+3days \-\-width=1000 \-\-height=200 \-\-alt\-autoscale\-max \e
\&    DEF:value=value.rrd:value:AVERAGE:start=\-14days \e
\&    LINE1:value#ff0000:value \e
\&    CDEF:predict=86400,\-7,1800,value,PREDICT \e
\&    CDEF:sigma=86400,\-7,1800,value,PREDICTSIGMA \e
\&    CDEF:upper=predict,sigma,3,*,+ \e
\&    CDEF:lower=predict,sigma,3,*,\- \e
\&    LINE1:predict#00ff00:prediction \e
\&    LINE1:upper#0000ff:upper\e certainty\e limit \e
\&    LINE1:lower#0000ff:lower\e certainty\e limit \e
\&    CDEF:exceeds=value,UN,0,value,lower,upper,LIMIT,UN,IF \e
\&    TICK:exceeds#aa000080:1 \e
\&    CDEF:perc95=86400,\-7,1800,95,value,PREDICTPERC \e
\&    LINE1:perc95#ffff00:95th_percentile
.Ve
.Sp
Note: Experience has shown that a factor between 3 and 5 to scale sigma is a good
discriminator to detect abnormal behavior. This obviously depends also on the type
of data and how \*(L"noisy\*(R" the data series is.
.Sp
Also Note the explicit use of start= in the \s-1CDEF \-\s0 this is necessary to load all
the necessary data (even if it is not displayed)
.Sp
This prediction can only be used for short term extrapolations \- say a few days into the future.
.IP "Special values" 4
.IX Item "Special values"
\&\fB\s-1UNKN\s0\fR
.Sp
Pushes an unknown value on the stack
.Sp
\&\fB\s-1INF, NEGINF\s0\fR
.Sp
Pushes a positive or negative infinite value on the stack. When
such a value is graphed, it appears at the top or bottom of the
graph, no matter what the actual value on the y\-axis is.
.Sp
\&\fB\s-1PREV\s0\fR
.Sp
Pushes an \fIunknown\fR value if this is the first value of a data
set or otherwise the result of this \fB\s-1CDEF\s0\fR at the previous time
step. This allows you to do calculations across the data.  This
function cannot be used in \fB\s-1VDEF\s0\fR instructions.
.Sp
\&\fB\s-1PREV\s0(vname)\fR
.Sp
Pushes an \fIunknown\fR value if this is the first value of a data
set or otherwise the result of the vname variable at the previous time
step. This allows you to do calculations across the data. This
function cannot be used in \fB\s-1VDEF\s0\fR instructions.
.Sp
\&\fB\s-1COUNT\s0\fR
.Sp
Pushes the number 1 if this is the first value of the data set, the
number 2 if it is the second, and so on. This special value allows
you to make calculations based on the position of the value within
the data set. This function cannot be used in \fB\s-1VDEF\s0\fR instructions.
.IP "Time" 4
.IX Item "Time"
Time inside RRDtool is measured in seconds since the epoch. The
epoch is defined to be \f(CW\*(C`Thu\ Jan\ \ 1\ 00:00:00\ UTC\ 1970\*(C'\fR.
.Sp
\&\fB\s-1NOW\s0\fR
.Sp
Pushes the current time on the stack.
.Sp
\&\fB\s-1STEPWIDTH\s0\fR
.Sp
The with of the current step in seconds. You can use this to go back from
rate based presentations to absolute numbers
.Sp
.Vb 1
\&  CDEF:abs=rate,STEPWIDTH,*,PREV,ADDNAN
.Ve
.Sp
\&\fB\s-1NEWDAY\s0\fR,\fB\s-1NEWWEEK\s0\fR,\fB\s-1NEWMONTH\s0\fR,\fB\s-1NEWYEAR\s0\fR
.Sp
These three operators will return 1.0 whenever a step is the first of the given period. The periods are determined
according to the local timezone \s-1AND\s0 the \f(CW\*(C`LC_TIME\*(C'\fR settings.
.Sp
.Vb 1
\&  CDEF:mtotal=rate,STEPWIDTH,*,NEWMONTH,0,PREV,IF,ADDNAN
.Ve
.Sp
\&\fB\s-1TIME\s0\fR
.Sp
Pushes the time the currently processed value was taken at onto the stack.
.Sp
\&\fB\s-1LTIME\s0\fR
.Sp
Takes the time as defined by \fB\s-1TIME\s0\fR, applies the time zone offset
valid at that time including daylight saving time if your \s-1OS\s0 supports
it, and pushes the result on the stack.  There is an elaborate example
in the examples section below on how to use this.
.IP "Processing the stack directly" 4
.IX Item "Processing the stack directly"
\&\fB\s-1DUP, POP, EXC\s0\fR
.Sp
Duplicate the top element, remove the top element, exchange the two
top elements.
.Sp
\&\fB\s-1DEPTH\s0\fR
.Sp
pushes the current depth of the stack onto the stack
.Sp
.Vb 1
\& a,b,DEPTH \-> a,b,2
.Ve
.Sp
n,\fB\s-1COPY\s0\fR
.Sp
push a copy of the top n elements onto the stack
.Sp
.Vb 1
\& a,b,c,d,2,COPY => a,b,c,d,c,d
.Ve
.Sp
n,\fB\s-1INDEX\s0\fR
.Sp
push the nth element onto the stack.
.Sp
.Vb 1
\& a,b,c,d,3,INDEX \-> a,b,c,d,b
.Ve
.Sp
n,m,\fB\s-1ROLL\s0\fR
.Sp
rotate the top n elements of the stack by m
.Sp
.Vb 2
\& a,b,c,d,3,1,ROLL => a,d,b,c
\& a,b,c,d,3,\-1,ROLL => a,c,d,b
.Ve
.Sp

.SH "VARIABLES"
.IX Header "VARIABLES"
These operators work only on \fB\s-1VDEF\s0\fR statements. Note that currently \s-1ONLY\s0 these work for \fB\s-1VDEF\s0\fR.
.IP "\s-1MAXIMUM, MINIMUM, AVERAGE\s0" 4
.IX Item "MAXIMUM, MINIMUM, AVERAGE"
Return the corresponding value, \s-1MAXIMUM\s0 and \s-1MINIMUM\s0 also return
the first occurrence of that value in the time component.
.Sp
Example: \f(CW\*(C`VDEF:avg=mydata,AVERAGE\*(C'\fR
.IP "\s-1STDEV\s0" 4
.IX Item "STDEV"
Returns the standard deviation of the values.
.Sp
Example: \f(CW\*(C`VDEF:stdev=mydata,STDEV\*(C'\fR
.IP "\s-1LAST, FIRST\s0" 4
.IX Item "LAST, FIRST"
Return the last/first non-nan or infinite value for the selected data
stream, including its timestamp.
.Sp
Example: \f(CW\*(C`VDEF:first=mydata,FIRST\*(C'\fR
.IP "\s-1TOTAL\s0" 4
.IX Item "TOTAL"
Returns the rate from each defined time slot multiplied with the
step size.  This can, for instance, return total bytes transferred
when you have logged bytes per second. The time component returns
the number of seconds.
.Sp
Example: \f(CW\*(C`VDEF:total=mydata,TOTAL\*(C'\fR
.IP "\s-1PERCENT, PERCENTNAN\s0" 4
.IX Item "PERCENT, PERCENTNAN"
This should follow a \fB\s-1DEF\s0\fR or \fB\s-1CDEF\s0\fR \fIvname\fR. The \fIvname\fR is popped,
another number is popped which is a certain percentage (0..100). The
data set is then sorted and the value returned is chosen such that
\&\fIpercentage\fR percent of the values is lower or equal than the result.
For \s-1PERCENTNAN \s0\fIUnknown\fR values are ignored, but for \s-1PERCENT
\&\s0\fIUnknown\fR values are considered lower than any finite number for this
purpose so if this operator returns an \fIunknown\fR you have quite a lot
of them in your data.  \fBInf\fRinite numbers are lesser, or more, than the
finite numbers and are always more than the \fIUnknown\fR numbers.
(NaN < \-INF < finite values < \s-1INF\s0)
.Sp
Example: \f(CW\*(C`VDEF:perc95=mydata,95,PERCENT\*(C'\fR
         \f(CW\*(C`VDEF:percnan95=mydata,95,PERCENTNAN\*(C'\fR
.IP "\s-1LSLSLOPE, LSLINT, LSLCORREL\s0" 4
.IX Item "LSLSLOPE, LSLINT, LSLCORREL"
Return the parameters for a \fBL\fReast \fBS\fRquares \fBL\fRine \fI(y = mx +b)\fR
which approximate the provided dataset.  \s-1LSLSLOPE\s0 is the slope \fI(m)\fR of
the line related to the \s-1COUNT\s0 position of the data.  \s-1LSLINT\s0 is the
y\-intercept \fI(b)\fR, which happens also to be the first data point on the
graph. \s-1LSLCORREL\s0 is the Correlation Coefficient (also know as Pearson's
Product Moment Correlation Coefficient).  It will range from 0 to +/\-1
and represents the quality of fit for the approximation.
.Sp
Example: \f(CW\*(C`VDEF:slope=mydata,LSLSLOPE\*(C'\fR
.SH "SEE ALSO"
.IX Header "SEE ALSO"
rrdgraph gives an overview of how \fBrrdtool graph\fR works.
rrdgraph_data describes \fB\s-1DEF\s0\fR,\fB\s-1CDEF\s0\fR and \fB\s-1VDEF\s0\fR in detail.
rrdgraph_rpn describes the \fB\s-1RPN\s0\fR language used in the \fB?DEF\fR statements.
rrdgraph_graph page describes all of the graph and print functions.
.PP
Make sure to read rrdgraph_examples for tips&tricks.
.SH "AUTHOR"
.IX Header "AUTHOR"
Program by Tobias Oetiker <tobi@oetiker.ch>
.PP
This manual page by Alex van den Bogaerdt <alex@vandenbogaerdt.nl>
with corrections and/or additions by several people
