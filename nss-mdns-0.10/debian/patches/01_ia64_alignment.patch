From: Steve Kowalik <stevenk@debian.org>
Date: Sat, 10 Sep 2011 17:04:29 +1000
Subject: Fix unaligned access on successful lookups on interesting 64-bit systems
  
Origin: vendor, Debian
Bug-Debian: http://bugs.debian.org/521184
Forwarded: no

--- a/src/nss.c	2007-05-13 00:43:48.000000000 +1000
+++ b/src/nss.c	2009-03-26 02:08:57.944206926 +1100
@@ -69,7 +69,7 @@
 
 #define ALIGN(idx) do { \
   if (idx % sizeof(void*)) \
-    idx += (sizeof(void*) - idx % sizeof(void*)); /* Align on 32 bit boundary */ \
+    idx += (sizeof(void*) - idx % sizeof(void*)); /* Align on word boundary */ \
 } while(0)
 
 struct userdata {
@@ -514,7 +514,7 @@
     result->h_length = address_length;
     
     /* Check if there's enough space for the addresses */
-    if (buflen < idx+u.data_len+sizeof(char*)*(u.count+1)) {
+    if (buflen < idx+u.data_len+sizeof(char*)*(u.count+1)+sizeof(void*)) {
         *errnop = ERANGE;
         *h_errnop = NO_RECOVERY;
         status = NSS_STATUS_TRYAGAIN;
@@ -525,9 +525,10 @@
     astart = idx;
     l = u.count*address_length;
     memcpy(buffer+astart, &u.data, l);
-    /* address_length is a multiple of 32bits, so idx is still aligned
-     * correctly */
     idx += l;
+    /* realign, whilst the address is a multiple of 32bits, we
+     * frequently lose alignment for 64bit systems */
+    ALIGN(idx);
 
     /* Address array address_lenght is always a multiple of 32bits */
     for (i = 0; i < u.count; i++)
