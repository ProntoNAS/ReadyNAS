From ceaa65908cdc18515d977890d4f2f0fa92bafcbf Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Tue, 8 Aug 2017 14:12:36 -0700
Subject: [PATCH 902/903] privsep: mod_dav changes

---
 modules/dav/fs/repos.c | 127 +++++++++++++++++++++++++++++--------------------
 1 file changed, 75 insertions(+), 52 deletions(-)

diff --git a/modules/dav/fs/repos.c b/modules/dav/fs/repos.c
index 6a5ff765f8..3361499e96 100644
--- a/modules/dav/fs/repos.c
+++ b/modules/dav/fs/repos.c
@@ -31,6 +31,7 @@
 #include "http_log.h"
 #include "http_protocol.h"      /* for ap_set_* (in dav_fs_set_headers) */
 #include "http_request.h"       /* for ap_update_mtime() */
+#include "privsep.h"
 
 #include "mod_dav.h"
 #include "repos.h"
@@ -199,6 +200,7 @@ struct dav_stream {
     const char *pathname;       /* we may need to remove it at close time */
     char *temppath;
     int unlink_on_error;
+    request_rec *r;
 };
 
 /* returns an appropriate HTTP status code given an APR status code for a
@@ -330,7 +332,8 @@ static dav_error * dav_fs_copymove_file(
     const char *dst,
     const apr_finfo_t *src_finfo,
     const apr_finfo_t *dst_finfo,
-    dav_buffer *pbuf)
+    dav_buffer *pbuf,
+    request_rec *r)
 {
     dav_buffer work_buf = { 0 };
     apr_file_t *inf = NULL;
@@ -348,7 +351,7 @@ static dav_error * dav_fs_copymove_file(
 
         if (dst_finfo != NULL) {
             /* chmod it if it already exist */
-            if ((status = apr_file_perms_set(dst, perms)) != APR_SUCCESS) {
+            if ((status = ap_privsep_file_perms_set(ap_privsep_token(r), dst, perms)) != APR_SUCCESS) {
                 return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
                                      "Could not set permissions on destination");
             }
@@ -360,7 +363,8 @@ static dav_error * dav_fs_copymove_file(
 
     dav_set_bufsize(p, pbuf, DAV_FS_COPY_BLOCKSIZE);
 
-    if ((status = apr_file_open(&inf, src, APR_READ | APR_BINARY,
+    if ((status = ap_privsep_file_open(ap_privsep_token(r), &inf, src,
+			         APR_READ | APR_BINARY,
                                 APR_OS_DEFAULT, p)) != APR_SUCCESS) {
         /* ### use something besides 500? */
         return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
@@ -368,8 +372,9 @@ static dav_error * dav_fs_copymove_file(
     }
 
     /* ### do we need to deal with the umask? */
-    status = apr_file_open(&outf, dst, APR_WRITE | APR_CREATE | APR_TRUNCATE
-                           | APR_BINARY, perms, p);
+    status = ap_privsep_file_open(ap_privsep_token(r), &outf, dst,
+                                  APR_WRITE | APR_CREATE | APR_TRUNCATE| APR_BINARY,
+                                  perms, p);
     if (status != APR_SUCCESS) {
         apr_file_close(inf);
 
@@ -387,7 +392,7 @@ static dav_error * dav_fs_copymove_file(
             apr_file_close(inf);
             apr_file_close(outf);
 
-            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
+            if ((lcl_status = ap_privsep_file_remove(ap_privsep_token(r), dst, p)) != APR_SUCCESS) {
                 /* ### ACK! Inconsistent state... */
 
                 /* ### use something besides 500? */
@@ -414,7 +419,7 @@ static dav_error * dav_fs_copymove_file(
             apr_file_close(inf);
             apr_file_close(outf);
 
-            if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
+            if ((lcl_status = ap_privsep_file_remove(ap_privsep_token(r), dst, p)) != APR_SUCCESS) {
                 /* ### ACK! Inconsistent state... */
 
                 /* ### use something besides 500? */
@@ -433,7 +438,7 @@ static dav_error * dav_fs_copymove_file(
     apr_file_close(inf);
     apr_file_close(outf);
 
-    if (is_move && (status = apr_file_remove(src, p)) != APR_SUCCESS) {
+    if (is_move && (status = ap_privsep_file_remove(ap_privsep_token(r), src, p)) != APR_SUCCESS) {
         dav_error *err;
         apr_status_t lcl_status;
 
@@ -449,7 +454,7 @@ static dav_error * dav_fs_copymove_file(
                                               "inconsistent state.", src, dst));
             return err;
         }
-        else if ((lcl_status = apr_file_remove(dst, p)) != APR_SUCCESS) {
+        else if ((lcl_status = ap_privsep_file_remove(ap_privsep_token(r), dst, p)) != APR_SUCCESS) {
             /* ### ACK. this creates an inconsistency. do more!? */
 
             /* ### use something besides 500? */
@@ -476,7 +481,8 @@ static dav_error * dav_fs_copymove_state(
     apr_pool_t * p,
     const char *src_dir, const char *src_file,
     const char *dst_dir, const char *dst_file,
-    dav_buffer *pbuf)
+    dav_buffer *pbuf,
+    request_rec *r)
 {
     apr_finfo_t src_finfo;        /* finfo for source file */
     apr_finfo_t dst_state_finfo;        /* finfo for STATE directory */
@@ -488,7 +494,7 @@ static dav_error * dav_fs_copymove_state(
     src = apr_pstrcat(p, src_dir, "/" DAV_FS_STATE_DIR "/", src_file, NULL);
 
     /* the source file doesn't exist */
-    rv = apr_stat(&src_finfo, src, APR_FINFO_NORM, p);
+    rv = ap_privsep_stat(ap_privsep_token(r), &src_finfo, src, APR_FINFO_NORM, p);
     if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {
         return NULL;
     }
@@ -499,7 +505,7 @@ static dav_error * dav_fs_copymove_state(
     /* ### do we need to deal with the umask? */
 
     /* ensure that it exists */
-    rv = apr_dir_make(dst, APR_OS_DEFAULT, p);
+    rv = ap_privsep_dir_make(ap_privsep_token(r), dst, APR_OS_DEFAULT, p);
     if (rv != APR_SUCCESS) {
         if (!APR_STATUS_IS_EEXIST(rv)) {
             /* ### use something besides 500? */
@@ -509,7 +515,7 @@ static dav_error * dav_fs_copymove_state(
     }
 
     /* get info about the state directory */
-    rv = apr_stat(&dst_state_finfo, dst, APR_FINFO_NORM, p);
+    rv = ap_privsep_stat(ap_privsep_token(r), &dst_state_finfo, dst, APR_FINFO_NORM, p);
     if (rv != APR_SUCCESS && rv != APR_INCOMPLETE) {
         /* Ack! Where'd it go? */
         /* ### use something besides 500? */
@@ -531,9 +537,9 @@ static dav_error * dav_fs_copymove_state(
     /* copy/move the file now */
     if (is_move) {
         /* try simple rename first */
-        rv = apr_file_rename(src, dst, p);
+        rv = ap_privsep_file_rename(ap_privsep_token(r), src, dst, p);
         if (APR_STATUS_IS_EXDEV(rv)) {
-            return dav_fs_copymove_file(is_move, p, src, dst, NULL, NULL, pbuf);
+            return dav_fs_copymove_file(is_move, p, src, dst, NULL, NULL, pbuf, r);
         }
         if (rv != APR_SUCCESS) {
             /* ### use something besides 500? */
@@ -544,7 +550,7 @@ static dav_error * dav_fs_copymove_state(
     else
     {
         /* gotta copy (and delete) */
-        return dav_fs_copymove_file(is_move, p, src, dst, NULL, NULL, pbuf);
+        return dav_fs_copymove_file(is_move, p, src, dst, NULL, NULL, pbuf, r);
     }
 
     return NULL;
@@ -585,13 +591,13 @@ static dav_error *dav_fs_copymoveset(int is_move, apr_pool_t *p,
     err = dav_fs_copymove_state(is_move, p,
                                 src_dir, src_state1,
                                 dst_dir, dst_state1,
-                                pbuf);
+                                pbuf, src->info->r);
 
     if (err == NULL && src_state2 != NULL) {
         err = dav_fs_copymove_state(is_move, p,
                                     src_dir, src_state2,
                                     dst_dir, dst_state2,
-                                    pbuf);
+                                    pbuf, src->info->r);
 
         if (err != NULL) {
             /* ### CRAP. inconsistency. */
@@ -631,7 +637,7 @@ static dav_error *dav_fs_deleteset(apr_pool_t *p, const dav_resource *resource)
                           NULL);
 
     /* note: we may get ENOENT if the state dir is not present */
-    if ((status = apr_file_remove(pathname, p)) != APR_SUCCESS
+    if ((status = ap_privsep_file_remove(ap_privsep_token(resource->info->r), pathname, p)) != APR_SUCCESS
         && !APR_STATUS_IS_ENOENT(status)) {
         return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
                              "Could not remove properties.");
@@ -645,7 +651,7 @@ static dav_error *dav_fs_deleteset(apr_pool_t *p, const dav_resource *resource)
                               state2,
                               NULL);
 
-        if ((status = apr_file_remove(pathname, p)) != APR_SUCCESS
+        if ((status = ap_privsep_file_remove(ap_privsep_token(resource->info->r), pathname, p)) != APR_SUCCESS
             && !APR_STATUS_IS_ENOENT(status)) {
             /* ### CRAP. only removed half. */
             return dav_new_error(p, HTTP_INTERNAL_SERVER_ERROR, 0, status,
@@ -803,6 +809,7 @@ static dav_error * dav_fs_get_parent_resource(const dav_resource *resource,
 
     /* Create private resource context descriptor */
     parent_ctx = apr_pcalloc(ctx->pool, sizeof(*parent_ctx));
+    parent_ctx->r = ctx->r;
 
     /* ### this should go away */
     parent_ctx->pool = ctx->pool;
@@ -825,8 +832,9 @@ static dav_error * dav_fs_get_parent_resource(const dav_resource *resource,
         parent_resource->uri = uri;
     }
 
-    rv = apr_stat(&parent_ctx->finfo, parent_ctx->pathname,
-                  APR_FINFO_NORM, ctx->pool);
+    rv = ap_privsep_stat(ap_privsep_token(ctx->r),
+			 &parent_ctx->finfo, parent_ctx->pathname,
+			 APR_FINFO_NORM, ctx->pool);
     if (rv == APR_SUCCESS || rv == APR_INCOMPLETE) {
         parent_resource->exists = 1;
     }
@@ -878,13 +886,13 @@ static apr_status_t tmpfile_cleanup(void *data)
 {
     dav_stream *ds = data;
     if (ds->temppath) {
-        apr_file_remove(ds->temppath, ds->p);
+        ap_privsep_file_remove(ap_privsep_token(ds->r), ds->temppath, ds->p);
     }
     return APR_SUCCESS;
 }
 
 /* custom mktemp that creates the file with APR_OS_DEFAULT permissions */
-static apr_status_t dav_fs_mktemp(apr_file_t **fp, char *templ, apr_pool_t *p)
+static apr_status_t dav_fs_mktemp(request_rec *r, apr_file_t **fp, char *templ, apr_pool_t *p)
 {
     apr_status_t rv;
     int num = ((getpid() << 7) + (apr_uintptr_t)templ % (1 << 16) ) %
@@ -896,7 +904,8 @@ static apr_status_t dav_fs_mktemp(apr_file_t **fp, char *templ, apr_pool_t *p)
     do {
         num = (num + 1) % ( 1 << 23 );
         apr_snprintf(numstr, 7, "%06x", num);
-        rv = apr_file_open(fp, templ,
+        rv = ap_privsep_file_open(ap_privsep_token(r),
+                           fp, templ,
                            APR_WRITE | APR_CREATE | APR_BINARY | APR_EXCL,
                            APR_OS_DEFAULT, p);
     } while (APR_STATUS_IS_EEXIST(rv));
@@ -910,6 +919,7 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
 {
     apr_pool_t *p = resource->info->pool;
     dav_stream *ds = apr_pcalloc(p, sizeof(*ds));
+    ds->r = resource->info->r;
     apr_int32_t flags;
     apr_status_t rv;
 
@@ -934,24 +944,24 @@ static dav_error * dav_fs_open_stream(const dav_resource *resource,
     if (mode == DAV_MODE_WRITE_TRUNC) {
         ds->temppath = apr_pstrcat(p, ap_make_dirstr_parent(p, ds->pathname),
                                    DAV_FS_TMP_PREFIX "XXXXXX", NULL);
-        rv = dav_fs_mktemp(&ds->f, ds->temppath, ds->p);
+        rv = dav_fs_mktemp(ds->r, &ds->f, ds->temppath, ds->p);
         apr_pool_cleanup_register(p, ds, tmpfile_cleanup,
                                   apr_pool_cleanup_null);
     }
     else if (mode == DAV_MODE_WRITE_SEEKABLE) {
-        rv = apr_file_open(&ds->f, ds->pathname, flags | APR_FOPEN_EXCL,
+        rv = ap_privsep_file_open(ap_privsep_token(ds->r), &ds->f, ds->pathname, flags | APR_FOPEN_EXCL,
                            APR_OS_DEFAULT, ds->p);
         if (rv == APR_SUCCESS) {
             /* we have created a new file */
             ds->unlink_on_error = 1;
         }
         else if (APR_STATUS_IS_EEXIST(rv)) {
-            rv = apr_file_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT,
+            rv = ap_privsep_file_open(ap_privsep_token(ds->r), &ds->f, ds->pathname, flags, APR_OS_DEFAULT,
                                ds->p);
         }
     }
     else {
-        rv = apr_file_open(&ds->f, ds->pathname, flags, APR_OS_DEFAULT, ds->p);
+        rv = ap_privsep_file_open(ap_privsep_token(ds->r), &ds->f, ds->pathname, flags, APR_OS_DEFAULT, ds->p);
     }
 
     if (rv != APR_SUCCESS) {
@@ -976,7 +986,7 @@ static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
             apr_pool_cleanup_run(stream->p, stream, tmpfile_cleanup);
         }
         else if (stream->unlink_on_error) {
-            if ((rv = apr_file_remove(stream->pathname, stream->p))
+            if ((rv = ap_privsep_file_remove(ap_privsep_token(stream->r), stream->pathname, stream->p))
                 != APR_SUCCESS) {
                 /* ### use a better description? */
                 return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -988,7 +998,7 @@ static dav_error * dav_fs_close_stream(dav_stream *stream, int commit)
         }
     }
     else if (stream->temppath) {
-        rv = apr_file_rename(stream->temppath, stream->pathname, stream->p);
+        rv = ap_privsep_file_rename(ap_privsep_token(stream->r), stream->temppath, stream->pathname, stream->p);
         if (rv) {
             return dav_new_error(stream->p, HTTP_INTERNAL_SERVER_ERROR, 0, rv,
                                  "There was a problem writing the file "
@@ -1090,9 +1100,10 @@ static dav_error * dav_fs_deliver(const dav_resource *resource,
                              "collection.");
     }
 
-    if ((status = apr_file_open(&fd, resource->info->pathname,
-                                APR_READ | APR_BINARY, 0,
-                                pool)) != APR_SUCCESS) {
+    if ((status = ap_privsep_file_open(ap_privsep_token(r),
+				       &fd, resource->info->pathname,
+				       APR_READ | APR_BINARY, 0,
+				       pool)) != APR_SUCCESS) {
         return dav_new_error(pool, HTTP_FORBIDDEN, 0, status,
                              "File permissions deny server access.");
     }
@@ -1120,7 +1131,8 @@ static dav_error * dav_fs_create_collection(dav_resource *resource)
     dav_resource_private *ctx = resource->info;
     apr_status_t status;
 
-    status = apr_dir_make(ctx->pathname, APR_OS_DEFAULT, ctx->pool);
+    status = ap_privsep_dir_make(ap_privsep_token(resource->info->r),
+				 ctx->pathname, APR_OS_DEFAULT, ctx->pool);
     if (APR_STATUS_IS_ENOSPC(status)) {
         return dav_new_error(ctx->pool, HTTP_INSUFFICIENT_STORAGE, 0, status,
                              "There is not enough storage to create "
@@ -1159,12 +1171,14 @@ static dav_error * dav_fs_copymove_walker(dav_walk_resource *wres,
              * Note: when copying, we do not enable the postfix-traversal.
              */
             /* ### we are ignoring any error here; what should we do? */
-            (void) apr_dir_remove(srcinfo->pathname, ctx->pool);
+            (void) ap_privsep_dir_remove(ap_privsep_token(srcinfo->r),
+					 srcinfo->pathname, ctx->pool);
         }
         else {
             /* copy/move of a collection. Create the new, target collection */
-            if ((status = apr_dir_make(dstinfo->pathname, APR_OS_DEFAULT,
-                                       ctx->pool)) != APR_SUCCESS) {
+            if ((status = ap_privsep_dir_make(ap_privsep_token(srcinfo->r),
+				    dstinfo->pathname, APR_OS_DEFAULT,
+				    ctx->pool)) != APR_SUCCESS) {
                 /* ### assume it was a permissions problem */
                 /* ### need a description here */
                 err = dav_new_error(ctx->pool, HTTP_FORBIDDEN, 0, status, NULL);
@@ -1176,7 +1190,7 @@ static dav_error * dav_fs_copymove_walker(dav_walk_resource *wres,
                                    srcinfo->pathname, dstinfo->pathname,
                                    &srcinfo->finfo,
                                    ctx->res_dst->exists ? &dstinfo->finfo : NULL,
-                                   &ctx->work_buf);
+                                   &ctx->work_buf, srcinfo->r);
         /* ### push a higher-level description? */
     }
 
@@ -1259,7 +1273,7 @@ static dav_error *dav_fs_copymove_resource(
                                     src->info->pathname, dst->info->pathname,
                                     &src->info->finfo,
                                     dst->exists ? &dst->info->finfo : NULL,
-                                    &work_buf)) != NULL) {
+                                    &work_buf, src->info->r)) != NULL) {
         /* ### push a higher-level description? */
         return err;
     }
@@ -1323,7 +1337,7 @@ static dav_error * dav_fs_move_resource(
 
 
     /* try rename first */
-    rv = apr_file_rename(srcinfo->pathname, dstinfo->pathname, srcinfo->pool);
+    rv = ap_privsep_file_rename(ap_privsep_token(srcinfo->r), srcinfo->pathname, dstinfo->pathname, srcinfo->pool);
 
     /* if we can't simply rename, then do it the hard way... */
     if (APR_STATUS_IS_EXDEV(rv)) {
@@ -1361,8 +1375,9 @@ static dav_error * dav_fs_move_resource(
     }
 
     /* error occurred during properties move; try to put resource back */
-    if (apr_file_rename(dstinfo->pathname, srcinfo->pathname,
-                       srcinfo->pool) != APR_SUCCESS) {
+    if (ap_privsep_file_rename(ap_privsep_token(dstinfo->r),
+			       dstinfo->pathname, srcinfo->pathname,
+			       srcinfo->pool) != APR_SUCCESS) {
         /* couldn't put it back! */
         return dav_push_error(srcinfo->pool,
                               HTTP_INTERNAL_SERVER_ERROR, 0,
@@ -1405,8 +1420,10 @@ static dav_error * dav_fs_delete_walker(dav_walk_resource *wres, int calltype)
         apr_status_t result;
 
         result = wres->resource->collection
-            ? apr_dir_remove(info->pathname, wres->pool)
-            : apr_file_remove(info->pathname, wres->pool);
+            ? ap_privsep_dir_remove(ap_privsep_token(info->r),
+				    info->pathname, wres->pool)
+	    : ap_privsep_file_remove(ap_privsep_token(info->r),
+				     info->pathname, wres->pool);
 
         /*
         ** If an error occurred, then add it to multistatus response.
@@ -1470,7 +1487,8 @@ static dav_error * dav_fs_remove_resource(dav_resource *resource,
     }
 
     /* not a collection; remove the file and its properties */
-    if ((status = apr_file_remove(info->pathname, info->pool)) != APR_SUCCESS) {
+    if ((status = ap_privsep_file_remove(ap_privsep_token(info->r),
+			       info->pathname, info->pool)) != APR_SUCCESS) {
         /* ### put a description in here */
         return dav_new_error(info->pool, HTTP_FORBIDDEN, 0, status, NULL);
     }
@@ -1532,11 +1550,13 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
     fsctx->res2.collection = 0;
 
     /* open and scan the directory */
-    if ((status = apr_dir_open(&dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
+    if ((status = ap_privsep_dir_open(ap_privsep_token(fsctx->info1.r),
+			     &dirp, fsctx->path1.buf, pool)) != APR_SUCCESS) {
         /* ### need a better error */
         return dav_new_error(pool, HTTP_NOT_FOUND, 0, status, NULL);
     }
-    while ((apr_dir_read(&dirent, APR_FINFO_DIRENT, dirp)) == APR_SUCCESS) {
+    while ((ap_privsep_dir_read(ap_privsep_token(fsctx->info1.r),
+				&dirent, APR_FINFO_DIRENT, dirp)) == APR_SUCCESS) {
         apr_size_t len;
 
         len = strlen(dirent.name);
@@ -1569,8 +1589,9 @@ static dav_error * dav_fs_walker(dav_fs_walker_context *fsctx, int depth)
         /* append this file onto the path buffer (copy null term) */
         dav_buffer_place_mem(pool, &fsctx->path1, dirent.name, len + 1, 0);
 
-        status = apr_stat(&fsctx->info1.finfo, fsctx->path1.buf,
-                          DAV_FINFO_MASK, pool);
+        status = ap_privsep_stat(ap_privsep_token(fsctx->info1.r),
+                                 &fsctx->info1.finfo, fsctx->path1.buf,
+                                 DAV_FINFO_MASK, pool);
         if (status != APR_SUCCESS && status != APR_INCOMPLETE) {
             /* woah! where'd it go? */
             /* ### should have a better error here */
@@ -2115,7 +2136,8 @@ static dav_error *dav_fs_patch_exec(const dav_resource *resource,
     if (value)
         perms |= APR_UEXECUTE;
 
-    if ((status = apr_file_perms_set(resource->info->pathname, perms))
+    if ((status = ap_privsep_file_perms_set(ap_privsep_token(resource->info->r),
+				  resource->info->pathname, perms))
         != APR_SUCCESS) {
         return dav_new_error(resource->info->pool,
                              HTTP_INTERNAL_SERVER_ERROR, 0, status,
@@ -2153,7 +2175,8 @@ static dav_error *dav_fs_patch_rollback(const dav_resource *resource,
     if (value)
         perms |= APR_UEXECUTE;
 
-    if ((status = apr_file_perms_set(resource->info->pathname, perms))
+    if ((status = ap_privsep_file_perms_set(ap_privsep_token(resource->info->r),
+				  resource->info->pathname, perms))
         != APR_SUCCESS) {
         return dav_new_error(resource->info->pool,
                              HTTP_INTERNAL_SERVER_ERROR, 0, status,
-- 
2.13.0

