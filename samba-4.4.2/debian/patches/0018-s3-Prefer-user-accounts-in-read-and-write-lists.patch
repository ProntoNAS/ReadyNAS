From 1ed71d621513c72f7fb9825cc136f401b5294f6a Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Thu, 28 Jul 2016 11:52:31 -0700
Subject: [PATCH 18/19] s3: Prefer user accounts in read and write lists

Currently, objects in the write list always override the same objects in
the read list.  This includes cases where you have an individual user
account in the read list, and a group he belongs to in the write list.
This seems unintuitive, as normally user account settings take precedence
over group account settings.

Change this behavior by keeping track of the object type, and giving
preference to user account objects.
---
 source3/smbd/share_access.c | 54 +++++++++++++++++++++++++++++++++++----------
 1 file changed, 42 insertions(+), 12 deletions(-)

diff --git a/source3/smbd/share_access.c b/source3/smbd/share_access.c
index 8b165e6..d86c7dd 100644
--- a/source3/smbd/share_access.c
+++ b/source3/smbd/share_access.c
@@ -72,7 +72,8 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 				const char *domain,
 				const char *sharename,
 				const struct security_token *token,
-				const char *name)
+				const char *name,
+				uint32_t *sid_type)
 {
 	const char *prefix;
 	struct dom_sid sid;
@@ -104,6 +105,9 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 			DEBUG(5, ("lookup_name %s failed\n", name));
 			return False;
 		}
+		if (sid_type) {
+			*sid_type = type;
+		}
 		if (type != SID_NAME_USER) {
 			DEBUG(5, ("%s is a %s, expected a user\n",
 				  name, sid_type_lookup(type)));
@@ -120,6 +124,9 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 				DEBUG(5, ("lookup_name %s failed\n", name));
 				return False;
 			}
+			if (sid_type) {
+				*sid_type = type;
+			}
 			if ((type != SID_NAME_DOM_GRP) &&
 			    (type != SID_NAME_ALIAS) &&
 			    (type != SID_NAME_WKN_GRP)) {
@@ -155,13 +162,15 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
  *
  * The other use is the netgroup check when using @group or &group.
  */
-
-bool token_contains_name_in_list(const char *username,
+static bool _token_contains_name_in_list(const char *username,
 				 const char *domain,
 				 const char *sharename,
 				 const struct security_token *token,
-				 const char **list)
+				 const char **list,
+				 uint32_t *type)
 {
+	bool found = False;
+
 	if (list == NULL) {
 		return False;
 	}
@@ -170,14 +179,27 @@ bool token_contains_name_in_list(const char *username,
 		bool ret;
 
 		ret = token_contains_name(frame, username, domain, sharename,
-					  token, *list);
+					  token, *list, type);
 		TALLOC_FREE(frame);
 		if (ret) {
-			return true;
+			found = True;
+			if (type && *type == SID_NAME_USER) {
+				break;
+			}
 		}
 		list += 1;
 	}
-	return False;
+	return found;
+}
+
+bool token_contains_name_in_list(const char *username,
+				 const char *domain,
+				 const char *sharename,
+				 const struct security_token *token,
+				 const char **list)
+{
+	return _token_contains_name_in_list(username, domain, sharename, token,
+					    list, NULL);
 }
 
 /*
@@ -260,22 +282,30 @@ bool is_share_read_only_for_token(const char *username,
 {
 	int snum = SNUM(conn);
 	bool result = conn->read_only;
+	bool user_match = False;
+	uint32_t type;
 
 	if (lp_read_list(snum) != NULL) {
-		if (token_contains_name_in_list(username, domain,
+		if (_token_contains_name_in_list(username, domain,
 						lp_servicename(talloc_tos(), snum),
 						token,
-						lp_read_list(snum))) {
+						lp_read_list(snum), &type)) {
 			result = True;
+			if (type == SID_NAME_USER) {
+				user_match = True;
+			}
 		}
 	}
 
 	if (lp_write_list(snum) != NULL) {
-		if (token_contains_name_in_list(username, domain,
+		if (_token_contains_name_in_list(username, domain,
 						lp_servicename(talloc_tos(), snum),
 						token,
-						lp_write_list(snum))) {
-			result = False;
+						lp_write_list(snum), &type)) {
+			/* Prefer user accounts to groups */
+			if (type == SID_NAME_USER || !user_match) {
+				result = False;
+			}
 		}
 	}
 
-- 
2.9.2

