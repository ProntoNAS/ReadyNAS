<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Generated by gnulib's pmccabe2html at 1269513156 -->
<head>
<title>Cyclomatic Complexity report for GNU SASL</title>

<meta name="description" content="Cyclomatic Complexity report for GNU SASL">
<meta name="keywords" content="Cyclomatic Complexity report for GNU SASL">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="pmccabe2html">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<script language="javascript" type="text/javascript">
function show_hide(idCapa, idButton, fuerzaVisibilidad){        var button = document.getElementById(idButton);	var capa = document.getElementById(idCapa);	if (capa)	{		if (fuerzaVisibilidad && fuerzaVisibilidad!="") {			if (fuerzaVisibilidad=="visible") capa.style.display="";			else capa.style.display="none";		}		else		{			if (capa.style.display == "none") {				capa.style.display = "";                                button.innerHTML = "&uarr;";			} else {				capa.style.display = "none";                                button.innerHTML = "&darr;";     			}		}	}}
</script>
<style type ="text/css" media="screen">
<!--
body {

    font-family: Helvetica, sans-serif;

}

.page_title {

    font: 18pt Georgia, serif;
/*    font-size: 1.5em;
    font-weight: bold; */
    color: darkred;
    border-bottom: 2px solid darkred;
}

.section_title {

    font: 14pt Georgia, serif;
    color: darkred;
    border-bottom: 2px dashed darkred;
}

.report_timestamp {

    color: darkred;
    font-weight: bold;

}

.function_src {

    text-align: left;
    background: white;
}

.resume_table {

}

.resume_header_entry {
    
    color: black;
}

.resume_number_entry {

    color: darkred;
    font-weight: bold;
    text-align: right;
}

.ranges_table {

    border-spacing: 0px;
    border-bottom: solid 2px black;
    border-top: solid 2px black;
    border-left: solid 2px black;
    border-right: solid 2px black;
}

.ranges_header_entry {

    padding: 5px;
    border-bottom: solid 1px black;
    font-size: 1em;
    font-weight: bold;
    color: darkred;
    text-align: left;
}

.ranges_entry {

}

.ranges_entry_simple {

    background: #87ff75; 

}

.ranges_entry_moderate {

    background: #fffc60;

}

.ranges_entry_high {

    background: #ff5a5d;

}

.ranges_entry_untestable {

    background: #993300

}


.function_table {

    border-spacing: 0px;
    border-bottom: solid 2px black;
    border-top: solid 2px black;
    border-left: solid 2px black;
    border-right: solid 2px black;
}

.function_table_caption {

    font-size: 1.1em;
    font-weight: bold;
    color: black;
    padding: 5px;
}

.function_table_header {
    
}


.function_table_header_entry {

    padding: 5px;
    border-bottom: solid 1px black;
    font-size: 1em;
    font-weight: bold;
    color: darkred;
    text-align: left;
}

.function_entry {


}


.function_entry_simple {

    background: #87ff75; 

}

.function_entry_moderate {

    background: #fffc60;

}

.function_entry_high {

    background: #ff5a5d;

}

.function_entry_untestable {

    background: #993300

}


.function_entry_name {

    font-size: 1em;
    text-align: left;
    font-weight: bold;
    text-valign: top;

    border-top: solid 1px black;
    padding: 3px;
}

.function_entry_cyclo {

    font-size: 1em;
    text-align: right;
    text-valign: top;

    border-top: solid 1px black;
    padding: 3px;
}

.function_entry_number {

    font-size: 1em;
    text-align: right;
    text-valign: top;

    border-top: solid 1px black;
    padding: 3px;
}

.function_entry_filename {

    font-size: 1em;
    text-align: left;
    text-valign: top;

    border-top: solid 1px black;
    padding: 3px;
}

.sidemenu {
    
    border: 1px black solid;
    padding: 5px;

}

.sidemenuheader {
 
    color: darkred;
    font-size: 1.1em;
    font-weight: bold;
    border-bottom: 1px dashed darkred;
}

.sidemenuentry {


}

.menu {

}

-->
</style />
</head>
<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<a href="http://www.gnu.org/software/gsasl/">Back to GNU SASL Homepage</a><br/><br/>
<div class="page_title">GNU SASL Cyclomatic Complexity Report</div>
<p>Report generated at: <span class="report_timestamp">Thu Mar 25 11:32:37 CET 2010</div></p>
<div class="section_title">Resume</div>
<br/>
<table class="resume_table">
<tr>
<td class="resume_header_entry">
Total number of functions
</td>
<td class="resume_number_entry">
266
</td>
</tr>
<tr>
<td class="resume_header_entry">
Number of low risk functions
</td>
<td class="resume_number_entry">
223
</td>
</tr>
<tr>
<td class="resume_header_entry">
Number of moderate risk functions
</td>
<td class="resume_number_entry">
22
</td>
</tr>
<tr>
<td class="resume_header_entry">
Number of high risk functions
</td>
<td class="resume_number_entry">
19
</td>
</tr>
<tr>
<td class="resume_header_entry">
Number of untestable functions
</td>
<td class="resume_number_entry">
2
</td>
</tr>
</table>
<br/>
<div class="section_title">Details for all functions</div>
<p>Used ranges:</p>
<table class="ranges_table">
<tr>
<td class="ranges_header_entry">
&nbsp;
</td>
<td class="ranges_header_entry">
Cyclomatic Complexity
</td>
<td class="ranges_header_entry">
Risk Evaluation
</td>
</tr>
<tr>
<td class="ranges_entry_simple">
&nbsp;
</td>
<td class="ranges_entry">
0 - 10
</td>
<td class="ranges_entry">
Simple module, without much risk
</td>
</tr>
<tr>
<td class="ranges_entry_moderate">
&nbsp;
</td>
<td class="ranges_entry">
11 - 20
</td>
<td class="ranges_entry">
More complex module, moderate risk
</td>
</tr>
<tr>
<td class="ranges_entry_high">
&nbsp;
</td>
<td class="ranges_entry">
21 - 50
</td>
<td class="ranges_entry">
Complex module, high risk
</td>
</tr>
<tr>
<td class="ranges_entry_untestable">
&nbsp;
</td>
<td class="ranges_entry">
greater than 50
</td>
<td class="ranges_entry">
Untestable module, very high risk
</td>
</tr>
</table>
<br/>
<table width="90%" class="function_table" cellpadding="0" cellspacing="0">
<tr class="function_table_header">
<td class="function_table_header_entry">

</td>
<td class="function_table_header_entry">
Function Name
</td>
<td class="function_table_header_entry">
Cyclomatic
<br/>
Complexity
</td>
<td class="function_table_header_entry">
Number of
<br/>
Statements
</td>
<td class="function_table_header_entry">
Number of
<br/>
Lines
</td>
<td class="function_table_header_entry">
Source File
</td>
</tr>
<tr class="function_entry_untestable">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_step_src', '_gsasl_kerberos_v5_server_step_button')"><span id="_gsasl_kerberos_v5_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_step
</td>
<td class="function_entry_cyclo">
59
</td>
<td class="function_entry_number">
214
</td>
<td class="function_entry_number">
381
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_step (Gsasl_session * sctx,
				void *mech_data,
				const char *input,
				size_t input_len,
				char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  Gsasl_server_callback_realm cb_realm;
  Gsasl_server_callback_qop cb_qop;
  Gsasl_server_callback_maxbuf cb_maxbuf;
  Gsasl_server_callback_cipher cb_cipher;
  Gsasl_server_callback_retrieve cb_retrieve;
  Gsasl_server_callback_service cb_service;
  unsigned char buf[BUFSIZ];
  size_t buflen;
  Gsasl_ctx *ctx;
  ASN1_TYPE asn1;
  int err;

  ctx = gsasl_server_ctx_get (sctx);
  if (ctx == NULL)
    return GSASL_CANNOT_GET_CTX;

  cb_realm = gsasl_server_callback_realm_get (ctx);
  cb_qop = gsasl_server_callback_qop_get (ctx);
  cb_maxbuf = gsasl_server_callback_maxbuf_get (ctx);
  cb_retrieve = gsasl_server_callback_retrieve_get (ctx);
  cb_service = gsasl_server_callback_service_get (ctx);
  if (cb_service == NULL)
    return GSASL_NEED_SERVER_SERVICE_CALLBACK;

  if (state->firststep)
    {
      uint32_t tmp;
      unsigned char *p;

      /*
       * The initial server packet should contain one octet containing
       * a bit mask of supported security layers, four octets
       * indicating the maximum cipher-text buffer size the server is
       * able to receive (or 0 if no security layers are supported) in
       * network byte order, and then 16 octets containing random data
       * (see [4] on how random data might be generated).
       *
       * The security layers and their corresponding bit-masks are as
       * follows:
       *
       *       Bit 0 No security layer
       *       Bit 1 Integrity (KRB-SAFE) protection
       *       Bit 2 Privacy (KRB-PRIV) protection
       *       Bit 3 Mutual authentication is required (AP option MUTUAL-
       *             REQUIRED must also be present).
       *
       * Other bit-masks may be defined in the future; bits which are
       * not understood must be negotiated off.
       *
       */
      if (output &amp;& *output_len < BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN)
	return GSASL_TOO_SMALL_BUFFER;

      p = &amp;state->serverhello[0];

      if (cb_qop)
	state->serverqops = cb_qop (sctx);
      *p = 0;
      if (state->serverqops &amp; GSASL_QOP_AUTH)
	*p |= GSASL_QOP_AUTH;
      if (state->serverqops &amp; GSASL_QOP_AUTH_INT)
	*p |= GSASL_QOP_AUTH_INT;
      if (state->serverqops &amp; GSASL_QOP_AUTH_CONF)
	*p |= GSASL_QOP_AUTH_CONF;
      /* XXX we always require mutual authentication for now */
      *p |= MUTUAL;

      if (!(state->serverqops &amp; ~GSASL_QOP_AUTH))
	state->servermaxbuf = 0;
      else if (cb_maxbuf)
	state->servermaxbuf = cb_maxbuf (sctx);
      else
	state->servermaxbuf = MAXBUF_DEFAULT;

      tmp = htonl (state->servermaxbuf);
      memcpy (&amp;state->serverhello[BITMAP_LEN], &tmp, MAXBUF_LEN);
      memcpy (&amp;state->serverhello[BITMAP_LEN + MAXBUF_LEN],
	      state->random, RANDOM_LEN);

      if (output)
	memcpy (output, state->serverhello, SERVER_HELLO_LEN);
      *output_len = BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN;

      state->firststep = 0;

      return GSASL_NEEDS_MORE;
    }

  if (cb_retrieve)
    {
      /* Non-infrastructure mode */

      if (*output_len < 2048)
	return GSASL_TOO_SMALL_BUFFER;

      if (shishi_as_req_der_set (state->as, input, input_len) == SHISHI_OK)
	{
	  Shishi_tkt *tkt;
	  int etype, i;

	  tkt = shishi_as_tkt (state->as);
	  if (!tkt)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  i = 1;
	  do
	    {
	      err = shishi_kdcreq_etype (state->sh,
					 shishi_as_req (state->as),
					 &amp;etype, i);
	      if (err == SHISHI_OK &amp;& shishi_cipher_supported_p (etype))
		break;
	    }
	  while (err == SHISHI_OK);
	  if (err != SHISHI_OK)
	    return err;

	  /* XXX use a "preferred server kdc etype" from shishi instead? */
	  err = shishi_key_random (state->sh, etype, &amp;state->sessionkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  err = shishi_tkt_key_set (tkt, state->sessionkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  buflen = sizeof (buf) - 1;
	  err = shishi_kdcreq_cname_get (state->sh,
					 shishi_as_req (state->as),
					 buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->username = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = shishi_kdcreq_realm_get (state->sh,
					 shishi_as_req (state->as),
					 buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->userrealm = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,
			     NULL, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;

	  state->password = malloc (buflen + 1);
	  if (state->password == NULL)
	    return GSASL_MALLOC_ERROR;

	  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,
			     state->password, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;
	  state->password[buflen] = '\0';

	  buflen = sizeof (buf) - 1;
	  if (cb_realm)
	    {
	      err = cb_realm (sctx, buf, &amp;buflen, 0);
	      if (err != GSASL_OK)
		return err;
	    }
	  else
	    buflen = 0;
	  buf[buflen] = '\0';
	  state->serverrealm = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_service (sctx, buf, &amp;buflen, NULL, NULL);
	  if (err != GSASL_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->serverservice = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_service (sctx, NULL, NULL, buf, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->serverhostname = strdup (buf);

	  /* XXX do some checking on realm and server name?  Right now
	     we simply doesn't care about what client requested and
	     return a ticket for this server.  This is bad. */

	  err = shishi_tkt_clientrealm_set (tkt, state->userrealm,
					    state->username);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  {
	    char *p;
	    p = malloc (strlen (state->serverservice) + strlen ("/") +
			strlen (state->serverhostname) + 1);
	    if (p == NULL)
	      return GSASL_MALLOC_ERROR;
	    sprintf (p, "%s/%s", state->serverservice, state->serverhostname);
	    err = shishi_tkt_serverrealm_set (tkt, state->serverrealm, p);
	    free (p);
	    if (err)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;
	  }

	  buflen = sizeof (buf);
	  err = shishi_as_derive_salt (state->sh,
				       shishi_as_req (state->as),
				       shishi_as_rep (state->as),
				       buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;

	  err = shishi_key_from_string (state->sh,
					etype,
					state->password,
					strlen (state->password),
					buf, buflen, NULL, &amp;state->userkey);
	  if (err != SHISHI_OK)
	    return err;

	  err = shishi_tkt_build (tkt, state->sessiontktkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  err = shishi_as_rep_build (state->as, state->userkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

#if DEBUG
	  shishi_kdcreq_print (state->sh, stderr, shishi_as_req (state->as));
	  shishi_encticketpart_print (state->sh, stderr,
				      shishi_tkt_encticketpart (tkt));
	  shishi_ticket_print (state->sh, stderr, shishi_tkt_ticket (tkt));
	  shishi_enckdcreppart_print (state->sh, stderr,
				      shishi_tkt_enckdcreppart (state->as));
	  shishi_kdcrep_print (state->sh, stderr, shishi_as_rep (state->as));
#endif

	  err = shishi_as_rep_der (state->as, output, output_len);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  return GSASL_NEEDS_MORE;
	}
      else if ((asn1 = shishi_der2asn1_apreq (state->sh, input, input_len)))
	{
	  int adtype;

	  err = shishi_ap (state->sh, &amp;state->ap);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  shishi_ap_req_set (state->ap, asn1);

	  err = shishi_ap_req_process (state->ap, state->sessiontktkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

#if DEBUG
	  shishi_apreq_print (state->sh, stderr, shishi_ap_req (state->ap));
	  shishi_ticket_print (state->sh, stderr,
			       shishi_tkt_ticket (shishi_ap_tkt (state->ap)));
	  shishi_authenticator_print (state->sh, stderr,
				      shishi_ap_authenticator (state->ap));
#endif

	  buflen = sizeof (buf);
	  err = shishi_authenticator_authorizationdata
	    (state->sh, shishi_ap_authenticator (state->ap),
	     &amp;adtype, buf, &buflen, 1);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  if (adtype != 0xFF /* -1 in one-complements form */  ||
	      buflen < CLIENT_HELLO_LEN + SERVER_HELLO_LEN)
	    return GSASL_AUTHENTICATION_ERROR;

	  {
	    unsigned char clientbitmap;

	    memcpy (&amp;clientbitmap, &buf[0], BITMAP_LEN);
	    state->clientqop = 0;
	    if (clientbitmap &amp; GSASL_QOP_AUTH)
	      state->clientqop |= GSASL_QOP_AUTH;
	    if (clientbitmap &amp; GSASL_QOP_AUTH_INT)
	      state->clientqop |= GSASL_QOP_AUTH_INT;
	    if (clientbitmap &amp; GSASL_QOP_AUTH_CONF)
	      state->clientqop |= GSASL_QOP_AUTH_CONF;
	    if (clientbitmap &amp; MUTUAL)
	      state->clientmutual = 1;
	  }
	  memcpy (&amp;state->clientmaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);
	  state->clientmaxbuf = ntohl (state->clientmaxbuf);

	  if (!(state->clientqop &amp; state->serverqops))
	    return GSASL_AUTHENTICATION_ERROR;

	  /* XXX check clientmaxbuf too */

	  if (memcmp (&amp;buf[CLIENT_HELLO_LEN],
		      state->serverhello, SERVER_HELLO_LEN) != 0)
	    return GSASL_AUTHENTICATION_ERROR;

	  {
	    char cksum[BUFSIZ];
	    int cksumlen;
	    int cksumtype;
	    Shishi_key *key;

	    key = shishi_tkt_key (shishi_as_tkt (state->as));
	    cksumtype =
	      shishi_cipher_defaultcksumtype (shishi_key_type (key));
	    cksumlen = sizeof (cksum);
	    err = shishi_checksum (state->sh, key,
				   SHISHI_KEYUSAGE_APREQ_AUTHENTICATOR_CKSUM,
				   cksumtype, buf, buflen, cksum, &amp;cksumlen);
	    if (err != SHISHI_OK)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	    buflen = sizeof (buf);
	    err = shishi_authenticator_cksum
	      (state->sh,
	       shishi_ap_authenticator (state->ap), &amp;cksumtype, buf, &buflen);
	    if (err != SHISHI_OK)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	    if (buflen != cksumlen || memcmp (buf, cksum, buflen) != 0)
	      return GSASL_AUTHENTICATION_ERROR;
	  }

	  /* XXX use authorization_id */

	  if (state->clientmutual)
	    {
	      err = shishi_ap_rep_build (state->ap);
	      if (err)
		return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	      err = shishi_ap_rep_der (state->ap, output, output_len);
	      if (err)
		return GSASL_KERBEROS_V5_INTERNAL_ERROR;
	    }
	  else
	    *output_len = 0;

	  return GSASL_OK;
	}
    }
  else
    {
      /* XXX Currently we only handle AS-REQ and AP-REQ in
         non-infrastructure mode.  Supporting infrastructure mode is
         simple, just send the AS-REQ to the KDC and wait for AS-REP
         instead of creating AS-REP locally.

         We should probably have a callback to decide policy:
         1) non-infrastructure mode (NIM) only
         2) infrastructure mode (IM) only
         3) proxied infrastructure mode (PIM) only
         4) NIM with fallback to IM (useful for local server overrides)
         5) IM with fallback to NIM (useful for admins if KDC is offline)
         6) ...etc with PIM too
       */
      return GSASL_NEED_SERVER_RETRIEVE_CALLBACK;
    }

  *output_len = 0;
  return GSASL_NEEDS_MORE;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_untestable">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_step_src', '_gsasl_kerberos_v5_server_step_button')"><span id="_gsasl_kerberos_v5_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_step
</td>
<td class="function_entry_cyclo">
59
</td>
<td class="function_entry_number">
214
</td>
<td class="function_entry_number">
381
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_step (Gsasl_session * sctx,
				void *mech_data,
				const char *input,
				size_t input_len,
				char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  Gsasl_server_callback_realm cb_realm;
  Gsasl_server_callback_qop cb_qop;
  Gsasl_server_callback_maxbuf cb_maxbuf;
  Gsasl_server_callback_cipher cb_cipher;
  Gsasl_server_callback_retrieve cb_retrieve;
  Gsasl_server_callback_service cb_service;
  unsigned char buf[BUFSIZ];
  size_t buflen;
  Gsasl_ctx *ctx;
  ASN1_TYPE asn1;
  int err;

  ctx = gsasl_server_ctx_get (sctx);
  if (ctx == NULL)
    return GSASL_CANNOT_GET_CTX;

  cb_realm = gsasl_server_callback_realm_get (ctx);
  cb_qop = gsasl_server_callback_qop_get (ctx);
  cb_maxbuf = gsasl_server_callback_maxbuf_get (ctx);
  cb_retrieve = gsasl_server_callback_retrieve_get (ctx);
  cb_service = gsasl_server_callback_service_get (ctx);
  if (cb_service == NULL)
    return GSASL_NEED_SERVER_SERVICE_CALLBACK;

  if (state->firststep)
    {
      uint32_t tmp;
      unsigned char *p;

      /*
       * The initial server packet should contain one octet containing
       * a bit mask of supported security layers, four octets
       * indicating the maximum cipher-text buffer size the server is
       * able to receive (or 0 if no security layers are supported) in
       * network byte order, and then 16 octets containing random data
       * (see [4] on how random data might be generated).
       *
       * The security layers and their corresponding bit-masks are as
       * follows:
       *
       *       Bit 0 No security layer
       *       Bit 1 Integrity (KRB-SAFE) protection
       *       Bit 2 Privacy (KRB-PRIV) protection
       *       Bit 3 Mutual authentication is required (AP option MUTUAL-
       *             REQUIRED must also be present).
       *
       * Other bit-masks may be defined in the future; bits which are
       * not understood must be negotiated off.
       *
       */
      if (output &amp;& *output_len < BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN)
	return GSASL_TOO_SMALL_BUFFER;

      p = &amp;state->serverhello[0];

      if (cb_qop)
	state->serverqops = cb_qop (sctx);
      *p = 0;
      if (state->serverqops &amp; GSASL_QOP_AUTH)
	*p |= GSASL_QOP_AUTH;
      if (state->serverqops &amp; GSASL_QOP_AUTH_INT)
	*p |= GSASL_QOP_AUTH_INT;
      if (state->serverqops &amp; GSASL_QOP_AUTH_CONF)
	*p |= GSASL_QOP_AUTH_CONF;
      /* XXX we always require mutual authentication for now */
      *p |= MUTUAL;

      if (!(state->serverqops &amp; ~GSASL_QOP_AUTH))
	state->servermaxbuf = 0;
      else if (cb_maxbuf)
	state->servermaxbuf = cb_maxbuf (sctx);
      else
	state->servermaxbuf = MAXBUF_DEFAULT;

      tmp = htonl (state->servermaxbuf);
      memcpy (&amp;state->serverhello[BITMAP_LEN], &tmp, MAXBUF_LEN);
      memcpy (&amp;state->serverhello[BITMAP_LEN + MAXBUF_LEN],
	      state->random, RANDOM_LEN);

      if (output)
	memcpy (output, state->serverhello, SERVER_HELLO_LEN);
      *output_len = BITMAP_LEN + MAXBUF_LEN + RANDOM_LEN;

      state->firststep = 0;

      return GSASL_NEEDS_MORE;
    }

  if (cb_retrieve)
    {
      /* Non-infrastructure mode */

      if (*output_len < 2048)
	return GSASL_TOO_SMALL_BUFFER;

      if (shishi_as_req_der_set (state->as, input, input_len) == SHISHI_OK)
	{
	  Shishi_tkt *tkt;
	  int etype, i;

	  tkt = shishi_as_tkt (state->as);
	  if (!tkt)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  i = 1;
	  do
	    {
	      err = shishi_kdcreq_etype (state->sh,
					 shishi_as_req (state->as),
					 &amp;etype, i);
	      if (err == SHISHI_OK &amp;& shishi_cipher_supported_p (etype))
		break;
	    }
	  while (err == SHISHI_OK);
	  if (err != SHISHI_OK)
	    return err;

	  /* XXX use a "preferred server kdc etype" from shishi instead? */
	  err = shishi_key_random (state->sh, etype, &amp;state->sessionkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  err = shishi_tkt_key_set (tkt, state->sessionkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  buflen = sizeof (buf) - 1;
	  err = shishi_kdcreq_cname_get (state->sh,
					 shishi_as_req (state->as),
					 buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->username = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = shishi_kdcreq_realm_get (state->sh,
					 shishi_as_req (state->as),
					 buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->userrealm = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,
			     NULL, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;

	  state->password = malloc (buflen + 1);
	  if (state->password == NULL)
	    return GSASL_MALLOC_ERROR;

	  err = cb_retrieve (sctx, state->username, NULL, state->userrealm,
			     state->password, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;
	  state->password[buflen] = '\0';

	  buflen = sizeof (buf) - 1;
	  if (cb_realm)
	    {
	      err = cb_realm (sctx, buf, &amp;buflen, 0);
	      if (err != GSASL_OK)
		return err;
	    }
	  else
	    buflen = 0;
	  buf[buflen] = '\0';
	  state->serverrealm = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_service (sctx, buf, &amp;buflen, NULL, NULL);
	  if (err != GSASL_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->serverservice = strdup (buf);

	  buflen = sizeof (buf) - 1;
	  err = cb_service (sctx, NULL, NULL, buf, &amp;buflen);
	  if (err != GSASL_OK)
	    return err;
	  buf[buflen] = '\0';
	  state->serverhostname = strdup (buf);

	  /* XXX do some checking on realm and server name?  Right now
	     we simply doesn't care about what client requested and
	     return a ticket for this server.  This is bad. */

	  err = shishi_tkt_clientrealm_set (tkt, state->userrealm,
					    state->username);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  {
	    char *p;
	    p = malloc (strlen (state->serverservice) + strlen ("/") +
			strlen (state->serverhostname) + 1);
	    if (p == NULL)
	      return GSASL_MALLOC_ERROR;
	    sprintf (p, "%s/%s", state->serverservice, state->serverhostname);
	    err = shishi_tkt_serverrealm_set (tkt, state->serverrealm, p);
	    free (p);
	    if (err)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;
	  }

	  buflen = sizeof (buf);
	  err = shishi_as_derive_salt (state->sh,
				       shishi_as_req (state->as),
				       shishi_as_rep (state->as),
				       buf, &amp;buflen);
	  if (err != SHISHI_OK)
	    return err;

	  err = shishi_key_from_string (state->sh,
					etype,
					state->password,
					strlen (state->password),
					buf, buflen, NULL, &amp;state->userkey);
	  if (err != SHISHI_OK)
	    return err;

	  err = shishi_tkt_build (tkt, state->sessiontktkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  err = shishi_as_rep_build (state->as, state->userkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

#if DEBUG
	  shishi_kdcreq_print (state->sh, stderr, shishi_as_req (state->as));
	  shishi_encticketpart_print (state->sh, stderr,
				      shishi_tkt_encticketpart (tkt));
	  shishi_ticket_print (state->sh, stderr, shishi_tkt_ticket (tkt));
	  shishi_enckdcreppart_print (state->sh, stderr,
				      shishi_tkt_enckdcreppart (state->as));
	  shishi_kdcrep_print (state->sh, stderr, shishi_as_rep (state->as));
#endif

	  err = shishi_as_rep_der (state->as, output, output_len);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  return GSASL_NEEDS_MORE;
	}
      else if ((asn1 = shishi_der2asn1_apreq (state->sh, input, input_len)))
	{
	  int adtype;

	  err = shishi_ap (state->sh, &amp;state->ap);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  shishi_ap_req_set (state->ap, asn1);

	  err = shishi_ap_req_process (state->ap, state->sessiontktkey);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

#if DEBUG
	  shishi_apreq_print (state->sh, stderr, shishi_ap_req (state->ap));
	  shishi_ticket_print (state->sh, stderr,
			       shishi_tkt_ticket (shishi_ap_tkt (state->ap)));
	  shishi_authenticator_print (state->sh, stderr,
				      shishi_ap_authenticator (state->ap));
#endif

	  buflen = sizeof (buf);
	  err = shishi_authenticator_authorizationdata
	    (state->sh, shishi_ap_authenticator (state->ap),
	     &amp;adtype, buf, &buflen, 1);
	  if (err)
	    return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	  if (adtype != 0xFF /* -1 in one-complements form */  ||
	      buflen < CLIENT_HELLO_LEN + SERVER_HELLO_LEN)
	    return GSASL_AUTHENTICATION_ERROR;

	  {
	    unsigned char clientbitmap;

	    memcpy (&amp;clientbitmap, &buf[0], BITMAP_LEN);
	    state->clientqop = 0;
	    if (clientbitmap &amp; GSASL_QOP_AUTH)
	      state->clientqop |= GSASL_QOP_AUTH;
	    if (clientbitmap &amp; GSASL_QOP_AUTH_INT)
	      state->clientqop |= GSASL_QOP_AUTH_INT;
	    if (clientbitmap &amp; GSASL_QOP_AUTH_CONF)
	      state->clientqop |= GSASL_QOP_AUTH_CONF;
	    if (clientbitmap &amp; MUTUAL)
	      state->clientmutual = 1;
	  }
	  memcpy (&amp;state->clientmaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);
	  state->clientmaxbuf = ntohl (state->clientmaxbuf);

	  if (!(state->clientqop &amp; state->serverqops))
	    return GSASL_AUTHENTICATION_ERROR;

	  /* XXX check clientmaxbuf too */

	  if (memcmp (&amp;buf[CLIENT_HELLO_LEN],
		      state->serverhello, SERVER_HELLO_LEN) != 0)
	    return GSASL_AUTHENTICATION_ERROR;

	  {
	    char cksum[BUFSIZ];
	    int cksumlen;
	    int cksumtype;
	    Shishi_key *key;

	    key = shishi_tkt_key (shishi_as_tkt (state->as));
	    cksumtype =
	      shishi_cipher_defaultcksumtype (shishi_key_type (key));
	    cksumlen = sizeof (cksum);
	    err = shishi_checksum (state->sh, key,
				   SHISHI_KEYUSAGE_APREQ_AUTHENTICATOR_CKSUM,
				   cksumtype, buf, buflen, cksum, &amp;cksumlen);
	    if (err != SHISHI_OK)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	    buflen = sizeof (buf);
	    err = shishi_authenticator_cksum
	      (state->sh,
	       shishi_ap_authenticator (state->ap), &amp;cksumtype, buf, &buflen);
	    if (err != SHISHI_OK)
	      return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	    if (buflen != cksumlen || memcmp (buf, cksum, buflen) != 0)
	      return GSASL_AUTHENTICATION_ERROR;
	  }

	  /* XXX use authorization_id */

	  if (state->clientmutual)
	    {
	      err = shishi_ap_rep_build (state->ap);
	      if (err)
		return GSASL_KERBEROS_V5_INTERNAL_ERROR;

	      err = shishi_ap_rep_der (state->ap, output, output_len);
	      if (err)
		return GSASL_KERBEROS_V5_INTERNAL_ERROR;
	    }
	  else
	    *output_len = 0;

	  return GSASL_OK;
	}
    }
  else
    {
      /* XXX Currently we only handle AS-REQ and AP-REQ in
         non-infrastructure mode.  Supporting infrastructure mode is
         simple, just send the AS-REQ to the KDC and wait for AS-REP
         instead of creating AS-REP locally.

         We should probably have a callback to decide policy:
         1) non-infrastructure mode (NIM) only
         2) infrastructure mode (IM) only
         3) proxied infrastructure mode (PIM) only
         4) NIM with fallback to IM (useful for local server overrides)
         5) IM with fallback to NIM (useful for admins if KDC is offline)
         6) ...etc with PIM too
       */
      return GSASL_NEED_SERVER_RETRIEVE_CALLBACK;
    }

  *output_len = 0;
  return GSASL_NEEDS_MORE;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_client_step_src', '_gsasl_kerberos_v5_client_step_button')"><span id="_gsasl_kerberos_v5_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_step
</td>
<td class="function_entry_cyclo">
44
</td>
<td class="function_entry_number">
153
</td>
<td class="function_entry_number">
277
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_client_step (Gsasl_session * sctx,
				void *mech_data,
				const char *input,
				size_t input_len,
				char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_client_state *state = mech_data;
  Gsasl_client_callback_authentication_id cb_authentication_id;
  Gsasl_client_callback_authorization_id cb_authorization_id;
  Gsasl_client_callback_qop cb_qop;
  Gsasl_client_callback_realm cb_realm;
  Gsasl_client_callback_password cb_password;
  Gsasl_client_callback_service cb_service;
  Gsasl_client_callback_maxbuf cb_maxbuf;
  Gsasl_ctx *ctx;
  int res;
  int len;

  ctx = gsasl_client_ctx_get (sctx);
  if (ctx == NULL)
    return GSASL_CANNOT_GET_CTX;

  /* These are optional */
  cb_realm = gsasl_client_callback_realm_get (ctx);
  cb_service = gsasl_client_callback_service_get (ctx);
  cb_authentication_id = gsasl_client_callback_authentication_id_get (ctx);
  cb_authorization_id = gsasl_client_callback_authorization_id_get (ctx);
  cb_qop = gsasl_client_callback_qop_get (ctx);
  cb_maxbuf = gsasl_client_callback_maxbuf_get (ctx);

  /* Only optionally needed in infrastructure mode */
  cb_password = gsasl_client_callback_password_get (ctx);
  if (cb_password == NULL)
    return GSASL_NEED_CLIENT_PASSWORD_CALLBACK;

  /* I think we really need this one */
  cb_service = gsasl_client_callback_service_get (ctx);
  if (cb_service == NULL)
    return GSASL_NEED_CLIENT_SERVICE_CALLBACK;

  switch (state->step)
    {
    case STEP_FIRST:
      if (input == NULL)
	{
	  *output_len = 0;
	  return GSASL_NEEDS_MORE;
	}

      if (input_len != SERVER_HELLO_LEN)
	return GSASL_MECHANISM_PARSE_ERROR;

      memcpy (state->serverhello, input, input_len);

      {
	unsigned char serverbitmap;

	memcpy (&amp;serverbitmap, input, BITMAP_LEN);
	state->serverqops = 0;
	if (serverbitmap &amp; GSASL_QOP_AUTH)
	  state->serverqops |= GSASL_QOP_AUTH;
	if (serverbitmap &amp; GSASL_QOP_AUTH_INT)
	  state->serverqops |= GSASL_QOP_AUTH_INT;
	if (serverbitmap &amp; GSASL_QOP_AUTH_CONF)
	  state->serverqops |= GSASL_QOP_AUTH_CONF;
	if (serverbitmap &amp; MUTUAL)
	  state->servermutual = 1;
      }
      memcpy (&amp;state->servermaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);
      state->servermaxbuf = ntohl (state->servermaxbuf);

      if (cb_qop)
	state->clientqop = cb_qop (sctx, state->serverqops);

      if (!(state->serverqops &amp; state->clientqop &
	    (GSASL_QOP_AUTH | GSASL_QOP_AUTH_INT | GSASL_QOP_AUTH_CONF)))
	return GSASL_AUTHENTICATION_ERROR;

      /* XXX for now we require server authentication */
      if (!state->servermutual)
	return GSASL_AUTHENTICATION_ERROR;

      /* Decide policy here: non-infrastructure, infrastructure or proxy.
       *
       * A callback to decide should be added, but without the default
       * should be:
       *
       * IF shishi_tktset_get_for_server() THEN
       *    INFRASTRUCTURE MODE
       * ELSE IF shishi_realm_for_server(server) THEN
       *    PROXY INFRASTRUCTURE (then fallback to NIM?)
       * ELSE
       *    NON-INFRASTRUCTURE MODE
       */
      state->step = STEP_NONINFRA_SEND_APREQ;	/* only NIM for now.. */
      /* fall through */

    case STEP_NONINFRA_SEND_ASREQ:
      res = shishi_as (state->sh, &amp;state->as);
      if (res)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      if (cb_authentication_id)	/* Shishi defaults to one otherwise */
	{
	  len = *output_len - 1;
	  res = cb_authentication_id (sctx, output, &amp;len);
	  if (res != GSASL_OK)
	    return res;
	  output[len] = '\0';

	  res = shishi_kdcreq_set_cname (state->sh, shishi_as_req (state->as),
					 SHISHI_NT_UNKNOWN, output);
	  if (res != GSASL_OK)
	    return res;
	}

      if (cb_realm)
	{
	  len = *output_len - 1;
	  res = cb_realm (sctx, output, &amp;len);
	  if (res != GSASL_OK)
	    return res;
	}
      else
	len = 0;

      output[len] = '\0';
      res = shishi_kdcreq_set_realm (state->sh, shishi_as_req (state->as),
				     output);
      if (res != GSASL_OK)
	return res;

      if (cb_service)
	{
	  char *sname[3];
	  size_t servicelen = 0;
	  size_t hostnamelen = 0;

	  res = cb_service (sctx, NULL, &amp;servicelen, NULL, &hostnamelen,
			    /* XXX support servicename a'la DIGEST-MD5 too? */
			    NULL, NULL);
	  if (res != GSASL_OK)
	    return res;

	  if (*output_len < servicelen + 1 + hostnamelen + 1)
	    return GSASL_TOO_SMALL_BUFFER;

	  sname[0] = &amp;output[0];
	  sname[1] = &amp;output[servicelen + 2];
	  sname[2] = NULL;

	  res = cb_service (sctx, sname[0], &amp;servicelen,
			    sname[1], &amp;hostnamelen, NULL, NULL);
	  if (res != GSASL_OK)
	    return res;

	  sname[0][servicelen] = '\0';
	  sname[1][hostnamelen] = '\0';

	  res = shishi_kdcreq_set_sname (state->sh, shishi_as_req (state->as),
					 SHISHI_NT_UNKNOWN, sname);
	  if (res != GSASL_OK)
	    return res;
	}

      /* XXX query application for encryption types and set the etype
         field?  Already configured by shishi though... */

      res = shishi_a2d (state->sh, shishi_as_req (state->as),
			output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      state->step = STEP_NONINFRA_WAIT_ASREP;

      res = GSASL_NEEDS_MORE;
      break;

    case STEP_NONINFRA_WAIT_ASREP:
      if (shishi_as_rep_der_set (state->as, input, input_len) != SHISHI_OK)
	return GSASL_MECHANISM_PARSE_ERROR;

      /* XXX? password stored in callee's output buffer */
      len = *output_len - 1;
      res = cb_password (sctx, output, &amp;len);
      if (res != GSASL_OK &amp;& res != GSASL_NEEDS_MORE)
	return res;
      output[len] = '\0';

      res = shishi_as_rep_process (state->as, NULL, output);
      if (res != SHISHI_OK)
	return GSASL_AUTHENTICATION_ERROR;

      state->step = STEP_NONINFRA_SEND_APREQ;
      /* fall through */

    case STEP_NONINFRA_SEND_APREQ:
      if (*output_len <= CLIENT_HELLO_LEN + SERVER_HELLO_LEN)
	return GSASL_TOO_SMALL_BUFFER;

      if (!(state->clientqop &amp; ~GSASL_QOP_AUTH))
	state->clientmaxbuf = 0;
      else if (cb_maxbuf)
	state->clientmaxbuf = cb_maxbuf (sctx, state->servermaxbuf);
      else
	state->clientmaxbuf = MAXBUF_DEFAULT;

      /* XXX for now we require server authentication */
      output[0] = state->clientqop | MUTUAL;
      {
	uint32_t tmp;

	tmp = ntohl (state->clientmaxbuf);
	memcpy (&amp;output[BITMAP_LEN], &tmp, MAXBUF_LEN);
      }
      memcpy (&amp;output[CLIENT_HELLO_LEN], state->serverhello,
	      SERVER_HELLO_LEN);

      if (cb_authorization_id)
	{
	  len = *output_len - CLIENT_HELLO_LEN + SERVER_HELLO_LEN;
	  res = cb_authorization_id (sctx, &amp;output[CLIENT_HELLO_LEN +
						   SERVER_HELLO_LEN], &amp;len);
	}
      else
	len = 0;

      len += CLIENT_HELLO_LEN + SERVER_HELLO_LEN;
      res = shishi_ap_tktoptionsdata (state->sh,
				      &amp;state->ap,
				      shishi_as_tkt (state->as),
				      SHISHI_APOPTIONS_MUTUAL_REQUIRED,
				      output, len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_authenticator_add_authorizationdata
	(state->sh, shishi_ap_authenticator (state->ap), -1, output, len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      /* XXX set realm in AP-REQ and Authenticator */

      res = shishi_ap_req_der (state->ap, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      state->step = STEP_NONINFRA_WAIT_APREP;

      res = GSASL_NEEDS_MORE;
      break;

    case STEP_NONINFRA_WAIT_APREP:
      if (shishi_ap_rep_der_set (state->ap, input, input_len) != SHISHI_OK)
	return GSASL_MECHANISM_PARSE_ERROR;

      res = shishi_ap_rep_verify (state->ap);
      if (res != SHISHI_OK)
	return GSASL_AUTHENTICATION_ERROR;

      state->step = STEP_SUCCESS;

      /* XXX support AP session keys */
      state->sessionkey = shishi_tkt_key (shishi_as_tkt (state->as));

      *output_len = 0;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_client_step_src', '_gsasl_kerberos_v5_client_step_button')"><span id="_gsasl_kerberos_v5_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_step
</td>
<td class="function_entry_cyclo">
44
</td>
<td class="function_entry_number">
153
</td>
<td class="function_entry_number">
277
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_client_step (Gsasl_session * sctx,
				void *mech_data,
				const char *input,
				size_t input_len,
				char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_client_state *state = mech_data;
  Gsasl_client_callback_authentication_id cb_authentication_id;
  Gsasl_client_callback_authorization_id cb_authorization_id;
  Gsasl_client_callback_qop cb_qop;
  Gsasl_client_callback_realm cb_realm;
  Gsasl_client_callback_password cb_password;
  Gsasl_client_callback_service cb_service;
  Gsasl_client_callback_maxbuf cb_maxbuf;
  Gsasl_ctx *ctx;
  int res;
  int len;

  ctx = gsasl_client_ctx_get (sctx);
  if (ctx == NULL)
    return GSASL_CANNOT_GET_CTX;

  /* These are optional */
  cb_realm = gsasl_client_callback_realm_get (ctx);
  cb_service = gsasl_client_callback_service_get (ctx);
  cb_authentication_id = gsasl_client_callback_authentication_id_get (ctx);
  cb_authorization_id = gsasl_client_callback_authorization_id_get (ctx);
  cb_qop = gsasl_client_callback_qop_get (ctx);
  cb_maxbuf = gsasl_client_callback_maxbuf_get (ctx);

  /* Only optionally needed in infrastructure mode */
  cb_password = gsasl_client_callback_password_get (ctx);
  if (cb_password == NULL)
    return GSASL_NEED_CLIENT_PASSWORD_CALLBACK;

  /* I think we really need this one */
  cb_service = gsasl_client_callback_service_get (ctx);
  if (cb_service == NULL)
    return GSASL_NEED_CLIENT_SERVICE_CALLBACK;

  switch (state->step)
    {
    case STEP_FIRST:
      if (input == NULL)
	{
	  *output_len = 0;
	  return GSASL_NEEDS_MORE;
	}

      if (input_len != SERVER_HELLO_LEN)
	return GSASL_MECHANISM_PARSE_ERROR;

      memcpy (state->serverhello, input, input_len);

      {
	unsigned char serverbitmap;

	memcpy (&amp;serverbitmap, input, BITMAP_LEN);
	state->serverqops = 0;
	if (serverbitmap &amp; GSASL_QOP_AUTH)
	  state->serverqops |= GSASL_QOP_AUTH;
	if (serverbitmap &amp; GSASL_QOP_AUTH_INT)
	  state->serverqops |= GSASL_QOP_AUTH_INT;
	if (serverbitmap &amp; GSASL_QOP_AUTH_CONF)
	  state->serverqops |= GSASL_QOP_AUTH_CONF;
	if (serverbitmap &amp; MUTUAL)
	  state->servermutual = 1;
      }
      memcpy (&amp;state->servermaxbuf, &input[BITMAP_LEN], MAXBUF_LEN);
      state->servermaxbuf = ntohl (state->servermaxbuf);

      if (cb_qop)
	state->clientqop = cb_qop (sctx, state->serverqops);

      if (!(state->serverqops &amp; state->clientqop &
	    (GSASL_QOP_AUTH | GSASL_QOP_AUTH_INT | GSASL_QOP_AUTH_CONF)))
	return GSASL_AUTHENTICATION_ERROR;

      /* XXX for now we require server authentication */
      if (!state->servermutual)
	return GSASL_AUTHENTICATION_ERROR;

      /* Decide policy here: non-infrastructure, infrastructure or proxy.
       *
       * A callback to decide should be added, but without the default
       * should be:
       *
       * IF shishi_tktset_get_for_server() THEN
       *    INFRASTRUCTURE MODE
       * ELSE IF shishi_realm_for_server(server) THEN
       *    PROXY INFRASTRUCTURE (then fallback to NIM?)
       * ELSE
       *    NON-INFRASTRUCTURE MODE
       */
      state->step = STEP_NONINFRA_SEND_APREQ;	/* only NIM for now.. */
      /* fall through */

    case STEP_NONINFRA_SEND_ASREQ:
      res = shishi_as (state->sh, &amp;state->as);
      if (res)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      if (cb_authentication_id)	/* Shishi defaults to one otherwise */
	{
	  len = *output_len - 1;
	  res = cb_authentication_id (sctx, output, &amp;len);
	  if (res != GSASL_OK)
	    return res;
	  output[len] = '\0';

	  res = shishi_kdcreq_set_cname (state->sh, shishi_as_req (state->as),
					 SHISHI_NT_UNKNOWN, output);
	  if (res != GSASL_OK)
	    return res;
	}

      if (cb_realm)
	{
	  len = *output_len - 1;
	  res = cb_realm (sctx, output, &amp;len);
	  if (res != GSASL_OK)
	    return res;
	}
      else
	len = 0;

      output[len] = '\0';
      res = shishi_kdcreq_set_realm (state->sh, shishi_as_req (state->as),
				     output);
      if (res != GSASL_OK)
	return res;

      if (cb_service)
	{
	  char *sname[3];
	  size_t servicelen = 0;
	  size_t hostnamelen = 0;

	  res = cb_service (sctx, NULL, &amp;servicelen, NULL, &hostnamelen,
			    /* XXX support servicename a'la DIGEST-MD5 too? */
			    NULL, NULL);
	  if (res != GSASL_OK)
	    return res;

	  if (*output_len < servicelen + 1 + hostnamelen + 1)
	    return GSASL_TOO_SMALL_BUFFER;

	  sname[0] = &amp;output[0];
	  sname[1] = &amp;output[servicelen + 2];
	  sname[2] = NULL;

	  res = cb_service (sctx, sname[0], &amp;servicelen,
			    sname[1], &amp;hostnamelen, NULL, NULL);
	  if (res != GSASL_OK)
	    return res;

	  sname[0][servicelen] = '\0';
	  sname[1][hostnamelen] = '\0';

	  res = shishi_kdcreq_set_sname (state->sh, shishi_as_req (state->as),
					 SHISHI_NT_UNKNOWN, sname);
	  if (res != GSASL_OK)
	    return res;
	}

      /* XXX query application for encryption types and set the etype
         field?  Already configured by shishi though... */

      res = shishi_a2d (state->sh, shishi_as_req (state->as),
			output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      state->step = STEP_NONINFRA_WAIT_ASREP;

      res = GSASL_NEEDS_MORE;
      break;

    case STEP_NONINFRA_WAIT_ASREP:
      if (shishi_as_rep_der_set (state->as, input, input_len) != SHISHI_OK)
	return GSASL_MECHANISM_PARSE_ERROR;

      /* XXX? password stored in callee's output buffer */
      len = *output_len - 1;
      res = cb_password (sctx, output, &amp;len);
      if (res != GSASL_OK &amp;& res != GSASL_NEEDS_MORE)
	return res;
      output[len] = '\0';

      res = shishi_as_rep_process (state->as, NULL, output);
      if (res != SHISHI_OK)
	return GSASL_AUTHENTICATION_ERROR;

      state->step = STEP_NONINFRA_SEND_APREQ;
      /* fall through */

    case STEP_NONINFRA_SEND_APREQ:
      if (*output_len <= CLIENT_HELLO_LEN + SERVER_HELLO_LEN)
	return GSASL_TOO_SMALL_BUFFER;

      if (!(state->clientqop &amp; ~GSASL_QOP_AUTH))
	state->clientmaxbuf = 0;
      else if (cb_maxbuf)
	state->clientmaxbuf = cb_maxbuf (sctx, state->servermaxbuf);
      else
	state->clientmaxbuf = MAXBUF_DEFAULT;

      /* XXX for now we require server authentication */
      output[0] = state->clientqop | MUTUAL;
      {
	uint32_t tmp;

	tmp = ntohl (state->clientmaxbuf);
	memcpy (&amp;output[BITMAP_LEN], &tmp, MAXBUF_LEN);
      }
      memcpy (&amp;output[CLIENT_HELLO_LEN], state->serverhello,
	      SERVER_HELLO_LEN);

      if (cb_authorization_id)
	{
	  len = *output_len - CLIENT_HELLO_LEN + SERVER_HELLO_LEN;
	  res = cb_authorization_id (sctx, &amp;output[CLIENT_HELLO_LEN +
						   SERVER_HELLO_LEN], &amp;len);
	}
      else
	len = 0;

      len += CLIENT_HELLO_LEN + SERVER_HELLO_LEN;
      res = shishi_ap_tktoptionsdata (state->sh,
				      &amp;state->ap,
				      shishi_as_tkt (state->as),
				      SHISHI_APOPTIONS_MUTUAL_REQUIRED,
				      output, len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_authenticator_add_authorizationdata
	(state->sh, shishi_ap_authenticator (state->ap), -1, output, len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      /* XXX set realm in AP-REQ and Authenticator */

      res = shishi_ap_req_der (state->ap, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      state->step = STEP_NONINFRA_WAIT_APREP;

      res = GSASL_NEEDS_MORE;
      break;

    case STEP_NONINFRA_WAIT_APREP:
      if (shishi_ap_rep_der_set (state->ap, input, input_len) != SHISHI_OK)
	return GSASL_MECHANISM_PARSE_ERROR;

      res = shishi_ap_rep_verify (state->ap);
      if (res != SHISHI_OK)
	return GSASL_AUTHENTICATION_ERROR;

      state->step = STEP_SUCCESS;

      /* XXX support AP session keys */
      state->sessionkey = shishi_tkt_key (shishi_as_tkt (state->as));

      *output_len = 0;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_scram_sha1_server_step_src', '_gsasl_scram_sha1_server_step_button')"><span id="_gsasl_scram_sha1_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_server_step
</td>
<td class="function_entry_cyclo">
39
</td>
<td class="function_entry_number">
139
</td>
<td class="function_entry_number">
268
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/server.c;hb=HEAD">lib/scram/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_scram_sha1_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_scram_sha1_server_step (Gsasl_session * sctx,
			       void *mech_data,
			       const char *input,
			       size_t input_len,
			       char **output, size_t * output_len)
{
  struct scram_server_state *state = mech_data;
  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
  int rc;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      {
	if (input_len == 0)
	  return GSASL_NEEDS_MORE;

	if (scram_parse_client_first (input, input_len, &amp;state->cf) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	/* We don't support channel bindings. */
	if (state->cf.cbflag != 'n')
	  return GSASL_AUTHENTICATION_ERROR;

	/* Check that username doesn't fail SASLprep. */
	{
	  char *tmp;
	  rc = gsasl_saslprep (state->cf.username, GSASL_ALLOW_UNASSIGNED,
			       &amp;tmp, NULL);
	  if (rc != GSASL_OK || *tmp == '\0')
	    return GSASL_AUTHENTICATION_ERROR;
	  gsasl_free (tmp);
	}

	{
	  const char *p;

	  /* Save "bare" for next step. */
	  p = memchr (input, ',', input_len);
	  if (!p)
	    return GSASL_AUTHENTICATION_ERROR;
	  p++;
	  p = memchr (p, ',', input_len - (p - input));
	  if (!p)
	    return GSASL_AUTHENTICATION_ERROR;
	  p++;

	  state->cfmb_str = malloc (input_len - (p - input) + 1);
	  if (!state->cfmb_str)
	    return GSASL_MALLOC_ERROR;
	  memcpy (state->cfmb_str, p, input_len - (p - input));
	  state->cfmb_str[input_len - (p - input)] = '\0';
	}

	/* Create new nonce. */
	{
	  size_t cnlen = strlen (state->cf.client_nonce);

	  state->sf.nonce = malloc (cnlen + SNONCE_ENTROPY_BYTES + 1);
	  if (!state->sf.nonce)
	    return GSASL_MALLOC_ERROR;

	  memcpy (state->sf.nonce, state->cf.client_nonce, cnlen);
	  memcpy (state->sf.nonce + cnlen, state->snonce,
		  SNONCE_ENTROPY_BYTES);
	  state->sf.nonce[cnlen + SNONCE_ENTROPY_BYTES] = '\0';
	}

	gsasl_property_set (sctx, GSASL_AUTHID, state->cf.username);
	gsasl_property_set (sctx, GSASL_AUTHZID, state->cf.authzid);

	{
	  const char *p = gsasl_property_get (sctx, GSASL_SCRAM_ITER);
	  if (p)
	    state->sf.iter = strtoul (p, NULL, 10);
	  if (!p || state->sf.iter == 0 || state->sf.iter == ULONG_MAX)
	    state->sf.iter = 4096;
	}

	{
	  const char *p = gsasl_property_get (sctx, GSASL_SCRAM_SALT);
	  if (p)
	    {
	      free (state->sf.salt);
	      state->sf.salt = strdup (p);
	    }
	}

	rc = scram_print_server_first (&amp;state->sf, &state->sf_str);
	if (rc != 0)
	  return GSASL_MALLOC_ERROR;

	*output = strdup (state->sf_str);
	if (!*output)
	  return GSASL_MALLOC_ERROR;
	*output_len = strlen (*output);

	state->step++;
	return GSASL_NEEDS_MORE;
	break;
      }

    case 1:
      {
	if (scram_parse_client_final (input, input_len, &amp;state->cl) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	if (strcmp (state->cl.nonce, state->sf.nonce) != 0)
	  return GSASL_AUTHENTICATION_ERROR;

	/* Base64 decode client proof and check that length matches
	   SHA-1 size. */
	{
	  size_t len;

	  rc = gsasl_base64_from (state->cl.proof, strlen (state->cl.proof),
				  &amp;state->clientproof, &len);
	  if (rc != 0)
	    return rc;
	  if (len != 20)
	    return GSASL_MECHANISM_PARSE_ERROR;
	}

	{
	  const char *p;

	  /* Get StoredKey and ServerKey */
	  if ((p = gsasl_property_get (sctx, GSASL_PASSWORD)))
	    {
	      Gc_rc err;
	      char *salt;
	      size_t saltlen;
	      char saltedpassword[20];
	      char *clientkey;
	      char *preppasswd;

	      rc = gsasl_saslprep (p, 0, &amp;preppasswd, NULL);
	      if (rc != GSASL_OK)
		return rc;

	      rc = gsasl_base64_from (state->sf.salt, strlen (state->sf.salt),
				      &amp;salt, &saltlen);
	      if (rc != 0)
		{
		  gsasl_free (preppasswd);
		  return rc;
		}

	      /* SaltedPassword := Hi(password, salt) */
	      err = gc_pbkdf2_sha1 (preppasswd, strlen (preppasswd),
				    salt, saltlen,
				    state->sf.iter, saltedpassword, 20);
	      gsasl_free (preppasswd);
	      gsasl_free (salt);
	      if (err != GC_OK)
		return GSASL_MALLOC_ERROR;

	      /* ClientKey := HMAC(SaltedPassword, "Client Key") */
#define CLIENT_KEY "Client Key"
	      rc = gsasl_hmac_sha1 (saltedpassword, 20,
				    CLIENT_KEY, strlen (CLIENT_KEY),
				    &amp;clientkey);
	      if (rc != 0)
		return rc;

	      /* StoredKey := H(ClientKey) */
	      rc = gsasl_sha1 (clientkey, 20, &amp;state->storedkey);
	      free (clientkey);
	      if (rc != 0)
		return rc;

	      /* ServerKey := HMAC(SaltedPassword, "Server Key") */
#define SERVER_KEY "Server Key"
	      rc = gsasl_hmac_sha1 (saltedpassword, 20,
				    SERVER_KEY, strlen (SERVER_KEY),
				    &amp;state->serverkey);
	      if (rc != 0)
		return rc;
	    }
	  else
	    return GSASL_NO_PASSWORD;

	  /* Compute AuthMessage */
	  {
	    size_t len;
	    int n;

	    /* Get client-final-message-without-proof. */
	    p = memmem (input, input_len, ",p=", 3);
	    if (!p)
	      return GSASL_MECHANISM_PARSE_ERROR;
	    len = p - input;

	    n = asprintf (&amp;state->authmessage, "%s,%.*s,%.*s",
			  state->cfmb_str,
			  strlen (state->sf_str), state->sf_str,
			  len, input);
	    if (n <= 0 || !state->authmessage)
	      return GSASL_MALLOC_ERROR;
	  }

	  /* Check client proof. */
	  {
	    char *clientsignature;
	    char *maybe_storedkey;

	    /* ClientSignature := HMAC(StoredKey, AuthMessage) */
	    rc = gsasl_hmac_sha1 (state->storedkey, 20,
				  state->authmessage,
				  strlen (state->authmessage),
				  &amp;clientsignature);
	    if (rc != 0)
	      return rc;

	    /* ClientKey := ClientProof XOR ClientSignature */
	    memxor (clientsignature, state->clientproof, 20);

	    rc = gsasl_sha1 (clientsignature, 20, &amp;maybe_storedkey);
	    free (clientsignature);
	    if (rc != 0)
	      return rc;

	    rc = memcmp (state->storedkey, maybe_storedkey, 20);
	    free (maybe_storedkey);
	    if (rc != 0)
	      return GSASL_AUTHENTICATION_ERROR;
	  }

	  /* Generate server verifier. */
	  {
	    char *serversignature;

	    /* ServerSignature := HMAC(ServerKey, AuthMessage) */
	    rc = gsasl_hmac_sha1 (state->serverkey, 20,
				  state->authmessage,
				  strlen (state->authmessage),
				  &amp;serversignature);
	    if (rc != 0)
	      return rc;

	    rc = gsasl_base64_to (serversignature, 20,
				  &amp;state->sl.verifier, NULL);
	    free (serversignature);
	    if (rc != 0)
	      return rc;
	  }
	}

	rc = scram_print_server_final (&amp;state->sl, output);
	if (rc != 0)
	  return GSASL_MALLOC_ERROR;
	*output_len = strlen (*output);

	state->step++;
	return GSASL_OK;
	break;
      }

    default:
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_print_response_src', 'digest_md5_print_response_button')"><span id="digest_md5_print_response_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_print_response
</td>
<td class="function_entry_cyclo">
38
</td>
<td class="function_entry_number">
86
</td>
<td class="function_entry_number">
146
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/printer.c;hb=HEAD">lib/digest-md5/printer.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_print_response_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
char *
digest_md5_print_response (digest_md5_response * r)
{
  char *out = NULL;
  const char *qop = NULL;
  const char *cipher = NULL;

  /* Below we assume the mandatory fields are present, verify that
     first to avoid crashes. */
  if (digest_md5_validate_response (r) != 0)
    return NULL;

  if (r->qop &amp; DIGEST_MD5_QOP_AUTH_CONF)
    qop = "qop=auth-conf";
  else if (r->qop &amp; DIGEST_MD5_QOP_AUTH_INT)
    qop = "qop=auth-int";
  else if (r->qop &amp; DIGEST_MD5_QOP_AUTH)
    qop = "qop=auth";

  if (r->cipher &amp; DIGEST_MD5_CIPHER_3DES)
    cipher = "cipher=3des";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_DES)
    cipher = "cipher=des";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_RC4_40)
    cipher = "cipher=rc4-40";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_RC4)
    cipher = "cipher=rc4";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_RC4_56)
    cipher = "cipher=rc4-56";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_AES_CBC)
    cipher = "cipher=aes-cbc";
  else if (r->cipher &amp; DIGEST_MD5_CIPHER_3DES)
    cipher = "cipher=3des";

  if (r->username)
    if (comma_append (&amp;out, "username", r->username, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->realm)
    if (comma_append (&amp;out, "realm", r->realm, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->nonce)
    if (comma_append (&amp;out, "nonce", r->nonce, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->cnonce)
    if (comma_append (&amp;out, "cnonce", r->cnonce, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->nc)
    {
      char *tmp;

      if (asprintf (&amp;tmp, "%08lx", r->nc) < 0)
	{
	  free (out);
	  return NULL;
	}

      if (comma_append (&amp;out, "nc", tmp, 0) < 0)
	{
	  free (tmp);
	  free (out);
	  return NULL;
	}

      free (tmp);
    }

  if (qop)
    if (comma_append (&amp;out, qop, NULL, 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->digesturi)
    if (comma_append (&amp;out, "digest-uri", r->digesturi, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->response)
    if (comma_append (&amp;out, "response", r->response, 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->clientmaxbuf)
    {
      char *tmp;

      if (asprintf (&amp;tmp, "%lu", r->clientmaxbuf) < 0)
	{
	  free (out);
	  return NULL;
	}

      if (comma_append (&amp;out, "maxbuf", tmp, 0) < 0)
	{
	  free (tmp);
	  free (out);
	  return NULL;
	}

      free (tmp);
    }

  if (r->utf8)
    if (comma_append (&amp;out, "charset", "utf-8", 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (cipher)
    if (comma_append (&amp;out, cipher, NULL, 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (r->authzid)
    if (comma_append (&amp;out, "authzid", r->authzid, 1) < 0)
      {
	free (out);
	return NULL;
      }

  return out;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('parse_response_src', 'parse_response_button')"><span id="parse_response_button">&darr;</span></a>
</td>
<td class="function_entry_name">
parse_response
</td>
<td class="function_entry_cyclo">
48
</td>
<td class="function_entry_number">
95
</td>
<td class="function_entry_number">
171
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="parse_response_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
static int
parse_response (char *response, digest_md5_response * out)
{
  char *value;

  memset (out, 0, sizeof (*out));

  /* The size of a digest-response MUST be less than 4096 bytes. */
  if (strlen (response) >= 4096)
    return -1;

  while (*response != '\0')
    switch (digest_md5_getsubopt (&amp;response, digest_response_opts, &value))
      {
      case RESPONSE_USERNAME:
	/* This directive is required and MUST be present exactly
	   once; otherwise, authentication fails. */
	if (out->username)
	  return -1;
	out->username = strdup (value);
	if (!out->username)
	  return -1;
	break;

      case RESPONSE_REALM:
	/* This directive is required if the server provided any
	   realms in the "digest-challenge", in which case it may
	   appear exactly once and its value SHOULD be one of those
	   realms. */
	if (out->realm)
	  return -1;
	out->realm = strdup (value);
	if (!out->realm)
	  return -1;
	break;

      case RESPONSE_NONCE:
	/* This directive is required and MUST be present exactly
	   once; otherwise, authentication fails. */
	if (out->nonce)
	  return -1;
	out->nonce = strdup (value);
	if (!out->nonce)
	  return -1;
	break;

      case RESPONSE_CNONCE:
	/* This directive is required and MUST be present exactly once;
	   otherwise, authentication fails. */
	if (out->cnonce)
	  return -1;
	out->cnonce = strdup (value);
	if (!out->cnonce)
	  return -1;
	break;

      case RESPONSE_NC:
	/* This directive is required and MUST be present exactly
	   once; otherwise, authentication fails. */
	if (out->nc)
	  return -1;
	/* nc-value = 8LHEX */
	if (strlen (value) != 8)
	  return -1;
	out->nc = strtoul (value, NULL, 16);
	/* FIXME: error handling. */
	break;

      case RESPONSE_QOP:
	/* If present, it may appear exactly once and its value MUST
	   be one of the alternatives in qop-options.  */
	if (out->qop)
	  return -1;
	if (strcmp (value, "auth") == 0)
	  out->qop = DIGEST_MD5_QOP_AUTH;
	else if (strcmp (value, "auth-int") == 0)
	  out->qop = DIGEST_MD5_QOP_AUTH_INT;
	else if (strcmp (value, "auth-conf") == 0)
	  out->qop = DIGEST_MD5_QOP_AUTH_CONF;
	else
	  return -1;
	break;

      case RESPONSE_DIGEST_URI:
	/* This directive is required and MUST be present exactly
	   once; if multiple instances are present, the client MUST
	   abort the authentication exchange. */
	if (out->digesturi)
	  return -1;
	/* FIXME: sub-parse. */
	out->digesturi = strdup (value);
	if (!out->digesturi)
	  return -1;
	break;

      case RESPONSE_RESPONSE:
	/* This directive is required and MUST be present exactly
	   once; otherwise, authentication fails. */
	if (*out->response)
	  return -1;
	/* A string of 32 hex digits */
	if (strlen (value) != DIGEST_MD5_RESPONSE_LENGTH)
	  return -1;
	strcpy (out->response, value);
	break;

      case RESPONSE_MAXBUF:
	/* This directive may appear at most once; if multiple
	   instances are present, the server MUST abort the
	   authentication exchange. */
	if (out->clientmaxbuf)
	  return -1;
	out->clientmaxbuf = strtoul (value, NULL, 10);
	/* FIXME: error handling. */
	/* If the value is less or equal to 16 (<<32 for aes-cbc>>) or
	   bigger than 16777215 (i.e. 2**24-1), the server MUST abort
	   the authentication exchange. */
	if (out->clientmaxbuf <= 16 || out->clientmaxbuf > 16777215)
	  return -1;
	break;

      case RESPONSE_CHARSET:
	if (strcmp (DEFAULT_CHARSET, value) != 0)
	  return -1;
	out->utf8 = 1;
	break;

      case RESPONSE_CIPHER:
	if (out->cipher)
	  return -1;
	if (strcmp (value, "3des") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_3DES;
	else if (strcmp (value, "des") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_DES;
	else if (strcmp (value, "rc4-40") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_RC4_40;
	else if (strcmp (value, "rc4") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_RC4;
	else if (strcmp (value, "rc4-56") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_RC4_56;
	else if (strcmp (value, "aes-cbc") == 0)
	  out->cipher = DIGEST_MD5_CIPHER_AES_CBC;
	else
	  return -1;
	break;

      case RESPONSE_AUTHZID:
	/* This directive may appear at most once; if multiple
	   instances are present, the server MUST abort the
	   authentication exchange.  <<FIXME NOT IN DRAFT>> */
	if (out->authzid)
	  return -1;
	/*  The authzid MUST NOT be an empty string. */
	if (*value == '\0')
	  return -1;
	out->authzid = strdup (value);
	if (!out->authzid)
	  return -1;
	break;

      default:
	/* The client MUST ignore any unrecognized directives. */
	break;
      }

  /* Validate that we have the mandatory fields. */
  if (digest_md5_validate_response (out) != 0)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_scram_sha1_client_step_src', '_gsasl_scram_sha1_client_step_button')"><span id="_gsasl_scram_sha1_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_client_step
</td>
<td class="function_entry_cyclo">
39
</td>
<td class="function_entry_number">
140
</td>
<td class="function_entry_number">
260
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_scram_sha1_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_scram_sha1_client_step (Gsasl_session * sctx,
			       void *mech_data,
			       const char *input, size_t input_len,
			       char **output, size_t * output_len)
{
  struct scram_client_state *state = mech_data;
  int res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
  int rc;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      {
	const char *p;

	/* We don't support channel bindings. */
	state->cf.cbflag = 'n';

	p = gsasl_property_get (sctx, GSASL_AUTHID);
	if (!p)
	  return GSASL_NO_AUTHID;

	/* FIXME check that final document uses query strings. */
	rc = gsasl_saslprep (p, GSASL_ALLOW_UNASSIGNED,
			     &amp;state->cf.username, NULL);
	if (rc != GSASL_OK)
	  return rc;

	p = gsasl_property_get (sctx, GSASL_AUTHZID);
	if (p)
	  state->cf.authzid = strdup (p);

	rc = scram_print_client_first (&amp;state->cf, output);
	if (rc == -2)
	  return GSASL_MALLOC_ERROR;
	else if (rc != 0)
	  return GSASL_AUTHENTICATION_ERROR;

	*output_len = strlen (*output);

	/* Save "cbind" and "bare" for next step. */
	p = strchr (*output, ',');
	if (!p)
	    return GSASL_AUTHENTICATION_ERROR;
	p++;
	p = strchr (p, ',');
	if (!p)
	    return GSASL_AUTHENTICATION_ERROR;
	p++;
	rc = gsasl_base64_to (*output, p - *output, &amp;state->cl.cbind, NULL);
	if (rc != 0)
	  return rc;

	state->cfmb = strdup (p);
	if (!state->cfmb)
	  return GSASL_MALLOC_ERROR;

	/* We are done. */
	state->step++;
	return GSASL_NEEDS_MORE;
	break;
      }

    case 1:
      {
	if (scram_parse_server_first (input, input_len, &amp;state->sf) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	if (strlen (state->sf.nonce) < strlen (state->cf.client_nonce) ||
	    memcmp (state->cf.client_nonce, state->sf.nonce,
		    strlen (state->cf.client_nonce)) != 0)
	  return GSASL_AUTHENTICATION_ERROR;

	state->cl.nonce = strdup (state->sf.nonce);
	if (!state->cl.nonce)
	  return GSASL_MALLOC_ERROR;

	/* Save salt/iter as properties, so that client callback can
	   access them. */
	{
	  char *str = NULL;
	  int n;
	  n = asprintf (&amp;str, "%d", state->sf.iter);
	  if (n < 0 || str == NULL)
	    return GSASL_MALLOC_ERROR;
	  gsasl_property_set (sctx, GSASL_SCRAM_ITER, str);
	  free (str);
	}

	gsasl_property_set (sctx, GSASL_SCRAM_SALT, state->sf.salt);

	/* Generate ClientProof. */
	{
	  char saltedpassword[20];
	  char *clientkey;
	  char *storedkey;
	  char *clientsignature;
	  char clientproof[20];
	  const char *p;

	  /* Get SaltedPassword. */
	  p = gsasl_property_get (sctx, GSASL_SCRAM_SALTED_PASSWORD);
	  if (p &amp;& strlen (p) == 40 && hex_p (p))
	    sha1_hex_to_byte (saltedpassword, p);
	  else if ((p = gsasl_property_get (sctx, GSASL_PASSWORD)) != NULL)
	    {
	      Gc_rc err;
	      char *salt;
	      size_t saltlen;
	      char *preppasswd;

	      rc = gsasl_saslprep (p, 0, &amp;preppasswd, NULL);
	      if (rc != GSASL_OK)
		return rc;

	      rc = gsasl_base64_from (state->sf.salt, strlen (state->sf.salt),
				      &amp;salt, &saltlen);
	      if (rc != 0)
		{
		  gsasl_free (preppasswd);
		  return rc;
		}

	      /* SaltedPassword := Hi(password, salt) */
	      err = gc_pbkdf2_sha1 (preppasswd, strlen (preppasswd),
				    salt, saltlen,
				    state->sf.iter, saltedpassword, 20);
	      gsasl_free (preppasswd);
	      gsasl_free (salt);
	      if (err != GC_OK)
		return GSASL_MALLOC_ERROR;
	    }
	  else
	    return GSASL_NO_PASSWORD;

	  /* Get client-final-message-without-proof. */
	  {
	    char *cfmwp;
	    int n;

	    state->cl.proof = strdup ("p");
	    rc = scram_print_client_final (&amp;state->cl, &cfmwp);
	    if (rc != 0)
	      return GSASL_MALLOC_ERROR;
	    free (state->cl.proof);

	    /* Compute AuthMessage */
	    n = asprintf (&amp;state->authmessage, "%s,%.*s,%.*s",
			  state->cfmb,
			  input_len, input,
			  strlen (cfmwp) - 4,
			  cfmwp);
	    free (cfmwp);
	    if (n <= 0 || !state->authmessage)
	      return GSASL_MALLOC_ERROR;
	  }

	  /* ClientKey := HMAC(SaltedPassword, "Client Key") */
#define CLIENT_KEY "Client Key"
	  rc = gsasl_hmac_sha1 (saltedpassword, 20,
				CLIENT_KEY, strlen (CLIENT_KEY),
				&amp;clientkey);
	  if (rc != 0)
	    return rc;

	  /* StoredKey := H(ClientKey) */
	  rc = gsasl_sha1 (clientkey, 20, &amp;storedkey);
	  if (rc != 0)
	    {
	      free (clientkey);
	      return rc;
	    }

	  /* ClientSignature := HMAC(StoredKey, AuthMessage) */
	  rc = gsasl_hmac_sha1 (storedkey, 20,
				state->authmessage,
				strlen (state->authmessage),
				&amp;clientsignature);
	  free (storedkey);
	  if (rc != 0)
	    {
	      free (clientkey);
	      return rc;
	    }

	  /* ClientProof := ClientKey XOR ClientSignature */
	  memcpy (clientproof, clientkey, 20);
	  memxor (clientproof, clientsignature, 20);

	  free (clientkey);
	  free (clientsignature);

	  rc = gsasl_base64_to (clientproof, 20, &amp;state->cl.proof, NULL);
	  if (rc != 0)
	    return rc;

	  /* Generate ServerSignature, for comparison in next step. */
	  {
	    char *serverkey;
	    char *serversignature;

	    /* ServerKey := HMAC(SaltedPassword, "Server Key") */
#define SERVER_KEY "Server Key"
	    rc = gsasl_hmac_sha1 (saltedpassword, 20,
				  SERVER_KEY, strlen (SERVER_KEY),
				  &amp;serverkey);
	    if (rc != 0)
	      return rc;

	    /* ServerSignature := HMAC(ServerKey, AuthMessage) */
	    rc = gsasl_hmac_sha1 (serverkey, 20,
				  state->authmessage,
				  strlen (state->authmessage),
				  &amp;serversignature);
	    gsasl_free (serverkey);
	    if (rc != 0)
	      return rc;

	    rc = gsasl_base64_to (serversignature, 20,
				  &amp;state->serversignature, NULL);
	    gsasl_free (serversignature);
	    if (rc != 0)
	      return rc;
	  }
	}

	rc = scram_print_client_final (&amp;state->cl, output);
	if (rc != 0)
	  return GSASL_MALLOC_ERROR;

	*output_len = strlen (*output);

	state->step++;
	return GSASL_NEEDS_MORE;
	break;
      }

    case 2:
      {
	if (scram_parse_server_final (input, input_len, &amp;state->sl) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	if (strcmp (state->sl.verifier, state->serversignature) != 0)
	  return GSASL_AUTHENTICATION_ERROR;

	state->step++;
	return GSASL_OK;
	break;
      }

    default:
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_hmac_src', 'digest_md5_hmac_button')"><span id="digest_md5_hmac_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_hmac
</td>
<td class="function_entry_cyclo">
37
</td>
<td class="function_entry_number">
162
</td>
<td class="function_entry_number">
236
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/digesthmac.c;hb=HEAD">lib/digest-md5/digesthmac.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_hmac_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
digest_md5_hmac (char *output, char secret[MD5LEN], const char *nonce,
		 unsigned long nc, const char *cnonce, digest_md5_qop qop,
		 const char *authzid, const char *digesturi, int rspauth,
		 digest_md5_cipher cipher,
		 char *kic, char *kis, char *kcc, char *kcs)
{
  const char *a2string = rspauth ? COLON : A2_PRE;
  char nchex[9];
  char a1hexhash[2 * MD5LEN];
  char a2hexhash[2 * MD5LEN];
  char hash[MD5LEN];
  char *tmp, *p;
  size_t tmplen;
  int rc;
  int i;

  /* A1 */

  tmplen = MD5LEN + strlen (COLON) + strlen (nonce) +
    strlen (COLON) + strlen (cnonce);
  if (authzid &amp;& strlen (authzid) > 0)
    tmplen += strlen (COLON) + strlen (authzid);

  p = tmp = malloc (tmplen);
  if (tmp == NULL)
    return -1;

  memcpy (p, secret, MD5LEN);
  p += MD5LEN;
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, nonce, strlen (nonce));
  p += strlen (nonce);
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, cnonce, strlen (cnonce));
  p += strlen (cnonce);
  if (authzid &amp;& strlen (authzid) > 0)
    {
      memcpy (p, COLON, strlen (COLON));
      p += strlen (COLON);
      memcpy (p, authzid, strlen (authzid));
      p += strlen (authzid);
    }

  rc = gc_md5 (tmp, tmplen, hash);
  free (tmp);
  if (rc)
    return rc;

  if (kic)
    {
      char hash2[MD5LEN];
      char q[MD5LEN + DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN];
      size_t qlen = MD5LEN + DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN;

      memcpy (q, hash, MD5LEN);
      memcpy (q + MD5LEN, DERIVE_CLIENT_INTEGRITY_KEY_STRING,
	      DERIVE_CLIENT_INTEGRITY_KEY_STRING_LEN);

      rc = gc_md5 (q, qlen, hash2);
      if (rc)
	return rc;

      memcpy (kic, hash2, MD5LEN);
    }

  if (kis)
    {
      char hash2[MD5LEN];
      char q[MD5LEN + DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN];
      size_t qlen = MD5LEN + DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN;

      memcpy (q, hash, MD5LEN);
      memcpy (q + MD5LEN, DERIVE_SERVER_INTEGRITY_KEY_STRING,
	      DERIVE_SERVER_INTEGRITY_KEY_STRING_LEN);

      rc = gc_md5 (q, qlen, hash2);
      if (rc)
	return rc;

      memcpy (kis, hash2, MD5LEN);
    }

  if (kcc)
    {
      char hash2[MD5LEN];
      int n;
      char q[MD5LEN + DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN];

      if (cipher == DIGEST_MD5_CIPHER_RC4_40)
	n = 5;
      else if (cipher == DIGEST_MD5_CIPHER_RC4_56)
	n = 7;
      else
	n = MD5LEN;

      memcpy (q, hash, n);
      memcpy (q + n, DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING,
	      DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN);

      rc = gc_md5 (q, n + DERIVE_CLIENT_CONFIDENTIALITY_KEY_STRING_LEN,
		   hash2);
      if (rc)
	return rc;

      memcpy (kcc, hash2, MD5LEN);
    }

  if (kcs)
    {
      char hash2[MD5LEN];
      int n;
      char q[MD5LEN + DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN];

      if (cipher == DIGEST_MD5_CIPHER_RC4_40)
	n = 5;
      else if (cipher == DIGEST_MD5_CIPHER_RC4_56)
	n = 7;
      else
	n = MD5LEN;

      memcpy (q, hash, n);
      memcpy (q + n, DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING,
	      DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN);

      rc = gc_md5 (q, n + DERIVE_SERVER_CONFIDENTIALITY_KEY_STRING_LEN,
		   hash2);
      if (rc)
	return rc;

      memcpy (kcs, hash2, MD5LEN);
    }

  for (i = 0; i < MD5LEN; i++)
    {
      a1hexhash[2 * i + 1] = HEXCHAR (hash[i]);
      a1hexhash[2 * i + 0] = HEXCHAR (hash[i] >> 4);
    }

  /* A2 */

  tmplen = strlen (a2string) + strlen (digesturi);
  if (qop &amp; DIGEST_MD5_QOP_AUTH_INT || qop & DIGEST_MD5_QOP_AUTH_CONF)
    tmplen += strlen (A2_POST);

  p = tmp = malloc (tmplen);
  if (tmp == NULL)
    return -1;

  memcpy (p, a2string, strlen (a2string));
  p += strlen (a2string);
  memcpy (p, digesturi, strlen (digesturi));
  p += strlen (digesturi);
  if (qop &amp; DIGEST_MD5_QOP_AUTH_INT || qop & DIGEST_MD5_QOP_AUTH_CONF)
    memcpy (p, A2_POST, strlen (A2_POST));

  rc = gc_md5 (tmp, tmplen, hash);
  free (tmp);
  if (rc)
    return rc;

  for (i = 0; i < MD5LEN; i++)
    {
      a2hexhash[2 * i + 1] = HEXCHAR (hash[i]);
      a2hexhash[2 * i + 0] = HEXCHAR (hash[i] >> 4);
    }

  /* response_value */

  sprintf (nchex, "%08lx", nc);

  tmplen = 2 * MD5LEN + strlen (COLON) + strlen (nonce) + strlen (COLON) +
    strlen (nchex) + strlen (COLON) + strlen (cnonce) + strlen (COLON);
  if (qop &amp; DIGEST_MD5_QOP_AUTH_CONF)
    tmplen += strlen (QOP_AUTH_CONF);
  else if (qop &amp; DIGEST_MD5_QOP_AUTH_INT)
    tmplen += strlen (QOP_AUTH_INT);
  else if (qop &amp; DIGEST_MD5_QOP_AUTH)
    tmplen += strlen (QOP_AUTH);
  tmplen += strlen (COLON) + 2 * MD5LEN;

  p = tmp = malloc (tmplen);
  if (tmp == NULL)
    return -1;

  memcpy (p, a1hexhash, 2 * MD5LEN);
  p += 2 * MD5LEN;
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, nonce, strlen (nonce));
  p += strlen (nonce);
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, nchex, strlen (nchex));
  p += strlen (nchex);
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, cnonce, strlen (cnonce));
  p += strlen (cnonce);
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  if (qop &amp; DIGEST_MD5_QOP_AUTH_CONF)
    {
      memcpy (p, QOP_AUTH_CONF, strlen (QOP_AUTH_CONF));
      p += strlen (QOP_AUTH_CONF);
    }
  else if (qop &amp; DIGEST_MD5_QOP_AUTH_INT)
    {
      memcpy (p, QOP_AUTH_INT, strlen (QOP_AUTH_INT));
      p += strlen (QOP_AUTH_INT);
    }
  else if (qop &amp; DIGEST_MD5_QOP_AUTH)
    {
      memcpy (p, QOP_AUTH, strlen (QOP_AUTH));
      p += strlen (QOP_AUTH);
    }
  memcpy (p, COLON, strlen (COLON));
  p += strlen (COLON);
  memcpy (p, a2hexhash, 2 * MD5LEN);

  rc = gc_md5 (tmp, tmplen, hash);
  free (tmp);
  if (rc)
    return rc;

  for (i = 0; i < MD5LEN; i++)
    {
      output[2 * i + 1] = HEXCHAR (hash[i]);
      output[2 * i + 0] = HEXCHAR (hash[i] >> 4);
    }
  output[32] = '\0';

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_print_challenge_src', 'digest_md5_print_challenge_button')"><span id="digest_md5_print_challenge_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_print_challenge
</td>
<td class="function_entry_cyclo">
36
</td>
<td class="function_entry_number">
94
</td>
<td class="function_entry_number">
168
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/printer.c;hb=HEAD">lib/digest-md5/printer.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_print_challenge_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
char *
digest_md5_print_challenge (digest_md5_challenge * c)
{
  char *out = NULL;
  size_t i;

  /* Below we assume the mandatory fields are present, verify that
     first to avoid crashes. */
  if (digest_md5_validate_challenge (c) != 0)
    return NULL;

  for (i = 0; i < c->nrealms; i++)
    {
      if (comma_append (&amp;out, "realm", c->realms[i], 1) < 0)
	{
	  free (out);
	  return NULL;
	}
    }

  if (c->nonce)
    if (comma_append (&amp;out, "nonce", c->nonce, 1) < 0)
      {
	free (out);
	return NULL;
      }

  if (c->qops)
    {
      char *tmp = NULL;

      if (c->qops &amp; DIGEST_MD5_QOP_AUTH)
	if (comma_append (&amp;tmp, "auth", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->qops &amp; DIGEST_MD5_QOP_AUTH_INT)
	if (comma_append (&amp;tmp, "auth-int", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->qops &amp; DIGEST_MD5_QOP_AUTH_CONF)
	if (comma_append (&amp;tmp, "auth-conf", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (comma_append (&amp;out, "qop", tmp, 1) < 0)
	{
	  free (tmp);
	  free (out);
	  return NULL;
	}

      free (tmp);
    }

  if (c->stale)
    if (comma_append (&amp;out, "stale", "true", 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (c->servermaxbuf)
    {
      char *tmp;

      if (asprintf (&amp;tmp, "%lu", c->servermaxbuf) < 0)
	{
	  free (out);
	  return NULL;
	}

      if (comma_append (&amp;out, "maxbuf", tmp, 0) < 0)
	{
	  free (out);
	  return NULL;
	}

      free (tmp);
    }

  if (c->utf8)
    if (comma_append (&amp;out, "charset", "utf-8", 0) < 0)
      {
	free (out);
	return NULL;
      }

  if (comma_append (&amp;out, "algorithm", "md5-sess", 0) < 0)
    {
      free (out);
      return NULL;
    }

  if (c->ciphers)
    {
      char *tmp = NULL;

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_3DES)
	if (comma_append (&amp;tmp, "3des", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_DES)
	if (comma_append (&amp;tmp, "des", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_RC4_40)
	if (comma_append (&amp;tmp, "rc4-40", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_RC4)
	if (comma_append (&amp;tmp, "rc4", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_RC4_56)
	if (comma_append (&amp;tmp, "rc4-56", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (c->ciphers &amp; DIGEST_MD5_CIPHER_AES_CBC)
	if (comma_append (&amp;tmp, "aes-cbc", NULL, 0) < 0)
	  {
	    free (tmp);
	    free (out);
	    return NULL;
	  }

      if (comma_append (&amp;out, "cipher", tmp, 1) < 0)
	{
	  free (tmp);
	  free (out);
	  return NULL;
	}

      free (tmp);
    }

  return out;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('scram_parse_client_first_src', 'scram_parse_client_first_button')"><span id="scram_parse_client_first_button">&darr;</span></a>
</td>
<td class="function_entry_name">
scram_parse_client_first
</td>
<td class="function_entry_cyclo">
33
</td>
<td class="function_entry_number">
80
</td>
<td class="function_entry_number">
122
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/parser.c;hb=HEAD">lib/scram/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="scram_parse_client_first_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
scram_parse_client_first (const char *str, size_t len,
			  struct scram_client_first *cf)
{
  /* Minimum client first string is 'n,,n=a,r=b'. */
  if (strnlen (str, len) < 10)
    return -1;

  if (len == 0 || *str != 'n')
      /* FIXME parse non-'n' cbflags */
    return -1;
  cf->cbflag = *str;
  str++, len--;

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0)
    return -1;
  if (*str == 'a')
    {
      const char *p;
      size_t l;

      str++, len--;
      if (len == 0 || *str != '=')
	return -1;
      str++, len--;

      p = memchr (str, ',', len);
      if (!p)
	return -1;

      l = p - str;
      if (len < l)
	return -1;

      cf->authzid = unescape (str, l);
      if (!cf->authzid)
	return -1;

      str = p;
      len -= l;
    }

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 'n')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    cf->username = unescape (str, l);
    if (!cf->username)
      return -1;

    str = p;
    len -= l;
  }

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 'r')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      p = str + len;
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    cf->client_nonce = malloc (l + 1);
    if (!cf->client_nonce)
      return -1;

    memcpy (cf->client_nonce, str, l);
    cf->client_nonce[l] = '\0';

    str = p;
    len -= l;
  }

  /* FIXME check that any extension fields follow valid syntax. */

  if (scram_valid_client_first (cf) < 0)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_getsubopt_src', 'digest_md5_getsubopt_button')"><span id="digest_md5_getsubopt_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_getsubopt
</td>
<td class="function_entry_cyclo">
33
</td>
<td class="function_entry_number">
38
</td>
<td class="function_entry_number">
71
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/getsubopt.c;hb=HEAD">lib/digest-md5/getsubopt.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_getsubopt_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
digest_md5_getsubopt (char **optionp,
		      const char *const *tokens, char **valuep)
{
  char *endp, *vstart;
  int cnt;
  int inside_quote = 0;

  if (**optionp == '\0')
    return -1;

  /* Find end of next token.  */
  endp = *optionp;
  while (*endp != '\0' &amp;& (inside_quote || (!inside_quote && *endp != ',')))
    {
      if (*endp == '"')
	inside_quote = !inside_quote;
      endp++;
    }

  /* Find start of value.  */
  vstart = memchr (*optionp, '=', endp - *optionp);
  if (vstart == NULL)
    vstart = endp;

  /* Try to match the characters between *OPTIONP and VSTART against
     one of the TOKENS.  */
  for (cnt = 0; tokens[cnt] != NULL; ++cnt)
    if (memcmp (*optionp, tokens[cnt], vstart - *optionp) == 0
	&amp;& tokens[cnt][vstart - *optionp] == '\0')
      {
	/* We found the current option in TOKENS.  */
	*valuep = vstart != endp ? vstart + 1 : NULL;

	while (*valuep &amp;& (**valuep == ' ' ||
			   **valuep == '\t' ||
			   **valuep == '\r' ||
			   **valuep == '\n' || **valuep == '"'))
	  (*valuep)++;

	if (*endp != '\0')
	  {
	    *endp = '\0';
	    *optionp = endp + 1;
	  }
	else
	  *optionp = endp;
	endp--;
	while (*endp == ' ' ||
	       *endp == '\t' ||
	       *endp == '\r' || *endp == '\n' || *endp == '"')
	  *endp-- = '\0';
	while (**optionp == ' ' ||
	       **optionp == '\t' || **optionp == '\r' || **optionp == '\n')
	  (*optionp)++;

	return cnt;
      }

  /* The current suboption does not match any option.  */
  *valuep = *optionp;

  if (*endp != '\0')
    *endp++ = '\0';
  *optionp = endp;
  while (**optionp == ' ' ||
	 **optionp == '\t' || **optionp == '\r' || **optionp == '\n')
    (*optionp)++;

  return -1;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('scram_parse_server_first_src', 'scram_parse_server_first_button')"><span id="scram_parse_server_first_button">&darr;</span></a>
</td>
<td class="function_entry_name">
scram_parse_server_first
</td>
<td class="function_entry_cyclo">
31
</td>
<td class="function_entry_number">
69
</td>
<td class="function_entry_number">
108
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/parser.c;hb=HEAD">lib/scram/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="scram_parse_server_first_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
scram_parse_server_first (const char *str, size_t len,
			  struct scram_server_first *sf)
{
  /* Minimum server first string is 'r=ab,s=biws,i=1'. */
  if (strnlen (str, len) < 15)
    return -1;

  if (len == 0 || *str != 'r')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    sf->nonce = malloc (l + 1);
    if (!sf->nonce)
      return -1;

    memcpy (sf->nonce, str, l);
    sf->nonce[l] = '\0';

    str = p;
    len -= l;
  }

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 's')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    sf->salt = malloc (l + 1);
    if (!sf->salt)
      return -1;

    memcpy (sf->salt, str, l);
    sf->salt[l] = '\0';

    str = p;
    len -= l;
  }

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 'i')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  sf->iter = 0;
  for (; len > 0 &amp;& *str >= '0' && *str <= '9'; str++, len--)
    {
      size_t last_iter = sf->iter;

      sf->iter = sf->iter * 10 + (*str - '0');

      /* Protect against wrap arounds. */
      if (sf->iter < last_iter)
	return -1;
    }

  if (len > 0 &amp;& *str != ',')
    return -1;

  /* FIXME check that any extension fields follow valid syntax. */

  if (scram_valid_server_first (sf) < 0)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('parse_challenge_src', 'parse_challenge_button')"><span id="parse_challenge_button">&darr;</span></a>
</td>
<td class="function_entry_name">
parse_challenge
</td>
<td class="function_entry_cyclo">
43
</td>
<td class="function_entry_number">
95
</td>
<td class="function_entry_number">
203
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="parse_challenge_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
static int
parse_challenge (char *challenge, digest_md5_challenge * out)
{
  int done_algorithm = 0;
  int disable_qop_auth_conf = 0;
  char *value;

  memset (out, 0, sizeof (*out));

  /* The size of a digest-challenge MUST be less than 2048 bytes. */
  if (strlen (challenge) >= 2048)
    return -1;

  while (*challenge != '\0')
    switch (digest_md5_getsubopt (&amp;challenge, digest_challenge_opts, &value))
      {
      case CHALLENGE_REALM:
	{
	  char **tmp;
	  out->nrealms++;
	  tmp = realloc (out->realms, out->nrealms * sizeof (*out->realms));
	  if (!tmp)
	    return -1;
	  out->realms = tmp;
	  out->realms[out->nrealms - 1] = strdup (value);
	  if (!out->realms[out->nrealms - 1])
	    return -1;
	}
	break;

      case CHALLENGE_NONCE:
	/* This directive is required and MUST appear exactly once; if
	   not present, or if multiple instances are present, the
	   client should abort the authentication exchange. */
	if (out->nonce)
	  return -1;
	out->nonce = strdup (value);
	if (!out->nonce)
	  return -1;
	break;

      case CHALLENGE_QOP:
	/* <<What if this directive is present multiple times? Error,
	   or take the union of all values?>> */
	if (out->qops)
	  return -1;
	{
	  char *subsubopts;
	  char *val;

	  subsubopts = value;
	  while (*subsubopts != '\0')
	    switch (digest_md5_getsubopt (&amp;subsubopts, qop_opts, &val))
	      {
	      case QOP_AUTH:
		out->qops |= DIGEST_MD5_QOP_AUTH;
		break;

	      case QOP_AUTH_INT:
		out->qops |= DIGEST_MD5_QOP_AUTH_INT;
		break;

	      case QOP_AUTH_CONF:
		out->qops |= DIGEST_MD5_QOP_AUTH_CONF;
		break;

	      default:
		/* The client MUST ignore unrecognized options */
		break;
	      }
	}
	/* if the client recognizes no cipher, it MUST behave as if
	   "auth-conf" qop option wasn't provided by the server. */
	if (disable_qop_auth_conf)
	  out->qops &amp;= ~DIGEST_MD5_QOP_AUTH_CONF;
	/* if the client recognizes no option, it MUST abort the
	   authentication exchange. */
	if (!out->qops)
	  return -1;
	break;

      case CHALLENGE_STALE:
	/* This directive may appear at most once; if multiple
	   instances are present, the client MUST abort the
	   authentication exchange. */
	if (out->stale)
	  return -1;
	out->stale = 1;
	break;

      case CHALLENGE_MAXBUF:
	/* This directive may appear at most once; if multiple
	   instances are present, or the value is out of range the
	   client MUST abort the authentication exchange. */
	if (out->servermaxbuf)
	  return -1;
	out->servermaxbuf = strtoul (value, NULL, 10);
	/* FIXME: error handling. */
	/* The value MUST be bigger than 16 (32 for Confidentiality
	   protection with the "aes-cbc" cipher) and smaller or equal
	   to 16777215 (i.e. 2**24-1). */
	if (out->servermaxbuf <= 16 || out->servermaxbuf > 16777215)
	  return -1;
	break;

      case CHALLENGE_CHARSET:
	/* This directive may appear at most once; if multiple
	   instances are present, the client MUST abort the
	   authentication exchange. */
	if (out->utf8)
	  return -1;
	if (strcmp (DEFAULT_CHARSET, value) != 0)
	  return -1;
	out->utf8 = 1;
	break;

      case CHALLENGE_ALGORITHM:
	/* This directive is required and MUST appear exactly once; if
	   not present, or if multiple instances are present, the
	   client SHOULD abort the authentication exchange. */
	if (done_algorithm)
	  return -1;
	if (strcmp (DEFAULT_ALGORITHM, value) != 0)
	  return -1;
	done_algorithm = 1;
	break;


      case CHALLENGE_CIPHER:
	/* This directive must be present exactly once if "auth-conf"
	   is offered in the "qop-options" directive */
	if (out->ciphers)
	  return -1;
	{
	  char *subsubopts;
	  char *val;

	  subsubopts = value;
	  while (*subsubopts != '\0')
	    switch (digest_md5_getsubopt (&amp;subsubopts, cipher_opts, &val))
	      {
	      case CIPHER_DES:
		out->ciphers |= DIGEST_MD5_CIPHER_DES;
		break;

	      case CIPHER_3DES:
		out->ciphers |= DIGEST_MD5_CIPHER_3DES;
		break;

	      case CIPHER_RC4:
		out->ciphers |= DIGEST_MD5_CIPHER_RC4;
		break;

	      case CIPHER_RC4_40:
		out->ciphers |= DIGEST_MD5_CIPHER_RC4_40;
		break;

	      case CIPHER_RC4_56:
		out->ciphers |= DIGEST_MD5_CIPHER_RC4_56;
		break;

	      case CIPHER_AES_CBC:
		out->ciphers |= DIGEST_MD5_CIPHER_AES_CBC;
		break;

	      default:
		/* The client MUST ignore unrecognized ciphers */
		break;
	      }
	}
	/* if the client recognizes no cipher, it MUST behave as if
	   "auth-conf" qop option wasn't provided by the server. */
	if (!out->ciphers)
	  {
	    disable_qop_auth_conf = 1;
	    if (out->qops)
	      {
		/* if the client recognizes no option, it MUST abort the
		   authentication exchange. */
		out->qops &amp;= ~DIGEST_MD5_QOP_AUTH_CONF;
		if (!out->qops)
		  return -1;
	      }
	  }
	break;

      default:
	/* The client MUST ignore any unrecognized directives. */
	break;
      }

  /* This directive is required and MUST appear exactly once; if
     not present, or if multiple instances are present, the
     client SHOULD abort the authentication exchange. */
  if (!done_algorithm)
    return -1;

  /* Validate that we have the mandatory fields. */
  if (digest_md5_validate_challenge (out) != 0)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_digest_md5_client_step_src', '_gsasl_digest_md5_client_step_button')"><span id="_gsasl_digest_md5_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_digest_md5_client_step
</td>
<td class="function_entry_cyclo">
29
</td>
<td class="function_entry_number">
91
</td>
<td class="function_entry_number">
185
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/client.c;hb=HEAD">lib/digest-md5/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_digest_md5_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_digest_md5_client_step (Gsasl_session * sctx,
			       void *mech_data,
			       const char *input,
			       size_t input_len,
			       char **output, size_t * output_len)
{
  _Gsasl_digest_md5_client_state *state = mech_data;
  int rc, res;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      state->step++;
      if (input_len == 0)
	return GSASL_NEEDS_MORE;
      /* fall through */

    case 1:
      {
	if (digest_md5_parse_challenge (input, input_len,
					&amp;state->challenge) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	/* FIXME: How to let application know of remaining realms?
	   One idea, add a GSASL_REALM_COUNT property, and have the
	   GSASL_REALM be that many concatenated zero terminated realm
	   strings.  Slightly hackish, though.  Another cleaner
	   approach would be to add gsasl_property_set_array and
	   gsasl_property_get_array APIs, for those properties that
	   may be used multiple times. */
	if (state->challenge.nrealms > 0)
	  gsasl_property_set (sctx, GSASL_REALM, state->challenge.realms[0]);
	else
	  gsasl_property_set (sctx, GSASL_REALM, NULL);

	/* FIXME: cipher, maxbuf. */

	/* Create response token. */
	state->response.utf8 = 1;

	gsasl_property_set (sctx, GSASL_QOPS,
			    digest_md5_qops2qopstr (state->challenge.qops));

	{
	  const char *qop = gsasl_property_get (sctx, GSASL_QOP);

	  if (!qop)
	    state->response.qop = GSASL_QOP_AUTH;
	  else if (strcmp (qop, "qop-int") == 0)
	    state->response.qop = GSASL_QOP_AUTH_INT;
	  else if (strcmp (qop, "qop-auth") == 0)
	    state->response.qop = GSASL_QOP_AUTH;
	  else
	    /* We don't support confidentiality or unknown
	       keywords. */
	    return GSASL_AUTHENTICATION_ERROR;
	}

	state->response.nonce = strdup (state->challenge.nonce);
	if (!state->response.nonce)
	  return GSASL_MALLOC_ERROR;

	{
	  const char *service = gsasl_property_get (sctx, GSASL_SERVICE);
	  const char *hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);
	  if (!service)
	    return GSASL_NO_SERVICE;
	  if (!hostname)
	    return GSASL_NO_HOSTNAME;
	  if (asprintf (&amp;state->response.digesturi, "%s/%s",
			service, hostname) < 0)
	    return GSASL_MALLOC_ERROR;
	}

	{
	  const char *c;
	  char *tmp, *tmp2;

	  c = gsasl_property_get (sctx, GSASL_AUTHID);
	  if (!c)
	    return GSASL_NO_AUTHID;

	  state->response.username = strdup (c);
	  if (!state->response.username)
	    return GSASL_MALLOC_ERROR;

	  c = gsasl_property_get (sctx, GSASL_AUTHZID);
	  if (c)
	    {
	      state->response.authzid = strdup (c);
	      if (!state->response.authzid)
		return GSASL_MALLOC_ERROR;
	    }

	  gsasl_callback (NULL, sctx, GSASL_REALM);
	  c = gsasl_property_fast (sctx, GSASL_REALM);
	  if (c)
	    {
	      state->response.realm = strdup (c);
	      if (!state->response.realm)
		return GSASL_MALLOC_ERROR;
	    }

	  c = gsasl_property_get (sctx, GSASL_PASSWORD);
	  if (!c)
	    return GSASL_NO_PASSWORD;

	  tmp2 = utf8tolatin1ifpossible (c);

	  rc = asprintf (&amp;tmp, "%s:%s:%s", state->response.username,
			 state->response.realm ?
			 state->response.realm : "", tmp2);
	  free (tmp2);
	  if (rc < 0)
	    return GSASL_MALLOC_ERROR;

	  rc = gsasl_md5 (tmp, strlen (tmp), &amp;tmp2);
	  free (tmp);
	  if (rc != GSASL_OK)
	    return rc;
	  memcpy (state->secret, tmp2, DIGEST_MD5_LENGTH);
	  free (tmp2);
	}

	rc = digest_md5_hmac (state->response.response,
			      state->secret,
			      state->response.nonce,
			      state->response.nc,
			      state->response.cnonce,
			      state->response.qop,
			      state->response.authzid,
			      state->response.digesturi,
			      0,
			      state->response.cipher,
			      state->kic, state->kis, state->kcc, state->kcs);
	if (rc)
	  return GSASL_CRYPTO_ERROR;

	*output = digest_md5_print_response (&amp;state->response);
	if (!*output)
	  return GSASL_AUTHENTICATION_ERROR;

	*output_len = strlen (*output);

	state->step++;
	res = GSASL_NEEDS_MORE;
      }
      break;

    case 2:
      {
	char check[DIGEST_MD5_RESPONSE_LENGTH + 1];

	if (digest_md5_parse_finish (input, input_len, &amp;state->finish) < 0)
	  return GSASL_MECHANISM_PARSE_ERROR;

	res = digest_md5_hmac (check, state->secret,
			       state->response.nonce, state->response.nc,
			       state->response.cnonce, state->response.qop,
			       state->response.authzid,
			       state->response.digesturi, 1,
			       state->response.cipher, NULL, NULL, NULL,
			       NULL);
	if (res != GSASL_OK)
	  break;

	if (strcmp (state->finish.rspauth, check) == 0)
	  res = GSASL_OK;
	else
	  res = GSASL_AUTHENTICATION_ERROR;
	state->step++;
      }
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('scram_parse_client_final_src', 'scram_parse_client_final_button')"><span id="scram_parse_client_final_button">&darr;</span></a>
</td>
<td class="function_entry_name">
scram_parse_client_final
</td>
<td class="function_entry_cyclo">
27
</td>
<td class="function_entry_number">
66
</td>
<td class="function_entry_number">
104
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/parser.c;hb=HEAD">lib/scram/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="scram_parse_client_final_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
scram_parse_client_final (const char *str, size_t len,
			  struct scram_client_final *cl)
{
  /* Minimum client final string is 'c=biws,r=ab,p=ab=='. */
  if (strnlen (str, len) < 18)
    return -1;

  if (len == 0 || *str != 'c')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    cl->cbind = malloc (l + 1);
    if (!cl->cbind)
      return -1;

    memcpy (cl->cbind, str, l);
    cl->cbind[l] = '\0';

    str = p;
    len -= l;
  }

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 'r')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  {
    const char *p;
    size_t l;

    p = memchr (str, ',', len);
    if (!p)
      return -1;

    l = p - str;
    if (len < l)
      return -1;

    cl->nonce = malloc (l + 1);
    if (!cl->nonce)
      return -1;

    memcpy (cl->nonce, str, l);
    cl->nonce[l] = '\0';

    str = p;
    len -= l;
  }

  /* FIXME check that any extension fields follow valid syntax. */

  if (len == 0 || *str != ',')
    return -1;
  str++, len--;

  if (len == 0 || *str != 'p')
    return -1;
  str++, len--;

  if (len == 0 || *str != '=')
    return -1;
  str++, len--;

  /* Sanity check proof. */
  if (memchr (str, '\0', len))
    return -1;

  cl->proof = malloc (len + 1);
  if (!cl->proof)
    return -1;

  memcpy (cl->proof, str, len);
  cl->proof[len] = '\0';

  if (scram_valid_client_final (cl) < 0)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_gs2_client_step_src', '_gsasl_gs2_client_step_button')"><span id="_gsasl_gs2_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_gs2_client_step
</td>
<td class="function_entry_cyclo">
28
</td>
<td class="function_entry_number">
98
</td>
<td class="function_entry_number">
197
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/client.c;hb=HEAD">lib/gs2/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_gs2_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_gs2_client_step (Gsasl_session * sctx,
			void *mech_data,
			const char *input, size_t input_len,
			char **output, size_t * output_len)
{
  _gsasl_gs2_client_state *state = mech_data;
  char clientwrap[4];
  gss_qop_t serverqop;
  gss_buffer_desc bufdesc, bufdesc2;
  gss_buffer_t buf = GSS_C_NO_BUFFER;
  OM_uint32 maj_stat, min_stat;
  int conf_state;
  int res;
  const char *p;
  OM_uint32 ret_flags;
  struct gs2_token tok = { NULL, 0, NULL, 0 };

  if (state->service == NULL)
    {
      const char *service, *hostname;

      service = gsasl_property_get (sctx, GSASL_SERVICE);
      if (!service)
	return GSASL_NO_SERVICE;

      hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);
      if (!hostname)
	return GSASL_NO_HOSTNAME;

      /* FIXME: Use asprintf. */

      bufdesc.length = strlen (service) + 1 + strlen (hostname) + 1;
      bufdesc.value = malloc (bufdesc.length);
      if (bufdesc.value == NULL)
	return GSASL_MALLOC_ERROR;

      sprintf (bufdesc.value, "%s@%s", service, hostname);

      maj_stat = gss_import_name (&amp;min_stat, &bufdesc,
				  GSS_C_NT_HOSTBASED_SERVICE,
				  &amp;state->service);
      free (bufdesc.value);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_IMPORT_NAME_ERROR;
    }

  switch (state->step)
    {
    case 1:
      res = gs2_parser (input, input_len, &amp;tok);
      if (res < 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      bufdesc.length = tok.context_length;
      bufdesc.value = (void *) tok.context_token;
      buf = &amp;bufdesc;
      /* fall through */

    case 0:
      bufdesc2.length = 0;
      bufdesc2.value = NULL;
      maj_stat = gss_init_sec_context (&amp;min_stat,
				       GSS_C_NO_CREDENTIAL,
				       &amp;state->context,
				       state->service,
				       GSS_C_NO_OID,
				       GSS_C_MUTUAL_FLAG |
				       GSS_C_REPLAY_FLAG |
				       GSS_C_SEQUENCE_FLAG |
				       GSS_C_INTEG_FLAG |
				       GSS_C_CONF_FLAG,
				       0,
				       GSS_C_NO_CHANNEL_BINDINGS,
				       buf, NULL, &amp;bufdesc2,
				       &amp;ret_flags, NULL);
      if (maj_stat != GSS_S_COMPLETE &amp;& maj_stat != GSS_S_CONTINUE_NEEDED)
	return GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;

      if ((ret_flags &amp; GSS_C_PROT_READY_FLAG) || (maj_stat == GSS_S_COMPLETE))
	{
	  puts ("prot_ready");
	  /* Deal with wrap token here. */
	  /* Generate wrap token here. */
	}
      else if (tok.wrap_length > 0)
	{
	  /* Server provided wrap token but we are not ready for it.
	     Server error. */
	  return GSASL_MECHANISM_PARSE_ERROR;
	}

      res = gs2_encode (bufdesc2.value, bufdesc2.length,
			NULL, 0, output, output_len);
      if (res < 0)
	return GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;

      if (maj_stat == GSS_S_COMPLETE)
	state->step = 2;
      else
	state->step = 1;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      /* [RFC 2222 section 7.2.1]:
         The client passes this token to GSS_Unwrap and interprets the
         first octet of resulting cleartext as a bit-mask specifying
         the security layers supported by the server and the second
         through fourth octets as the maximum size output_message to
         send to the server.  The client then constructs data, with
         the first octet containing the bit-mask specifying the
         selected security layer, the second through fourth octets
         containing in network byte order the maximum size
         output_message the client is able to receive, and the
         remaining octets containing the authorization identity.  The
         client passes the data to GSS_Wrap with conf_flag set to
         FALSE, and responds with the generated output_message.  The
         client can then consider the server authenticated. */

      bufdesc.length = input_len;
      bufdesc.value = (void *) input;
      maj_stat = gss_unwrap (&amp;min_stat, state->context, &bufdesc,
			     &amp;bufdesc2, &conf_state, &serverqop);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_UNWRAP_ERROR;

      if (bufdesc2.length != 4)
	return GSASL_MECHANISM_PARSE_ERROR;

      memcpy (clientwrap, bufdesc2.value, 4);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

#if 0
      /* FIXME: Fix qop. */
      if (cb_qop)
	state->qop = cb_qop (sctx, serverqop);

      if ((state->qop &amp; serverqop) == 0)
	/*  Server does not support what user wanted. */
	return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;
#endif

      /* FIXME: Fix maxbuf. */

      p = gsasl_property_get (sctx, GSASL_AUTHID);
      if (!p)
	return GSASL_NO_AUTHID;

      bufdesc.length = 4 + strlen (p);
      bufdesc.value = malloc (bufdesc.length);
      if (!bufdesc.value)
	return GSASL_MALLOC_ERROR;

      {
	char *q = bufdesc.value;
	q[0] = state->qop;
	memcpy (q + 1, clientwrap + 1, 3);
	memcpy (q + 4, p, strlen (p));
      }

      maj_stat = gss_wrap (&amp;min_stat, state->context, 0, GSS_C_QOP_DEFAULT,
			   &amp;bufdesc, &conf_state, &bufdesc2);
      free (bufdesc.value);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_WRAP_ERROR;

      *output_len = bufdesc2.length;
      *output = malloc (bufdesc2.length);
      if (!*output)
	return GSASL_MALLOC_ERROR;

      memcpy (*output, bufdesc2.value, bufdesc2.length);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      state->step++;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_digest_md5_server_step_src', '_gsasl_digest_md5_server_step_button')"><span id="_gsasl_digest_md5_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_digest_md5_server_step
</td>
<td class="function_entry_cyclo">
28
</td>
<td class="function_entry_number">
96
</td>
<td class="function_entry_number">
198
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_digest_md5_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_digest_md5_server_step (Gsasl_session * sctx,
			       void *mech_data,
			       const char *input,
			       size_t input_len,
			       char **output, size_t * output_len)
{
  _Gsasl_digest_md5_server_state *state = mech_data;
  int rc, res;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      /* Set realm. */
      {
	const char *c;
	c = gsasl_property_get (sctx, GSASL_REALM);
	if (c)
	  {
	    state->challenge.nrealms = 1;

	    state->challenge.realms =
	      malloc (sizeof (*state->challenge.realms));
	    if (!state->challenge.realms)
	      return GSASL_MALLOC_ERROR;

	    state->challenge.realms[0] = strdup (c);
	    if (!state->challenge.realms[0])
	      return GSASL_MALLOC_ERROR;
	  }
      }

      /* Set QOP */
      {
	const char *qopstr = gsasl_property_get (sctx, GSASL_QOPS);

	if (qopstr)
	  {
	    int qops = digest_md5_qopstr2qops (qopstr);

	    if (qops == -1)
	      return GSASL_MALLOC_ERROR;

	    /* We don't support confidentiality right now. */
	    if (qops &amp; DIGEST_MD5_QOP_AUTH_CONF)
	      return GSASL_AUTHENTICATION_ERROR;

	    if (qops)
	      state->challenge.qops = qops;
	  }
      }

      /* FIXME: cipher, maxbuf, more realms. */

      /* Create challenge. */
      *output = digest_md5_print_challenge (&amp;state->challenge);
      if (!*output)
	return GSASL_AUTHENTICATION_ERROR;

      *output_len = strlen (*output);
      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 1:
      if (digest_md5_parse_response (input, input_len, &amp;state->response) < 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      /* Make sure response is consistent with challenge. */
      if (digest_md5_validate (&amp;state->challenge, &state->response) < 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      /* Store properties, from the client response. */
      if (state->response.utf8)
	{
	  gsasl_property_set (sctx, GSASL_AUTHID, state->response.username);
	  gsasl_property_set (sctx, GSASL_REALM, state->response.realm);
	}
      else
	{
	  /* Client provided username/realm in ISO-8859-1 form,
	     convert it to UTF-8 since the library is all-UTF-8. */
	  char *tmp;

	  tmp = latin1toutf8 (state->response.username);
	  if (!tmp)
	    return GSASL_MALLOC_ERROR;
	  gsasl_property_set (sctx, GSASL_AUTHID, tmp);
	  free (tmp);

	  tmp = latin1toutf8 (state->response.realm);
	  if (!tmp)
	    return GSASL_MALLOC_ERROR;
	  gsasl_property_set (sctx, GSASL_REALM, tmp);
	  free (tmp);
	}
      gsasl_property_set (sctx, GSASL_AUTHZID, state->response.authzid);

      /* FIXME: cipher, maxbuf.  */

      /* Compute secret. */
      {
	const char *passwd;
	const char *hashed_passwd;

	hashed_passwd =
	  gsasl_property_get (sctx, GSASL_DIGEST_MD5_HASHED_PASSWORD);
	if (hashed_passwd)
	  {
	    if (strlen (hashed_passwd) != (DIGEST_MD5_LENGTH * 2))
	      return GSASL_AUTHENTICATION_ERROR;

	    rc = _gsasl_digest_md5_set_hashed_secret (state->secret,
						      hashed_passwd);
	    if (rc != GSASL_OK)
	      return rc;
	  }
	else if ((passwd = gsasl_property_get (sctx, GSASL_PASSWORD)) != NULL)
	  {
	    char *tmp, *tmp2;

	    tmp2 = utf8tolatin1ifpossible (passwd);

	    rc = asprintf (&amp;tmp, "%s:%s:%s", state->response.username,
			   state->response.realm ?
			   state->response.realm : "", tmp2);
	    free (tmp2);
	    if (rc < 0)
	      return GSASL_MALLOC_ERROR;

	    rc = gsasl_md5 (tmp, strlen (tmp), &amp;tmp2);
	    free (tmp);
	    if (rc != GSASL_OK)
	      return rc;

	    memcpy (state->secret, tmp2, DIGEST_MD5_LENGTH);
	    free (tmp2);
	  }
	else
	  {
	    return GSASL_NO_PASSWORD;
	  }
      }

      /* Check client response. */
      {
	char check[DIGEST_MD5_RESPONSE_LENGTH + 1];

	rc = digest_md5_hmac (check, state->secret,
			      state->response.nonce, state->response.nc,
			      state->response.cnonce, state->response.qop,
			      state->response.authzid,
			      state->response.digesturi, 0,
			      state->response.cipher,
			      state->kic, state->kis, state->kcc, state->kcs);
	if (rc)
	  return GSASL_AUTHENTICATION_ERROR;

	if (strcmp (state->response.response, check) != 0)
	  return GSASL_AUTHENTICATION_ERROR;
      }

      /* Create finish token. */
      rc = digest_md5_hmac (state->finish.rspauth, state->secret,
			    state->response.nonce, state->response.nc,
			    state->response.cnonce, state->response.qop,
			    state->response.authzid,
			    state->response.digesturi, 1,
			    state->response.cipher, NULL, NULL, NULL, NULL);
      if (rc)
	return GSASL_AUTHENTICATION_ERROR;

      *output = digest_md5_print_finish (&amp;state->finish);
      if (!*output)
	return GSASL_MALLOC_ERROR;

      *output_len = strlen (*output);

      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      *output_len = 0;
      state->step++;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('main_src', 'main_button')"><span id="main_button">&darr;</span></a>
</td>
<td class="function_entry_name">
main
</td>
<td class="function_entry_cyclo">
25
</td>
<td class="function_entry_number">
112
</td>
<td class="function_entry_number">
174
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/test-parser.c;hb=HEAD">lib/digest-md5/test-parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="main_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
main (int argc, char *argv[])
{
  digest_md5_challenge c;
  digest_md5_response r;
  digest_md5_finish f;
  char buf32[33];
  char buf16[16];
  int rc;
  char *tmp;

  {
    const char *token = "nonce=4711, foo=bar, algorithm=md5-sess";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc != 0)
      abort ();
    printf ("nonce `%s': %s", c.nonce,
	    strcmp ("4711", c.nonce) == 0 ? "PASS" : "FAILURE");
    printf ("\n");
    tmp = digest_md5_print_challenge (&amp;c);
    if (!tmp)
      abort ();
    printf ("printed `%s' PASS\n", tmp);
    free (tmp);
  }

  {
    const char *token = "qop=\"auth, auth-conf\", nonce=42, algorithm=md5-sess";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc == 0)
      abort ();
    printf ("PASS\n");
  }

  {
    const char *token = "cipher=\"des\", nonce=42, algorithm=md5-sess";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc == 0)
      abort ();
    printf ("PASS\n");
  }

  {
    const char *token = "qop=\"auth, auth-conf\", nonce=42, "
      "algorithm=md5-sess, cipher=\"des\"";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc != 0)
      abort ();
    printf ("qop %02x ciphers %02x: %s\n", c.qops, c.ciphers,
	    (c.qops == 5 &amp;& c.ciphers == 1) ? "PASS" : "FAILURE");
    tmp = digest_md5_print_challenge (&amp;c);
    if (!tmp)
      abort ();
    printf ("printed `%s' PASS\n", tmp);
    free (tmp);
  }

  {
    const char *token = "bar=foo, foo=bar";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc == 0)
      abort ();
    printf ("PASS\n");
  }

  {
    const char *token = "realm=foo, realm=bar, nonce=42, algorithm=md5-sess";

    printf ("challenge `%s': ", token);
    rc = digest_md5_parse_challenge (token, 0, &amp;c);
    if (rc != 0)
      abort ();
    if (c.nrealms != 2)
      abort ();
    printf ("realms `%s', `%s': PASS\n", c.realms[0], c.realms[1]);
    tmp = digest_md5_print_challenge (&amp;c);
    if (!tmp)
      abort ();
    printf ("printed `%s' PASS\n", tmp);
    free (tmp);
  }

  /* Response */

  {
    const char *token = "bar=foo, foo=bar";

    printf ("response `%s': ", token);
    rc = digest_md5_parse_response (token, 0, &amp;r);
    if (rc == 0)
      abort ();
    printf ("PASS\n");
  }

  {
    const char *token = "username=jas, nonce=42, cnonce=4711, nc=00000001, "
      "digest-uri=foo, response=01234567890123456789012345678901";

    printf ("response `%s': ", token);
    rc = digest_md5_parse_response (token, 0, &amp;r);
    if (rc != 0)
      abort ();
    printf ("username `%s', nonce `%s', cnonce `%s',"
	    " nc %08lx, digest-uri `%s', response `%s': PASS\n",
	    r.username, r.nonce, r.cnonce, r.nc, r.digesturi, r.response);
    tmp = digest_md5_print_response (&amp;r);
    if (!tmp)
      abort ();
    printf ("printed `%s' PASS\n", tmp);
    free (tmp);
  }

  /* Auth-response, finish. */

  {
    const char *token = "rspauth=\"6a204da26b9888ee40bb3052ff056a67\"";

    printf ("finish `%s': ", token);
    rc = digest_md5_parse_finish (token, 0, &amp;f);
    if (rc != 0)
      abort ();
    printf ("`%s'? %s\n", f.rspauth,
	    strcmp ("6a204da26b9888ee40bb3052ff056a67", f.rspauth) == 0
	    ? "ok" : "FAILURE");
  }

  {
    const char *token = "bar=foo, foo=bar";

    printf ("finish `%s': ", token);
    rc = digest_md5_parse_finish (token, 0, &amp;f);
    if (rc == 0)
      abort ();
    printf ("invalid? PASS\n");
  }

  rc = gc_init ();
  if (rc != 0)
    abort ();

  memset (buf16, 'Q', 16);

  rc = digest_md5_hmac (buf32, buf16, "nonce", 1, "cnonce",
			DIGEST_MD5_QOP_AUTH, "authzid", "digesturi",
			1, 0, NULL, NULL, NULL, NULL);
  if (rc != 0)
    abort ();
  buf32[32] = '\0';
  if (strcmp (buf32, "6a204da26b9888ee40bb3052ff056a67") != 0)
    abort ();
  printf ("digest: `%s': PASS\n", buf32);

  rc = digest_md5_hmac (buf32, buf16, "nonce", 1, "cnonce",
			DIGEST_MD5_QOP_AUTH, "authzid", "digesturi", 0, 0,
			NULL, NULL, NULL, NULL);
  if (rc != 0)
    abort ();
  buf32[32] = '\0';
  if (strcmp (buf32, "6c1f58bfa46e9c225b93745c84204efd") != 0)
    abort ();
  printf ("digest: `%s': PASS\n", buf32);

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('pmap_src', 'pmap_button')"><span id="pmap_button">&darr;</span></a>
</td>
<td class="function_entry_name">
pmap
</td>
<td class="function_entry_cyclo">
32
</td>
<td class="function_entry_number">
98
</td>
<td class="function_entry_number">
163
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="pmap_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
static const char *
pmap (Gsasl_session * sctx, Gsasl_property prop, char *buf, size_t buflen)
{
  int res;

  buf[0] = '\0';

  /* Translate obsolete callbacks to modern properties. */

  switch (prop)
    {
    case GSASL_SERVICE:
      {
	Gsasl_client_callback_service cb_service
	  = gsasl_client_callback_service_get (sctx->ctx);
	if (!cb_service)
	  break;
	res = cb_service (sctx, buf, &amp;buflen, NULL, 0, NULL, 0);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_HOSTNAME:
      {
	Gsasl_client_callback_service cb_service
	  = gsasl_client_callback_service_get (sctx->ctx);
	if (!cb_service)
	  break;
	res = cb_service (sctx, NULL, 0, buf, &amp;buflen, NULL, 0);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_ANONYMOUS_TOKEN:
      {
	Gsasl_client_callback_anonymous cb_anonymous
	  = gsasl_client_callback_anonymous_get (sctx->ctx);
	if (!cb_anonymous)
	  break;
	res = cb_anonymous (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_AUTHID:
      {
	Gsasl_client_callback_authentication_id cb_authentication_id
	  = gsasl_client_callback_authentication_id_get (sctx->ctx);
	if (!cb_authentication_id)
	  break;
	res = cb_authentication_id (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_AUTHZID:
      {
	Gsasl_client_callback_authorization_id cb_authorization_id
	  = gsasl_client_callback_authorization_id_get (sctx->ctx);
	if (!cb_authorization_id)
	  break;
	res = cb_authorization_id (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_PASSWORD:
      {
	Gsasl_client_callback_password cb_password
	  = gsasl_client_callback_password_get (sctx->ctx);
	if (!cb_password)
	  break;
	res = cb_password (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_PASSCODE:
      {
	Gsasl_client_callback_passcode cb_passcode
	  = gsasl_client_callback_passcode_get (sctx->ctx);
	if (!cb_passcode)
	  break;
	res = cb_passcode (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_PIN:
      {
	Gsasl_client_callback_pin cb_pin
	  = gsasl_client_callback_pin_get (sctx->ctx);
	if (!cb_pin)
	  break;
	res = cb_pin (sctx, sctx->suggestedpin, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

    case GSASL_REALM:
      {
	Gsasl_client_callback_realm cb_realm
	  = gsasl_client_callback_realm_get (sctx->ctx);
	if (!cb_realm)
	  break;
	res = cb_realm (sctx, buf, &amp;buflen);
	if (res != GSASL_OK)
	  break;
	buf[buflen] = '\0';
	gsasl_property_set (sctx, prop, buf);
	break;
      }

#if USE_DIGEST_MD5
    case GSASL_QOP:
      {
	Gsasl_client_callback_qop cb_qop
	  = gsasl_client_callback_qop_get (sctx->ctx);
	int serverqops;
	Gsasl_qop qop;
	if (!cb_qop)
	  break;
	serverqops = digest_md5_qopstr2qops (sctx->qops);
	if (serverqops == -1)
	  return NULL;
	qop = cb_qop (sctx, serverqops);
	if (qop &amp; 0x07)
	  gsasl_property_set (sctx, prop, digest_md5_qops2qopstr (qop));
	break;
      }
      break;
#endif

    default:
      break;
    }

  return gsasl_property_fast (sctx, prop);
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_high">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_gssapi_client_step_src', '_gsasl_gssapi_client_step_button')"><span id="_gsasl_gssapi_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_gssapi_client_step
</td>
<td class="function_entry_cyclo">
24
</td>
<td class="function_entry_number">
91
</td>
<td class="function_entry_number">
178
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/client.c;hb=HEAD">lib/gssapi/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_gssapi_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_gssapi_client_step (Gsasl_session * sctx,
			   void *mech_data,
			   const char *input, size_t input_len,
			   char **output, size_t * output_len)
{
  _Gsasl_gssapi_client_state *state = mech_data;
  char clientwrap[4];
  gss_qop_t serverqop;
  gss_buffer_desc bufdesc, bufdesc2;
  gss_buffer_t buf = GSS_C_NO_BUFFER;
  OM_uint32 maj_stat, min_stat;
  int conf_state;
  int res;
  const char *p;

  if (state->service == NULL)
    {
      const char *service, *hostname;

      service = gsasl_property_get (sctx, GSASL_SERVICE);
      if (!service)
	return GSASL_NO_SERVICE;

      hostname = gsasl_property_get (sctx, GSASL_HOSTNAME);
      if (!hostname)
	return GSASL_NO_HOSTNAME;

      /* FIXME: Use asprintf. */

      bufdesc.length = strlen (service) + 1 + strlen (hostname) + 1;
      bufdesc.value = malloc (bufdesc.length);
      if (bufdesc.value == NULL)
	return GSASL_MALLOC_ERROR;

      sprintf (bufdesc.value, "%s@%s", service, hostname);

      maj_stat = gss_import_name (&amp;min_stat, &bufdesc,
				  GSS_C_NT_HOSTBASED_SERVICE,
				  &amp;state->service);
      free (bufdesc.value);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_IMPORT_NAME_ERROR;
    }

  switch (state->step)
    {
    case 1:
      bufdesc.length = input_len;
      bufdesc.value = (void *) input;
      buf = &amp;bufdesc;
      /* fall through */

    case 0:
      bufdesc2.length = 0;
      bufdesc2.value = NULL;
      maj_stat = gss_init_sec_context (&amp;min_stat,
				       GSS_C_NO_CREDENTIAL,
				       &amp;state->context,
				       state->service,
				       GSS_C_NO_OID,
				       GSS_C_MUTUAL_FLAG |
				       GSS_C_REPLAY_FLAG |
				       GSS_C_SEQUENCE_FLAG |
				       GSS_C_INTEG_FLAG |
				       GSS_C_CONF_FLAG,
				       0,
				       GSS_C_NO_CHANNEL_BINDINGS,
				       buf, NULL, &amp;bufdesc2, NULL, NULL);
      if (maj_stat != GSS_S_COMPLETE &amp;& maj_stat != GSS_S_CONTINUE_NEEDED)
	return GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;

      *output_len = bufdesc2.length;
      *output = malloc (*output_len);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, bufdesc2.value, bufdesc2.length);

      if (maj_stat == GSS_S_COMPLETE)
	state->step = 2;
      else
	state->step = 1;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (maj_stat != GSS_S_COMPLETE)
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      /* [RFC 2222 section 7.2.1]:
         The client passes this token to GSS_Unwrap and interprets the
         first octet of resulting cleartext as a bit-mask specifying
         the security layers supported by the server and the second
         through fourth octets as the maximum size output_message to
         send to the server.  The client then constructs data, with
         the first octet containing the bit-mask specifying the
         selected security layer, the second through fourth octets
         containing in network byte order the maximum size
         output_message the client is able to receive, and the
         remaining octets containing the authorization identity.  The
         client passes the data to GSS_Wrap with conf_flag set to
         FALSE, and responds with the generated output_message.  The
         client can then consider the server authenticated. */

      bufdesc.length = input_len;
      bufdesc.value = (void *) input;
      maj_stat = gss_unwrap (&amp;min_stat, state->context, &bufdesc,
			     &amp;bufdesc2, &conf_state, &serverqop);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_UNWRAP_ERROR;

      if (bufdesc2.length != 4)
	return GSASL_MECHANISM_PARSE_ERROR;

      memcpy (clientwrap, bufdesc2.value, 4);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

#if 0
      /* FIXME: Fix qop. */
      if (cb_qop)
	state->qop = cb_qop (sctx, serverqop);

      if ((state->qop &amp; serverqop) == 0)
	/*  Server does not support what user wanted. */
	return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;
#endif

      /* FIXME: Fix maxbuf. */

      p = gsasl_property_get (sctx, GSASL_AUTHID);
      if (!p)
	return GSASL_NO_AUTHID;

      bufdesc.length = 4 + strlen (p);
      bufdesc.value = malloc (bufdesc.length);
      if (!bufdesc.value)
	return GSASL_MALLOC_ERROR;

      {
	char *q = bufdesc.value;
	q[0] = state->qop;
	memcpy (q + 1, clientwrap + 1, 3);
	memcpy (q + 4, p, strlen (p));
      }

      maj_stat = gss_wrap (&amp;min_stat, state->context, 0, GSS_C_QOP_DEFAULT,
			   &amp;bufdesc, &conf_state, &bufdesc2);
      free (bufdesc.value);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_WRAP_ERROR;

      *output_len = bufdesc2.length;
      *output = malloc (bufdesc2.length);
      if (!*output)
	return GSASL_MALLOC_ERROR;

      memcpy (*output, bufdesc2.value, bufdesc2.length);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      state->step++;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_gs2_server_step_src', '_gsasl_gs2_server_step_button')"><span id="_gsasl_gs2_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_gs2_server_step
</td>
<td class="function_entry_cyclo">
21
</td>
<td class="function_entry_number">
78
</td>
<td class="function_entry_number">
159
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/server.c;hb=HEAD">lib/gs2/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_gs2_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_gs2_server_step (Gsasl_session * sctx,
			void *mech_data,
			const char *input, size_t input_len,
			char **output, size_t * output_len)
{
  _Gsasl_gs2_server_state *state = mech_data;
  gss_buffer_desc bufdesc1, bufdesc2;
  OM_uint32 maj_stat, min_stat;
  gss_buffer_desc client_name;
  gss_OID mech_type;
  char tmp[4];
  int res;
  OM_uint32 ret_flags;
  struct gs2_token tok;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      if (input_len == 0)
	{
	  res = GSASL_NEEDS_MORE;
	  break;
	}
      state->step++;
      /* fall through */

    case 1:
      res = gs2_parser (input, input_len, &amp;tok);
      if (res < 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      bufdesc1.value = tok.context_token;
      bufdesc1.length = tok.context_length;
      if (state->client)
	{
	  gss_release_name (&amp;min_stat, &state->client);
	  state->client = GSS_C_NO_NAME;
	}

      maj_stat = gss_accept_sec_context (&amp;min_stat,
					 &amp;state->context,
					 state->cred,
					 &amp;bufdesc1,
					 GSS_C_NO_CHANNEL_BINDINGS,
					 &amp;state->client,
					 &amp;mech_type,
					 &amp;bufdesc2, &ret_flags, NULL, NULL);
      if (maj_stat != GSS_S_COMPLETE &amp;& maj_stat != GSS_S_CONTINUE_NEEDED)
	return GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR;

      /* XXX check wrap token */

      if (ret_flags &amp; GSS_C_PROT_READY_FLAG)
	{
	  puts ("prot_ready");
	  /* XXX gss_wrap token */
	}

      res = gs2_encode (bufdesc2.value, bufdesc2.length,
			NULL, 0, output, output_len);
      if (res < 0)
	return GSASL_GSSAPI_INIT_SEC_CONTEXT_ERROR;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      if (maj_stat == GSS_S_COMPLETE)
	state->step++;

      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      memset (tmp, 0xFF, 4);
      tmp[0] = GSASL_QOP_AUTH;
      bufdesc1.length = 4;
      bufdesc1.value = tmp;
      maj_stat = gss_wrap (&amp;min_stat, state->context, 0, GSS_C_QOP_DEFAULT,
			   &amp;bufdesc1, NULL, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_WRAP_ERROR;

      *output = malloc (bufdesc2.length);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, bufdesc2.value, bufdesc2.length);
      *output_len = bufdesc2.length;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 3:
      bufdesc1.value = (void *) input;
      bufdesc1.length = input_len;
      maj_stat = gss_unwrap (&amp;min_stat, state->context, &bufdesc1,
			     &amp;bufdesc2, NULL, NULL);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_UNWRAP_ERROR;

      /* [RFC 2222 section 7.2.1]:
         The client passes this token to GSS_Unwrap and interprets the
         first octet of resulting cleartext as a bit-mask specifying
         the security layers supported by the server and the second
         through fourth octets as the maximum size output_message to
         send to the server.  The client then constructs data, with
         the first octet containing the bit-mask specifying the
         selected security layer, the second through fourth octets
         containing in network byte order the maximum size
         output_message the client is able to receive, and the
         remaining octets containing the authorization identity.  The
         client passes the data to GSS_Wrap with conf_flag set to
         FALSE, and responds with the generated output_message.  The
         client can then consider the server authenticated. */

      if ((((char *) bufdesc2.value)[0] &amp; GSASL_QOP_AUTH) == 0)
	{
	  /* Integrity or privacy unsupported */
	  maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
	  return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;
	}

      gsasl_property_set_raw (sctx, GSASL_AUTHZID,
			      (char *) bufdesc2.value + 4,
			      bufdesc2.length - 4);

      maj_stat = gss_display_name (&amp;min_stat, state->client,
				   &amp;client_name, &mech_type);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_DISPLAY_NAME_ERROR;

      gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME,
			      client_name.value, client_name.length);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI);

      state->step++;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_gssapi_server_step_src', '_gsasl_gssapi_server_step_button')"><span id="_gsasl_gssapi_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_gssapi_server_step
</td>
<td class="function_entry_cyclo">
19
</td>
<td class="function_entry_number">
73
</td>
<td class="function_entry_number">
146
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/server.c;hb=HEAD">lib/gssapi/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_gssapi_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_gssapi_server_step (Gsasl_session * sctx,
			   void *mech_data,
			   const char *input, size_t input_len,
			   char **output, size_t * output_len)
{
  _Gsasl_gssapi_server_state *state = mech_data;
  gss_buffer_desc bufdesc1, bufdesc2;
  OM_uint32 maj_stat, min_stat;
  gss_buffer_desc client_name;
  gss_OID mech_type;
  char tmp[4];
  int res;

  *output = NULL;
  *output_len = 0;

  switch (state->step)
    {
    case 0:
      if (input_len == 0)
	{
	  res = GSASL_NEEDS_MORE;
	  break;
	}
      state->step++;
      /* fall through */

    case 1:
      bufdesc1.value = (void *) input;
      bufdesc1.length = input_len;
      if (state->client)
	{
	  gss_release_name (&amp;min_stat, &state->client);
	  state->client = GSS_C_NO_NAME;
	}

      maj_stat = gss_accept_sec_context (&amp;min_stat,
					 &amp;state->context,
					 state->cred,
					 &amp;bufdesc1,
					 GSS_C_NO_CHANNEL_BINDINGS,
					 &amp;state->client,
					 &amp;mech_type,
					 &amp;bufdesc2, NULL, NULL, NULL);
      if (maj_stat != GSS_S_COMPLETE &amp;& maj_stat != GSS_S_CONTINUE_NEEDED)
	return GSASL_GSSAPI_ACCEPT_SEC_CONTEXT_ERROR;

      *output = malloc (bufdesc2.length);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, bufdesc2.value, bufdesc2.length);
      *output_len = bufdesc2.length;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      if (maj_stat == GSS_S_COMPLETE)
	state->step++;

      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      memset (tmp, 0xFF, 4);
      tmp[0] = GSASL_QOP_AUTH;
      bufdesc1.length = 4;
      bufdesc1.value = tmp;
      maj_stat = gss_wrap (&amp;min_stat, state->context, 0, GSS_C_QOP_DEFAULT,
			   &amp;bufdesc1, NULL, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_WRAP_ERROR;

      *output = malloc (bufdesc2.length);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, bufdesc2.value, bufdesc2.length);
      *output_len = bufdesc2.length;

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 3:
      bufdesc1.value = (void *) input;
      bufdesc1.length = input_len;
      maj_stat = gss_unwrap (&amp;min_stat, state->context, &bufdesc1,
			     &amp;bufdesc2, NULL, NULL);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_UNWRAP_ERROR;

      /* [RFC 2222 section 7.2.1]:
         The client passes this token to GSS_Unwrap and interprets the
         first octet of resulting cleartext as a bit-mask specifying
         the security layers supported by the server and the second
         through fourth octets as the maximum size output_message to
         send to the server.  The client then constructs data, with
         the first octet containing the bit-mask specifying the
         selected security layer, the second through fourth octets
         containing in network byte order the maximum size
         output_message the client is able to receive, and the
         remaining octets containing the authorization identity.  The
         client passes the data to GSS_Wrap with conf_flag set to
         FALSE, and responds with the generated output_message.  The
         client can then consider the server authenticated. */

      if ((((char *) bufdesc2.value)[0] &amp; GSASL_QOP_AUTH) == 0)
	{
	  /* Integrity or privacy unsupported */
	  maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
	  return GSASL_GSSAPI_UNSUPPORTED_PROTECTION_ERROR;
	}

      gsasl_property_set_raw (sctx, GSASL_AUTHZID,
			      (char *) bufdesc2.value + 4,
			      bufdesc2.length - 4);

      maj_stat = gss_display_name (&amp;min_stat, state->client,
				   &amp;client_name, &mech_type);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_DISPLAY_NAME_ERROR;

      gsasl_property_set_raw (sctx, GSASL_GSSAPI_DISPLAY_NAME,
			      client_name.value, client_name.length);

      maj_stat = gss_release_buffer (&amp;min_stat, &bufdesc2);
      if (GSS_ERROR (maj_stat))
	return GSASL_GSSAPI_RELEASE_BUFFER_ERROR;

      res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_GSSAPI);

      state->step++;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_securid_client_step_src', '_gsasl_securid_client_step_button')"><span id="_gsasl_securid_client_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_securid_client_step
</td>
<td class="function_entry_cyclo">
18
</td>
<td class="function_entry_number">
59
</td>
<td class="function_entry_number">
106
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/securid/client.c;hb=HEAD">lib/securid/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_securid_client_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_securid_client_step (Gsasl_session * sctx,
			    void *mech_data,
			    const char *input,
			    size_t input_len,
			    char **output, size_t * output_len)
{
  int *step = mech_data;
  const char *authzid = NULL, *authid = NULL, *passcode = NULL, *pin = NULL;
  size_t authzidlen, authidlen, passcodelen, pinlen = 0;
  int do_pin = 0;
  int res;

  switch (*step)
    {
    case 1:
      if (input_len == strlen (PASSCODE) &amp;&
	  memcmp (input, PASSCODE, strlen (PASSCODE)) == 0)
	{
	  *step = 0;
	}
      else if (input_len >= strlen (PIN) &amp;&
	       memcmp (input, PIN, strlen (PIN)) == 0)
	{
	  do_pin = 1;
	  *step = 0;
	}
      else
	{
	  *output_len = 0;
	  res = GSASL_OK;
	  break;
	}
      /* fall through */

    case 0:
      authzid = gsasl_property_get (sctx, GSASL_AUTHZID);
      if (authzid)
	authzidlen = strlen (authzid);
      else
	authzidlen = 0;

      authid = gsasl_property_get (sctx, GSASL_AUTHID);
      if (!authid)
	return GSASL_NO_AUTHID;
      authidlen = strlen (authid);

      passcode = gsasl_property_get (sctx, GSASL_PASSCODE);
      if (!passcode)
	return GSASL_NO_PASSCODE;
      passcodelen = strlen (passcode);

      if (do_pin)
	{
	  if (input_len > strlen (PIN))
	    gsasl_property_set_raw (sctx, GSASL_SUGGESTED_PIN,
				    &amp;input[strlen (PIN)],
				    input_len - strlen (PIN));

	  pin = gsasl_property_get (sctx, GSASL_PIN);
	  if (!pin)
	    return GSASL_NO_PIN;
	  pinlen = strlen (pin);
	}

      *output_len = authzidlen + 1 + authidlen + 1 + passcodelen + 1;
      if (do_pin)
	*output_len += pinlen + 1;
      *output = malloc (*output_len);
      if (*output == NULL)
	return GSASL_MALLOC_ERROR;

      if (authzid)
	memcpy (*output, authzid, authzidlen);
      (*output)[authzidlen] = '\0';
      memcpy (*output + authzidlen + 1, authid, authidlen);
      (*output)[authzidlen + 1 + authidlen] = '\0';
      memcpy (*output + authzidlen + 1 + authidlen + 1, passcode,
	      passcodelen);
      (*output)[authzidlen + 1 + authidlen + 1 + passcodelen] = '\0';
      if (do_pin)
	{
	  memcpy (*output + authzidlen + 1 + authidlen + 1 + passcodelen + 1,
		  pin, pinlen);
	  (*output)[authzidlen + 1 + authidlen + 1 + passcodelen + 1 +
		    pinlen] = '\0';
	}

      (*step)++;
      res = GSASL_OK;
      break;

    case 2:
      *output_len = 0;
      *output = NULL;
      (*step)++;
      res = GSASL_OK;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_obsolete_callback_src', '_gsasl_obsolete_callback_button')"><span id="_gsasl_obsolete_callback_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_obsolete_callback
</td>
<td class="function_entry_cyclo">
21
</td>
<td class="function_entry_number">
64
</td>
<td class="function_entry_number">
119
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_obsolete_callback_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_obsolete_callback (Gsasl * ctx, Gsasl_session * sctx,
			  Gsasl_property prop)
{
  int res;

  /* Call obsolete callbacks. */

  switch (prop)
    {
    case GSASL_VALIDATE_ANONYMOUS:
      {
	Gsasl_server_callback_anonymous cb_anonymous;
	if (!sctx->anonymous_token)
	  break;
	cb_anonymous = gsasl_server_callback_anonymous_get (sctx->ctx);
	if (!cb_anonymous)
	  break;
	res = cb_anonymous (sctx, sctx->anonymous_token);
	return res;
	break;
      }

    case GSASL_VALIDATE_EXTERNAL:
      {
	Gsasl_server_callback_external cb_external
	  = gsasl_server_callback_external_get (sctx->ctx);
	if (!cb_external)
	  break;
	res = cb_external (sctx);
	return res;
	break;
      }

    case GSASL_VALIDATE_SECURID:
      {
	Gsasl_server_callback_securid cb_securid
	  = gsasl_server_callback_securid_get (sctx->ctx);
#define MAX_SECURID 32 /* See RFC 2808. */
	char buf[MAX_SECURID + 1];
	size_t buflen = MAX_SECURID;
	if (!cb_securid)
	  break;
	res = cb_securid (sctx, sctx->authid, sctx->authzid, sctx->passcode,
			  sctx->pin, buf, &amp;buflen);
	if (buflen > 0 &amp;& buflen < MAX_SECURID)
	  {
	    buf[buflen] = '\0';
	    gsasl_property_set (sctx, GSASL_SUGGESTED_PIN, buf);
	  }
	return res;
	break;
      }

    case GSASL_VALIDATE_GSSAPI:
      {
	Gsasl_server_callback_gssapi cb_gssapi
	  = gsasl_server_callback_gssapi_get (sctx->ctx);
	if (!cb_gssapi)
	  break;
	res = cb_gssapi (sctx, sctx->gssapi_display_name, sctx->authzid);
	return res;
	break;
      }

    case GSASL_VALIDATE_SIMPLE:
      {
	Gsasl_server_callback_validate cb_validate
	  = gsasl_server_callback_validate_get (sctx->ctx);
	if (!cb_validate)
	  break;
	res = cb_validate (sctx, sctx->authzid, sctx->authid, sctx->password);
	return res;
	break;
      }

    case GSASL_PASSWORD:
      {
	Gsasl_server_callback_retrieve cb_retrieve
	  = gsasl_server_callback_retrieve_get (sctx->ctx);
	char *buf;
	size_t buflen = BUFSIZ - 1;
	if (!cb_retrieve)
	  break;
	buf = malloc (BUFSIZ);
	if (!buf)
	  return GSASL_MALLOC_ERROR;
	res = cb_retrieve (sctx, sctx->authid, sctx->authzid,
			   sctx->hostname, buf, &amp;buflen);
	if (res == GSASL_OK)
	  gsasl_property_set_raw (sctx, GSASL_PASSWORD, buf, buflen);
	/* FIXME else if (res == GSASL_TOO_SMALL_BUFFER)... */
	free (buf);
	return res;
	break;
      }

#if USE_DIGEST_MD5
    case GSASL_QOPS:
      {
	Gsasl_server_callback_qop cb_qop
	  = gsasl_server_callback_qop_get (sctx->ctx);
	Gsasl_qop qops;
	if (!cb_qop)
	  break;
	qops = cb_qop (sctx);
	if (qops &amp; 0x07)
	  gsasl_property_set (sctx, GSASL_QOPS, digest_md5_qops2qopstr(qops));
	return GSASL_OK;
	break;
      }
#endif

    default:
      break;
    }

  return GSASL_NO_CALLBACK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_securid_server_step_src', '_gsasl_securid_server_step_button')"><span id="_gsasl_securid_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_securid_server_step
</td>
<td class="function_entry_cyclo">
15
</td>
<td class="function_entry_number">
55
</td>
<td class="function_entry_number">
89
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/securid/server.c;hb=HEAD">lib/securid/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_securid_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_securid_server_step (Gsasl_session * sctx,
			    void *mech_data,
			    const char *input, size_t input_len,
			    char **output, size_t * output_len)
{
  const char *authorization_id = NULL;
  const char *authentication_id = NULL;
  const char *passcode = NULL;
  const char *suggestedpin;
  char *pin = NULL;
  int res;
  size_t len;

  if (input_len == 0)
    {
      *output_len = 0;
      *output = NULL;
      return GSASL_NEEDS_MORE;
    }

  authorization_id = input;
  authentication_id = memchr (input, '\0', input_len - 1);
  if (authentication_id)
    {
      authentication_id++;
      passcode = memchr (authentication_id, '\0',
			 input_len - strlen (authorization_id) - 1 - 1);
      if (passcode)
	{
	  passcode++;
	  pin = memchr (passcode, '\0', input_len -
			strlen (authorization_id) - 1 -
			strlen (authentication_id) - 1 - 1);
	  if (pin)
	    {
	      pin++;
	      if (pin &amp;& !*pin)
		pin = NULL;
	    }
	}
    }

  if (passcode == NULL)
    return GSASL_MECHANISM_PARSE_ERROR;

  gsasl_property_set (sctx, GSASL_AUTHID, authentication_id);
  gsasl_property_set (sctx, GSASL_AUTHZID, authorization_id);
  gsasl_property_set (sctx, GSASL_PASSCODE, passcode);
  if (pin)
    gsasl_property_set (sctx, GSASL_PIN, pin);
  else
    gsasl_property_set (sctx, GSASL_PIN, NULL);

  res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SECURID);
  switch (res)
    {
    case GSASL_SECURID_SERVER_NEED_ADDITIONAL_PASSCODE:
      *output = strdup (PASSCODE);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      *output_len = strlen (PASSCODE);
      res = GSASL_NEEDS_MORE;
      break;

    case GSASL_SECURID_SERVER_NEED_NEW_PIN:
      suggestedpin = gsasl_property_get (sctx, GSASL_SUGGESTED_PIN);
      if (suggestedpin)
	len = strlen (suggestedpin);
      else
	len = 0;
      *output_len = strlen (PIN) + len;
      *output = malloc (*output_len);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, PIN, strlen (PIN));
      if (suggestedpin)
	memcpy (*output + strlen (PIN), suggestedpin, len);
      res = GSASL_NEEDS_MORE;
      break;

    default:
      *output_len = 0;
      *output = NULL;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('gs2_parse_request_src', 'gs2_parse_request_button')"><span id="gs2_parse_request_button">&darr;</span></a>
</td>
<td class="function_entry_name">
gs2_parse_request
</td>
<td class="function_entry_cyclo">
14
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/gs2wrap.c;hb=HEAD">lib/gs2/gs2wrap.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="gs2_parse_request_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
gs2_parse_request (const char *request, size_t reqlen,
		   int clientp,
		   int *qop, size_t * maxbuf, size_t * cblen,
		   int *cbqops, char **cbdata, char **authzid)
{
  size_t l;

  if (reqlen < 8)
    return -1;

  if (qop)
    *qop = request[0];

  if (maxbuf)
    *maxbuf =
      (request[1] << 16) &amp; 0xFF0000 |
      (request[2] << 8) &amp; 0xFF00 | (request[3]) & 0xFF;

  l = (request[4] << 24) &amp; 0xFF000000 |
    (request[5] << 16) &amp; 0xFF0000 |
    (request[6] << 8) &amp; 0xFF00 | (request[7]) & 0xFF;

  if (l > 0 &amp;& reqlen == 8)
    return -2;

  if (cblen)
    *cblen = l;

  if (l > 0)
    {
      if (cbqops)
	*cbqops = request[8];
      if (cbdata)
	*cbdata = &amp;request[9];
      if (authzid)
	*authzid = &amp;request[9] + l;
    }
  else
    {
      if (cbqops)
	*cbqops = 0;
      if (cbdata)
	*cbdata = NULL;
      if (authzid)
	*authzid = NULL;
    }

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_login_server_step_src', '_gsasl_login_server_step_button')"><span id="_gsasl_login_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_login_server_step
</td>
<td class="function_entry_cyclo">
15
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_number">
87
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/server.c;hb=HEAD">lib/login/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_login_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_login_server_step (Gsasl_session * sctx,
			  void *mech_data,
			  const char *input, size_t input_len,
			  char **output, size_t * output_len)
{
  struct _Gsasl_login_server_state *state = mech_data;
  int res;

  switch (state->step)
    {
    case 0:
      *output = strdup (CHALLENGE_USERNAME);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      *output_len = strlen (CHALLENGE_USERNAME);

      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 1:
      if (input_len == 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      state->username = malloc (input_len + 1);
      if (state->username == NULL)
	return GSASL_MALLOC_ERROR;

      memcpy (state->username, input, input_len);
      state->username[input_len] = '\0';

      *output = strdup (CHALLENGE_PASSWORD);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      *output_len = strlen (CHALLENGE_PASSWORD);

      state->step++;
      res = GSASL_NEEDS_MORE;
      break;

    case 2:
      if (input_len == 0)
	return GSASL_MECHANISM_PARSE_ERROR;

      state->password = malloc (input_len + 1);
      if (state->password == NULL)
	return GSASL_MALLOC_ERROR;

      memcpy (state->password, input, input_len);
      state->password[input_len] = '\0';

      if (input_len != strlen (state->password))
	return GSASL_MECHANISM_PARSE_ERROR;

      gsasl_property_set (sctx, GSASL_AUTHID, state->username);
      gsasl_property_set (sctx, GSASL_PASSWORD, state->password);

      res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SIMPLE);
      if (res == GSASL_NO_CALLBACK)
	{
	  const char *key;

	  gsasl_property_set (sctx, GSASL_AUTHZID, NULL);
	  gsasl_property_set (sctx, GSASL_PASSWORD, NULL);

	  key = gsasl_property_get (sctx, GSASL_PASSWORD);

	  if (key &amp;& strlen (state->password) == strlen (key) &&
	      strcmp (state->password, key) == 0)
	    res = GSASL_OK;
	  else
	    res = GSASL_AUTHENTICATION_ERROR;
	}

      *output_len = 0;
      *output = NULL;
      state->step++;
      break;

    default:
      res = GSASL_MECHANISM_CALLED_TOO_MANY_TIMES;
      break;
    }

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_plain_server_step_src', '_gsasl_plain_server_step_button')"><span id="_gsasl_plain_server_step_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_plain_server_step
</td>
<td class="function_entry_cyclo">
13
</td>
<td class="function_entry_number">
59
</td>
<td class="function_entry_number">
114
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/plain/server.c;hb=HEAD">lib/plain/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_plain_server_step_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_plain_server_step (Gsasl_session * sctx,
			  void *mech_data,
			  const char *input, size_t input_len,
			  char **output, size_t * output_len)
{
  const char *authzidptr = input;
  char *authidptr = NULL;
  char *passwordptr = NULL;
  char *passwdz = NULL, *passprep = NULL, *authidprep = NULL;
  int res;

  *output_len = 0;
  *output = NULL;

  if (input_len == 0)
    return GSASL_NEEDS_MORE;

  /* Parse input. */
  {
    size_t tmplen;

    authidptr = memchr (input, 0, input_len - 1);
    if (authidptr)
      {
	authidptr++;
	passwordptr = memchr (authidptr, 0, input_len - strlen (input) - 1);
	if (passwordptr)
	  passwordptr++;
	else
	  return GSASL_MECHANISM_PARSE_ERROR;
      }
    else
      return GSASL_MECHANISM_PARSE_ERROR;

    /* As the NUL (U+0000) character is used as a deliminator, the NUL
       (U+0000) character MUST NOT appear in authzid, authcid, or passwd
       productions. */
    tmplen = input_len - (size_t) (passwordptr - input);
    if (memchr (passwordptr, 0, tmplen))
      return GSASL_MECHANISM_PARSE_ERROR;
  }

  /* Store authid, after preparing it... */
  {
    res = gsasl_saslprep (authidptr, GSASL_ALLOW_UNASSIGNED,
			  &amp;authidprep, NULL);
    if (res != GSASL_OK)
      return res;

    gsasl_property_set (sctx, GSASL_AUTHID, authidprep);

    /* Store authzid, if absent, use SASLprep(authcid). */
    if (*authzidptr == '\0')
      gsasl_property_set (sctx, GSASL_AUTHZID, authidprep);
    else
      gsasl_property_set (sctx, GSASL_AUTHZID, authzidptr);

    free (authidprep);
  }

  /* Store passwd, after preparing it... */
  {
    size_t passwdzlen = input_len - (size_t) (passwordptr - input);

    /* Need to zero terminate password... */
    passwdz = malloc (passwdzlen + 1);
    if (passwdz == NULL)
      return GSASL_MALLOC_ERROR;
    memcpy (passwdz, passwordptr, passwdzlen);
    passwdz[passwdzlen] = '\0';

    res = gsasl_saslprep (passwdz, GSASL_ALLOW_UNASSIGNED, &amp;passprep, NULL);
    free (passwdz);
    if (res != GSASL_OK)
      return res;

    gsasl_property_set (sctx, GSASL_PASSWORD, passprep);
  }

  /* Authorization.  Let application verify credentials internally,
     but fall back to deal with it locally... */
  res = gsasl_callback (NULL, sctx, GSASL_VALIDATE_SIMPLE);
  if (res == GSASL_NO_CALLBACK)
    {
      const char *key;
      char *normkey;

      gsasl_property_set (sctx, GSASL_PASSWORD, NULL);
      key = gsasl_property_get (sctx, GSASL_PASSWORD);
      if (!key)
	{
	  free (passprep);
	  return GSASL_NO_PASSWORD;
	}

      /* Unassigned code points are not permitted. */
      res = gsasl_saslprep (key, 0, &amp;normkey, NULL);
      if (res != GSASL_OK)
	{
	  free (passprep);
	  return res;
	}

      if (strcmp (normkey, passprep) == 0)
	res = GSASL_OK;
      else
	res = GSASL_AUTHENTICATION_ERROR;
      free (normkey);
    }
  free (passprep);

  return res;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('gs2_encode_src', 'gs2_encode_button')"><span id="gs2_encode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
gs2_encode
</td>
<td class="function_entry_cyclo">
13
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_number">
39
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/gs2parser.c;hb=HEAD">lib/gs2/gs2parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="gs2_encode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
gs2_encode (const char *context, size_t context_length,
	    const char *wrap, size_t wrap_length, char **out, size_t * outlen)
{
  size_t totlen = 4 + context_length + wrap_length;
  uint32_t ctxlen;

  /* Reject out of bounds conditions. */
  if (totlen > UINT32_MAX || totlen < context_length || totlen < wrap_length)
    return -1;

  /* Only time we accept NULL inputs is for zero-length inputs. */
  if (context == NULL &amp;& context_length != 0)
    return -2;
  if (wrap == NULL &amp;& wrap_length != 0)
    return -3;

  if (outlen)
    *outlen = totlen;

  if (!out)
    return 0;

  *out = malloc (*outlen);
  if (!*out)
    return -4;

  (*out)[0] = (context_length >> 24) &amp; 0xFF;
  (*out)[1] = (context_length >> 16) &amp; 0xFF;
  (*out)[2] = (context_length >> 8) &amp; 0xFF;
  (*out)[3] = context_length &amp; 0xFF;

  if (context)
    memcpy (*out + 4, context, context_length);
  if (wrap)
    memcpy (*out + 4 + context_length, wrap, wrap_length);

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_decode_src', 'digest_md5_decode_button')"><span id="digest_md5_decode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_decode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
40
</td>
<td class="function_entry_number">
76
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/session.c;hb=HEAD">lib/digest-md5/session.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_decode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
digest_md5_decode (const char *input, size_t input_len,
		   char **output, size_t * output_len,
		   digest_md5_qop qop,
		   unsigned long readseqnum, char key[DIGEST_MD5_LENGTH])
{
  if (qop &amp; DIGEST_MD5_QOP_AUTH_CONF)
    {
      return -1;
    }
  else if (qop &amp; DIGEST_MD5_QOP_AUTH_INT)
    {
      char *seqnumin;
      char hash[GC_MD5_DIGEST_SIZE];
      unsigned long len;
      char tmpbuf[SASL_INTEGRITY_PREFIX_LENGTH];
      int res;

      if (input_len < SASL_INTEGRITY_PREFIX_LENGTH)
	return -2;

      len = C2I (input);

      if (input_len < SASL_INTEGRITY_PREFIX_LENGTH + len)
	return -2;

      len -= MAC_HMAC_LEN + MAC_MSG_TYPE_LEN + MAC_SEQNUM_LEN;

      seqnumin = malloc (SASL_INTEGRITY_PREFIX_LENGTH + len);
      if (seqnumin == NULL)
	return -1;

      tmpbuf[0] = (readseqnum >> 24) &amp; 0xFF;
      tmpbuf[1] = (readseqnum >> 16) &amp; 0xFF;
      tmpbuf[2] = (readseqnum >> 8) &amp; 0xFF;
      tmpbuf[3] = readseqnum &amp; 0xFF;

      memcpy (seqnumin, tmpbuf, SASL_INTEGRITY_PREFIX_LENGTH);
      memcpy (seqnumin + SASL_INTEGRITY_PREFIX_LENGTH,
	      input + MAC_DATA_LEN, len);

      res = gc_hmac_md5 (key, MD5LEN, seqnumin, MAC_SEQNUM_LEN + len, hash);
      free (seqnumin);
      if (res)
	return -1;

      if (memcmp
	  (hash,
	   input + input_len - MAC_SEQNUM_LEN - MAC_MSG_TYPE_LEN -
	   MAC_HMAC_LEN, MAC_HMAC_LEN) == 0
	  &amp;& memcmp (MAC_MSG_TYPE,
		     input + input_len - MAC_SEQNUM_LEN - MAC_MSG_TYPE_LEN,
		     MAC_MSG_TYPE_LEN) == 0
	  &amp;& memcmp (tmpbuf, input + input_len - MAC_SEQNUM_LEN,
		     MAC_SEQNUM_LEN) == 0)
	{
	  *output_len = len;
	  *output = malloc (*output_len);
	  if (!*output)
	    return -1;
	  memcpy (*output, input + MAC_DATA_LEN, len);
	}
      else
	return -1;
    }
  else
    {
      *output_len = input_len;
      *output = malloc (input_len);
      if (!*output)
	return -1;
      memcpy (*output, input, input_len);
    }

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('register_builtin_mechs_src', 'register_builtin_mechs_button')"><span id="register_builtin_mechs_button">&darr;</span></a>
</td>
<td class="function_entry_name">
register_builtin_mechs
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
35
</td>
<td class="function_entry_number">
73
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/init.c;hb=HEAD">lib/src/init.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="register_builtin_mechs_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
static int
register_builtin_mechs (Gsasl * ctx)
{
  int rc = GSASL_OK;

#ifdef USE_ANONYMOUS
  rc = gsasl_register (ctx, &amp;gsasl_anonymous_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_ANONYMOUS */

#ifdef USE_EXTERNAL
  rc = gsasl_register (ctx, &amp;gsasl_external_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_EXTERNAL */

#ifdef USE_LOGIN
  rc = gsasl_register (ctx, &amp;gsasl_login_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_LOGIN */

#ifdef USE_PLAIN
  rc = gsasl_register (ctx, &amp;gsasl_plain_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_PLAIN */

#ifdef USE_SECURID
  rc = gsasl_register (ctx, &amp;gsasl_securid_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_SECURID */

#ifdef USE_NTLM
  rc = gsasl_register (ctx, &amp;gsasl_ntlm_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_NTLM */

#ifdef USE_DIGEST_MD5
  rc = gsasl_register (ctx, &amp;gsasl_digest_md5_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_DIGEST_MD5 */

#ifdef USE_CRAM_MD5
  rc = gsasl_register (ctx, &amp;gsasl_cram_md5_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_CRAM_MD5 */

#ifdef USE_SCRAM_SHA1
  rc = gsasl_register (ctx, &amp;gsasl_scram_sha1_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_SCRAM_SHA1 */

#ifdef USE_GSSAPI
  rc = gsasl_register (ctx, &amp;gsasl_gssapi_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_GSSAPI */

#ifdef USE_GS2
  rc = gsasl_register (ctx, &amp;gsasl_gs2_krb5_mechanism);
  if (rc != GSASL_OK)
    return rc;
#endif /* USE_GSSAPI */

  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_decode_src', '_gsasl_kerberos_v5_server_decode_button')"><span id="_gsasl_kerberos_v5_server_decode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_decode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_decode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_decode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      /* XXX */
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      Shishi_asn1 asn1safe;

      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der_set (state->safe, input, input_len);
      printf ("len %d err %d\n", input_len, res);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_verify (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_user_data (state->sh, shishi_safe_safe (state->safe),
				   output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;
      printf ("len=%d\n", *output_len);
      return GSASL_OK;
    }
  else
    {
      *output_len = input_len;
      if (output)
	memcpy (output, input, input_len);
      return GSASL_OK;
    }


  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_decode_src', '_gsasl_kerberos_v5_server_decode_button')"><span id="_gsasl_kerberos_v5_server_decode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_decode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_decode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_decode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      return GSASL_INTEGRITY_ERROR;
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      Shishi_asn1 asn1safe;

      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der_set (state->safe, input, input_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_verify (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_user_data (state->sh, shishi_safe_safe (state->safe),
				   output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      return GSASL_OK;
    }
  else
    {
      *output_len = input_len;
      *output = malloc (input_len);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, input, input_len);
    }


  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_encode_src', '_gsasl_kerberos_v5_server_encode_button')"><span id="_gsasl_kerberos_v5_server_encode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_encode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_number">
46
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_encode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_encode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      return GSASL_INTEGRITY_ERROR;
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_set_user_data (state->sh,
				       shishi_safe_safe (state->safe),
				       input, input_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_build (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der (state->safe, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;
    }
  else
    {
      *output_len = input_len;
      *output = malloc (input_len);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, input, input_len);
    }

  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_client_encode_src', '_gsasl_kerberos_v5_client_encode_button')"><span id="_gsasl_kerberos_v5_client_encode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_encode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_number">
46
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_client_encode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_client_encode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char **output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_client_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      return GSASL_INTEGRITY_ERROR;
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_set_user_data (state->sh,
				       shishi_safe_safe (state->safe),
				       input, input_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_build (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der (state->safe, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;
    }
  else
    {
      *output_len = input_len;
      *output = malloc (input_len);
      if (!*output)
	return GSASL_MALLOC_ERROR;
      memcpy (*output, input, input_len);
    }

  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_server_encode_src', '_gsasl_kerberos_v5_server_encode_button')"><span id="_gsasl_kerberos_v5_server_encode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_encode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
21
</td>
<td class="function_entry_number">
45
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_server_encode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_server_encode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_server_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      /* XXX */
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_set_user_data (state->sh,
				       shishi_safe_safe (state->safe),
				       input, input_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_build (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der (state->safe, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;
    }
  else
    {
      *output_len = input_len;
      if (output)
	memcpy (output, input, input_len);
      return GSASL_OK;
    }

  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('_gsasl_kerberos_v5_client_encode_src', '_gsasl_kerberos_v5_client_encode_button')"><span id="_gsasl_kerberos_v5_client_encode_button">&darr;</span></a>
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_encode
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
21
</td>
<td class="function_entry_number">
45
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="_gsasl_kerberos_v5_client_encode_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
_gsasl_kerberos_v5_client_encode (Gsasl_session * sctx,
				  void *mech_data,
				  const char *input,
				  size_t input_len,
				  char *output, size_t * output_len)
{
  struct _Gsasl_kerberos_v5_client_state *state = mech_data;
  int res;

  if (state &amp;& state->sessionkey && state->clientqop & GSASL_QOP_AUTH_CONF)
    {
      /* XXX */
    }
  else if (state &amp;& state->sessionkey
	   &amp;& state->clientqop & GSASL_QOP_AUTH_INT)
    {
      res = shishi_safe (state->sh, &amp;state->safe);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_set_user_data (state->sh,
				       shishi_safe_safe (state->safe),
				       input, input_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_build (state->safe, state->sessionkey);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;

      res = shishi_safe_safe_der (state->safe, output, output_len);
      if (res != SHISHI_OK)
	return GSASL_KERBEROS_V5_INTERNAL_ERROR;
    }
  else
    {
      *output_len = input_len;
      if (output)
	memcpy (output, input, input_len);
      return GSASL_OK;
    }

  return GSASL_OK;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_validate_response_src', 'digest_md5_validate_response_button')"><span id="digest_md5_validate_response_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_validate_response
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
19
</td>
<td class="function_entry_number">
49
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/validate.c;hb=HEAD">lib/digest-md5/validate.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_validate_response_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
digest_md5_validate_response (digest_md5_response * r)
{
  /* This directive is required and MUST be present exactly
     once; otherwise, authentication fails. */
  if (!r->username)
    return -1;

  /* This directive is required and MUST be present exactly
     once; otherwise, authentication fails. */
  if (!r->nonce)
    return -1;

  /* This directive is required and MUST be present exactly once;
     otherwise, authentication fails. */
  if (!r->cnonce)
    return -1;

  /* This directive is required and MUST be present exactly once;
     otherwise, or if the value is 0, authentication fails. */
  if (!r->nc)
    return -1;

  /* This directive is required and MUST be present exactly
     once; if multiple instances are present, the client MUST
     abort the authentication exchange. */
  if (!r->digesturi)
    return -1;

  /* This directive is required and MUST be present exactly
     once; otherwise, authentication fails. */
  if (!*r->response)
    return -1;

  if (strlen (r->response) != DIGEST_MD5_RESPONSE_LENGTH)
    return -1;

  /* This directive MUST appear exactly once if "auth-conf" is
     negotiated; if required and not present, authentication fails.
     If the client recognizes no cipher and the server only advertised
     "auth-conf" in the qop option, the client MUST abort the
     authentication exchange.  */
  if (r->qop == DIGEST_MD5_QOP_AUTH_CONF &amp;& !r->cipher)
    return -1;
  if (r->qop != DIGEST_MD5_QOP_AUTH_CONF &amp;& r->cipher)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('unescape_src', 'unescape_button')"><span id="unescape_button">&darr;</span></a>
</td>
<td class="function_entry_name">
unescape
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_number">
34
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/parser.c;hb=HEAD">lib/scram/parser.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="unescape_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
static char *
unescape (const char *str, size_t len)
{
  char *out = malloc (len + 1);
  char *p = out;

  if (!out)
    return NULL;

  while (len > 0 &amp;& *str)
    {
      if (len >= 3 &amp;& str[0] == '=' && str[1] == '2' && str[2] == 'C')
	{
	  *p++ = ',';
	  str += 3;
	  len -= 3;
	}
      else if (len >= 3 &amp;& str[0] == '=' && str[1] == '3' && str[2] == 'D')
	{
	  *p++ = '=';
	  str += 3;
	  len -= 3;
	}
      else
	{
	  *p++ = *str;
	  str++;
	  len--;
	}
    }
  *p = '\0';

  return out;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('digest_md5_validate_src', 'digest_md5_validate_button')"><span id="digest_md5_validate_button">&darr;</span></a>
</td>
<td class="function_entry_name">
digest_md5_validate
</td>
<td class="function_entry_cyclo">
12
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/validate.c;hb=HEAD">lib/digest-md5/validate.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="digest_md5_validate_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
digest_md5_validate (digest_md5_challenge * c, digest_md5_response * r)
{
  if (!c->nonce || !r->nonce)
    return -1;

  if (strcmp (c->nonce, r->nonce) != 0)
    return -1;

  if (r->nc != 1)
    return -1;

  if (!c->utf8 &amp;& r->utf8)
    return -1;

  if (!((c->qops ? c->qops : DIGEST_MD5_QOP_AUTH) &amp;
	(r->qop ? r->qop : DIGEST_MD5_QOP_AUTH)))
    return -1;

  if ((r->qop &amp; DIGEST_MD5_QOP_AUTH_CONF) && !(c->ciphers & r->cipher))
    return -1;

  /* FIXME: Check more? */

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('scram_valid_client_first_src', 'scram_valid_client_first_button')"><span id="scram_valid_client_first_button">&darr;</span></a>
</td>
<td class="function_entry_name">
scram_valid_client_first
</td>
<td class="function_entry_cyclo">
13
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
37
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/validate.c;hb=HEAD">lib/scram/validate.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="scram_valid_client_first_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
bool
scram_valid_client_first (struct scram_client_first *cf)
{
  /* Check that cbflag is one of permitted values. */
  switch (cf->cbflag)
    {
    case 'p':
    case 'n':
    case 'y':
      break;

    default:
      return false;
    }

  /* Check that cbname is only set when cbflag is p. */
  if (cf->cbflag == 'p' &amp;& cf->cbname == NULL)
    return false;
  else if (cf->cbflag != 'p' &amp;& cf->cbname != NULL)
    return false;

  /* FIXME check that cbname matches [A-Za-z0-9.-]. */

  /* We require a non-zero username string. */
  if (cf->username == NULL || *cf->username == '\0')
    return false;

  /* We require a non-zero client nonce. */
  if (cf->client_nonce == NULL || *cf->client_nonce == '\0')
    return false;

  /* Nonce cannot contain ','. */
  if (strchr (cf->client_nonce, ','))
    return false;

  return true;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_moderate">
<td class="function_entry_filename">
<a href="javascript:void(0);" title="show/hide function source" onClick="javascript:show_hide('scram_print_client_first_src', 'scram_print_client_first_button')"><span id="scram_print_client_first_button">&darr;</span></a>
</td>
<td class="function_entry_name">
scram_print_client_first
</td>
<td class="function_entry_cyclo">
11
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_number">
42
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/printer.c;hb=HEAD">lib/scram/printer.c</a>
</td>
</tr>
<tr>
<td colspan="6" height="0">
<div id="scram_print_client_first_src" class="function_src" style="position: relative; display: none;">
<pre class="function_src">
int
scram_print_client_first (struct scram_client_first *cf, char **out)
{
  char *username = NULL;
  char *authzid = NULL;
  int n;

  /* Below we assume fields are sensible, so first verify that to
     avoid crashes. */
  if (!scram_valid_client_first (cf))
    return -1;

  /* Escape username and authzid. */

  username = scram_escape (cf->username);
  if (!username)
    return -2;

  if (cf->authzid)
    {
      authzid = scram_escape (cf->authzid);
      if (!authzid)
	return -2;
    }

  n = asprintf (out, "%c%s%s,%s%s,n=%s,r=%s",
		cf->cbflag,
		cf->cbflag == 'p' ? "=" : "",
		cf->cbflag == 'p' ? cf->cbname : "",
		authzid ? "a=" : "",
		authzid ? authzid : "",
		username,
		cf->client_nonce);

  free (username);
  free (authzid);

  if (n <= 0 || *out == NULL)
    return -1;

  return 0;
}
</pre>
</div>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_ntlm_client_step
</td>
<td class="function_entry_cyclo">
11
</td>
<td class="function_entry_number">
53
</td>
<td class="function_entry_number">
105
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/ntlm/ntlm.c;hb=HEAD">lib/ntlm/ntlm.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_simple_getpass
</td>
<td class="function_entry_cyclo">
10
</td>
<td class="function_entry_number">
27
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/md5pwd.c;hb=HEAD">lib/src/md5pwd.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
utf8tolatin1ifpossible
</td>
<td class="function_entry_cyclo">
10
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_number">
39
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/nonascii.c;hb=HEAD">lib/digest-md5/nonascii.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_valid_client_final
</td>
<td class="function_entry_cyclo">
10
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
29
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/validate.c;hb=HEAD">lib/scram/validate.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_client_encode
</td>
<td class="function_entry_cyclo">
9
</td>
<td class="function_entry_number">
28
</td>
<td class="function_entry_number">
54
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/client.c;hb=HEAD">lib/gs2/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_client_encode
</td>
<td class="function_entry_cyclo">
9
</td>
<td class="function_entry_number">
28
</td>
<td class="function_entry_number">
54
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/client.c;hb=HEAD">lib/gssapi/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_saslprep
</td>
<td class="function_entry_cyclo">
9
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_number">
50
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/saslprep.c;hb=HEAD">lib/src/saslprep.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_suggest_mechanism
</td>
<td class="function_entry_cyclo">
9
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_number">
45
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/suggest.c;hb=HEAD">lib/src/suggest.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_parse_server_final
</td>
<td class="function_entry_cyclo">
9
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_number">
32
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/parser.c;hb=HEAD">lib/scram/parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_cram_md5_server_step
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
34
</td>
<td class="function_entry_number">
62
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/server.c;hb=HEAD">lib/cram-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_client_decode
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
27
</td>
<td class="function_entry_number">
52
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/client.c;hb=HEAD">lib/gs2/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_client_decode
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
27
</td>
<td class="function_entry_number">
52
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/client.c;hb=HEAD">lib/gssapi/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
setup
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_number">
40
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstart.c;hb=HEAD">lib/src/xstart.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gs2_parser
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_number">
41
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/gs2parser.c;hb=HEAD">lib/gs2/gs2parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_valid_server_first
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/validate.c;hb=HEAD">lib/scram/validate.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_decode
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
29
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_decode
</td>
<td class="function_entry_cyclo">
8
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
30
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_encode
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
45
</td>
<td class="function_entry_number">
68
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/session.c;hb=HEAD">lib/digest-md5/session.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_cram_md5_client_step
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
37
</td>
<td class="function_entry_number">
66
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/client.c;hb=HEAD">lib/cram-md5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_server_start
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
36
</td>
<td class="function_entry_number">
61
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/server.c;hb=HEAD">lib/gs2/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_server_start
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
36
</td>
<td class="function_entry_number">
61
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/server.c;hb=HEAD">lib/gssapi/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_start
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_number">
40
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_start
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_number">
40
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
comma_append
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_number">
31
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/printer.c;hb=HEAD">lib/digest-md5/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_register
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_number">
37
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/register.c;hb=HEAD">lib/src/register.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
parse_finish
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_number">
34
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_validate_challenge
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/validate.c;hb=HEAD">lib/digest-md5/validate.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_plain_client_step
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_number">
47
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/plain/client.c;hb=HEAD">lib/plain/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_server_start
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_number">
39
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/server.c;hb=HEAD">lib/scram/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_finish
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_number">
34
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xfinish.c;hb=HEAD">lib/src/xfinish.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_listmech
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_number">
35
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/listmech.c;hb=HEAD">lib/src/listmech.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_done
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_number">
28
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/done.c;hb=HEAD">lib/src/done.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_step64
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_number">
31
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstep.c;hb=HEAD">lib/src/xstep.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
main
</td>
<td class="function_entry_cyclo">
6
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
34
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/test-parser.c;hb=HEAD">lib/gs2/test-parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_qopstr2qops
</td>
<td class="function_entry_cyclo">
7
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_number">
54
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/qop.c;hb=HEAD">lib/digest-md5/qop.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_callback
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_hexdigit_to_char
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
hexdigit_to_char
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_md5pwd_get_password
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_number">
35
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_escape
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_number">
32
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/printer.c;hb=HEAD">lib/scram/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
latin1toutf8
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_number">
27
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/nonascii.c;hb=HEAD">lib/digest-md5/nonascii.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_step
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
28
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_server_finish
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/server.c;hb=HEAD">lib/gs2/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_server_finish
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/server.c;hb=HEAD">lib/gssapi/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_step64
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_login_client_step
</td>
<td class="function_entry_cyclo">
5
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_number">
43
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/client.c;hb=HEAD">lib/login/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_client_finish
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/client.c;hb=HEAD">lib/gs2/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_client_finish
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/client.c;hb=HEAD">lib/gssapi/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
find_mechanism
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstart.c;hb=HEAD">lib/src/xstart.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_strerror
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/error.c;hb=HEAD">lib/src/error.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_property_set_raw
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/property.c;hb=HEAD">lib/src/property.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_anonymous_server_step
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
25
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/anonymous/server.c;hb=HEAD">lib/anonymous/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_support_p
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/supportp.c;hb=HEAD">lib/src/supportp.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_print_server_final
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/printer.c;hb=HEAD">lib/scram/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_print_client_final
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/printer.c;hb=HEAD">lib/scram/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_print_server_first
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
17
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/printer.c;hb=HEAD">lib/scram/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_valid_server_final
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/validate.c;hb=HEAD">lib/scram/validate.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_server_start
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_number">
33
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_client_start
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_number">
30
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/client.c;hb=HEAD">lib/digest-md5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_client_start
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_number">
30
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_listmech
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_listmech
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_number">
26
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_init
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
21
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/init.c;hb=HEAD">lib/src/init.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
cram_md5_digest
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
19
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/digest.c;hb=HEAD">lib/cram-md5/digest.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_server_decode
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_server_encode
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_external_server_step
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
28
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/external/server.c;hb=HEAD">lib/external/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_client_decode
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/client.c;hb=HEAD">lib/digest-md5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_client_encode
</td>
<td class="function_entry_cyclo">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/client.c;hb=HEAD">lib/digest-md5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_external_client_step
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
19
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/external/client.c;hb=HEAD">lib/external/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_anonymous_client_step
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_number">
19
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/anonymous/client.c;hb=HEAD">lib/anonymous/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
main
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/tests/test-error.c;hb=HEAD">lib/tests/test-error.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_code
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xcode.c;hb=HEAD">lib/src/xcode.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_stringprep_trace
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_stringprep_saslprep
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_property_get
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/property.c;hb=HEAD">lib/src/property.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
hex_p
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_base64_from
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/base64.c;hb=HEAD">lib/src/base64.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_base64_to
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/base64.c;hb=HEAD">lib/src/base64.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_print_finish
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/printer.c;hb=HEAD">lib/digest-md5/printer.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_validate_finish
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
12
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/validate.c;hb=HEAD">lib/digest-md5/validate.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_check_version
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/version.c;hb=HEAD">lib/src/version.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_mechanism_name
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/mechname.c;hb=HEAD">lib/src/mechname.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_strerror_name
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/error.c;hb=HEAD">lib/src/error.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_start
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
cram_md5_challenge
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_number">
23
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/challenge.c;hb=HEAD">lib/cram-md5/challenge.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_start
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
start
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
24
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstart.c;hb=HEAD">lib/src/xstart.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_parse_finish
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_parse_response
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_parse_challenge
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
20
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/parser.c;hb=HEAD">lib/digest-md5/parser.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_decode_inline
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
21
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_encode_inline
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
21
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_set_hashed_secret
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_cram_md5_server_start
</td>
<td class="function_entry_cyclo">
3
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/server.c;hb=HEAD">lib/cram-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
map
</td>
<td class="function_entry_cyclo">
19
</td>
<td class="function_entry_number">
39
</td>
<td class="function_entry_number">
84
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/property.c;hb=HEAD">lib/src/property.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_free_challenge
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
12
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/free.c;hb=HEAD">lib/digest-md5/free.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_obsolete_property_map
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_ntlm_client_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/ntlm/ntlm.c;hb=HEAD">lib/ntlm/ntlm.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_login_client_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/client.c;hb=HEAD">lib/login/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_securid_client_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/securid/client.c;hb=HEAD">lib/securid/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_server_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_client_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/client.c;hb=HEAD">lib/digest-md5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_login_server_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_number">
13
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/server.c;hb=HEAD">lib/login/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_login_server_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_number">
12
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/server.c;hb=HEAD">lib/login/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_decode
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xcode.c;hb=HEAD">lib/src/xcode.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_encode
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xcode.c;hb=HEAD">lib/src/xcode.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_step
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstep.c;hb=HEAD">lib/src/xstep.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_hmac_md5
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_md5
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_property_fast
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/property.c;hb=HEAD">lib/src/property.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_hmac_sha1
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_sha1
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
sha1_hex_to_byte
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_login_client_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/login/client.c;hb=HEAD">lib/login/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_init
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_init
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_init
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_init
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_randomize
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_qop_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_anonymous_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_service_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_pin_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_passcode_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_password_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_authorization_id_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_authentication_id_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_service_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_gssapi_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_securid_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_cipher_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_maxbuf_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_qop_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_realm_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_anonymous_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_external_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_property_set
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/property.c;hb=HEAD">lib/src/property.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_cram_md5_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_retrieve_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_validate_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_realm_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_maxbuf_get
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_server_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
15
</td>
<td class="function_entry_number">
22
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/server.c;hb=HEAD">lib/scram/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_scram_sha1_client_finish
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/client.c;hb=HEAD">lib/scram/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_base64_decode
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_base64_encode
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_number">
19
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gs2_client_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gs2/client.c;hb=HEAD">lib/gs2/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_gssapi_client_start
</td>
<td class="function_entry_cyclo">
2
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_number">
18
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/gssapi/client.c;hb=HEAD">lib/gssapi/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/server.c;hb=HEAD">lib/kerberos_v5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_free_response
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
12
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/free.c;hb=HEAD">lib/digest-md5/free.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_server_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_number">
14
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_free_client_first
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/tokens.c;hb=HEAD">lib/scram/tokens.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_free_client_final
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
9
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/tokens.c;hb=HEAD">lib/scram/tokens.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/kerberos_v5.c;hb=HEAD">lib/kerberos_v5/kerberos_v5.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_kerberos_v5_client_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
4
</td>
<td class="function_entry_number">
10
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/kerberos_v5/client.c;hb=HEAD">lib/kerberos_v5/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_free_server_first
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
8
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/tokens.c;hb=HEAD">lib/scram/tokens.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_stringprep_nfkc
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
3
</td>
<td class="function_entry_number">
11
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_qops2qopstr
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
16
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/qop.c;hb=HEAD">lib/digest-md5/qop.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
scram_free_server_final
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/scram/tokens.c;hb=HEAD">lib/scram/tokens.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_ntlm_client_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/ntlm/ntlm.c;hb=HEAD">lib/ntlm/ntlm.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_securid_client_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/securid/client.c;hb=HEAD">lib/securid/client.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_cram_md5_server_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
2
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/cram-md5/server.c;hb=HEAD">lib/cram-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_maxbuf_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_qop_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_mechlist
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/listmech.c;hb=HEAD">lib/src/listmech.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_anonymous_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_service_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_pin_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_passcode_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_password_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_mechlist
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/listmech.c;hb=HEAD">lib/src/listmech.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_authorization_id_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_support_p
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/supportp.c;hb=HEAD">lib/src/supportp.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_authentication_id_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_suggest_mechanism
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
digest_md5_free_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/free.c;hb=HEAD">lib/digest-md5/free.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_appinfo_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_appinfo_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_application_data_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_application_data_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_random
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_support_p
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/supportp.c;hb=HEAD">lib/src/supportp.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_ctx_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_callback_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_application_data_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_free
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/free.c;hb=HEAD">lib/src/free.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_application_data_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_ctx_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_nonce
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/crypto.c;hb=HEAD">lib/src/crypto.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_application_data_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
to_uchar
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/nonascii.c;hb=HEAD">lib/digest-md5/nonascii.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_application_data_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_ctx_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_finish
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_step_base64
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_step_base64
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_step
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_session_hook_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_step
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
7
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_service_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_gssapi_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_securid_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_session_hook_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_cipher_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_maxbuf_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_qop_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_start
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstart.c;hb=HEAD">lib/src/xstart.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_realm_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_anonymous_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_callback_hook_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_external_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_digest_md5_get
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_digest_md5_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_start
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/xstart.c;hb=HEAD">lib/src/xstart.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_cram_md5_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_retrieve_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
_gsasl_digest_md5_hex_to_char
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/digest-md5/server.c;hb=HEAD">lib/digest-md5/server.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_server_callback_validate_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
6
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_callback_hook_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/callback.c;hb=HEAD">lib/src/callback.c</a>
</td>
</tr>
<tr class="function_entry_simple">
<td class="function_entry_filename">
&nbsp;
</td>
<td class="function_entry_name">
gsasl_client_callback_realm_set
</td>
<td class="function_entry_cyclo">
1
</td>
<td class="function_entry_number">
1
</td>
<td class="function_entry_number">
5
</td>
<td class="function_entry_filename">
<a href="http://git.savannah.gnu.org/gitweb/?p=gsasl.git;a=blob;f=lib/src/obsolete.c;hb=HEAD">lib/src/obsolete.c</a>
</td>
</tr>
</table>
<hr color="black" size="2"/> Copyright (c) 2007, 2008 Free Software Foundation, Inc.
</body>
</html>
