#! /bin/sh

# Copyright (c) 1999 University of Cambridge.
# See the file NOTICE for conditions of use and distribution.


# Shell script for cycling exim main and reject log files. Each time it is run,
# the files get "shuffled down" by one, the current one (e.g. mainlog) becoming
# mainlog.01, the previous mainlog.01 becoming mainlog.02, and so on, up to the
# limit configured here. The same happens to the reject logs. All those with
# numbers greater than 1 are compressed.

# This script should be called regularly (e.g. daily) by a root crontab
# entry of the form

# 1 0 * * *   /opt/exim/bin/exicyclog

# The following lines are generated from Exim's configuration file when
# this source is built into a script, but you can subsequently edit them
# without rebuilding things, as long are you are careful not to overwrite
# the script in the next Exim rebuild/install. "Keep" is the number of old log
# files that are required to be kept. "Compress" and "suffix" define your
# chosen compression method. The others are provided because the location
# of certain commands varies from OS to OS. Sigh.

keep=EXICYCLOG_MAX
compress=COMPRESS_COMMAND
suffix=COMPRESS_SUFFIX

chown=CHOWN_COMMAND
chgrp=CHGRP_COMMAND
mv=MV_COMMAND
rm=RM_COMMAND

# End of editable lines
#########################################################################


# See if this installation is using the esoteric "USE_NODE" feature of Exim,
# in which it uses the host's name as a suffix for the configuration file name.
# Set $hostsuffix if a suffixed file is found.

configure_file_use_node=CONFIGURE_FILE_USE_NODE
if [ "$configure_file_use_node" = "yes" ]; then
  host=`uname -n`
  if [ ! "$host" != "" ]; then
      if [ -f CONFIGURE_FILE.$host ]; then
          hostsuffix=.$host
      fi
  fi
fi

# Set the configuration file name

config=CONFIGURE_FILE$hostsuffix

# Determine if the log file path is set, and where the spool directory is. The
# strings CONFIGURE_FILE and BIN_DIRECTORY below are replaced by their compile-
# time settings when this source is build into a script. Search for an
# exim_path setting in the configure file; otherwise use the bin directory.
# Call that version of Exim to find the spool directory and log file path.

exim_path=`grep '^[	 ]*exim_path' $config | sed 's/.*=[	  ]*//'`
if test "$exim_path" = ""; then exim_path=BIN_DIRECTORY/exim; fi

spool_directory=`$exim_path -C $config -bP spool_directory | sed 's/.*=[  ]*//'`
log_file_path=`$exim_path -C $config -bP log_file_path | sed 's/.*=[  ]*//'`

# If log_file_path contains only "syslog" then no Exim log files are in use.
# We can't cycle anything. Complain and give up.

if [ "$log_file_path" = "syslog" ] ; then
  echo "*** Exim is logging to syslog - no log files to cycle ***"
  exit 1
fi

# Otherwise, remove ":syslog" or "syslog:" (some spaces allowed) and inspect
# what remains. The simplistic regex originally used failed when a filename
# contained "syslog", so we have to use three less general ones, because sed
# doesn't have much power in its regexs.

log_file_path=`echo "$log_file_path" | \
  sed 's/^ *:\{0,1\} *syslog *:\{0,1\} *//;s/: *syslog *:/:/;s/: *syslog *$//'`

# If log_file_path is empty, then the logs we are interested in are called
# "mainlog" and "rejectlog" in the directory called "log" in the spool
# directory. Otherwise we fish out the directory from the given path, and
# also the names of the logs.

if [ "$log_file_path" = "" ]; then
  logdir=$spool_directory/log
  mainlog=mainlog
  rejectlog=rejectlog
else
  logdir=`echo $log_file_path | sed 's?/[^/]*$??'`
  logbase=`echo $log_file_path | sed 's?^.*/??'`
  mainlog=`echo $logbase | sed 's/%s/main/'`
  rejectlog=`echo $logbase | sed 's/%s/reject/'`
fi

# Get into the log directory to do the business.

cd $logdir

# If there is no main log file, do nothing.

if [ ! -f $mainlog ]; then exit; fi

# Find out the owner and group of the main log file so that we can re-instate
# this on moved and compressed files, since some operating systems may change
# things. This is a tedious bit of code, but it should work both in operating
# systems where the -l option of ls gives the user and group, and those in which
# you need -lg. The condition is that, if the fifth field of the output from
# ls consists entirely of digits, then the third and fourth fields are the user
# and group.

a=`ls -lg $mainlog`
b=`ls -l  $mainlog`

# These statements work fine in the Bourne or Korn shells, but not in Bash.
# So for the benefit of systems whose /bin/sh is really Bash, they have been
# changed to a messier form.

# user=`echo "$a\n$b\n" | awk 'BEGIN { OFS=""} { if ($5 ~ /^[0-9]+$/) print $3; }'`
# group=`echo "$a\n$b\n" | awk 'BEGIN { OFS=""} { if ($5 ~ /^[0-9]+$/) print $4; }'`

user=`echo "$a
$b
" | awk 'BEGIN { OFS=""} { if ($5 ~ /^[0-9]+$/) { print $3; exit; } }'`

group=`echo "$a
$b
" | awk 'BEGIN { OFS=""} { if ($5 ~ /^[0-9]+$/) { print $4; exit; } }'`

# Now do the job. Originally the files were numbered 1, 2, etc., but it was
# pointed out that using 01, 02, etc. would be better. So that things continue
# to work, we first of all rename any files we find that have old names. This
# code was written in February 1998. It can be removed at some point in the
# future. Say around the millennium. To save running this pointlessly again
# and again, predicate it on the existence of mainlog.1.

if [ -f $mainlog.1 ]; then
  count=9
  while [ $count -gt 0 ]; do
    if [ -f $mainlog.$count ]; then
      $mv $mainlog.$count $mainlog.0$count;
    fi;
    if [ -f $mainlog.$count.$suffix ]; then
      $mv $mainlog.$count.$suffix $mainlog.0$count.$suffix;
    fi;
    if [ -f $rejectlog.$count ]; then
      $mv $rejectlog.$count $rejectlog.0$count;
    fi;
    if [ -f $rejectlog.$count.$suffix ]; then
      $mv $rejectlog.$count.$suffix $rejectlog.0$count.$suffix;
    fi;
    count=`expr $count - 1`
  done
fi

# Now operate on the new style of name only.

if [ $keep -lt 10 ]; then keept=0$keep; else keept=$keep; fi;

if [ -f $mainlog.$keept ]; then $rm $mainlog.$keept; fi;
if [ -f $mainlog.$keept.$suffix ]; then $rm $mainlog.$keept.$suffix; fi;

if [ -f $rejectlog.$keept ]; then $rm $rejectlog.$keept; fi;
if [ -f $rejectlog.$keept.$suffix ]; then $rm $rejectlog.$keept.$suffix; fi;

while [ $keep -gt 1 ]; do
  old=`expr $keep - 1`
  if [ $old -lt 10 ]; then oldt=0$old; else oldt=$old; fi;
  if [ -f $mainlog.$oldt ]; then
    $mv $mainlog.$oldt $mainlog.$keept
    $compress $mainlog.$keept
    $chown $user $mainlog.$keept.$suffix
    $chgrp $group $mainlog.$keept.$suffix
  elif [ -f $mainlog.$oldt.$suffix ]; then
    $mv $mainlog.$oldt.$suffix $mainlog.$keept.$suffix
    $chown $user $mainlog.$keept.$suffix
    $chgrp $group $mainlog.$keept.$suffix
  fi
  if [ -f $rejectlog.$oldt ]; then
    $mv $rejectlog.$oldt $rejectlog.$keept
    $compress $rejectlog.$keept
    $chown $user $rejectlog.$keept.$suffix
    $chgrp $group $rejectlog.$keept.$suffix
  elif [ -f $rejectlog.$oldt.$suffix ]; then
    $mv $rejectlog.$oldt.$suffix $rejectlog.$keept.$suffix
    $chown $user $rejectlog.$keept.$suffix
    $chgrp $group $rejectlog.$keept.$suffix
  fi
  keep=$old
  keept=$oldt
done

if [ -f $mainlog ]; then
  $mv $mainlog $mainlog.01
  $chown $user $mainlog.01
  $chgrp $group $mainlog.01
fi

if [ -f $rejectlog ]; then
  $mv $rejectlog $rejectlog.01
  $chown $user $rejectlog.01
  $chgrp $group $rejectlog.01
fi

# End of exicyclog
