Description: top: avoid name conflict in the next version of stdlib
 Since its inception top has always used enumerators to
 identify displayable fields. They've taken the form of
 P_PID, etc. As it turns out, something has changed for
 libc6-dev versions beyond 2.17-93 wherein 'P_PID' will
 now be exposed via stdlib.h. I have not pinpointed the
 exact cause but it may depend on header include order.
 .
 This patch just trades top's long standing 'P_' prefix
 convention for that of 'EU_' (short for enumerator). I
 cannot find *any* header under /usr/include/ currently
 utilizing this particular three character combination.
 .
 And as a further safeguard top will henceforth include
 'system' specific headers after the standard includes.
Reference(s):
 http://www.freelists.org/post/procps/top-wont-compile-anymore
Signed-off-by: Jim Warner <james.warner@comcast.net>
--- a/top/top.c
+++ b/top/top.c
@@ -18,12 +18,6 @@
  *    Sami Kerola, <kerolasa@iki.fi>
  */
 
-#include <sys/ioctl.h>
-#include <sys/resource.h>
-#include <sys/select.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
 #include <ctype.h>
 #include <curses.h>
 #ifndef NUMA_DISABLE
@@ -37,7 +31,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <term.h>       // foul sob, defines all sorts of stuff...
+#include <term.h>            // foul sob, defines all sorts of stuff...
 #undef    tab
 #undef    TTY
 #include <termios.h>
@@ -45,6 +39,12 @@
 #include <unistd.h>
 #include <values.h>
 
+#include <sys/ioctl.h>
+#include <sys/resource.h>
+#include <sys/select.h>      // also available via <sys/types.h>
+#include <sys/time.h>
+#include <sys/types.h>       // also available via <stdlib.h>
+
 #include "../include/fileutils.h"
 #include "../include/nls.h"
 
@@ -201,10 +201,10 @@
 
         /* Support for automatically sized fixed-width column expansions.
          * (hopefully, the macros help clarify/document our new 'feature') */
-static int Autox_array [P_MAXPFLGS],
+static int Autox_array [EU_MAXPFLGS],
            Autox_found;
-#define AUTOX_NO      P_MAXPFLGS
-#define AUTOX_COL(f)  if (P_MAXPFLGS > f) Autox_array[f] = Autox_found = 1
+#define AUTOX_NO      EU_MAXPFLGS
+#define AUTOX_COL(f)  if (EU_MAXPFLGS > f) Autox_array[f] = Autox_found = 1
 #define AUTOX_MODE   (0 > Rc.fixed_widest)
 
         /* Support for scale_mem and scale_num (to avoid duplication. */
@@ -1673,9 +1673,9 @@
         a -1 width represents variable width columns
         a  0 width represents columns set once at startup (see zap_fieldstab)
    .lflg anomalies:
-        P_UED, L_NONE  - natural outgrowth of 'stat()' in readproc        (euid)
-        P_CPU, L_stat  - never filled by libproc, but requires times      (pcpu)
-        P_CMD, L_stat  - may yet require L_CMDLINE in calibrate_fields    (cmd/cmdline)
+        EU_UED, L_NONE - natural outgrowth of 'stat()' in readproc        (euid)
+        EU_CPU, L_stat - never filled by libproc, but requires times      (pcpu)
+        EU_CMD, L_stat - may yet require L_CMDLINE in calibrate_fields    (cmd/cmdline)
         L_EITHER       - must L_status, else L_stat == 64-bit math (__udivdi3) on 32-bit !
 
      .width  .scale  .align    .sort     .lflg
@@ -1700,11 +1700,11 @@
    {     0,     -1,  A_right,  SF(CPN),  L_stat    },
    {     0,     -1,  A_right,  SF(CPU),  L_stat    },
    {     6,     -1,  A_right,  SF(TME),  L_stat    },
-   {     9,     -1,  A_right,  SF(TME),  L_stat    }, // P_TM2 slot
+   {     9,     -1,  A_right,  SF(TME),  L_stat    }, // EU_TM2 slot
 #ifdef BOOST_PERCNT
-   {     5,     -1,  A_right,  SF(RES),  L_statm   }, // P_MEM slot
+   {     5,     -1,  A_right,  SF(RES),  L_statm   }, // EU_MEM slot
 #else
-   {     4,     -1,  A_right,  SF(RES),  L_statm   }, // P_MEM slot
+   {     4,     -1,  A_right,  SF(RES),  L_statm   }, // EU_MEM slot
 #endif
 #ifndef NOBOOST_MEMS
    {     7,  SK_Kb,  A_right,  SF(VRT),  L_statm   },
@@ -1864,10 +1864,10 @@
                w->hdrcaplen += strlen(Caps_off) + strlen(w->capclr_msg);
             }
 #else
-            if (P_MAXPFLGS <= f) continue;
+            if (EU_MAXPFLGS <= f) continue;
 #endif
-            if (P_WCH == f) needpsdb = 1;
-            if (P_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
+            if (EU_WCH == f) needpsdb = 1;
+            if (EU_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
             Frames_libflags |= Fieldstab[w->procflgs[i]].lflg;
             s = scat(s, justify_pad(N_col(f)
                , VARcol(f) ? w->varcolsz : Fieldstab[f].width
@@ -1890,7 +1890,7 @@
          // we must also accommodate an out of view sort field...
          f = w->rc.sortindx;
          Frames_libflags |= Fieldstab[f].lflg;
-         if (P_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
+         if (EU_CMD == f && CHKw(w, Show_CMDLIN)) Frames_libflags |= L_CMDLINE;
       } // end: VIZISw(w)
 
       if (Rc.mode_altscr) w = w->next;
@@ -1943,16 +1943,16 @@
       if (VIZISw(w)) {
          w->hdrcaplen = 0;   // really only used with USE_X_COLHDR
          // build window's pflgsall array, establish upper bounds for maxpflgs
-         for (i = 0, w->totpflgs = 0; i < P_MAXPFLGS; i++) {
+         for (i = 0, w->totpflgs = 0; i < EU_MAXPFLGS; i++) {
             if (FLDviz(w, i)) {
                f = FLDget(w, i);
 #ifdef USE_X_COLHDR
                w->pflgsall[w->totpflgs++] = f;
 #else
                if (CHKw(w, Show_HICOLS) && f == w->rc.sortindx) {
-                  w->pflgsall[w->totpflgs++] = X_XON;
+                  w->pflgsall[w->totpflgs++] = EU_XON;
                   w->pflgsall[w->totpflgs++] = f;
-                  w->pflgsall[w->totpflgs++] = X_XOF;
+                  w->pflgsall[w->totpflgs++] = EU_XOF;
                } else
                   w->pflgsall[w->totpflgs++] = f;
 #endif
@@ -1968,7 +1968,7 @@
             f = w->pflgsall[i + w->begpflg];
             w->procflgs[i] = f;
 #ifndef USE_X_COLHDR
-            if (P_MAXPFLGS <= f) continue;
+            if (EU_MAXPFLGS <= f) continue;
 #endif
             h = N_col(f);
             len = (VARcol(f) ? (int)strlen(h) : Fieldstab[f].width) + COLPADSIZ;
@@ -1978,7 +1978,7 @@
             s = scat(s, fmtmk("%*.*s", len, len, h));
          }
 #ifndef USE_X_COLHDR
-         if (X_XON == w->procflgs[i - 1]) --i;
+         if (EU_XON == w->procflgs[i - 1]) --i;
 #endif
 
          /* establish the final maxpflgs and prepare to grow the variable column
@@ -1995,7 +1995,7 @@
          for (i = w->totpflgs - 1; -1 < i; i--) {
             f = w->pflgsall[i];
 #ifndef USE_X_COLHDR
-            if (P_MAXPFLGS <= f) { w->endpflg = i; continue; }
+            if (EU_MAXPFLGS <= f) { w->endpflg = i; continue; }
 #endif
             h = N_col(f);
             len = (VARcol(f) ? (int)strlen(h) : Fieldstab[f].width) + COLPADSIZ;
@@ -2004,7 +2004,7 @@
             w->endpflg = i;
          }
 #ifndef USE_X_COLHDR
-         if (X_XOF == w->pflgsall[w->endpflg]) ++w->endpflg;
+         if (EU_XOF == w->pflgsall[w->endpflg]) ++w->endpflg;
 #endif
       } // end: if (VIZISw(w))
 
@@ -2061,10 +2061,10 @@
    int rmax = Screen_rows - yRSVD;     // total useable rows
    static int col_sav, row_sav;
 
-   i = (P_MAXPFLGS % mxCOL) ? 1 : 0;
-   if (rmax < i + (P_MAXPFLGS / mxCOL)) mkERR;
-   i = P_MAXPFLGS / rmax;
-   if (P_MAXPFLGS % rmax) ++i;
+   i = (EU_MAXPFLGS % mxCOL) ? 1 : 0;
+   if (rmax < i + (EU_MAXPFLGS / mxCOL)) mkERR;
+   i = EU_MAXPFLGS / rmax;
+   if (EU_MAXPFLGS % rmax) ++i;
    if (i > 1) { cmax /= i; xadd = 1; }
    if (cmax > xTOTL) cmax = xTOTL;
    smax = cmax - xPRFX;
@@ -2079,7 +2079,7 @@
    }
    fflush(stdout);
 
-   for (i = 0; i < P_MAXPFLGS; ++i) {
+   for (i = 0; i < EU_MAXPFLGS; ++i) {
       int b = FLDviz(w, i), x = (i / rmax) * cmax, y = (i % rmax) + yRSVD;
       const char *e = (i == focus && extend) ? w->capclr_hdr : "";
       FLG_t f = FLDget(w, i);
@@ -2154,7 +2154,7 @@
             if (i > 0) { --i; if (p) swapEM }
             break;
          case kbd_DOWN:
-            if (i + 1 < P_MAXPFLGS) { ++i; if (p) swapEM }
+            if (i + 1 < EU_MAXPFLGS) { ++i; if (p) swapEM }
             break;
          case kbd_LEFT:
          case kbd_ENTER:
@@ -2169,7 +2169,7 @@
             break;
          case kbd_END:
          case kbd_PGDN:
-            if (!p) i = P_MAXPFLGS - 1;
+            if (!p) i = EU_MAXPFLGS - 1;
             break;
          case kbd_SPACE:
          case 'd':
@@ -2207,7 +2207,7 @@
 
    // next var may also be set by the guys that actually truncate stuff
    Autox_found = 0;
-   for (i = 0; i < P_MAXPFLGS; i++) {
+   for (i = 0; i < EU_MAXPFLGS; i++) {
       if (Autox_array[i]) {
          Fieldstab[i].width++;
          Autox_array[i] = 0;
@@ -2227,29 +2227,29 @@
    char buf[8];
 
    if (!once) {
-      Fieldstab[P_PID].width = Fieldstab[P_PPD].width
-         = Fieldstab[P_PGD].width = Fieldstab[P_SID].width
-         = Fieldstab[P_TGD].width = Fieldstab[P_TPG].width = 5;
+      Fieldstab[EU_PID].width = Fieldstab[EU_PPD].width
+         = Fieldstab[EU_PGD].width = Fieldstab[EU_SID].width
+         = Fieldstab[EU_TGD].width = Fieldstab[EU_TPG].width = 5;
       if (5 < (digits = get_pid_digits())) {
          if (10 < digits) error_exit(N_txt(FAIL_widepid_txt));
-         Fieldstab[P_PID].width = Fieldstab[P_PPD].width
-            = Fieldstab[P_PGD].width = Fieldstab[P_SID].width
-            = Fieldstab[P_TGD].width = Fieldstab[P_TPG].width = digits;
+         Fieldstab[EU_PID].width = Fieldstab[EU_PPD].width
+            = Fieldstab[EU_PGD].width = Fieldstab[EU_SID].width
+            = Fieldstab[EU_TGD].width = Fieldstab[EU_TPG].width = digits;
       }
       once = 1;
    }
 
    /*** hotplug_acclimated ***/
 
-   Fieldstab[P_CPN].width = 1;
+   Fieldstab[EU_CPN].width = 1;
    if (1 < (digits = (unsigned)snprintf(buf, sizeof(buf), "%u", (unsigned)smp_num_cpus))) {
       if (5 < digits) error_exit(N_txt(FAIL_widecpu_txt));
-      Fieldstab[P_CPN].width = digits;
+      Fieldstab[EU_CPN].width = digits;
    }
 
 #ifdef BOOST_PERCNT
    Cpu_pmax = 99.9;
-   Fieldstab[P_CPU].width = 5;
+   Fieldstab[EU_CPU].width = 5;
    if (Rc.mode_irixps && smp_num_cpus > 1 && !Thread_mode) {
       Cpu_pmax = 100.0 * smp_num_cpus;
       if (smp_num_cpus > 10) {
@@ -2260,7 +2260,7 @@
    }
 #else
    Cpu_pmax = 99.9;
-   Fieldstab[P_CPU].width = 4;
+   Fieldstab[EU_CPU].width = 4;
    if (Rc.mode_irixps && smp_num_cpus > 1 && !Thread_mode) {
       Cpu_pmax = 100.0 * smp_num_cpus;
       if (smp_num_cpus > 10) {
@@ -2268,33 +2268,33 @@
       } else {
          if (Cpu_pmax > 999.9) Cpu_pmax = 999.9;
       }
-      Fieldstab[P_CPU].width = 5;
+      Fieldstab[EU_CPU].width = 5;
    }
 #endif
 
    /* and accommodate optional wider non-scalable columns (maybe) */
    if (!AUTOX_MODE) {
       int i;
-      Fieldstab[P_UED].width = Fieldstab[P_URD].width
-         = Fieldstab[P_USD].width = Fieldstab[P_GID].width
+      Fieldstab[EU_UED].width = Fieldstab[EU_URD].width
+         = Fieldstab[EU_USD].width = Fieldstab[EU_GID].width
          = Rc.fixed_widest ? 5 + Rc.fixed_widest : 5;
-      Fieldstab[P_UEN].width = Fieldstab[P_URN].width
-         = Fieldstab[P_USN].width = Fieldstab[P_GRP].width
+      Fieldstab[EU_UEN].width = Fieldstab[EU_URN].width
+         = Fieldstab[EU_USN].width = Fieldstab[EU_GRP].width
          = Rc.fixed_widest ? 8 + Rc.fixed_widest : 8;
-      Fieldstab[P_TTY].width
+      Fieldstab[EU_TTY].width
          = Rc.fixed_widest ? 8 + Rc.fixed_widest : 8;
-      Fieldstab[P_WCH].width
+      Fieldstab[EU_WCH].width
          = Rc.fixed_widest ? 10 + Rc.fixed_widest : 10;
-      for (i = P_NS1; i < P_NS1 + NUM_NS; i++)
+      for (i = EU_NS1; i < EU_NS1 + NUM_NS; i++)
          Fieldstab[i].width
             = Rc.fixed_widest ? 10 + Rc.fixed_widest : 10;
    }
 
    /* plus user selectable scaling */
-   Fieldstab[P_VRT].scale = Fieldstab[P_SWP].scale
-      = Fieldstab[P_RES].scale = Fieldstab[P_COD].scale
-      = Fieldstab[P_DAT].scale = Fieldstab[P_SHR].scale
-      = Fieldstab[P_USE].scale = Rc.task_mscale;
+   Fieldstab[EU_VRT].scale = Fieldstab[EU_SWP].scale
+      = Fieldstab[EU_RES].scale = Fieldstab[EU_COD].scale
+      = Fieldstab[EU_DAT].scale = Fieldstab[EU_SHR].scale
+      = Fieldstab[EU_USE].scale = Rc.task_mscale;
 
    // lastly, ensure we've got proper column headers...
    calibrate_fields();
@@ -3473,8 +3473,8 @@
             default:                           // and future versions?
                if (strlen(w->rc.fieldscur) != sizeof(DEF_FIELDS) - 1)
                   goto default_or_error;
-               for (x = 0; x < P_MAXPFLGS; ++x)
-                  if (P_MAXPFLGS <= FLDget(w, x))
+               for (x = 0; x < EU_MAXPFLGS; ++x)
+                  if (EU_MAXPFLGS <= FLDget(w, x))
                      goto default_or_error;
                break;
          }
@@ -3653,16 +3653,16 @@
                else error_exit(fmtmk(N_fmt(MISSING_args_fmt), ch));
                if (*cp == '+') { SETw(Curwin, Qsrt_NORMAL); ++cp; }
                else if (*cp == '-') { OFFw(Curwin, Qsrt_NORMAL); ++cp; }
-               for (i = 0; i < P_MAXPFLGS; i++)
+               for (i = 0; i < EU_MAXPFLGS; i++)
                   if (!STRCMP(cp, N_col(i))) break;
-               if (i == P_MAXPFLGS)
+               if (i == EU_MAXPFLGS)
                   error_exit(fmtmk(N_fmt(XTRA_badflds_fmt), cp));
                OFFw(Curwin, Show_FOREST);
                Curwin->rc.sortindx = i;
                cp += strlen(cp);
                break;
             case 'O':
-               for (i = 0; i < P_MAXPFLGS; i++)
+               for (i = 0; i < EU_MAXPFLGS; i++)
                   puts(N_col(i));
                bye_bye(NULL);
             case 'p':
@@ -4226,9 +4226,9 @@
    }
    ops = *(pval);
    *(pval++) = '\0';
-   for (enu = 0; enu < P_MAXPFLGS; enu++)      // #4: is this a valid field?
+   for (enu = 0; enu < EU_MAXPFLGS; enu++)     // #4: is this a valid field?
       if (!STRCMP(N_col(enu), glob)) break;
-   if (enu == P_MAXPFLGS) {
+   if (enu == EU_MAXPFLGS) {
       show_msg(fmtmk(N_fmt(XTRA_badflds_fmt), glob));
       return;
    }
@@ -4503,7 +4503,7 @@
             if (*p == w->rc.sortindx) {
                --p;
 #ifndef USE_X_COLHDR
-               if (P_MAXPFLGS < *p) --p;
+               if (EU_MAXPFLGS < *p) --p;
 #endif
                if (p >= w->procflgs) {
                   w->rc.sortindx = *p;
@@ -4524,7 +4524,7 @@
             if (*p == w->rc.sortindx) {
                ++p;
 #ifndef USE_X_COLHDR
-               if (P_MAXPFLGS < *p) ++p;
+               if (EU_MAXPFLGS < *p) ++p;
 #endif
                if (p < w->procflgs + w->maxpflgs) {
                   w->rc.sortindx = *p;
@@ -4593,7 +4593,7 @@
       case 'V':
          if (VIZCHKw(w)) {
             TOGw(w, Show_FOREST);
-            if (!ENUviz(w, P_CMD))
+            if (!ENUviz(w, EU_CMD))
                show_msg(fmtmk(N_fmt(FOREST_modes_fmt) , CHKw(w, Show_FOREST)
                   ? N_txt(ON_word_only_txt) : N_txt(OFF_one_word_txt)));
          }
@@ -4713,13 +4713,13 @@
                w->varcolbeg -= SCROLLAMT;
             else if (0 < w->begpflg) {
                w->begpflg -= 1;
-               if (P_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;
+               if (EU_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;
             }
          }
 #else
          if (VIZCHKw(w)) if (0 < w->begpflg) {
             w->begpflg -= 1;
-            if (P_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;
+            if (EU_MAXPFLGS < w->pflgsall[w->begpflg]) w->begpflg -= 2;
          }
 #endif
          break;
@@ -4730,14 +4730,14 @@
                w->varcolbeg += SCROLLAMT;
                if (0 > w->varcolbeg) w->varcolbeg = 0;
             } else if (w->begpflg + 1 < w->totpflgs) {
-               if (P_MAXPFLGS < w->pflgsall[w->begpflg])
+               if (EU_MAXPFLGS < w->pflgsall[w->begpflg])
                   w->begpflg += (w->begpflg + 3 < w->totpflgs) ? 3 : 0;
                else w->begpflg += 1;
             }
          }
 #else
          if (VIZCHKw(w)) if (w->begpflg + 1 < w->totpflgs) {
-            if (P_MAXPFLGS < w->pflgsall[w->begpflg])
+            if (EU_MAXPFLGS < w->pflgsall[w->begpflg])
                w->begpflg += (w->begpflg + 3 < w->totpflgs) ? 3 : 0;
             else w->begpflg += 1;
          }
@@ -4794,19 +4794,19 @@
       we would just whack do_key's key_tab entry and this function... */
    switch (ch) {
       case 'M':
-         w->rc.sortindx = P_MEM;
+         w->rc.sortindx = EU_MEM;
 //       xmsg = "Memory";
          break;
       case 'N':
-         w->rc.sortindx = P_PID;
+         w->rc.sortindx = EU_PID;
 //       xmsg = "Numerical";
          break;
       case 'P':
-         w->rc.sortindx = P_CPU;
+         w->rc.sortindx = EU_CPU;
 //       xmsg = "CPU";
          break;
       case 'T':
-         w->rc.sortindx = P_TM2;
+         w->rc.sortindx = EU_TM2;
 //       xmsg = "Time";
          break;
       default:                    // keep gcc happy
@@ -5179,30 +5179,30 @@
       switch (i) {
 #ifndef USE_X_COLHDR
          // these 2 aren't real procflgs, they're used in column highlighting!
-         case X_XON:
-         case X_XOF:
+         case EU_XON:
+         case EU_XOF:
             cp = NULL;
             if (!CHKw(q, INFINDS_xxx | NOHIFND_xxx | NOHISEL_xxx)) {
                /* treat running tasks specially - entire row may get highlighted
                   so we needn't turn it on and we MUST NOT turn it off */
                if (!('R' == p->state && CHKw(q, Show_HIROWS)))
-                  cp = (X_XON == i ? q->capclr_rowhigh : q->capclr_rownorm);
+                  cp = (EU_XON == i ? q->capclr_rowhigh : q->capclr_rownorm);
             }
             break;
 #endif
-         case P_CGR:
+         case EU_CGR:
             makeVAR(p->cgroup[0]);
             break;
-         case P_CMD:
+         case EU_CMD:
             makeVAR(forest_display(q, p));
             break;
-         case P_COD:
+         case EU_COD:
             cp = scale_mem(S, pages2K(p->trs), W, Jn);
             break;
-         case P_CPN:
+         case EU_CPN:
             cp = make_num(p->processor, W, Jn, AUTOX_NO);
             break;
-         case P_CPU:
+         case EU_CPU:
          {  float u = (float)p->pcpu * Frame_etscale;
             /* process can't use more %cpu than number of threads it has
              ( thanks Jaromir Capik <jcapik@redhat.com> ) */
@@ -5211,150 +5211,150 @@
             cp = scale_pcnt(u, W, Jn);
          }
             break;
-         case P_DAT:
+         case EU_DAT:
             cp = scale_mem(S, pages2K(p->drs), W, Jn);
             break;
-         case P_DRT:
+         case EU_DRT:
             cp = scale_num(p->dt, W, Jn);
             break;
-         case P_ENV:
+         case EU_ENV:
             makeVAR(p->environ[0]);
             break;
-         case P_FL1:
+         case EU_FL1:
             cp = scale_num(p->maj_flt, W, Jn);
             break;
-         case P_FL2:
+         case EU_FL2:
             cp = scale_num(p->min_flt, W, Jn);
             break;
-         case P_FLG:
+         case EU_FLG:
             cp = make_str(hex_make(p->flags, 1), W, Js, AUTOX_NO);
             break;
-         case P_FV1:
+         case EU_FV1:
             cp = scale_num(p->maj_delta, W, Jn);
             break;
-         case P_FV2:
+         case EU_FV2:
             cp = scale_num(p->min_delta, W, Jn);
             break;
-         case P_GID:
-            cp = make_num(p->egid, W, Jn, P_GID);
+         case EU_GID:
+            cp = make_num(p->egid, W, Jn, EU_GID);
             break;
-         case P_GRP:
-            cp = make_str(p->egroup, W, Js, P_GRP);
+         case EU_GRP:
+            cp = make_str(p->egroup, W, Js, EU_GRP);
             break;
-         case P_MEM:
+         case EU_MEM:
             cp = scale_pcnt((float)pages2K(p->resident) * 100 / kb_main_total, W, Jn);
             break;
-         case P_NCE:
+         case EU_NCE:
             cp = make_num(p->nice, W, Jn, AUTOX_NO);
             break;
-         case P_NS1:   // IPCNS
-         case P_NS2:   // MNTNS
-         case P_NS3:   // NETNS
-         case P_NS4:   // PIDNS
-         case P_NS5:   // USERNS
-         case P_NS6:   // UTSNS
-         {  long ino = p->ns[i - P_NS1];
+         case EU_NS1:  // IPCNS
+         case EU_NS2:  // MNTNS
+         case EU_NS3:  // NETNS
+         case EU_NS4:  // PIDNS
+         case EU_NS5:  // USERNS
+         case EU_NS6:  // UTSNS
+         {  long ino = p->ns[i - EU_NS1];
             if (ino > 0) cp = make_num(ino, W, Jn, i);
             else cp = make_str("-", W, Js, i);
          }
             break;
 #ifdef OOMEM_ENABLE
-         case P_OOA:
+         case EU_OOA:
             cp = make_num(p->oom_adj, W, Jn, AUTOX_NO);
             break;
-         case P_OOM:
+         case EU_OOM:
             cp = make_num(p->oom_score, W, Jn, AUTOX_NO);
             break;
 #endif
-         case P_PGD:
+         case EU_PGD:
             cp = make_num(p->pgrp, W, Jn, AUTOX_NO);
             break;
-         case P_PID:
+         case EU_PID:
             cp = make_num(p->tid, W, Jn, AUTOX_NO);
             break;
-         case P_PPD:
+         case EU_PPD:
             cp = make_num(p->ppid, W, Jn, AUTOX_NO);
             break;
-         case P_PRI:
+         case EU_PRI:
             if (-99 > p->priority || 999 < p->priority) {
                cp = make_str("rt", W, Jn, AUTOX_NO);
             } else
                cp = make_num(p->priority, W, Jn, AUTOX_NO);
             break;
-         case P_RES:
+         case EU_RES:
             cp = scale_mem(S, pages2K(p->resident), W, Jn);
             break;
-         case P_SGD:
+         case EU_SGD:
             makeVAR(p->supgid);
             break;
-         case P_SGN:
+         case EU_SGN:
             makeVAR(p->supgrp);
             break;
-         case P_SHR:
+         case EU_SHR:
             cp = scale_mem(S, pages2K(p->share), W, Jn);
             break;
-         case P_SID:
+         case EU_SID:
             cp = make_num(p->session, W, Jn, AUTOX_NO);
             break;
-         case P_STA:
+         case EU_STA:
             cp = make_chr(p->state, W, Js);
             break;
-         case P_SWP:
+         case EU_SWP:
             cp = scale_mem(S, p->vm_swap, W, Jn);
             break;
-         case P_TGD:
+         case EU_TGD:
             cp = make_num(p->tgid, W, Jn, AUTOX_NO);
             break;
-         case P_THD:
+         case EU_THD:
             cp = make_num(p->nlwp, W, Jn, AUTOX_NO);
             break;
-         case P_TM2:
-         case P_TME:
+         case EU_TM2:
+         case EU_TME:
          {  TIC_t t = p->utime + p->stime;
             if (CHKw(q, Show_CTIMES)) t += (p->cutime + p->cstime);
             cp = scale_tics(t, W, Jn);
          }
             break;
-         case P_TPG:
+         case EU_TPG:
             cp = make_num(p->tpgid, W, Jn, AUTOX_NO);
             break;
-         case P_TTY:
+         case EU_TTY:
          {  char tmp[SMLBUFSIZ];
             dev_to_tty(tmp, W, p->tty, p->tid, ABBREV_DEV);
-            cp = make_str(tmp, W, Js, P_TTY);
+            cp = make_str(tmp, W, Js, EU_TTY);
          }
             break;
-         case P_UED:
-            cp = make_num(p->euid, W, Jn, P_UED);
+         case EU_UED:
+            cp = make_num(p->euid, W, Jn, EU_UED);
             break;
-         case P_UEN:
-            cp = make_str(p->euser, W, Js, P_UEN);
+         case EU_UEN:
+            cp = make_str(p->euser, W, Js, EU_UEN);
             break;
-         case P_URD:
-            cp = make_num(p->ruid, W, Jn, P_URD);
+         case EU_URD:
+            cp = make_num(p->ruid, W, Jn, EU_URD);
             break;
-         case P_URN:
-            cp = make_str(p->ruser, W, Js, P_URN);
+         case EU_URN:
+            cp = make_str(p->ruser, W, Js, EU_URN);
             break;
-         case P_USD:
-            cp = make_num(p->suid, W, Jn, P_USD);
+         case EU_USD:
+            cp = make_num(p->suid, W, Jn, EU_USD);
             break;
-         case P_USE:
+         case EU_USE:
             cp = scale_mem(S, (p->vm_swap + pages2K(p->resident)), W, Jn);
             break;
-         case P_USN:
-            cp = make_str(p->suser, W, Js, P_USN);
+         case EU_USN:
+            cp = make_str(p->suser, W, Js, EU_USN);
             break;
-         case P_VRT:
+         case EU_VRT:
             cp = scale_mem(S, pages2K(p->size), W, Jn);
             break;
-         case P_WCH:
+         case EU_WCH:
          {  const char *u;
             if (No_ksyms)
                u = hex_make(p->wchan, 0);
             else
                u = lookup_wchan(p->wchan, p->tid);
-            cp = make_str(u, W, Js, P_WCH);
+            cp = make_str(u, W, Js, EU_WCH);
          }
             break;
          default:                 // keep gcc happy
--- a/top/top.h
+++ b/top/top.h
@@ -179,28 +179,28 @@
         /* Flags for each possible field (and then some) --
            these MUST be kept in sync with the FLD_t Fieldstab[] array !! */
 enum pflag {
-   P_PID = 0, P_PPD,
-   P_UED, P_UEN, P_URD, P_URN, P_USD, P_USN,
-   P_GID, P_GRP, P_PGD, P_TTY, P_TPG, P_SID,
-   P_PRI, P_NCE, P_THD,
-   P_CPN, P_CPU, P_TME, P_TM2,
-   P_MEM, P_VRT, P_SWP, P_RES, P_COD, P_DAT, P_SHR,
-   P_FL1, P_FL2, P_DRT,
-   P_STA, P_CMD, P_WCH, P_FLG, P_CGR,
-   P_SGD, P_SGN, P_TGD,
+   EU_PID = 0, EU_PPD,
+   EU_UED, EU_UEN, EU_URD, EU_URN, EU_USD, EU_USN,
+   EU_GID, EU_GRP, EU_PGD, EU_TTY, EU_TPG, EU_SID,
+   EU_PRI, EU_NCE, EU_THD,
+   EU_CPN, EU_CPU, EU_TME, EU_TM2,
+   EU_MEM, EU_VRT, EU_SWP, EU_RES, EU_COD, EU_DAT, EU_SHR,
+   EU_FL1, EU_FL2, EU_DRT,
+   EU_STA, EU_CMD, EU_WCH, EU_FLG, EU_CGR,
+   EU_SGD, EU_SGN, EU_TGD,
 #ifdef OOMEM_ENABLE
-   P_OOA, P_OOM,
+   EU_OOA, EU_OOM,
 #endif
-   P_ENV,
-   P_FV1, P_FV2,
-   P_USE,
-   P_NS1, P_NS2, P_NS3, P_NS4, P_NS5, P_NS6,
+   EU_ENV,
+   EU_FV1, EU_FV2,
+   EU_USE,
+   EU_NS1, EU_NS2, EU_NS3, EU_NS4, EU_NS5, EU_NS6,
 #ifdef USE_X_COLHDR
    // not really pflags, used with tbl indexing
-   P_MAXPFLGS
+   EU_MAXPFLGS
 #else
    // not really pflags, used with tbl indexing & col highlighting
-   P_MAXPFLGS, X_XON, X_XOF
+   EU_MAXPFLGS, EU_XON, EU_XOF
 #endif
 };
 
@@ -444,7 +444,7 @@
 #define VARright(w)  (1 == w->maxpflgs && VARcol(w->procflgs[0]))
 #else
 #define VARright(w) ((1 == w->maxpflgs && VARcol(w->procflgs[0])) || \
-                     (3 == w->maxpflgs && X_XON == w->procflgs[0] && VARcol(w->procflgs[1])))
+                     (3 == w->maxpflgs && EU_XON == w->procflgs[0] && VARcol(w->procflgs[1])))
 #endif
 #define VARleft(w)   (w->varcolbeg && VARright(w))
 #define SCROLLAMT    8
@@ -474,7 +474,7 @@
         /* Used to create *most* of the sort callback functions
            note: some of the callbacks are NOT your father's callbacks, they're
                  highly optimized to save them ol' precious cycles! */
-#define SCB_NAME(f) sort_P_ ## f
+#define SCB_NAME(f) sort_EU_ ## f
 #define SCB_NUM1(f,n) \
    static int SCB_NAME(f) (const proc_t **P, const proc_t **Q) { \
       if ( (*P)->n < (*Q)->n ) return SORT_lt; \
@@ -596,16 +596,16 @@
         /* The default values for the local config file */
 #define DEF_RCFILE { \
    RCF_VERSION_ID, 0, 1, DEF_DELAY, 0, { \
-   { P_CPU, DEF_WINFLGS, 0, \
+   { EU_CPU, DEF_WINFLGS, 0, \
       COLOR_RED, COLOR_RED, COLOR_YELLOW, COLOR_RED, \
       "Def", DEF_FIELDS }, \
-   { P_PID, DEF_WINFLGS, 0, \
+   { EU_PID, DEF_WINFLGS, 0, \
       COLOR_CYAN, COLOR_CYAN, COLOR_WHITE, COLOR_CYAN, \
       "Job", JOB_FIELDS }, \
-   { P_MEM, DEF_WINFLGS, 0, \
+   { EU_MEM, DEF_WINFLGS, 0, \
       COLOR_MAGENTA, COLOR_MAGENTA, COLOR_BLUE, COLOR_MAGENTA, \
       "Mem", MEM_FIELDS }, \
-   { P_UEN, DEF_WINFLGS, 0, \
+   { EU_UEN, DEF_WINFLGS, 0, \
       COLOR_YELLOW, COLOR_YELLOW, COLOR_GREEN, COLOR_YELLOW, \
       "Usr", USR_FIELDS } \
    }, 0, SK_Kb, SK_Kb, 0 }
@@ -642,7 +642,7 @@
    /* ( see the find_string function for the one true required protoype ) */
 /*------  Sort callbacks  ------------------------------------------------*/
 /*        for each possible field, in the form of:                        */
-/*atic int           sort_P_XXX (const proc_t **P, const proc_t **Q);     */
+/*atic int           sort_EU_XXX (const proc_t **P, const proc_t **Q);    */
 /*------  Tiny useful routine(s)  ----------------------------------------*/
 //atic const char   *fmtmk (const char *fmts, ...);
 //atic inline char  *scat (char *dst, const char *src);
--- a/top/top_nls.c
+++ b/top/top_nls.c
@@ -94,8 +94,8 @@
          *    +  none of the important translator only comments will
          *       clutter and obscure the main program
          */
-const char *Head_nlstab[P_MAXPFLGS];
-const char *Desc_nlstab[P_MAXPFLGS];
+const char *Head_nlstab[EU_MAXPFLGS];
+const char *Desc_nlstab[EU_MAXPFLGS];
 const char *Norm_nlstab[norm_MAX];
 const char *Uniq_nlstab[uniq_MAX];
 
@@ -121,162 +121,162 @@
    . */
 
 /* Translation Hint: maximum 'PID' = 5 */
-   Head_nlstab[P_PID] = _("PID");
-   Desc_nlstab[P_PID] = _("Process Id");
+   Head_nlstab[EU_PID] = _("PID");
+   Desc_nlstab[EU_PID] = _("Process Id");
 /* Translation Hint: maximum 'PPID' = 5 */
-   Head_nlstab[P_PPD] = _("PPID");
-   Desc_nlstab[P_PPD] = _("Parent Process pid");
+   Head_nlstab[EU_PPD] = _("PPID");
+   Desc_nlstab[EU_PPD] = _("Parent Process pid");
 /* Translation Hint: maximum 'UID' = 5 */
-   Head_nlstab[P_UED] = _("UID");
-   Desc_nlstab[P_UED] = _("Effective User Id");
+   Head_nlstab[EU_UED] = _("UID");
+   Desc_nlstab[EU_UED] = _("Effective User Id");
 /* Translation Hint: maximum 'USER' = 8 */
-   Head_nlstab[P_UEN] = _("USER");
-   Desc_nlstab[P_UEN] = _("Effective User Name");
+   Head_nlstab[EU_UEN] = _("USER");
+   Desc_nlstab[EU_UEN] = _("Effective User Name");
 /* Translation Hint: maximum 'RUID' = 5 */
-   Head_nlstab[P_URD] = _("RUID");
-   Desc_nlstab[P_URD] = _("Real User Id");
+   Head_nlstab[EU_URD] = _("RUID");
+   Desc_nlstab[EU_URD] = _("Real User Id");
 /* Translation Hint: maximum 'RUSER' = 8 */
-   Head_nlstab[P_URN] = _("RUSER");
-   Desc_nlstab[P_URN] = _("Real User Name");
+   Head_nlstab[EU_URN] = _("RUSER");
+   Desc_nlstab[EU_URN] = _("Real User Name");
 /* Translation Hint: maximum 'SUID' = 5 */
-   Head_nlstab[P_USD] = _("SUID");
-   Desc_nlstab[P_USD] = _("Saved User Id");
+   Head_nlstab[EU_USD] = _("SUID");
+   Desc_nlstab[EU_USD] = _("Saved User Id");
 /* Translation Hint: maximum 'SUSER' = 8 */
-   Head_nlstab[P_USN] = _("SUSER");
-   Desc_nlstab[P_USN] = _("Saved User Name");
+   Head_nlstab[EU_USN] = _("SUSER");
+   Desc_nlstab[EU_USN] = _("Saved User Name");
 /* Translation Hint: maximum 'GID' = 5 */
-   Head_nlstab[P_GID] = _("GID");
-   Desc_nlstab[P_GID] = _("Group Id");
+   Head_nlstab[EU_GID] = _("GID");
+   Desc_nlstab[EU_GID] = _("Group Id");
 /* Translation Hint: maximum 'GROUP' = 8 */
-   Head_nlstab[P_GRP] = _("GROUP");
-   Desc_nlstab[P_GRP] = _("Group Name");
+   Head_nlstab[EU_GRP] = _("GROUP");
+   Desc_nlstab[EU_GRP] = _("Group Name");
 /* Translation Hint: maximum 'PGRP' = 5 */
-   Head_nlstab[P_PGD] = _("PGRP");
-   Desc_nlstab[P_PGD] = _("Process Group Id");
+   Head_nlstab[EU_PGD] = _("PGRP");
+   Desc_nlstab[EU_PGD] = _("Process Group Id");
 /* Translation Hint: maximum 'TTY' = 8 */
-   Head_nlstab[P_TTY] = _("TTY");
-   Desc_nlstab[P_TTY] = _("Controlling Tty");
+   Head_nlstab[EU_TTY] = _("TTY");
+   Desc_nlstab[EU_TTY] = _("Controlling Tty");
 /* Translation Hint: maximum 'TPGID' = 5 */
-   Head_nlstab[P_TPG] = _("TPGID");
-   Desc_nlstab[P_TPG] = _("Tty Process Grp Id");
+   Head_nlstab[EU_TPG] = _("TPGID");
+   Desc_nlstab[EU_TPG] = _("Tty Process Grp Id");
 /* Translation Hint: maximum 'SID' = 5 */
-   Head_nlstab[P_SID] = _("SID");
-   Desc_nlstab[P_SID] = _("Session Id");
+   Head_nlstab[EU_SID] = _("SID");
+   Desc_nlstab[EU_SID] = _("Session Id");
 /* Translation Hint: maximum 'PR' = 3 */
-   Head_nlstab[P_PRI] = _("PR");
-   Desc_nlstab[P_PRI] = _("Priority");
+   Head_nlstab[EU_PRI] = _("PR");
+   Desc_nlstab[EU_PRI] = _("Priority");
 /* Translation Hint: maximum 'NI' = 3 */
-   Head_nlstab[P_NCE] = _("NI");
-   Desc_nlstab[P_NCE] = _("Nice Value");
+   Head_nlstab[EU_NCE] = _("NI");
+   Desc_nlstab[EU_NCE] = _("Nice Value");
 /* Translation Hint: maximum 'nTH' = 3 */
-   Head_nlstab[P_THD] = _("nTH");
-   Desc_nlstab[P_THD] = _("Number of Threads");
+   Head_nlstab[EU_THD] = _("nTH");
+   Desc_nlstab[EU_THD] = _("Number of Threads");
 /* Translation Hint: maximum 'P' = 1 */
-   Head_nlstab[P_CPN] = _("P");
-   Desc_nlstab[P_CPN] = _("Last Used Cpu (SMP)");
+   Head_nlstab[EU_CPN] = _("P");
+   Desc_nlstab[EU_CPN] = _("Last Used Cpu (SMP)");
 /* Translation Hint: maximum '%CPU' = 4 */
-   Head_nlstab[P_CPU] = _("%CPU");
-   Desc_nlstab[P_CPU] = _("CPU Usage");
+   Head_nlstab[EU_CPU] = _("%CPU");
+   Desc_nlstab[EU_CPU] = _("CPU Usage");
 /* Translation Hint: maximum '' = 6 */
-   Head_nlstab[P_TME] = _("TIME");
-   Desc_nlstab[P_TME] = _("CPU Time");
+   Head_nlstab[EU_TME] = _("TIME");
+   Desc_nlstab[EU_TME] = _("CPU Time");
 /* Translation Hint: maximum 'TIME+' = 9 */
-   Head_nlstab[P_TM2] = _("TIME+");
-   Desc_nlstab[P_TM2] = _("CPU Time, hundredths");
+   Head_nlstab[EU_TM2] = _("TIME+");
+   Desc_nlstab[EU_TM2] = _("CPU Time, hundredths");
 /* Translation Hint: maximum '%MEM' = 4 */
-   Head_nlstab[P_MEM] = _("%MEM");
-   Desc_nlstab[P_MEM] = _("Memory Usage (RES)");
+   Head_nlstab[EU_MEM] = _("%MEM");
+   Desc_nlstab[EU_MEM] = _("Memory Usage (RES)");
 /* Translation Hint: maximum 'VIRT' = 5 */
-   Head_nlstab[P_VRT] = _("VIRT");
-   Desc_nlstab[P_VRT] = _("Virtual Image (KiB)");
+   Head_nlstab[EU_VRT] = _("VIRT");
+   Desc_nlstab[EU_VRT] = _("Virtual Image (KiB)");
 /* Translation Hint: maximum 'SWAP' = 4 */
-   Head_nlstab[P_SWP] = _("SWAP");
-   Desc_nlstab[P_SWP] = _("Swapped Size (KiB)");
+   Head_nlstab[EU_SWP] = _("SWAP");
+   Desc_nlstab[EU_SWP] = _("Swapped Size (KiB)");
 /* Translation Hint: maximum 'RES' = 4 */
-   Head_nlstab[P_RES] = _("RES");
-   Desc_nlstab[P_RES] = _("Resident Size (KiB)");
+   Head_nlstab[EU_RES] = _("RES");
+   Desc_nlstab[EU_RES] = _("Resident Size (KiB)");
 /* Translation Hint: maximum 'CODE' = 4 */
-   Head_nlstab[P_COD] = _("CODE");
-   Desc_nlstab[P_COD] = _("Code Size (KiB)");
+   Head_nlstab[EU_COD] = _("CODE");
+   Desc_nlstab[EU_COD] = _("Code Size (KiB)");
 /* Translation Hint: maximum 'DATA' = 4 */
-   Head_nlstab[P_DAT] = _("DATA");
-   Desc_nlstab[P_DAT] = _("Data+Stack (KiB)");
+   Head_nlstab[EU_DAT] = _("DATA");
+   Desc_nlstab[EU_DAT] = _("Data+Stack (KiB)");
 /* Translation Hint: maximum 'SHR' = 4 */
-   Head_nlstab[P_SHR] = _("SHR");
-   Desc_nlstab[P_SHR] = _("Shared Memory (KiB)");
+   Head_nlstab[EU_SHR] = _("SHR");
+   Desc_nlstab[EU_SHR] = _("Shared Memory (KiB)");
 /* Translation Hint: maximum 'nMaj' = 4 */
-   Head_nlstab[P_FL1] = _("nMaj");
-   Desc_nlstab[P_FL1] = _("Major Page Faults");
+   Head_nlstab[EU_FL1] = _("nMaj");
+   Desc_nlstab[EU_FL1] = _("Major Page Faults");
 /* Translation Hint: maximum 'nMin' = 4 */
-   Head_nlstab[P_FL2] = _("nMin");
-   Desc_nlstab[P_FL2] = _("Minor Page Faults");
+   Head_nlstab[EU_FL2] = _("nMin");
+   Desc_nlstab[EU_FL2] = _("Minor Page Faults");
 /* Translation Hint: maximum 'nDRT' = 4 */
-   Head_nlstab[P_DRT] = _("nDRT");
-   Desc_nlstab[P_DRT] = _("Dirty Pages Count");
+   Head_nlstab[EU_DRT] = _("nDRT");
+   Desc_nlstab[EU_DRT] = _("Dirty Pages Count");
 /* Translation Hint: maximum 'S' = 1 */
-   Head_nlstab[P_STA] = _("S");
-   Desc_nlstab[P_STA] = _("Process Status");
+   Head_nlstab[EU_STA] = _("S");
+   Desc_nlstab[EU_STA] = _("Process Status");
 /* Translation Hint: maximum 'COMMAND' = 7 */
-   Head_nlstab[P_CMD] = _("COMMAND");
-   Desc_nlstab[P_CMD] = _("Command Name/Line");
+   Head_nlstab[EU_CMD] = _("COMMAND");
+   Desc_nlstab[EU_CMD] = _("Command Name/Line");
 /* Translation Hint: maximum 'WCHAN' = 7 */
-   Head_nlstab[P_WCH] = _("WCHAN");
-   Desc_nlstab[P_WCH] = _("Sleeping in Function");
+   Head_nlstab[EU_WCH] = _("WCHAN");
+   Desc_nlstab[EU_WCH] = _("Sleeping in Function");
 /* Translation Hint: maximum 'Flags' = 8 */
-   Head_nlstab[P_FLG] = _("Flags");
-   Desc_nlstab[P_FLG] = _("Task Flags <sched.h>");
+   Head_nlstab[EU_FLG] = _("Flags");
+   Desc_nlstab[EU_FLG] = _("Task Flags <sched.h>");
 /* Translation Hint: maximum 'CGROUPS' = 7 */
-   Head_nlstab[P_CGR] = _("CGROUPS");
-   Desc_nlstab[P_CGR] = _("Control Groups");
+   Head_nlstab[EU_CGR] = _("CGROUPS");
+   Desc_nlstab[EU_CGR] = _("Control Groups");
 /* Translation Hint: maximum 'SUPGIDS' = 7 */
-   Head_nlstab[P_SGD] = _("SUPGIDS");
-   Desc_nlstab[P_SGD] = _("Supp Groups IDs");
+   Head_nlstab[EU_SGD] = _("SUPGIDS");
+   Desc_nlstab[EU_SGD] = _("Supp Groups IDs");
 /* Translation Hint: maximum 'SUPGRPS' = 7 */
-   Head_nlstab[P_SGN] = _("SUPGRPS");
-   Desc_nlstab[P_SGN] = _("Supp Groups Names");
+   Head_nlstab[EU_SGN] = _("SUPGRPS");
+   Desc_nlstab[EU_SGN] = _("Supp Groups Names");
 /* Translation Hint: maximum 'TGID' = 5 */
-   Head_nlstab[P_TGD] = _("TGID");
-   Desc_nlstab[P_TGD] = _("Thread Group Id");
+   Head_nlstab[EU_TGD] = _("TGID");
+   Desc_nlstab[EU_TGD] = _("Thread Group Id");
 #ifdef OOMEM_ENABLE
 /* Translation Hint: maximum 'Adj' = 3 */
-   Head_nlstab[P_OOA] = _("Adj");
-   Desc_nlstab[P_OOA] = _("oom_adjustment (2^X)");
+   Head_nlstab[EU_OOA] = _("Adj");
+   Desc_nlstab[EU_OOA] = _("oom_adjustment (2^X)");
 /* Translation Hint: maximum 'Badness' = 8 */
-   Head_nlstab[P_OOM] = _("Badness");
-   Desc_nlstab[P_OOM] = _("oom_score (badness)");
+   Head_nlstab[EU_OOM] = _("Badness");
+   Desc_nlstab[EU_OOM] = _("oom_score (badness)");
 #endif
 /* Translation Hint: maximum 'ENVIRON' = 7 */
-   Head_nlstab[P_ENV] = _("ENVIRON");
+   Head_nlstab[EU_ENV] = _("ENVIRON");
 /* Translation Hint: the abbreviation 'vars' below is shorthand for
                      'variables' */
-   Desc_nlstab[P_ENV] = _("Environment vars");
+   Desc_nlstab[EU_ENV] = _("Environment vars");
 /* Translation Hint: maximum 'vMj' = 3 */
-   Head_nlstab[P_FV1] = _("vMj");
-   Desc_nlstab[P_FV1] = _("Major Faults delta");
+   Head_nlstab[EU_FV1] = _("vMj");
+   Desc_nlstab[EU_FV1] = _("Major Faults delta");
 /* Translation Hint: maximum 'vMn' = 3 */
-   Head_nlstab[P_FV2] = _("vMn");
-   Desc_nlstab[P_FV2] = _("Minor Faults delta");
+   Head_nlstab[EU_FV2] = _("vMn");
+   Desc_nlstab[EU_FV2] = _("Minor Faults delta");
 /* Translation Hint: maximum 'USED' = 4 */
-   Head_nlstab[P_USE] = _("USED");
-   Desc_nlstab[P_USE] = _("Res+Swap Size (KiB)");
+   Head_nlstab[EU_USE] = _("USED");
+   Desc_nlstab[EU_USE] = _("Res+Swap Size (KiB)");
 /* Translation Hint: maximum 'nsIPC' = 10 */
-   Head_nlstab[P_NS1] = _("nsIPC");
-   Desc_nlstab[P_NS1] = _("IPC namespace Inode");
+   Head_nlstab[EU_NS1] = _("nsIPC");
+   Desc_nlstab[EU_NS1] = _("IPC namespace Inode");
 /* Translation Hint: maximum 'nsMNT' = 10 */
-   Head_nlstab[P_NS2] = _("nsMNT");
-   Desc_nlstab[P_NS2] = _("MNT namespace Inode");
+   Head_nlstab[EU_NS2] = _("nsMNT");
+   Desc_nlstab[EU_NS2] = _("MNT namespace Inode");
 /* Translation Hint: maximum 'nsNET' = 10 */
-   Head_nlstab[P_NS3] = _("nsNET");
-   Desc_nlstab[P_NS3] = _("NET namespace Inode");
+   Head_nlstab[EU_NS3] = _("nsNET");
+   Desc_nlstab[EU_NS3] = _("NET namespace Inode");
 /* Translation Hint: maximum 'nsPID' = 10 */
-   Head_nlstab[P_NS4] = _("nsPID");
-   Desc_nlstab[P_NS4] = _("PID namespace Inode");
+   Head_nlstab[EU_NS4] = _("nsPID");
+   Desc_nlstab[EU_NS4] = _("PID namespace Inode");
 /* Translation Hint: maximum 'nsUSER' = 10 */
-   Head_nlstab[P_NS5] = _("nsUSER");
-   Desc_nlstab[P_NS5] = _("USER namespace Inode");
+   Head_nlstab[EU_NS5] = _("nsUSER");
+   Desc_nlstab[EU_NS5] = _("USER namespace Inode");
 /* Translation Hint: maximum 'nsUTS' = 10 */
-   Head_nlstab[P_NS6] = _("nsUTS");
-   Desc_nlstab[P_NS6] = _("UTS namespace Inode");
+   Head_nlstab[EU_NS6] = _("nsUTS");
+   Desc_nlstab[EU_NS6] = _("UTS namespace Inode");
 }
 
 
@@ -681,7 +681,7 @@
    memset(Head_nlstab, 0, sizeof(Head_nlstab));
    memset(Desc_nlstab, 0, sizeof(Desc_nlstab));
    build_two_nlstabs();
-   for (i = 0; i < P_MAXPFLGS; i++) {
+   for (i = 0; i < EU_MAXPFLGS; i++) {
       if (!Head_nlstab[i]) {
          fprintf(stderr, nls_err, "Head", i);
          exit(1);
