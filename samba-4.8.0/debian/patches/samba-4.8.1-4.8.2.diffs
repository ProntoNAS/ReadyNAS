diff -Npur samba-4.8.1/WHATSNEW.txt samba-4.8.2/WHATSNEW.txt
--- samba-4.8.1/WHATSNEW.txt	2018-04-26 09:21:03.000000000 +0200
+++ samba-4.8.2/WHATSNEW.txt	2018-05-16 12:09:25.000000000 +0200
@@ -1,4 +1,95 @@
                    =============================
+                   Release Notes for Samba 4.8.2
+                            May 16, 2018
+                   =============================
+
+
+This is the latest stable release of the Samba 4.8 release series.
+
+Major bug fixes include:
+------------------------
+
+   o After update to 4.8.0 DC failed with "Failed to find our own
+     NTDS Settings objectGUID" (bug #13335).
+
+Changes since 4.8.1:
+--------------------
+
+o  Jeremy Allison <jra@samba.org>
+   * BUG 13380: s3: smbd: Generic fix for incorrect reporting of stream dos
+     attributes on a directory.
+   * BUG 13412: ceph: VFS: Add asynchronous fsync to ceph module, fake using
+     synchronous call.
+   * BUG 13419: s3: libsmbclient: Fix hard-coded connection error return of
+     ETIMEDOUT.
+
+o  Andrew Bartlett <abartlet@samba.org>
+   * BUG 13306: ldb: Release ldb 1.3.3:
+     * Fix failure to upgrade to the GUID index DB format.
+     * Add tests for GUID index behaviour.
+   * BUG 13420: s4-lsa: Fix use-after-free in LSA server.
+   * BUG 13430: winbindd: Do re-connect if the RPC call fails in the passdb
+     case.
+
+o  Ralph Boehme <slow@samba.org>
+   * BUG 13416: s3:cleanupd: Sends MSG_SMB_UNLOCK twice to interested peers.
+   * BUG 13414: s3:cleanupd: Use MSG_SMB_BRL_VALIDATE to signal cleanupd
+     unclean process shutdown.
+
+o  David Disseldorp <ddiss@samba.org>
+   * BUG 13425: vfs_ceph: add fake async pwrite/pread send/recv hooks.
+
+o  Amitay Isaacs <amitay@gmail.com>
+   * BUG 13411: ctdb-client: Remove ununsed functions from old client code.
+
+o  Bj√∂rn Jacke <bjacke@samba.org>
+   * BUG 13395: printing: Return the same error code as windows does on upload
+     failures.
+
+o  Gary Lockyer <gary@catalyst.net.nz>
+   * BUG 13335: After update to 4.8.0 DC failed with "Failed to find our own
+     NTDS Settings objectGUID".
+
+o  Stefan Metzmacher <metze@samba.org>
+   * BUG 13400: nsswitch: Fix memory leak in winbind_open_pipe_sock() when the
+     privileged pipe is not accessable.
+   * BUG 13420: s4:lsa_lookup: remove TALLOC_FREE(state) after all
+     dcesrv_lsa_Lookup{Names,Sids}_base_map() calls.
+
+o  Vandana Rungta <vrungta@amazon.com>
+   * BUG 13424: s3: VFS: Fix memory leak in vfs_ceph.
+
+o  Christof Schmitt <cs@samba.org>
+   * BUG 13407: rpc_server: Fix NetSessEnum with stale sessions.
+
+o  Andreas Schneider <asn@samba.org>
+   * BUG 13417: s3:smbspool: Fix cmdline argument handling.
+
+
+#######################################
+Reporting bugs & Development Discussion
+#######################################
+
+Please discuss this release on the samba-technical mailing list or by
+joining the #samba-technical IRC channel on irc.freenode.net.
+
+If you do report problems then please try to send high quality
+feedback. If you don't provide vital information to help us track down
+the problem then you will probably be ignored.  All bug reports should
+be filed under the "Samba 4.1 and newer" product in the project's Bugzilla
+database (https://bugzilla.samba.org/).
+
+
+======================================================================
+== Our Code, Our Bugs, Our Responsibility.
+== The Samba Team
+======================================================================
+
+
+Release notes for older releases follow:
+----------------------------------------
+
+                   =============================
                    Release Notes for Samba 4.8.1
                            April 26, 2018
                    =============================
@@ -103,8 +194,8 @@ database (https://bugzilla.samba.org/).
 ======================================================================
 
 
-Release notes for older releases follow:
-----------------------------------------
+----------------------------------------------------------------------
+
 
                    =============================
                    Release Notes for Samba 4.8.0
diff -Npur samba-4.8.1/ctdb/client/ctdb_client.c samba-4.8.2/ctdb/client/ctdb_client.c
--- samba-4.8.1/ctdb/client/ctdb_client.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/ctdb/client/ctdb_client.c	2018-05-16 12:09:25.000000000 +0200
@@ -584,354 +584,6 @@ int ctdb_client_send_message(struct ctdb
 
 
 /*
-  cancel a ctdb_fetch_lock operation, releasing the lock
- */
-static int fetch_lock_destructor(struct ctdb_record_handle *h)
-{
-	ctdb_ltdb_unlock(h->ctdb_db, h->key);
-	return 0;
-}
-
-/*
-  force the migration of a record to this node
- */
-static int ctdb_client_force_migration(struct ctdb_db_context *ctdb_db, TDB_DATA key)
-{
-	struct ctdb_call call;
-	ZERO_STRUCT(call);
-	call.call_id = CTDB_NULL_FUNC;
-	call.key = key;
-	call.flags = CTDB_IMMEDIATE_MIGRATION;
-	return ctdb_call(ctdb_db, &call);
-}
-
-/*
-  try to fetch a readonly copy of a record
- */
-static int
-ctdb_client_fetch_readonly(struct ctdb_db_context *ctdb_db, TDB_DATA key, TALLOC_CTX *mem_ctx, struct ctdb_ltdb_header **hdr, TDB_DATA *data)
-{
-	int ret;
-
-	struct ctdb_call call;
-	ZERO_STRUCT(call);
-
-	call.call_id = CTDB_FETCH_WITH_HEADER_FUNC;
-	call.call_data.dptr = NULL;
-	call.call_data.dsize = 0;
-	call.key = key;
-	call.flags = CTDB_WANT_READONLY;
-	ret = ctdb_call(ctdb_db, &call);
-
-	if (ret != 0) {
-		return -1;
-	}
-	if (call.reply_data.dsize < sizeof(struct ctdb_ltdb_header)) {
-		return -1;
-	}
-
-	*hdr = talloc_memdup(mem_ctx, &call.reply_data.dptr[0], sizeof(struct ctdb_ltdb_header));
-	if (*hdr == NULL) {
-		talloc_free(call.reply_data.dptr);
-		return -1;
-	}
-
-	data->dsize = call.reply_data.dsize - sizeof(struct ctdb_ltdb_header);
-	data->dptr  = talloc_memdup(mem_ctx, &call.reply_data.dptr[sizeof(struct ctdb_ltdb_header)], data->dsize);
-	if (data->dptr == NULL) {
-		talloc_free(call.reply_data.dptr);
-		talloc_free(hdr);
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  get a lock on a record, and return the records data. Blocks until it gets the lock
- */
-struct ctdb_record_handle *ctdb_fetch_lock(struct ctdb_db_context *ctdb_db, TALLOC_CTX *mem_ctx, 
-					   TDB_DATA key, TDB_DATA *data)
-{
-	int ret;
-	struct ctdb_record_handle *h;
-
-	/*
-	  procedure is as follows:
-
-	  1) get the chain lock. 
-	  2) check if we are dmaster
-	  3) if we are the dmaster then return handle 
-	  4) if not dmaster then ask ctdb daemon to make us dmaster, and wait for
-	     reply from ctdbd
-	  5) when we get the reply, goto (1)
-	 */
-
-	h = talloc_zero(mem_ctx, struct ctdb_record_handle);
-	if (h == NULL) {
-		return NULL;
-	}
-
-	h->ctdb_db = ctdb_db;
-	h->key     = key;
-	h->key.dptr = talloc_memdup(h, key.dptr, key.dsize);
-	if (h->key.dptr == NULL) {
-		talloc_free(h);
-		return NULL;
-	}
-	h->data    = data;
-
-	DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: key=%*.*s\n", (int)key.dsize, (int)key.dsize, 
-		 (const char *)key.dptr));
-
-again:
-	/* step 1 - get the chain lock */
-	ret = ctdb_ltdb_lock(ctdb_db, key);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR, (__location__ " failed to lock ltdb record\n"));
-		talloc_free(h);
-		return NULL;
-	}
-
-	DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: got chain lock\n"));
-
-	talloc_set_destructor(h, fetch_lock_destructor);
-
-	ret = ctdb_ltdb_fetch(ctdb_db, key, &h->header, h, data);
-
-	/* when torturing, ensure we test the remote path */
-	if ((ctdb_db->ctdb->flags & CTDB_FLAG_TORTURE) &&
-	    random() % 5 == 0) {
-		h->header.dmaster = (uint32_t)-1;
-	}
-
-
-	DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: done local fetch\n"));
-
-	if (ret != 0 || h->header.dmaster != ctdb_db->ctdb->pnn) {
-		ctdb_ltdb_unlock(ctdb_db, key);
-		ret = ctdb_client_force_migration(ctdb_db, key);
-		if (ret != 0) {
-			DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: force_migration failed\n"));
-			talloc_free(h);
-			return NULL;
-		}
-		goto again;
-	}
-
-	/* if this is a request for read/write and we have delegations
-	   we have to revoke all delegations first
-	*/
-	if ((h->header.dmaster == ctdb_db->ctdb->pnn) &&
-	    (h->header.flags & CTDB_REC_RO_HAVE_DELEGATIONS)) {
-		ctdb_ltdb_unlock(ctdb_db, key);
-		ret = ctdb_client_force_migration(ctdb_db, key);
-		if (ret != 0) {
-			DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-			talloc_free(h);
-			return NULL;
-		}
-		goto again;
-	}
-
-	DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: we are dmaster - done\n"));
-	return h;
-}
-
-/*
-  get a readonly lock on a record, and return the records data. Blocks until it gets the lock
- */
-struct ctdb_record_handle *
-ctdb_fetch_readonly_lock(
-	struct ctdb_db_context *ctdb_db, TALLOC_CTX *mem_ctx, 
-	TDB_DATA key, TDB_DATA *data,
-	int read_only)
-{
-	int ret;
-	struct ctdb_record_handle *h;
-	struct ctdb_ltdb_header *roheader = NULL;
-
-	h = talloc_zero(mem_ctx, struct ctdb_record_handle);
-	if (h == NULL) {
-		return NULL;
-	}
-
-	h->ctdb_db = ctdb_db;
-	h->key     = key;
-	h->key.dptr = talloc_memdup(h, key.dptr, key.dsize);
-	if (h->key.dptr == NULL) {
-		talloc_free(h);
-		return NULL;
-	}
-	h->data    = data;
-
-	data->dptr = NULL;
-	data->dsize = 0;
-
-
-again:
-	talloc_free(roheader);
-	roheader = NULL;
-
-	talloc_free(data->dptr);
-	data->dptr = NULL;
-	data->dsize = 0;
-
-	/* Lock the record/chain */
-	ret = ctdb_ltdb_lock(ctdb_db, key);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR, (__location__ " failed to lock ltdb record\n"));
-		talloc_free(h);
-		return NULL;
-	}
-
-	talloc_set_destructor(h, fetch_lock_destructor);
-
-	/* Check if record exists yet in the TDB */
-	ret = ctdb_ltdb_fetch_with_header(ctdb_db, key, &h->header, h, data);
-	if (ret != 0) {
-		ctdb_ltdb_unlock(ctdb_db, key);
-		ret = ctdb_client_force_migration(ctdb_db, key);
-		if (ret != 0) {
-			DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-			talloc_free(h);
-			return NULL;
-		}
-		goto again;
-	}
-
-	/* if this is a request for read/write and we have delegations
-	   we have to revoke all delegations first
-	*/
-	if ((read_only == 0) 
-	&&  (h->header.dmaster == ctdb_db->ctdb->pnn)
-	&&  (h->header.flags & CTDB_REC_RO_HAVE_DELEGATIONS)) {
-		ctdb_ltdb_unlock(ctdb_db, key);
-		ret = ctdb_client_force_migration(ctdb_db, key);
-		if (ret != 0) {
-			DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-			talloc_free(h);
-			return NULL;
-		}
-		goto again;
-	}
-
-	/* if we are dmaster, just return the handle */
-	if (h->header.dmaster == ctdb_db->ctdb->pnn) {
-		return h;
-	}
-
-	if (read_only != 0) {
-		TDB_DATA rodata = {NULL, 0};
-
-		if ((h->header.flags & CTDB_REC_RO_HAVE_READONLY)
-		||  (h->header.flags & CTDB_REC_RO_HAVE_DELEGATIONS)) {
-			return h;
-		}
-
-		ctdb_ltdb_unlock(ctdb_db, key);
-		ret = ctdb_client_fetch_readonly(ctdb_db, key, h, &roheader, &rodata);
-		if (ret != 0) {
-			DEBUG(DEBUG_ERR,("ctdb_fetch_readonly_lock:  failed. force migration and try again\n"));
-			ret = ctdb_client_force_migration(ctdb_db, key);
-			if (ret != 0) {
-				DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-				talloc_free(h);
-				return NULL;
-			}
-
-			goto again;
-		}
-
-		if (!(roheader->flags&CTDB_REC_RO_HAVE_READONLY)) {
-			ret = ctdb_client_force_migration(ctdb_db, key);
-			if (ret != 0) {
-				DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-				talloc_free(h);
-				return NULL;
-			}
-
-			goto again;
-		}
-
-		ret = ctdb_ltdb_lock(ctdb_db, key);
-		if (ret != 0) {
-			DEBUG(DEBUG_ERR, (__location__ " failed to lock ltdb record\n"));
-			talloc_free(h);
-			return NULL;
-		}
-
-		ret = ctdb_ltdb_fetch_with_header(ctdb_db, key, &h->header, h, data);
-		if (ret != 0) {
-			ctdb_ltdb_unlock(ctdb_db, key);
-
-			ret = ctdb_client_force_migration(ctdb_db, key);
-			if (ret != 0) {
-				DEBUG(DEBUG_DEBUG,("ctdb_fetch_readonly_lock: force_migration failed\n"));
-				talloc_free(h);
-				return NULL;
-			}
-
-			goto again;
-		}
-
-		return h;
-	}
-
-	/* we are not dmaster and this was not a request for a readonly lock
-	 * so unlock the record, migrate it and try again
-	 */
-	ctdb_ltdb_unlock(ctdb_db, key);
-	ret = ctdb_client_force_migration(ctdb_db, key);
-	if (ret != 0) {
-		DEBUG(DEBUG_DEBUG,("ctdb_fetch_lock: force_migration failed\n"));
-		talloc_free(h);
-		return NULL;
-	}
-	goto again;
-}
-
-/*
-  store some data to the record that was locked with ctdb_fetch_lock()
-*/
-int ctdb_record_store(struct ctdb_record_handle *h, TDB_DATA data)
-{
-	if (! ctdb_db_volatile(h->ctdb_db)) {
-		DEBUG(DEBUG_ERR,
-		      ("ctdb_record_store prohibited for non-volatile dbs\n"));
-		return -1;
-	}
-
-	return ctdb_ltdb_store(h->ctdb_db, h->key, &h->header, data);
-}
-
-/*
-  non-locking fetch of a record
- */
-int ctdb_fetch(struct ctdb_db_context *ctdb_db, TALLOC_CTX *mem_ctx, 
-	       TDB_DATA key, TDB_DATA *data)
-{
-	struct ctdb_call call;
-	int ret;
-
-	call.call_id = CTDB_FETCH_FUNC;
-	call.call_data.dptr = NULL;
-	call.call_data.dsize = 0;
-	call.key = key;
-
-	ret = ctdb_call(ctdb_db, &call);
-
-	if (ret == 0) {
-		*data = call.reply_data;
-		talloc_steal(mem_ctx, data->dptr);
-	}
-
-	return ret;
-}
-
-
-
-/*
    called when a control completes or timesout to invoke the callback
    function the user provided
 */
@@ -1210,134 +862,6 @@ int ctdb_control(struct ctdb_context *ct
 			errormsg);
 }
 
-
-
-
-/*
-  a process exists call. Returns 0 if process exists, -1 otherwise
- */
-int ctdb_ctrl_process_exists(struct ctdb_context *ctdb, uint32_t destnode, pid_t pid)
-{
-	int ret;
-	TDB_DATA data;
-	int32_t status;
-
-	data.dptr = (uint8_t*)&pid;
-	data.dsize = sizeof(pid);
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_PROCESS_EXISTS, 0, data, 
-			   NULL, NULL, &status, NULL, NULL);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for process_exists failed\n"));
-		return -1;
-	}
-
-	return status;
-}
-
-/*
-  get remote statistics
- */
-int ctdb_ctrl_statistics(struct ctdb_context *ctdb, uint32_t destnode, struct ctdb_statistics *status)
-{
-	int ret;
-	TDB_DATA data;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_STATISTICS, 0, tdb_null, 
-			   ctdb, &data, &res, NULL, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for statistics failed\n"));
-		return -1;
-	}
-
-	if (data.dsize != sizeof(struct ctdb_statistics)) {
-		DEBUG(DEBUG_ERR,(__location__ " Wrong statistics size %u - expected %u\n",
-			 (unsigned)data.dsize, (unsigned)sizeof(struct ctdb_statistics)));
-		      return -1;
-	}
-
-	*status = *(struct ctdb_statistics *)data.dptr;
-	talloc_free(data.dptr);
-			
-	return 0;
-}
-
-/*
- * get db statistics
- */
-int ctdb_ctrl_dbstatistics(struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid,
-			   TALLOC_CTX *mem_ctx, struct ctdb_db_statistics_old **dbstat)
-{
-	int ret;
-	TDB_DATA indata, outdata;
-	int32_t res;
-	struct ctdb_db_statistics_old *wire, *s;
-	char *ptr;
-	int i;
-
-	indata.dptr = (uint8_t *)&dbid;
-	indata.dsize = sizeof(dbid);
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_GET_DB_STATISTICS,
-			   0, indata, ctdb, &outdata, &res, NULL, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for dbstatistics failed\n"));
-		return -1;
-	}
-
-	if (outdata.dsize < offsetof(struct ctdb_db_statistics_old, hot_keys_wire)) {
-		DEBUG(DEBUG_ERR,(__location__ " Wrong dbstatistics size %zi - expected >= %lu\n",
-				 outdata.dsize,
-				 (long unsigned int)sizeof(struct ctdb_statistics)));
-		return -1;
-	}
-
-	s = talloc_zero(mem_ctx, struct ctdb_db_statistics_old);
-	if (s == NULL) {
-		talloc_free(outdata.dptr);
-		CTDB_NO_MEMORY(ctdb, s);
-	}
-
-	wire = (struct ctdb_db_statistics_old *)outdata.dptr;
-	memcpy(s, wire, offsetof(struct ctdb_db_statistics_old, hot_keys_wire));
-	ptr = &wire->hot_keys_wire[0];
-	for (i=0; i<wire->num_hot_keys; i++) {
-		s->hot_keys[i].key.dptr = talloc_size(mem_ctx, s->hot_keys[i].key.dsize);
-		if (s->hot_keys[i].key.dptr == NULL) {
-			talloc_free(outdata.dptr);
-			CTDB_NO_MEMORY(ctdb, s->hot_keys[i].key.dptr);
-		}
-
-		memcpy(s->hot_keys[i].key.dptr, ptr, s->hot_keys[i].key.dsize);
-		ptr += wire->hot_keys[i].key.dsize;
-	}
-
-	talloc_free(outdata.dptr);
-	*dbstat = s;
-	return 0;
-}
-
-/*
-  shutdown a remote ctdb node
- */
-int ctdb_ctrl_shutdown(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode)
-{
-	struct ctdb_client_control_state *state;
-
-	state = ctdb_control_send(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SHUTDOWN, 0, tdb_null, 
-			   NULL, &timeout, NULL);
-	if (state == NULL) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for shutdown failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
 /*
   get vnn map from a remote node
  */
@@ -1554,199 +1078,8 @@ int ctdb_ctrl_getnodemap(struct ctdb_con
 	return 0;
 }
 
-/*
-  load nodes file on a remote node and return as a node map
- */
-int ctdb_ctrl_getnodesfile(struct ctdb_context *ctdb,
-			   struct timeval timeout, uint32_t destnode,
-			   TALLOC_CTX *mem_ctx, struct ctdb_node_map_old **nodemap)
-{
-	int ret;
-	TDB_DATA outdata;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0,
-			   CTDB_CONTROL_GET_NODES_FILE, 0, tdb_null,
-			   mem_ctx, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0 || outdata.dsize == 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for getnodes failed ret:%d res:%d\n", ret, res));
-		return -1;
-	}
-
-	*nodemap = (struct ctdb_node_map_old *)talloc_memdup(mem_ctx, outdata.dptr, outdata.dsize);
-	talloc_free(outdata.dptr);
-
-	return 0;
-}
-
-/*
-  drop the transport, reload the nodes file and restart the transport
- */
-int ctdb_ctrl_reload_nodes_file(struct ctdb_context *ctdb, 
-		    struct timeval timeout, uint32_t destnode)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_RELOAD_NODES_FILE, 0, tdb_null, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for reloadnodesfile failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/*
-  set vnn map on a node
- */
-int ctdb_ctrl_setvnnmap(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, 
-			TALLOC_CTX *mem_ctx, struct ctdb_vnn_map *vnnmap)
-{
-	int ret;
-	TDB_DATA data;
-	int32_t res;
-	struct ctdb_vnn_map_wire *map;
-	size_t len;
-
-	len = offsetof(struct ctdb_vnn_map_wire, map) + sizeof(uint32_t)*vnnmap->size;
-	map = talloc_size(mem_ctx, len);
-	CTDB_NO_MEMORY(ctdb, map);
-
-	map->generation = vnnmap->generation;
-	map->size = vnnmap->size;
-	memcpy(map->map, vnnmap->map, sizeof(uint32_t)*map->size);
-	
-	data.dsize = len;
-	data.dptr  = (uint8_t *)map;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SETVNNMAP, 0, data, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for setvnnmap failed\n"));
-		return -1;
-	}
-
-	talloc_free(map);
-
-	return 0;
-}
-
-
-/*
-  async send for pull database
- */
-struct ctdb_client_control_state *ctdb_ctrl_pulldb_send(
-	struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid,
-	uint32_t lmaster, TALLOC_CTX *mem_ctx, struct timeval timeout)
-{
-	TDB_DATA indata;
-	struct ctdb_pulldb *pull;
-	struct ctdb_client_control_state *state;
-
-	pull = talloc(mem_ctx, struct ctdb_pulldb);
-	CTDB_NO_MEMORY_NULL(ctdb, pull);
-
-	pull->db_id   = dbid;
-	pull->lmaster = lmaster;
-
-	indata.dsize = sizeof(struct ctdb_pulldb);
-	indata.dptr  = (unsigned char *)pull;
-
-	state = ctdb_control_send(ctdb, destnode, 0, 
-				  CTDB_CONTROL_PULL_DB, 0, indata, 
-				  mem_ctx, &timeout, NULL);
-	talloc_free(pull);
-
-	return state;
-}
-
-/*
-  async recv for pull database
- */
-int ctdb_ctrl_pulldb_recv(
-	struct ctdb_context *ctdb, 
-	TALLOC_CTX *mem_ctx, struct ctdb_client_control_state *state, 
-	TDB_DATA *outdata)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control_recv(ctdb, state, mem_ctx, outdata, &res, NULL);
-	if ( (ret != 0) || (res != 0) ){
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_ctrl_pulldb_recv failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  pull all keys and records for a specific database on a node
- */
-int ctdb_ctrl_pulldb(struct ctdb_context *ctdb, uint32_t destnode, 
-		uint32_t dbid, uint32_t lmaster, 
-		TALLOC_CTX *mem_ctx, struct timeval timeout,
-		TDB_DATA *outdata)
-{
-	struct ctdb_client_control_state *state;
-
-	state = ctdb_ctrl_pulldb_send(ctdb, destnode, dbid, lmaster, mem_ctx,
-				      timeout);
-	
-	return ctdb_ctrl_pulldb_recv(ctdb, mem_ctx, state, outdata);
-}
-
-
-/*
-  change dmaster for all keys in the database to the new value
- */
-int ctdb_ctrl_setdmaster(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, 
-			 TALLOC_CTX *mem_ctx, uint32_t dbid, uint32_t dmaster)
-{
-	int ret;
-	TDB_DATA indata;
-	int32_t res;
-
-	indata.dsize = 2*sizeof(uint32_t);
-	indata.dptr = (unsigned char *)talloc_array(mem_ctx, uint32_t, 2);
-
-	((uint32_t *)(&indata.dptr[0]))[0] = dbid;
-	((uint32_t *)(&indata.dptr[0]))[1] = dmaster;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_DMASTER, 0, indata, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for setdmaster failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  ping a node, return number of clients connected
- */
-int ctdb_ctrl_ping(struct ctdb_context *ctdb, uint32_t destnode)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_PING, 0, 
-			   tdb_null, NULL, NULL, &res, NULL, NULL);
-	if (ret != 0) {
-		return -1;
-	}
-	return res;
-}
-
-int ctdb_ctrl_get_runstate(struct ctdb_context *ctdb, 
-			   struct timeval timeout, 
+int ctdb_ctrl_get_runstate(struct ctdb_context *ctdb,
+			   struct timeval timeout,
 			   uint32_t destnode,
 			   uint32_t *runstate)
 {
@@ -1776,9 +1109,9 @@ int ctdb_ctrl_get_runstate(struct ctdb_c
 }
 
 /*
-  find the real path to a ltdb 
+  find the real path to a ltdb
  */
-int ctdb_ctrl_getdbpath(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, uint32_t dbid, TALLOC_CTX *mem_ctx, 
+int ctdb_ctrl_getdbpath(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, uint32_t dbid, TALLOC_CTX *mem_ctx,
 		   const char **path)
 {
 	int ret;
@@ -1789,7 +1122,7 @@ int ctdb_ctrl_getdbpath(struct ctdb_cont
 	data.dsize = sizeof(dbid);
 
 	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GETDBPATH, 0, data, 
+			   CTDB_CONTROL_GETDBPATH, 0, data,
 			   mem_ctx, &data, &res, &timeout, NULL);
 	if (ret != 0 || res != 0) {
 		return -1;
@@ -1836,80 +1169,6 @@ int ctdb_ctrl_getdbname(struct ctdb_cont
 }
 
 /*
-  get the health status of a db
- */
-int ctdb_ctrl_getdbhealth(struct ctdb_context *ctdb,
-			  struct timeval timeout,
-			  uint32_t destnode,
-			  uint32_t dbid, TALLOC_CTX *mem_ctx,
-			  const char **reason)
-{
-	int ret;
-	int32_t res;
-	TDB_DATA data;
-
-	data.dptr = (uint8_t *)&dbid;
-	data.dsize = sizeof(dbid);
-
-	ret = ctdb_control(ctdb, destnode, 0,
-			   CTDB_CONTROL_DB_GET_HEALTH, 0, data,
-			   mem_ctx, &data, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		return -1;
-	}
-
-	if (data.dsize == 0) {
-		(*reason) = NULL;
-		return 0;
-	}
-
-	(*reason) = talloc_strndup(mem_ctx, (const char *)data.dptr, data.dsize);
-	if ((*reason) == NULL) {
-		return -1;
-	}
-
-	talloc_free(data.dptr);
-
-	return 0;
-}
-
-/*
- * get db sequence number
- */
-int ctdb_ctrl_getdbseqnum(struct ctdb_context *ctdb, struct timeval timeout,
-			  uint32_t destnode, uint32_t dbid, uint64_t *seqnum)
-{
-	int ret;
-	int32_t res;
-	TDB_DATA data, outdata;
-	uint8_t buf[sizeof(uint64_t)] = { 0 };
-
-	*(uint32_t *)buf = dbid;
-	data.dptr = buf;
-	data.dsize = sizeof(uint64_t);
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_GET_DB_SEQNUM,
-			   0, data, ctdb, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,("ctdb_control for getdbesqnum failed\n"));
-		return -1;
-	}
-
-	if (outdata.dsize != sizeof(uint64_t)) {
-		DEBUG(DEBUG_ERR,("Invalid return data in get_dbseqnum\n"));
-		talloc_free(outdata.dptr);
-		return -1;
-	}
-
-	if (seqnum != NULL) {
-		*seqnum = *(uint64_t *)outdata.dptr;
-	}
-	talloc_free(outdata.dptr);
-
-	return 0;
-}
-
-/*
   create a database
  */
 int ctdb_ctrl_createdb(struct ctdb_context *ctdb, struct timeval timeout,
@@ -1976,80 +1235,6 @@ int ctdb_ctrl_get_debuglevel(struct ctdb
 }
 
 /*
-  set debug level on a node
- */
-int ctdb_ctrl_set_debuglevel(struct ctdb_context *ctdb, uint32_t destnode, int32_t level)
-{
-	int ret;
-	int32_t res;
-	TDB_DATA data;
-
-	data.dptr = (uint8_t *)&level;
-	data.dsize = sizeof(level);
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_SET_DEBUG, 0, data, 
-			   NULL, NULL, &res, NULL, NULL);
-	if (ret != 0 || res != 0) {
-		return -1;
-	}
-	return 0;
-}
-
-
-/*
-  get a list of connected nodes
- */
-uint32_t *ctdb_get_connected_nodes(struct ctdb_context *ctdb, 
-				struct timeval timeout,
-				TALLOC_CTX *mem_ctx,
-				uint32_t *num_nodes)
-{
-	struct ctdb_node_map_old *map=NULL;
-	int ret, i;
-	uint32_t *nodes;
-
-	*num_nodes = 0;
-
-	ret = ctdb_ctrl_getnodemap(ctdb, timeout, CTDB_CURRENT_NODE, mem_ctx, &map);
-	if (ret != 0) {
-		return NULL;
-	}
-
-	nodes = talloc_array(mem_ctx, uint32_t, map->num);
-	if (nodes == NULL) {
-		return NULL;
-	}
-
-	for (i=0;i<map->num;i++) {
-		if (!(map->nodes[i].flags & NODE_FLAGS_DISCONNECTED)) {
-			nodes[*num_nodes] = map->nodes[i].pnn;
-			(*num_nodes)++;
-		}
-	}
-
-	return nodes;
-}
-
-
-/*
-  reset remote status
- */
-int ctdb_statistics_reset(struct ctdb_context *ctdb, uint32_t destnode)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_STATISTICS_RESET, 0, tdb_null, 
-			   NULL, NULL, &res, NULL, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for reset statistics failed\n"));
-		return -1;
-	}
-	return 0;
-}
-
-/*
  * Get db open flags
  */
 int ctdb_ctrl_db_open_flags(struct ctdb_context *ctdb, uint32_t db_id,
@@ -2150,26 +1335,6 @@ struct ctdb_db_context *ctdb_attach(stru
 }
 
 /*
- * detach from a specific database - client call
- */
-int ctdb_detach(struct ctdb_context *ctdb, uint32_t db_id)
-{
-	int ret;
-	int32_t status;
-	TDB_DATA data;
-
-	data.dsize = sizeof(db_id);
-	data.dptr = (uint8_t *)&db_id;
-
-	ret = ctdb_control(ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_DB_DETACH,
-			   0, data, NULL, NULL, &status, NULL, NULL);
-	if (ret != 0 || status != 0) {
-		return -1;
-	}
-	return 0;
-}
-
-/*
   setup a call for a database
  */
 int ctdb_set_call(struct ctdb_db_context *ctdb_db, ctdb_fn_t fn, uint32_t id)
@@ -2185,222 +1350,6 @@ int ctdb_set_call(struct ctdb_db_context
 	return 0;
 }
 
-
-struct traverse_state {
-	bool done;
-	uint32_t count;
-	ctdb_traverse_func fn;
-	void *private_data;
-	bool listemptyrecords;
-};
-
-/*
-  called on each key during a ctdb_traverse
- */
-static void traverse_handler(uint64_t srvid, TDB_DATA data, void *p)
-{
-	struct traverse_state *state = (struct traverse_state *)p;
-	struct ctdb_rec_data_old *d = (struct ctdb_rec_data_old *)data.dptr;
-	TDB_DATA key;
-
-	if (data.dsize < sizeof(uint32_t) || d->length != data.dsize) {
-		DEBUG(DEBUG_ERR, ("Bad data size %u in traverse_handler\n",
-				  (unsigned)data.dsize));
-		state->done = true;
-		return;
-	}
-
-	key.dsize = d->keylen;
-	key.dptr  = &d->data[0];
-	data.dsize = d->datalen;
-	data.dptr = &d->data[d->keylen];
-
-	if (key.dsize == 0 && data.dsize == 0) {
-		/* end of traverse */
-		state->done = true;
-		return;
-	}
-
-	if (!state->listemptyrecords &&
-	    data.dsize == sizeof(struct ctdb_ltdb_header))
-	{
-		/* empty records are deleted records in ctdb */
-		return;
-	}
-
-	if (state->fn(key, data, state->private_data) != 0) {
-		state->done = true;
-	}
-
-	state->count++;
-}
-
-/**
- * start a cluster wide traverse, calling the supplied fn on each record
- * return the number of records traversed, or -1 on error
- *
- * Extendet variant with a flag to signal whether empty records should
- * be listed.
- */
-static int ctdb_traverse_ext(struct ctdb_db_context *ctdb_db,
-			     ctdb_traverse_func fn,
-			     bool withemptyrecords,
-			     void *private_data)
-{
-	TDB_DATA data;
-	struct ctdb_traverse_start_ext t;
-	int32_t status;
-	int ret;
-	uint64_t srvid = (getpid() | 0xFLL<<60);
-	struct traverse_state state;
-
-	state.done = false;
-	state.count = 0;
-	state.private_data = private_data;
-	state.fn = fn;
-	state.listemptyrecords = withemptyrecords;
-
-	ret = ctdb_client_set_message_handler(ctdb_db->ctdb, srvid, traverse_handler, &state);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR,("Failed to setup traverse handler\n"));
-		return -1;
-	}
-
-	t.db_id = ctdb_db->db_id;
-	t.srvid = srvid;
-	t.reqid = 0;
-	t.withemptyrecords = withemptyrecords;
-
-	data.dptr = (uint8_t *)&t;
-	data.dsize = sizeof(t);
-
-	ret = ctdb_control(ctdb_db->ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_TRAVERSE_START_EXT, 0,
-			   data, NULL, NULL, &status, NULL, NULL);
-	if (ret != 0 || status != 0) {
-		DEBUG(DEBUG_ERR,("ctdb_traverse_all failed\n"));
-		ctdb_client_remove_message_handler(ctdb_db->ctdb, srvid, &state);
-		return -1;
-	}
-
-	while (!state.done) {
-		tevent_loop_once(ctdb_db->ctdb->ev);
-	}
-
-	ret = ctdb_client_remove_message_handler(ctdb_db->ctdb, srvid, &state);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR,("Failed to remove ctdb_traverse handler\n"));
-		return -1;
-	}
-
-	return state.count;
-}
-
-/**
- * start a cluster wide traverse, calling the supplied fn on each record
- * return the number of records traversed, or -1 on error
- *
- * Standard version which does not list the empty records:
- * These are considered deleted.
- */
-int ctdb_traverse(struct ctdb_db_context *ctdb_db, ctdb_traverse_func fn, void *private_data)
-{
-	return ctdb_traverse_ext(ctdb_db, fn, false, private_data);
-}
-
-#define ISASCII(x) (isprint(x) && !strchr("\"\\", (x)))
-/*
-  called on each key during a catdb
- */
-int ctdb_dumpdb_record(TDB_DATA key, TDB_DATA data, void *p)
-{
-	int i;
-	struct ctdb_dump_db_context *c = (struct ctdb_dump_db_context *)p;
-	FILE *f = c->f;
-	struct ctdb_ltdb_header *h = (struct ctdb_ltdb_header *)data.dptr;
-
-	fprintf(f, "key(%u) = \"", (unsigned)key.dsize);
-	for (i=0;i<key.dsize;i++) {
-		if (ISASCII(key.dptr[i])) {
-			fprintf(f, "%c", key.dptr[i]);
-		} else {
-			fprintf(f, "\\%02X", key.dptr[i]);
-		}
-	}
-	fprintf(f, "\"\n");
-
-	fprintf(f, "dmaster: %u\n", h->dmaster);
-	fprintf(f, "rsn: %llu\n", (unsigned long long)h->rsn);
-
-	if (c->printlmaster && c->ctdb->vnn_map != NULL) {
-		fprintf(f, "lmaster: %u\n", ctdb_lmaster(c->ctdb, &key));
-	}
-
-	if (c->printhash) {
-		fprintf(f, "hash: 0x%08x\n", ctdb_hash(&key));
-	}
-
-	if (c->printrecordflags) {
-		fprintf(f, "flags: 0x%08x", h->flags);
-		if (h->flags & CTDB_REC_FLAG_MIGRATED_WITH_DATA) printf(" MIGRATED_WITH_DATA");
-		if (h->flags & CTDB_REC_FLAG_VACUUM_MIGRATED) printf(" VACUUM_MIGRATED");
-		if (h->flags & CTDB_REC_FLAG_AUTOMATIC) printf(" AUTOMATIC");
-		if (h->flags & CTDB_REC_RO_HAVE_DELEGATIONS) printf(" RO_HAVE_DELEGATIONS");
-		if (h->flags & CTDB_REC_RO_HAVE_READONLY) printf(" RO_HAVE_READONLY");
-		if (h->flags & CTDB_REC_RO_REVOKING_READONLY) printf(" RO_REVOKING_READONLY");
-		if (h->flags & CTDB_REC_RO_REVOKE_COMPLETE) printf(" RO_REVOKE_COMPLETE");
-		fprintf(f, "\n");
-	}
-
-	if (c->printdatasize) {
-		fprintf(f, "data size: %u\n", (unsigned)data.dsize);
-	} else {
-		fprintf(f, "data(%u) = \"", (unsigned)(data.dsize - sizeof(*h)));
-		for (i=sizeof(*h);i<data.dsize;i++) {
-			if (ISASCII(data.dptr[i])) {
-				fprintf(f, "%c", data.dptr[i]);
-			} else {
-				fprintf(f, "\\%02X", data.dptr[i]);
-			}
-		}
-		fprintf(f, "\"\n");
-	}
-
-	fprintf(f, "\n");
-
-	return 0;
-}
-
-/*
-  convenience function to list all keys to stdout
- */
-int ctdb_dump_db(struct ctdb_db_context *ctdb_db,
-		 struct ctdb_dump_db_context *ctx)
-{
-	return ctdb_traverse_ext(ctdb_db, ctdb_dumpdb_record,
-				 ctx->printemptyrecords, ctx);
-}
-
-/*
-  get the pid of a ctdb daemon
- */
-int ctdb_ctrl_getpid(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, uint32_t *pid)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GET_PID, 0, tdb_null, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for getpid failed\n"));
-		return -1;
-	}
-
-	*pid = res;
-
-	return 0;
-}
-
 /* Freeze all databases */
 int ctdb_ctrl_freeze(struct ctdb_context *ctdb, struct timeval timeout,
 		     uint32_t destnode)
@@ -2438,181 +1387,6 @@ int ctdb_ctrl_getpnn(struct ctdb_context
 	return res;
 }
 
-
-/*
-  sent to a node to make it take over an ip address
-*/
-int ctdb_ctrl_takeover_ip(struct ctdb_context *ctdb, struct timeval timeout,
-			  uint32_t destnode, struct ctdb_public_ip *ip)
-{
-	TDB_DATA data;
-	int ret;
-	int32_t res;
-
-	data.dsize = sizeof(*ip);
-	data.dptr  = (uint8_t *)ip;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_TAKEOVER_IP, 0,
-			   data, NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for takeover_ip failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/*
-  sent to a node to make it release an ip address
-*/
-int ctdb_ctrl_release_ip(struct ctdb_context *ctdb, struct timeval timeout,
-			 uint32_t destnode, struct ctdb_public_ip *ip)
-{
-	TDB_DATA data;
-	int ret;
-	int32_t res;
-
-	data.dsize = sizeof(*ip);
-	data.dptr  = (uint8_t *)ip;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_RELEASE_IP, 0,
-			   data, NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for release_ip failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-
-/*
-  get a tunable
- */
-int ctdb_ctrl_get_tunable(struct ctdb_context *ctdb, 
-			  struct timeval timeout, 
-			  uint32_t destnode,
-			  const char *name, uint32_t *value)
-{
-	struct ctdb_control_get_tunable *t;
-	TDB_DATA data, outdata;
-	int32_t res;
-	int ret;
-
-	data.dsize = offsetof(struct ctdb_control_get_tunable, name) + strlen(name) + 1;
-	data.dptr  = talloc_size(ctdb, data.dsize);
-	CTDB_NO_MEMORY(ctdb, data.dptr);
-
-	t = (struct ctdb_control_get_tunable *)data.dptr;
-	t->length = strlen(name)+1;
-	memcpy(t->name, name, t->length);
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_GET_TUNABLE, 0, data, ctdb,
-			   &outdata, &res, &timeout, NULL);
-	talloc_free(data.dptr);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get_tunable failed\n"));
-		return ret != 0 ? ret : res;
-	}
-
-	if (outdata.dsize != sizeof(uint32_t)) {
-		DEBUG(DEBUG_ERR,("Invalid return data in get_tunable\n"));
-		talloc_free(outdata.dptr);
-		return -1;
-	}
-	
-	*value = *(uint32_t *)outdata.dptr;
-	talloc_free(outdata.dptr);
-
-	return 0;
-}
-
-/*
-  set a tunable
- */
-int ctdb_ctrl_set_tunable(struct ctdb_context *ctdb, 
-			  struct timeval timeout, 
-			  uint32_t destnode,
-			  const char *name, uint32_t value)
-{
-	struct ctdb_tunable_old *t;
-	TDB_DATA data;
-	int32_t res;
-	int ret;
-
-	data.dsize = offsetof(struct ctdb_tunable_old, name) + strlen(name) + 1;
-	data.dptr  = talloc_size(ctdb, data.dsize);
-	CTDB_NO_MEMORY(ctdb, data.dptr);
-
-	t = (struct ctdb_tunable_old *)data.dptr;
-	t->length = strlen(name)+1;
-	memcpy(t->name, name, t->length);
-	t->value = value;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_SET_TUNABLE, 0, data, NULL,
-			   NULL, &res, &timeout, NULL);
-	talloc_free(data.dptr);
-	if ((ret != 0) || (res == -1)) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for set_tunable failed\n"));
-		return -1;
-	}
-
-	return res;
-}
-
-/*
-  list tunables
- */
-int ctdb_ctrl_list_tunables(struct ctdb_context *ctdb, 
-			    struct timeval timeout, 
-			    uint32_t destnode,
-			    TALLOC_CTX *mem_ctx,
-			    const char ***list, uint32_t *count)
-{
-	TDB_DATA outdata;
-	int32_t res;
-	int ret;
-	struct ctdb_control_list_tunable *t;
-	char *p, *s, *ptr;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_LIST_TUNABLES, 0, tdb_null, 
-			   mem_ctx, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for list_tunables failed\n"));
-		return -1;
-	}
-
-	t = (struct ctdb_control_list_tunable *)outdata.dptr;
-	if (outdata.dsize < offsetof(struct ctdb_control_list_tunable, data) ||
-	    t->length > outdata.dsize-offsetof(struct ctdb_control_list_tunable, data)) {
-		DEBUG(DEBUG_ERR,("Invalid data in list_tunables reply\n"));
-		talloc_free(outdata.dptr);
-		return -1;		
-	}
-	
-	p = talloc_strndup(mem_ctx, (char *)t->data, t->length);
-	CTDB_NO_MEMORY(ctdb, p);
-
-	talloc_free(outdata.dptr);
-	
-	(*list) = NULL;
-	(*count) = 0;
-
-	for (s=strtok_r(p, ":", &ptr); s; s=strtok_r(NULL, ":", &ptr)) {
-		(*list) = talloc_realloc(mem_ctx, *list, const char *, 1+(*count));
-		CTDB_NO_MEMORY(ctdb, *list);
-		(*list)[*count] = talloc_strdup(*list, s);
-		CTDB_NO_MEMORY(ctdb, (*list)[*count]);
-		(*count)++;
-	}
-
-	talloc_free(p);
-
-	return 0;
-}
-
-
 int ctdb_ctrl_get_public_ips_flags(struct ctdb_context *ctdb,
 				   struct timeval timeout, uint32_t destnode,
 				   TALLOC_CTX *mem_ctx,
@@ -2649,74 +1423,6 @@ int ctdb_ctrl_get_public_ips(struct ctdb
 					      0, ips);
 }
 
-int ctdb_ctrl_get_public_ip_info(struct ctdb_context *ctdb,
-				 struct timeval timeout, uint32_t destnode,
-				 TALLOC_CTX *mem_ctx,
-				 const ctdb_sock_addr *addr,
-				 struct ctdb_public_ip_info_old **_info)
-{
-	int ret;
-	TDB_DATA indata;
-	TDB_DATA outdata;
-	int32_t res;
-	struct ctdb_public_ip_info_old *info;
-	uint32_t len;
-	uint32_t i;
-
-	indata.dptr = discard_const_p(uint8_t, addr);
-	indata.dsize = sizeof(*addr);
-
-	ret = ctdb_control(ctdb, destnode, 0,
-			   CTDB_CONTROL_GET_PUBLIC_IP_INFO, 0, indata,
-			   mem_ctx, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get public ip info "
-				"failed ret:%d res:%d\n",
-				ret, res));
-		return -1;
-	}
-
-	len = offsetof(struct ctdb_public_ip_info_old, ifaces);
-	if (len > outdata.dsize) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get public ip info "
-				"returned invalid data with size %u > %u\n",
-				(unsigned int)outdata.dsize,
-				(unsigned int)len));
-		dump_data(DEBUG_DEBUG, outdata.dptr, outdata.dsize);
-		return -1;
-	}
-
-	info = (struct ctdb_public_ip_info_old *)outdata.dptr;
-	len += info->num*sizeof(struct ctdb_iface);
-
-	if (len > outdata.dsize) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get public ip info "
-				"returned invalid data with size %u > %u\n",
-				(unsigned int)outdata.dsize,
-				(unsigned int)len));
-		dump_data(DEBUG_DEBUG, outdata.dptr, outdata.dsize);
-		return -1;
-	}
-
-	/* make sure we null terminate the returned strings */
-	for (i=0; i < info->num; i++) {
-		info->ifaces[i].name[CTDB_IFACE_SIZE] = '\0';
-	}
-
-	*_info = (struct ctdb_public_ip_info_old *)talloc_memdup(mem_ctx,
-								outdata.dptr,
-								outdata.dsize);
-	talloc_free(outdata.dptr);
-	if (*_info == NULL) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get public ip info "
-				"talloc_memdup size %u failed\n",
-				(unsigned int)outdata.dsize));
-		return -1;
-	}
-
-	return 0;
-}
-
 int ctdb_ctrl_get_ifaces(struct ctdb_context *ctdb,
 			 struct timeval timeout, uint32_t destnode,
 			 TALLOC_CTX *mem_ctx,
@@ -2780,31 +1486,6 @@ int ctdb_ctrl_get_ifaces(struct ctdb_con
 	return 0;
 }
 
-int ctdb_ctrl_set_iface_link(struct ctdb_context *ctdb,
-			     struct timeval timeout, uint32_t destnode,
-			     TALLOC_CTX *mem_ctx,
-			     const struct ctdb_iface *info)
-{
-	int ret;
-	TDB_DATA indata;
-	int32_t res;
-
-	indata.dptr = discard_const_p(uint8_t, info);
-	indata.dsize = sizeof(*info);
-
-	ret = ctdb_control(ctdb, destnode, 0,
-			   CTDB_CONTROL_SET_IFACE_LINK_STATE, 0, indata,
-			   mem_ctx, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for set iface link "
-				"failed ret:%d res:%d\n",
-				ret, res));
-		return -1;
-	}
-
-	return 0;
-}
-
 /*
   set/clear the permanent disabled bit on a remote node
  */
@@ -2901,122 +1582,6 @@ int ctdb_ctrl_get_all_tunables(struct ct
 }
 
 /*
-  add a public address to a node
- */
-int ctdb_ctrl_add_public_ip(struct ctdb_context *ctdb,
-			    struct timeval timeout, uint32_t destnode,
-			    struct ctdb_addr_info_old *pub)
-{
-	TDB_DATA data;
-	int32_t res;
-	int ret;
-
-	data.dsize = offsetof(struct ctdb_addr_info_old, iface) + pub->len;
-	data.dptr  = (unsigned char *)pub;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_ADD_PUBLIC_IP, 0, data, NULL,
-			   NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for add_public_ip failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  delete a public address from a node
- */
-int ctdb_ctrl_del_public_ip(struct ctdb_context *ctdb,
-			    struct timeval timeout, uint32_t destnode,
-			    struct ctdb_addr_info_old *pub)
-{
-	TDB_DATA data;
-	int32_t res;
-	int ret;
-
-	data.dsize = offsetof(struct ctdb_addr_info_old, iface) + pub->len;
-	data.dptr  = (unsigned char *)pub;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_DEL_PUBLIC_IP, 0, data, NULL,
-			   NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for del_public_ip failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  send a gratious arp
- */
-int ctdb_ctrl_gratious_arp(struct ctdb_context *ctdb,
-			   struct timeval timeout, uint32_t destnode,
-			   ctdb_sock_addr *addr, const char *ifname)
-{
-	TDB_DATA data;
-	int32_t res;
-	int ret, len;
-	struct ctdb_addr_info_old *gratious_arp;
-	TALLOC_CTX *tmp_ctx = talloc_new(ctdb);
-
-
-	len = strlen(ifname)+1;
-	gratious_arp = talloc_size(tmp_ctx,
-		offsetof(struct ctdb_addr_info_old, iface) + len);
-	CTDB_NO_MEMORY(ctdb, gratious_arp);
-
-	gratious_arp->addr = *addr;
-	gratious_arp->len = len;
-	memcpy(&gratious_arp->iface[0], ifname, len);
-
-
-	data.dsize = offsetof(struct ctdb_addr_info_old, iface) + len;
-	data.dptr  = (unsigned char *)gratious_arp;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_SEND_GRATUITOUS_ARP, 0, data, NULL,
-			   NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for gratious_arp failed\n"));
-		talloc_free(tmp_ctx);
-		return -1;
-	}
-
-	talloc_free(tmp_ctx);
-	return 0;
-}
-
-/*
-  get a list of all tcp tickles that a node knows about for a particular vnn
- */
-int ctdb_ctrl_get_tcp_tickles(struct ctdb_context *ctdb, 
-			      struct timeval timeout, uint32_t destnode, 
-			      TALLOC_CTX *mem_ctx, 
-			      ctdb_sock_addr *addr,
-			      struct ctdb_tickle_list_old **list)
-{
-	int ret;
-	TDB_DATA data, outdata;
-	int32_t status;
-
-	data.dptr = (uint8_t*)addr;
-	data.dsize = sizeof(ctdb_sock_addr);
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GET_TCP_TICKLE_LIST, 0, data, 
-			   mem_ctx, &outdata, &status, NULL, NULL);
-	if (ret != 0 || status != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for get tcp tickles failed\n"));
-		return -1;
-	}
-
-	*list = (struct ctdb_tickle_list_old *)outdata.dptr;
-
-	return status;
-}
-
-/*
   initialise the ctdb daemon for client applications
 
   NOTE: In current code the daemon does not fork. This is for testing purposes only
@@ -3093,62 +1658,6 @@ uint32_t ctdb_get_pnn(struct ctdb_contex
 	return ctdb->pnn;
 }
 
-
-/*
-  get the uptime of a remote node
- */
-struct ctdb_client_control_state *
-ctdb_ctrl_uptime_send(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx, struct timeval timeout, uint32_t destnode)
-{
-	return ctdb_control_send(ctdb, destnode, 0, 
-			   CTDB_CONTROL_UPTIME, 0, tdb_null, 
-			   mem_ctx, &timeout, NULL);
-}
-
-int ctdb_ctrl_uptime_recv(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx, struct ctdb_client_control_state *state, struct ctdb_uptime **uptime)
-{
-	int ret;
-	int32_t res;
-	TDB_DATA outdata;
-
-	ret = ctdb_control_recv(ctdb, state, mem_ctx, &outdata, &res, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_ctrl_uptime_recv failed\n"));
-		return -1;
-	}
-
-	*uptime = (struct ctdb_uptime *)talloc_steal(mem_ctx, outdata.dptr);
-
-	return 0;
-}
-
-int ctdb_ctrl_uptime(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx, struct timeval timeout, uint32_t destnode, struct ctdb_uptime **uptime)
-{
-	struct ctdb_client_control_state *state;
-
-	state = ctdb_ctrl_uptime_send(ctdb, mem_ctx, timeout, destnode);
-	return ctdb_ctrl_uptime_recv(ctdb, mem_ctx, state, uptime);
-}
-
-/*
-  send a control to execute the "recovered" event script on a node
- */
-int ctdb_ctrl_end_recovery(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode)
-{
-	int ret;
-	int32_t status;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_END_RECOVERY, 0, tdb_null, 
-			   NULL, NULL, &status, &timeout, NULL);
-	if (ret != 0 || status != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for end_recovery failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
 /* 
   callback for the async helpers used when sending the same control
   to multiple nodes in parallell.
@@ -3375,40 +1884,6 @@ uint32_t *list_of_connected_nodes(struct
 			     include_self ? -1 : ctdb->pnn);
 }
 
-/* 
-  this is used to test if a pnn lock exists and if it exists will return
-  the number of connections that pnn has reported or -1 if that recovery
-  daemon is not running.
-*/
-int
-ctdb_read_pnn_lock(int fd, int32_t pnn)
-{
-	struct flock lock;
-	char c;
-
-	lock.l_type = F_WRLCK;
-	lock.l_whence = SEEK_SET;
-	lock.l_start = pnn;
-	lock.l_len = 1;
-	lock.l_pid = 0;
-
-	if (fcntl(fd, F_GETLK, &lock) != 0) {
-		DEBUG(DEBUG_ERR, (__location__ " F_GETLK failed with %s\n", strerror(errno)));
-		return -1;
-	}
-
-	if (lock.l_type == F_UNLCK) {
-		return -1;
-	}
-
-	if (pread(fd, &c, 1, pnn) == -1) {
-		DEBUG(DEBUG_CRIT,(__location__ " failed read pnn count - %s\n", strerror(errno)));
-		return -1;
-	}
-
-	return c;
-}
-
 /*
   get capabilities of a remote node
  */
@@ -3528,532 +2003,6 @@ bool ctdb_node_has_capabilities(struct c
 		((*capp & capabilities_required) == capabilities_required);
 }
 
-
-static struct ctdb_server_id server_id_fetch(struct ctdb_context *ctdb, uint32_t reqid)
-{
-	struct ctdb_server_id id;
-
-	id.pid = getpid();
-	id.task_id = reqid;
-	id.vnn = ctdb_get_pnn(ctdb);
-	id.unique_id = id.vnn;
-	id.unique_id = (id.unique_id << 32) | reqid;
-
-	return id;
-}
-
-/* This is basically a copy from Samba's server_id.*.  However, a
- * dependency chain stops us from using Samba's version, so use a
- * renamed copy until a better solution is found. */
-static bool ctdb_server_id_equal(struct ctdb_server_id *id1, struct ctdb_server_id *id2)
-{
-	if (id1->pid != id2->pid) {
-		return false;
-	}
-
-	if (id1->task_id != id2->task_id) {
-		return false;
-	}
-
-	if (id1->vnn != id2->vnn) {
-		return false;
-	}
-
-	if (id1->unique_id != id2->unique_id) {
-		return false;
-	}
-
-	return true;
-}
-
-static bool server_id_exists(struct ctdb_context *ctdb,
-			     struct ctdb_server_id *id)
-{
-	int ret;
-
-	ret = ctdb_ctrl_process_exists(ctdb, id->vnn, id->pid);
-	if (ret == 0) {
-		return true;
-	}
-
-	return false;
-}
-
-static bool g_lock_parse(TALLOC_CTX *mem_ctx, TDB_DATA data,
-			 struct ctdb_g_lock_list **locks)
-{
-	struct ctdb_g_lock_list *recs;
-
-	recs = talloc_zero(mem_ctx, struct ctdb_g_lock_list);
-	if (recs == NULL) {
-		return false;
-	}
-
-	if (data.dsize == 0) {
-		goto done;
-	}
-
-	if (data.dsize % sizeof(struct ctdb_g_lock) != 0) {
-		DEBUG(DEBUG_ERR, (__location__ "invalid data size %lu in g_lock record\n",
-				  (unsigned long)data.dsize));
-		talloc_free(recs);
-		return false;
-	}
-
-	recs->num = data.dsize / sizeof(struct ctdb_g_lock);
-	recs->lock = talloc_memdup(mem_ctx, data.dptr, data.dsize);
-	if (recs->lock == NULL) {
-		talloc_free(recs);
-		return false;
-	}
-
-done:
-	if (locks != NULL) {
-		*locks = recs;
-	}
-
-	return true;
-}
-
-
-static bool g_lock_lock(TALLOC_CTX *mem_ctx,
-			struct ctdb_db_context *ctdb_db,
-			const char *keyname, uint32_t reqid)
-{
-	TDB_DATA key, data;
-	struct ctdb_record_handle *h;
-	struct ctdb_g_lock_list *locks;
-	struct ctdb_server_id id;
-	struct timeval t_start;
-	int i;
-
-	key.dptr = (uint8_t *)discard_const(keyname);
-	key.dsize = strlen(keyname) + 1;
-
-	t_start = timeval_current();
-
-again:
-	/* Keep trying for an hour. */
-	if (timeval_elapsed(&t_start) > 3600) {
-		return false;
-	}
-
-	h = ctdb_fetch_lock(ctdb_db, mem_ctx, key, &data);
-	if (h == NULL) {
-		return false;
-	}
-
-	if (!g_lock_parse(h, data, &locks)) {
-		DEBUG(DEBUG_ERR, ("g_lock: error parsing locks\n"));
-		talloc_free(data.dptr);
-		talloc_free(h);
-		return false;
-	}
-
-	talloc_free(data.dptr);
-
-	id = server_id_fetch(ctdb_db->ctdb, reqid);
-
-	i = 0;
-	while (i < locks->num) {
-		if (ctdb_server_id_equal(&locks->lock[i].sid, &id)) {
-			/* Internal error */
-			talloc_free(h);
-			return false;
-		}
-
-		if (!server_id_exists(ctdb_db->ctdb, &locks->lock[i].sid)) {
-			if (i < locks->num-1) {
-				locks->lock[i] = locks->lock[locks->num-1];
-			}
-			locks->num--;
-			continue;
-		}
-
-		/* This entry is locked. */
-		DEBUG(DEBUG_INFO, ("g_lock: lock already granted for "
-				   "pid=0x%llx taskid=%x vnn=%d id=0x%llx\n",
-				   (unsigned long long)id.pid,
-				   id.task_id, id.vnn,
-				   (unsigned long long)id.unique_id));
-		talloc_free(h);
-		goto again;
-	}
-
-	locks->lock = talloc_realloc(locks, locks->lock, struct ctdb_g_lock,
-				     locks->num+1);
-	if (locks->lock == NULL) {
-		talloc_free(h);
-		return false;
-	}
-
-	locks->lock[locks->num].type = CTDB_G_LOCK_WRITE;
-	locks->lock[locks->num].sid = id;
-	locks->num++;
-
-	data.dptr = (uint8_t *)locks->lock;
-	data.dsize = locks->num * sizeof(struct ctdb_g_lock);
-
-	if (ctdb_record_store(h, data) != 0) {
-		DEBUG(DEBUG_ERR, ("g_lock: failed to write transaction lock for "
-				  "pid=0x%llx taskid=%x vnn=%d id=0x%llx\n",
-				  (unsigned long long)id.pid,
-				  id.task_id, id.vnn,
-				  (unsigned long long)id.unique_id));
-		talloc_free(h);
-		return false;
-	}
-
-	DEBUG(DEBUG_INFO, ("g_lock: lock granted for "
-			   "pid=0x%llx taskid=%x vnn=%d id=0x%llx\n",
-			   (unsigned long long)id.pid,
-			   id.task_id, id.vnn,
-			   (unsigned long long)id.unique_id));
-
-	talloc_free(h);
-	return true;
-}
-
-static bool g_lock_unlock(TALLOC_CTX *mem_ctx,
-			  struct ctdb_db_context *ctdb_db,
-			  const char *keyname, uint32_t reqid)
-{
-	TDB_DATA key, data;
-	struct ctdb_record_handle *h;
-	struct ctdb_g_lock_list *locks;
-	struct ctdb_server_id id;
-	int i;
-	bool found = false;
-
-	key.dptr = (uint8_t *)discard_const(keyname);
-	key.dsize = strlen(keyname) + 1;
-	h = ctdb_fetch_lock(ctdb_db, mem_ctx, key, &data);
-	if (h == NULL) {
-		return false;
-	}
-
-	if (!g_lock_parse(h, data, &locks)) {
-		DEBUG(DEBUG_ERR, ("g_lock: error parsing locks\n"));
-		talloc_free(data.dptr);
-		talloc_free(h);
-		return false;
-	}
-
-	talloc_free(data.dptr);
-
-	id = server_id_fetch(ctdb_db->ctdb, reqid);
-
-	for (i=0; i<locks->num; i++) {
-		if (ctdb_server_id_equal(&locks->lock[i].sid, &id)) {
-			if (i < locks->num-1) {
-				locks->lock[i] = locks->lock[locks->num-1];
-			}
-			locks->num--;
-			found = true;
-			break;
-		}
-	}
-
-	if (!found) {
-		DEBUG(DEBUG_ERR, ("g_lock: lock not found\n"));
-		talloc_free(h);
-		return false;
-	}
-
-	data.dptr = (uint8_t *)locks->lock;
-	data.dsize = locks->num * sizeof(struct ctdb_g_lock);
-
-	if (ctdb_record_store(h, data) != 0) {
-		talloc_free(h);
-		return false;
-	}
-
-	talloc_free(h);
-	return true;
-}
-
-
-struct ctdb_transaction_handle {
-	struct ctdb_db_context *ctdb_db;
-	struct ctdb_db_context *g_lock_db;
-	char *lock_name;
-	uint32_t reqid;
-	/*
-	 * we store reads and writes done under a transaction:
-	 * - one list stores both reads and writes (m_all)
-	 * - the other just writes (m_write)
-	 */
-	struct ctdb_marshall_buffer *m_all;
-	struct ctdb_marshall_buffer *m_write;
-};
-
-static int ctdb_transaction_destructor(struct ctdb_transaction_handle *h)
-{
-	g_lock_unlock(h, h->g_lock_db, h->lock_name, h->reqid);
-	reqid_remove(h->ctdb_db->ctdb->idr, h->reqid);
-	return 0;
-}
-
-
-/**
- * start a transaction on a database
- */
-struct ctdb_transaction_handle *ctdb_transaction_start(struct ctdb_db_context *ctdb_db,
-						       TALLOC_CTX *mem_ctx)
-{
-	struct ctdb_transaction_handle *h;
-
-	h = talloc_zero(mem_ctx, struct ctdb_transaction_handle);
-	if (h == NULL) {
-		DEBUG(DEBUG_ERR, (__location__ " memory allocation error\n"));
-		return NULL;
-	}
-
-	h->ctdb_db = ctdb_db;
-	h->lock_name = talloc_asprintf(h, "transaction_db_0x%08x",
-				       (unsigned int)ctdb_db->db_id);
-	if (h->lock_name == NULL) {
-		DEBUG(DEBUG_ERR, (__location__ " talloc asprintf failed\n"));
-		talloc_free(h);
-		return NULL;
-	}
-
-	h->g_lock_db = ctdb_attach(h->ctdb_db->ctdb, timeval_current_ofs(3,0),
-				   "g_lock.tdb", 0);
-	if (!h->g_lock_db) {
-		DEBUG(DEBUG_ERR, (__location__ " unable to attach to g_lock.tdb\n"));
-		talloc_free(h);
-		return NULL;
-	}
-
-	h->reqid = reqid_new(h->ctdb_db->ctdb->idr, h);
-
-	if (!g_lock_lock(h, h->g_lock_db, h->lock_name, h->reqid)) {
-		DEBUG(DEBUG_ERR, (__location__ " Error locking g_lock.tdb\n"));
-		talloc_free(h);
-		return NULL;
-	}
-
-	talloc_set_destructor(h, ctdb_transaction_destructor);
-	return h;
-}
-
-/**
- * fetch a record inside a transaction
- */
-int ctdb_transaction_fetch(struct ctdb_transaction_handle *h,
-			   TALLOC_CTX *mem_ctx,
-			   TDB_DATA key, TDB_DATA *data)
-{
-	struct ctdb_ltdb_header header;
-	int ret;
-
-	ZERO_STRUCT(header);
-
-	ret = ctdb_ltdb_fetch(h->ctdb_db, key, &header, mem_ctx, data);
-	if (ret == -1 && header.dmaster == (uint32_t)-1) {
-		/* record doesn't exist yet */
-		*data = tdb_null;
-		ret = 0;
-	}
-
-	if (ret != 0) {
-		return ret;
-	}
-
-	h->m_all = ctdb_marshall_add(h, h->m_all, h->ctdb_db->db_id, 1, key, NULL, *data);
-	if (h->m_all == NULL) {
-		DEBUG(DEBUG_ERR,(__location__ " Failed to add to marshalling record\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/**
- * stores a record inside a transaction
- */
-int ctdb_transaction_store(struct ctdb_transaction_handle *h,
-			   TDB_DATA key, TDB_DATA data)
-{
-	TALLOC_CTX *tmp_ctx = talloc_new(h);
-	struct ctdb_ltdb_header header;
-	TDB_DATA olddata;
-	int ret;
-
-	/* we need the header so we can update the RSN */
-	ret = ctdb_ltdb_fetch(h->ctdb_db, key, &header, tmp_ctx, &olddata);
-	if (ret == -1 && header.dmaster == (uint32_t)-1) {
-		/* the record doesn't exist - create one with us as dmaster.
-		   This is only safe because we are in a transaction and this
-		   is a persistent database */
-		ZERO_STRUCT(header);
-	} else if (ret != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " Failed to fetch record\n"));
-		talloc_free(tmp_ctx);
-		return ret;
-	}
-
-	if (data.dsize == olddata.dsize &&
-	    memcmp(data.dptr, olddata.dptr, data.dsize) == 0 &&
-	    header.rsn != 0) {
-		/* save writing the same data */
-		talloc_free(tmp_ctx);
-		return 0;
-	}
-
-	header.dmaster = h->ctdb_db->ctdb->pnn;
-	header.rsn++;
-
-	h->m_all = ctdb_marshall_add(h, h->m_all, h->ctdb_db->db_id, 0, key, NULL, data);
-	if (h->m_all == NULL) {
-		DEBUG(DEBUG_ERR,(__location__ " Failed to add to marshalling record\n"));
-		talloc_free(tmp_ctx);
-		return -1;
-	}
-
-	h->m_write = ctdb_marshall_add(h, h->m_write, h->ctdb_db->db_id, 0, key, &header, data);
-	if (h->m_write == NULL) {
-		DEBUG(DEBUG_ERR,(__location__ " Failed to add to marshalling record\n"));
-		talloc_free(tmp_ctx);
-		return -1;
-	}
-
-	talloc_free(tmp_ctx);
-	return 0;
-}
-
-static int ctdb_fetch_db_seqnum(struct ctdb_db_context *ctdb_db, uint64_t *seqnum)
-{
-	const char *keyname = CTDB_DB_SEQNUM_KEY;
-	TDB_DATA key, data;
-	struct ctdb_ltdb_header header;
-	int ret;
-
-	key.dptr = (uint8_t *)discard_const(keyname);
-	key.dsize = strlen(keyname) + 1;
-
-	ret = ctdb_ltdb_fetch(ctdb_db, key, &header, ctdb_db, &data);
-	if (ret != 0) {
-		*seqnum = 0;
-		return 0;
-	}
-
-	if (data.dsize == 0) {
-		*seqnum = 0;
-		return 0;
-	}
-
-	if (data.dsize != sizeof(*seqnum)) {
-		DEBUG(DEBUG_ERR, (__location__ " Invalid data received len=%zi\n",
-				  data.dsize));
-		talloc_free(data.dptr);
-		return -1;
-	}
-
-	*seqnum = *(uint64_t *)data.dptr;
-	talloc_free(data.dptr);
-
-	return 0;
-}
-
-
-static int ctdb_store_db_seqnum(struct ctdb_transaction_handle *h,
-				uint64_t seqnum)
-{
-	const char *keyname = CTDB_DB_SEQNUM_KEY;
-	TDB_DATA key, data;
-
-	key.dptr = (uint8_t *)discard_const(keyname);
-	key.dsize = strlen(keyname) + 1;
-
-	data.dptr = (uint8_t *)&seqnum;
-	data.dsize = sizeof(seqnum);
-
-	return ctdb_transaction_store(h, key, data);
-}
-
-
-/**
- * commit a transaction
- */
-int ctdb_transaction_commit(struct ctdb_transaction_handle *h)
-{
-	int ret;
-	uint64_t old_seqnum, new_seqnum;
-	int32_t status;
-	struct timeval timeout;
-
-	if (h->m_write == NULL) {
-		/* no changes were made */
-		talloc_free(h);
-		return 0;
-	}
-
-	ret = ctdb_fetch_db_seqnum(h->ctdb_db, &old_seqnum);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR, (__location__ " failed to fetch db sequence number\n"));
-		ret = -1;
-		goto done;
-	}
-
-	new_seqnum = old_seqnum + 1;
-	ret = ctdb_store_db_seqnum(h, new_seqnum);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR, (__location__ " failed to store db sequence number\n"));
-		ret = -1;
-		goto done;
-	}
-
-again:
-	timeout = timeval_current_ofs(30,0);
-	ret = ctdb_control(h->ctdb_db->ctdb, CTDB_CURRENT_NODE,
-			   h->ctdb_db->db_id,
-			   CTDB_CONTROL_TRANS3_COMMIT, 0,
-			   ctdb_marshall_finish(h->m_write), NULL, NULL,
-			   &status, &timeout, NULL);
-	if (ret != 0 || status != 0) {
-		/*
-		 * TRANS3_COMMIT control will only fail if recovery has been
-		 * triggered.  Check if the database has been updated or not.
-		 */
-		ret = ctdb_fetch_db_seqnum(h->ctdb_db, &new_seqnum);
-		if (ret != 0) {
-			DEBUG(DEBUG_ERR, (__location__ " failed to fetch db sequence number\n"));
-			goto done;
-		}
-
-		if (new_seqnum == old_seqnum) {
-			/* Database not yet updated, try again */
-			goto again;
-		}
-
-		if (new_seqnum != (old_seqnum + 1)) {
-			DEBUG(DEBUG_ERR, (__location__ " new seqnum [%llu] != old seqnum [%llu] + 1\n",
-					  (long long unsigned)new_seqnum,
-					  (long long unsigned)old_seqnum));
-			ret = -1;
-			goto done;
-		}
-	}
-
-	ret = 0;
-
-done:
-	talloc_free(h);
-	return ret;
-}
-
-/**
- * cancel a transaction
- */
-int ctdb_transaction_cancel(struct ctdb_transaction_handle *h)
-{
-	talloc_free(h);
-	return 0;
-}
-
-
 /*
   recovery daemon ping to main daemon
  */
@@ -4062,7 +2011,7 @@ int ctdb_ctrl_recd_ping(struct ctdb_cont
 	int ret;
 	int32_t res;
 
-	ret = ctdb_control(ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_RECD_PING, 0, tdb_null, 
+	ret = ctdb_control(ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_RECD_PING, 0, tdb_null,
 			   ctdb, NULL, &res, NULL, NULL);
 	if (ret != 0 || res != 0) {
 		DEBUG(DEBUG_ERR,("Failed to send recd ping\n"));
@@ -4084,7 +2033,7 @@ int ctdb_ctrl_report_recd_lock_latency(s
 	data.dptr = (uint8_t *)&latency;
 	data.dsize = sizeof(latency);
 
-	ret = ctdb_control(ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_RECD_RECLOCK_LATENCY, 0, data, 
+	ret = ctdb_control(ctdb, CTDB_CURRENT_NODE, 0, CTDB_CONTROL_RECD_RECLOCK_LATENCY, 0, data,
 			   ctdb, NULL, &res, NULL, NULL);
 	if (ret != 0 || res != 0) {
 		DEBUG(DEBUG_ERR,("Failed to send recd reclock latency\n"));
@@ -4094,115 +2043,6 @@ int ctdb_ctrl_report_recd_lock_latency(s
 	return 0;
 }
 
-/*
-  get the name of the reclock file
- */
-int ctdb_ctrl_getreclock(struct ctdb_context *ctdb, struct timeval timeout,
-			 uint32_t destnode, TALLOC_CTX *mem_ctx,
-			 const char **name)
-{
-	int ret;
-	int32_t res;
-	TDB_DATA data;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GET_RECLOCK_FILE, 0, tdb_null, 
-			   mem_ctx, &data, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		return -1;
-	}
-
-	if (data.dsize == 0) {
-		*name = NULL;
-	} else {
-		*name = talloc_strdup(mem_ctx, discard_const(data.dptr));
-	}
-	talloc_free(data.dptr);
-
-	return 0;
-}
-
-/*
-  stop a node
- */
-int ctdb_ctrl_stop_node(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_STOP_NODE, 0, tdb_null, 
-			   ctdb, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,("Failed to stop node\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  continue a node
- */
-int ctdb_ctrl_continue_node(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode)
-{
-	int ret;
-
-	ret = ctdb_control(ctdb, destnode, 0, CTDB_CONTROL_CONTINUE_NODE, 0, tdb_null, 
-			   ctdb, NULL, NULL, &timeout, NULL);
-	if (ret != 0) {
-		DEBUG(DEBUG_ERR,("Failed to continue node\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  set the lmaster role for a node
- */
-int ctdb_ctrl_setlmasterrole(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, uint32_t lmasterrole)
-{
-	int ret;
-	TDB_DATA data;
-	int32_t res;
-
-	data.dsize = sizeof(lmasterrole);
-	data.dptr  = (uint8_t *)&lmasterrole;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_LMASTERROLE, 0, data, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for setlmasterrole failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
-/*
-  set the recmaster role for a node
- */
-int ctdb_ctrl_setrecmasterrole(struct ctdb_context *ctdb, struct timeval timeout, uint32_t destnode, uint32_t recmasterrole)
-{
-	int ret;
-	TDB_DATA data;
-	int32_t res;
-
-	data.dsize = sizeof(recmasterrole);
-	data.dptr  = (uint8_t *)&recmasterrole;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_RECMASTERROLE, 0, data, 
-			   NULL, NULL, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for setrecmasterrole failed\n"));
-		return -1;
-	}
-
-	return 0;
-}
-
 int ctdb_ctrl_set_ban(struct ctdb_context *ctdb, struct timeval timeout,
 		      uint32_t destnode, struct ctdb_ban_state *bantime)
 {
@@ -4213,8 +2053,8 @@ int ctdb_ctrl_set_ban(struct ctdb_contex
 	data.dsize = sizeof(*bantime);
 	data.dptr  = (uint8_t *)bantime;
 
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_BAN_STATE, 0, data, 
+	ret = ctdb_control(ctdb, destnode, 0,
+			   CTDB_CONTROL_SET_BAN_STATE, 0, data,
 			   NULL, NULL, &res, &timeout, NULL);
 	if (ret != 0 || res != 0) {
 		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for set ban state failed\n"));
@@ -4224,66 +2064,6 @@ int ctdb_ctrl_set_ban(struct ctdb_contex
 	return 0;
 }
 
-
-int ctdb_ctrl_get_ban(struct ctdb_context *ctdb, struct timeval timeout,
-		      uint32_t destnode, TALLOC_CTX *mem_ctx,
-		      struct ctdb_ban_state **bantime)
-{
-	int ret;
-	TDB_DATA outdata;
-	int32_t res;
-	TALLOC_CTX *tmp_ctx = talloc_new(NULL);
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GET_BAN_STATE, 0, tdb_null,
-			   tmp_ctx, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for set ban state failed\n"));
-		talloc_free(tmp_ctx);
-		return -1;
-	}
-
-	*bantime = (struct ctdb_ban_state *)talloc_steal(mem_ctx, outdata.dptr);
-	talloc_free(tmp_ctx);
-
-	return 0;
-}
-
-int ctdb_ctrl_getstathistory(struct ctdb_context *ctdb,
-			     struct timeval timeout, uint32_t destnode,
-			     TALLOC_CTX *mem_ctx,
-			     struct ctdb_statistics_list_old **stats)
-{
-	int ret;
-	TDB_DATA outdata;
-	int32_t res;
-
-	ret = ctdb_control(ctdb, destnode, 0, 
-			   CTDB_CONTROL_GET_STAT_HISTORY, 0, tdb_null, 
-			   mem_ctx, &outdata, &res, &timeout, NULL);
-	if (ret != 0 || res != 0 || outdata.dsize == 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_control for getstathistory failed ret:%d res:%d\n", ret, res));
-		return -1;
-	}
-
-	*stats = (struct ctdb_statistics_list_old *)talloc_memdup(mem_ctx,
-								  outdata.dptr,
-								  outdata.dsize);
-	talloc_free(outdata.dptr);
-
-	return 0;
-}
-
-struct ctdb_ltdb_header *ctdb_header_from_record_handle(struct ctdb_record_handle *h)
-{
-	if (h == NULL) {
-		return NULL;
-	}
-
-	return &h->header;
-}
-
-
 struct ctdb_client_control_state *
 ctdb_ctrl_updaterecord_send(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx, struct timeval timeout, uint32_t destnode, struct ctdb_db_context *ctdb_db, TDB_DATA key, struct ctdb_ltdb_header *header, TDB_DATA data)
 {
@@ -4319,7 +2099,7 @@ ctdb_ctrl_updaterecord_send(struct ctdb_
 	outdata.dptr = (uint8_t *)m;
 	outdata.dsize = talloc_get_size(m);
 
-	handle = ctdb_control_send(ctdb, destnode, 0, 
+	handle = ctdb_control_send(ctdb, destnode, 0,
 			   CTDB_CONTROL_UPDATE_RECORD, 0, outdata,
 			   mem_ctx, &timeout, NULL);
 	talloc_free(m);
@@ -4348,84 +2128,3 @@ ctdb_ctrl_updaterecord(struct ctdb_conte
 	state = ctdb_ctrl_updaterecord_send(ctdb, mem_ctx, timeout, destnode, ctdb_db, key, header, data);
 	return ctdb_ctrl_updaterecord_recv(ctdb, state);
 }
-
-
-
-
-
-
-/*
-  set a database to be readonly
- */
-struct ctdb_client_control_state *
-ctdb_ctrl_set_db_readonly_send(struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid)
-{
-	TDB_DATA data;
-
-	data.dptr = (uint8_t *)&dbid;
-	data.dsize = sizeof(dbid);
-
-	return ctdb_control_send(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_DB_READONLY, 0, data, 
-			   ctdb, NULL, NULL);
-}
-
-int ctdb_ctrl_set_db_readonly_recv(struct ctdb_context *ctdb, struct ctdb_client_control_state *state)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control_recv(ctdb, state, ctdb, NULL, &res, NULL);
-	if (ret != 0 || res != 0) {
-	  DEBUG(DEBUG_ERR,(__location__ " ctdb_ctrl_set_db_readonly_recv failed  ret:%d res:%d\n", ret, res));
-		return -1;
-	}
-
-	return 0;
-}
-
-int ctdb_ctrl_set_db_readonly(struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid)
-{
-	struct ctdb_client_control_state *state;
-
-	state = ctdb_ctrl_set_db_readonly_send(ctdb, destnode, dbid);
-	return ctdb_ctrl_set_db_readonly_recv(ctdb, state);
-}
-
-/*
-  set a database to be sticky
- */
-struct ctdb_client_control_state *
-ctdb_ctrl_set_db_sticky_send(struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid)
-{
-	TDB_DATA data;
-
-	data.dptr = (uint8_t *)&dbid;
-	data.dsize = sizeof(dbid);
-
-	return ctdb_control_send(ctdb, destnode, 0, 
-			   CTDB_CONTROL_SET_DB_STICKY, 0, data, 
-			   ctdb, NULL, NULL);
-}
-
-int ctdb_ctrl_set_db_sticky_recv(struct ctdb_context *ctdb, struct ctdb_client_control_state *state)
-{
-	int ret;
-	int32_t res;
-
-	ret = ctdb_control_recv(ctdb, state, ctdb, NULL, &res, NULL);
-	if (ret != 0 || res != 0) {
-		DEBUG(DEBUG_ERR,(__location__ " ctdb_ctrl_set_db_sticky_recv failed  ret:%d res:%d\n", ret, res));
-		return -1;
-	}
-
-	return 0;
-}
-
-int ctdb_ctrl_set_db_sticky(struct ctdb_context *ctdb, uint32_t destnode, uint32_t dbid)
-{
-	struct ctdb_client_control_state *state;
-
-	state = ctdb_ctrl_set_db_sticky_send(ctdb, destnode, dbid);
-	return ctdb_ctrl_set_db_sticky_recv(ctdb, state);
-}
diff -Npur samba-4.8.1/ctdb/doc/ctdb-etcd.7 samba-4.8.2/ctdb/doc/ctdb-etcd.7
--- samba-4.8.1/ctdb/doc/ctdb-etcd.7	2018-04-26 09:25:24.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb-etcd.7	2018-05-16 12:14:56.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb-etcd
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB\-ETCD" "7" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB\-ETCD" "7" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb-statistics.7 samba-4.8.2/ctdb/doc/ctdb-statistics.7
--- samba-4.8.1/ctdb/doc/ctdb-statistics.7	2018-04-26 09:25:23.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb-statistics.7	2018-05-16 12:14:55.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb-statistics
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB\-STATISTICS" "7" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB\-STATISTICS" "7" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb-tunables.7 samba-4.8.2/ctdb/doc/ctdb-tunables.7
--- samba-4.8.1/ctdb/doc/ctdb-tunables.7	2018-04-26 09:25:23.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb-tunables.7	2018-05-16 12:14:55.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb-tunables
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB\-TUNABLES" "7" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB\-TUNABLES" "7" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb.1 samba-4.8.2/ctdb/doc/ctdb.1
--- samba-4.8.1/ctdb/doc/ctdb.1	2018-04-26 09:25:20.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb.1	2018-05-16 12:14:51.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb.7 samba-4.8.2/ctdb/doc/ctdb.7
--- samba-4.8.1/ctdb/doc/ctdb.7	2018-04-26 09:25:23.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb.7	2018-05-16 12:14:54.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB" "7" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB" "7" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb_diagnostics.1 samba-4.8.2/ctdb/doc/ctdb_diagnostics.1
--- samba-4.8.1/ctdb/doc/ctdb_diagnostics.1	2018-04-26 09:25:21.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb_diagnostics.1	2018-05-16 12:14:53.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdb_diagnostics
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDB_DIAGNOSTICS" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDB_DIAGNOSTICS" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdb_mutex_ceph_rados_helper.7 samba-4.8.2/ctdb/doc/ctdb_mutex_ceph_rados_helper.7
--- samba-4.8.1/ctdb/doc/ctdb_mutex_ceph_rados_helper.7	2018-04-26 09:25:24.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdb_mutex_ceph_rados_helper.7	2018-05-16 12:14:56.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: Ceph RADOS Mutex
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CEPH RADOS MUTEX" "7" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CEPH RADOS MUTEX" "7" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdbd.1 samba-4.8.2/ctdb/doc/ctdbd.1
--- samba-4.8.1/ctdb/doc/ctdbd.1	2018-04-26 09:25:20.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdbd.1	2018-05-16 12:14:52.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdbd
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDBD" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDBD" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdbd.conf.5 samba-4.8.2/ctdb/doc/ctdbd.conf.5
--- samba-4.8.1/ctdb/doc/ctdbd.conf.5	2018-04-26 09:25:22.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdbd.conf.5	2018-05-16 12:14:54.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdbd.conf
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDBD\&.CONF" "5" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDBD\&.CONF" "5" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ctdbd_wrapper.1 samba-4.8.2/ctdb/doc/ctdbd_wrapper.1
--- samba-4.8.1/ctdb/doc/ctdbd_wrapper.1	2018-04-26 09:25:22.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ctdbd_wrapper.1	2018-05-16 12:14:53.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ctdbd_wrapper
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "CTDBD_WRAPPER" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "CTDBD_WRAPPER" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ltdbtool.1 samba-4.8.2/ctdb/doc/ltdbtool.1
--- samba-4.8.1/ctdb/doc/ltdbtool.1	2018-04-26 09:25:21.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ltdbtool.1	2018-05-16 12:14:52.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ltdbtool
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "LTDBTOOL" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "LTDBTOOL" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/onnode.1 samba-4.8.2/ctdb/doc/onnode.1
--- samba-4.8.1/ctdb/doc/onnode.1	2018-04-26 09:25:22.000000000 +0200
+++ samba-4.8.2/ctdb/doc/onnode.1	2018-05-16 12:14:54.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: onnode
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "ONNODE" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "ONNODE" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/doc/ping_pong.1 samba-4.8.2/ctdb/doc/ping_pong.1
--- samba-4.8.1/ctdb/doc/ping_pong.1	2018-04-26 09:25:21.000000000 +0200
+++ samba-4.8.2/ctdb/doc/ping_pong.1	2018-05-16 12:14:53.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ping_pong
 .\"    Author: 
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: CTDB - clustered TDB database
 .\"    Source: ctdb
 .\"  Language: English
 .\"
-.TH "PING_PONG" "1" "04/26/2018" "ctdb" "CTDB \- clustered TDB database"
+.TH "PING_PONG" "1" "05/16/2018" "ctdb" "CTDB \- clustered TDB database"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/ctdb/include/ctdb_client.h samba-4.8.2/ctdb/include/ctdb_client.h
--- samba-4.8.1/ctdb/include/ctdb_client.h	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/ctdb/include/ctdb_client.h	2018-05-16 12:09:25.000000000 +0200
@@ -100,24 +100,6 @@ int ctdb_client_remove_message_handler(s
 int ctdb_client_send_message(struct ctdb_context *ctdb, uint32_t pnn,
 			     uint64_t srvid, TDB_DATA data);
 
-/*
-   Fetch a ctdb record from a remote node. Underneath this will force the
-   dmaster for the record to be moved to the local node.
-*/
-struct ctdb_record_handle *ctdb_fetch_lock(struct ctdb_db_context *ctdb_db,
-					   TALLOC_CTX *mem_ctx,
-					   TDB_DATA key, TDB_DATA *data);
-
-struct ctdb_record_handle *ctdb_fetch_readonly_lock(
-					struct ctdb_db_context *ctdb_db,
-					TALLOC_CTX *mem_ctx, TDB_DATA key,
-					TDB_DATA *data, int read_only);
-
-int ctdb_record_store(struct ctdb_record_handle *h, TDB_DATA data);
-
-int ctdb_fetch(struct ctdb_db_context *ctdb_db, TALLOC_CTX *mem_ctx,
-	       TDB_DATA key, TDB_DATA *data);
-
 struct ctdb_client_control_state *ctdb_control_send(struct ctdb_context *ctdb,
 						    uint32_t destnode,
 						    uint64_t srvid,
@@ -136,24 +118,9 @@ int ctdb_control(struct ctdb_context *ct
 		 TALLOC_CTX *mem_ctx, TDB_DATA *outdata, int32_t *status,
 		 struct timeval *timeout, char **errormsg);
 
-int ctdb_ctrl_process_exists(struct ctdb_context *ctdb, uint32_t destnode,
-			     pid_t pid);
-
-int ctdb_ctrl_statistics(struct ctdb_context *ctdb, uint32_t destnode,
-			 struct ctdb_statistics *status);
-int ctdb_ctrl_dbstatistics(struct ctdb_context *ctdb, uint32_t destnode,
-			   uint32_t dbid, TALLOC_CTX *mem_ctx,
-			   struct ctdb_db_statistics_old **dbstat);
-
-int ctdb_ctrl_shutdown(struct ctdb_context *ctdb, struct timeval timeout,
-		       uint32_t destnode);
-
 int ctdb_ctrl_getvnnmap(struct ctdb_context *ctdb, struct timeval timeout,
 			uint32_t destnode, TALLOC_CTX *mem_ctx,
 			struct ctdb_vnn_map **vnnmap);
-int ctdb_ctrl_setvnnmap(struct ctdb_context *ctdb, struct timeval timeout,
-			uint32_t destnode, TALLOC_CTX *mem_ctx,
-			struct ctdb_vnn_map *vnnmap);
 
 /*
   get the recovery mode of a remote node
@@ -206,34 +173,6 @@ int ctdb_ctrl_getnodemap(struct ctdb_con
 			 uint32_t destnode, TALLOC_CTX *mem_ctx,
 			 struct ctdb_node_map_old **nodemap);
 
-int ctdb_ctrl_getnodesfile(struct ctdb_context *ctdb, struct timeval timeout,
-			   uint32_t destnode, TALLOC_CTX *mem_ctx,
-			   struct ctdb_node_map_old **nodemap);
-
-int ctdb_ctrl_reload_nodes_file(struct ctdb_context *ctdb,
-				struct timeval timeout, uint32_t destnode);
-
-struct ctdb_client_control_state *ctdb_ctrl_pulldb_send(
-					struct ctdb_context *ctdb,
-					uint32_t destnode, uint32_t dbid,
-					uint32_t lmaster, TALLOC_CTX *mem_ctx,
-					struct timeval timeout);
-int ctdb_ctrl_pulldb_recv(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx,
-			  struct ctdb_client_control_state *state,
-			  TDB_DATA *outdata);
-int ctdb_ctrl_pulldb(struct ctdb_context *ctdb, uint32_t destnode,
-		     uint32_t dbid, uint32_t lmaster, TALLOC_CTX *mem_ctx,
-		     struct timeval timeout, TDB_DATA *outdata);
-
-/*
-  change dmaster for all keys in the database to the new value
- */
-int ctdb_ctrl_setdmaster(struct ctdb_context *ctdb, struct timeval timeout,
-			 uint32_t destnode, TALLOC_CTX *mem_ctx,
-			 uint32_t dbid, uint32_t dmaster);
-
-int ctdb_ctrl_ping(struct ctdb_context *ctdb, uint32_t destnode);
-
 int ctdb_ctrl_get_runstate(struct ctdb_context *ctdb, struct timeval timeout,
 			   uint32_t destnode, uint32_t *runstate);
 
@@ -243,11 +182,6 @@ int ctdb_ctrl_getdbpath(struct ctdb_cont
 int ctdb_ctrl_getdbname(struct ctdb_context *ctdb, struct timeval timeout,
 			uint32_t destnode, uint32_t dbid,
 			TALLOC_CTX *mem_ctx, const char **name);
-int ctdb_ctrl_getdbhealth(struct ctdb_context *ctdb, struct timeval timeout,
-			  uint32_t destnode, uint32_t dbid,
-			  TALLOC_CTX *mem_ctx, const char **reason);
-int ctdb_ctrl_getdbseqnum(struct ctdb_context *ctdb, struct timeval timeout,
-			  uint32_t destnode, uint32_t dbid, uint64_t *seqnum);
 
 int ctdb_ctrl_createdb(struct ctdb_context *ctdb, struct timeval timeout,
 		       uint32_t destnode, TALLOC_CTX *mem_ctx,
@@ -255,14 +189,6 @@ int ctdb_ctrl_createdb(struct ctdb_conte
 
 int ctdb_ctrl_get_debuglevel(struct ctdb_context *ctdb, uint32_t destnode,
 			     int32_t *level);
-int ctdb_ctrl_set_debuglevel(struct ctdb_context *ctdb, uint32_t destnode,
-			     int32_t level);
-
-uint32_t *ctdb_get_connected_nodes(struct ctdb_context *ctdb,
-				   struct timeval timeout,
-				   TALLOC_CTX *mem_ctx, uint32_t *num_nodes);
-
-int ctdb_statistics_reset(struct ctdb_context *ctdb, uint32_t destnode);
 
 /*
   attach to a ctdb database
@@ -275,8 +201,6 @@ struct ctdb_db_context *ctdb_attach(stru
 				    const char *name,
 				    uint8_t db_flags);
 
-int ctdb_detach(struct ctdb_context *ctdb, uint32_t db_id);
-
 /* a ctdb call function */
 typedef int (*ctdb_fn_t)(struct ctdb_call_info *);
 
@@ -285,54 +209,12 @@ typedef int (*ctdb_fn_t)(struct ctdb_cal
 */
 int ctdb_set_call(struct ctdb_db_context *ctdb_db, ctdb_fn_t fn, uint32_t id);
 
-
-typedef int (*ctdb_traverse_func)(TDB_DATA, TDB_DATA, void *);
-
-int ctdb_traverse(struct ctdb_db_context *ctdb_db, ctdb_traverse_func fn,
-		  void *private_data);
-
-struct ctdb_dump_db_context {
-	struct ctdb_context *ctdb;
-	FILE *f;
-	bool printemptyrecords;
-	bool printdatasize;
-	bool printlmaster;
-	bool printhash;
-	bool printrecordflags;
-};
-
-int ctdb_dumpdb_record(TDB_DATA key, TDB_DATA data, void *p);
-int ctdb_dump_db(struct ctdb_db_context *ctdb_db,
-		 struct ctdb_dump_db_context *ctx);
-
-/*
-  get the pid of a ctdb daemon
- */
-int ctdb_ctrl_getpid(struct ctdb_context *ctdb, struct timeval timeout,
-		     uint32_t destnode, uint32_t *pid);
-
 int ctdb_ctrl_freeze(struct ctdb_context *ctdb, struct timeval timeout,
 		     uint32_t destnode);
 
 int ctdb_ctrl_getpnn(struct ctdb_context *ctdb, struct timeval timeout,
 		     uint32_t destnode);
 
-int ctdb_ctrl_takeover_ip(struct ctdb_context *ctdb, struct timeval timeout,
-			  uint32_t destnode, struct ctdb_public_ip *ip);
-int ctdb_ctrl_release_ip(struct ctdb_context *ctdb, struct timeval timeout,
-			 uint32_t destnode, struct ctdb_public_ip *ip);
-
-int ctdb_ctrl_get_tunable(struct ctdb_context *ctdb,
-			  struct timeval timeout, uint32_t destnode,
-			  const char *name, uint32_t *value);
-int ctdb_ctrl_set_tunable(struct ctdb_context *ctdb,
-			  struct timeval timeout, uint32_t destnode,
-			  const char *name, uint32_t value);
-int ctdb_ctrl_list_tunables(struct ctdb_context *ctdb,
-			    struct timeval timeout, uint32_t destnode,
-			    TALLOC_CTX *mem_ctx,
-			    const char ***list, uint32_t *count);
-
 int ctdb_ctrl_get_public_ips_flags(struct ctdb_context *ctdb,
 				   struct timeval timeout, uint32_t destnode,
 				   TALLOC_CTX *mem_ctx, uint32_t flags,
@@ -341,20 +223,11 @@ int ctdb_ctrl_get_public_ips(struct ctdb
 			     struct timeval timeout, uint32_t destnode,
 			     TALLOC_CTX *mem_ctx,
 			     struct ctdb_public_ip_list_old **ips);
-int ctdb_ctrl_get_public_ip_info(struct ctdb_context *ctdb,
-				 struct timeval timeout, uint32_t destnode,
-				 TALLOC_CTX *mem_ctx,
-				 const ctdb_sock_addr *addr,
-				 struct ctdb_public_ip_info_old **info);
 
 int ctdb_ctrl_get_ifaces(struct ctdb_context *ctdb,
 			 struct timeval timeout, uint32_t destnode,
 			 TALLOC_CTX *mem_ctx,
 			 struct ctdb_iface_list_old **ifaces);
-int ctdb_ctrl_set_iface_link(struct ctdb_context *ctdb,
-			     struct timeval timeout, uint32_t destnode,
-			     TALLOC_CTX *mem_ctx,
-			     const struct ctdb_iface *info);
 
 int ctdb_ctrl_modflags(struct ctdb_context *ctdb,
 		       struct timeval timeout,
@@ -365,22 +238,6 @@ int ctdb_ctrl_get_all_tunables(struct ct
 			       struct timeval timeout, uint32_t destnode,
 			       struct ctdb_tunable_list *tunables);
 
-int ctdb_ctrl_add_public_ip(struct ctdb_context *ctdb,
-			    struct timeval timeout, uint32_t destnode,
-			    struct ctdb_addr_info_old *pub);
-int ctdb_ctrl_del_public_ip(struct ctdb_context *ctdb,
-			    struct timeval timeout, uint32_t destnode,
-			    struct ctdb_addr_info_old *pub);
-
-int ctdb_ctrl_gratious_arp(struct ctdb_context *ctdb,
-			   struct timeval timeout, uint32_t destnode,
-			   ctdb_sock_addr *addr, const char *ifname);
-
-int ctdb_ctrl_get_tcp_tickles(struct ctdb_context *ctdb,
-			      struct timeval timeout, uint32_t destnode,
-			      TALLOC_CTX *mem_ctx, ctdb_sock_addr *addr,
-			      struct ctdb_tickle_list_old **list);
-
 /*
   initialise ctdb subsystem
 */
@@ -397,24 +254,6 @@ const char *ctdb_get_socketname(struct c
 /* return pnn of this node */
 uint32_t ctdb_get_pnn(struct ctdb_context *ctdb);
 
-/*
-  get the uptime of a remote node
- */
-struct ctdb_client_control_state *ctdb_ctrl_uptime_send(
-					struct ctdb_context *ctdb,
-					TALLOC_CTX *mem_ctx,
-					struct timeval timeout,
-					uint32_t destnode);
-int ctdb_ctrl_uptime_recv(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx,
-			  struct ctdb_client_control_state *state,
-			  struct ctdb_uptime **uptime);
-int ctdb_ctrl_uptime(struct ctdb_context *ctdb, TALLOC_CTX *mem_ctx,
-		     struct timeval timeout, uint32_t destnode,
-		     struct ctdb_uptime **uptime);
-
-int ctdb_ctrl_end_recovery(struct ctdb_context *ctdb, struct timeval timeout,
-			   uint32_t destnode);
-
 typedef void (*client_async_callback)(struct ctdb_context *ctdb,
 				      uint32_t node_pnn, int32_t res,
 				      TDB_DATA outdata, void *callback_data);
@@ -455,8 +294,6 @@ uint32_t *list_of_connected_nodes(struct
 				  struct ctdb_node_map_old *node_map,
 				  TALLOC_CTX *mem_ctx, bool include_self);
 
-int ctdb_read_pnn_lock(int fd, int32_t pnn);
-
 /*
   get capabilities of a remote node
  */
@@ -495,52 +332,13 @@ uint32_t *ctdb_get_node_capabilities(str
 bool ctdb_node_has_capabilities(struct ctdb_node_capabilities *caps,
 				uint32_t pnn, uint32_t capabilities_required);
 
-
-struct ctdb_transaction_handle *ctdb_transaction_start(
-					struct ctdb_db_context *ctdb_db,
-					TALLOC_CTX *mem_ctx);
-int ctdb_transaction_fetch(struct ctdb_transaction_handle *h,
-			   TALLOC_CTX *mem_ctx,
-			   TDB_DATA key, TDB_DATA *data);
-int ctdb_transaction_store(struct ctdb_transaction_handle *h,
-			   TDB_DATA key, TDB_DATA data);
-int ctdb_transaction_commit(struct ctdb_transaction_handle *h);
-int ctdb_transaction_cancel(struct ctdb_transaction_handle *h);
-
 int ctdb_ctrl_recd_ping(struct ctdb_context *ctdb);
 
 int ctdb_ctrl_report_recd_lock_latency(struct ctdb_context *ctdb,
 				       struct timeval timeout, double latency);
 
-int ctdb_ctrl_getreclock(struct ctdb_context *ctdb,
-			 struct timeval timeout, uint32_t destnode,
-			 TALLOC_CTX *mem_ctx, const char **reclock);
-
-int ctdb_ctrl_stop_node(struct ctdb_context *ctdb, struct timeval timeout,
-			uint32_t destnode);
-int ctdb_ctrl_continue_node(struct ctdb_context *ctdb, struct timeval timeout,
-			    uint32_t destnode);
-
-int ctdb_ctrl_setlmasterrole(struct ctdb_context *ctdb,
-			     struct timeval timeout, uint32_t destnode,
-			     uint32_t lmasterrole);
-int ctdb_ctrl_setrecmasterrole(struct ctdb_context *ctdb,
-			       struct timeval timeout, uint32_t destnode,
-			       uint32_t recmasterrole);
-
 int ctdb_ctrl_set_ban(struct ctdb_context *ctdb, struct timeval timeout,
 		      uint32_t destnode, struct ctdb_ban_state *bantime);
-int ctdb_ctrl_get_ban(struct ctdb_context *ctdb, struct timeval timeout,
-		      uint32_t destnode, TALLOC_CTX *mem_ctx,
-		      struct ctdb_ban_state **bantime);
-
-int ctdb_ctrl_getstathistory(struct ctdb_context *ctdb,
-			     struct timeval timeout, uint32_t destnode,
-			     TALLOC_CTX *mem_ctx,
-			     struct ctdb_statistics_list_old **stats);
-
-struct ctdb_ltdb_header *ctdb_header_from_record_handle(
-					struct ctdb_record_handle *h);
 
 struct ctdb_client_control_state *ctdb_ctrl_updaterecord_send(
 					struct ctdb_context *ctdb,
@@ -558,20 +356,4 @@ int ctdb_ctrl_updaterecord(struct ctdb_c
 			   struct ctdb_db_context *ctdb_db, TDB_DATA key,
 			   struct ctdb_ltdb_header *header, TDB_DATA data);
 
-struct ctdb_client_control_state *ctdb_ctrl_set_db_readonly_send(
-					struct ctdb_context *ctdb,
-					uint32_t destnode, uint32_t dbid);
-int ctdb_ctrl_set_db_readonly_recv(struct ctdb_context *ctdb,
-				   struct ctdb_client_control_state *state);
-int ctdb_ctrl_set_db_readonly(struct ctdb_context *ctdb, uint32_t destnode,
-			      uint32_t dbid);
-
-struct ctdb_client_control_state *ctdb_ctrl_set_db_sticky_send(
-					struct ctdb_context *ctdb,
-					uint32_t destnode, uint32_t dbid);
-int ctdb_ctrl_set_db_sticky_recv(struct ctdb_context *ctdb,
-				 struct ctdb_client_control_state *state);
-int ctdb_ctrl_set_db_sticky(struct ctdb_context *ctdb, uint32_t destnode,
-			    uint32_t dbid);
-
 #endif /* _CTDB_CLIENT_H */
diff -Npur samba-4.8.1/docs/manpages/cifsdd.8 samba-4.8.2/docs/manpages/cifsdd.8
--- samba-4.8.1/docs/manpages/cifsdd.8	2018-04-26 09:25:26.000000000 +0200
+++ samba-4.8.2/docs/manpages/cifsdd.8	2018-05-16 12:14:57.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: cifsdd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "CIFSDD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "CIFSDD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/dbwrap_tool.1 samba-4.8.2/docs/manpages/dbwrap_tool.1
--- samba-4.8.1/docs/manpages/dbwrap_tool.1	2018-04-26 09:25:26.000000000 +0200
+++ samba-4.8.2/docs/manpages/dbwrap_tool.1	2018-05-16 12:14:58.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: dbwrap_tool
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "DBWRAP_TOOL" "1" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "DBWRAP_TOOL" "1" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -301,7 +301,7 @@ dbwrap_tool
 Use with caution!
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/eventlogadm.8 samba-4.8.2/docs/manpages/eventlogadm.8
--- samba-4.8.1/docs/manpages/eventlogadm.8	2018-04-26 09:25:26.000000000 +0200
+++ samba-4.8.2/docs/manpages/eventlogadm.8	2018-05-16 12:14:58.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: eventlogadm
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "EVENTLOGADM" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "EVENTLOGADM" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -339,7 +339,7 @@ Filter messages from the system log into
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/findsmb.1 samba-4.8.2/docs/manpages/findsmb.1
--- samba-4.8.1/docs/manpages/findsmb.1	2018-04-26 09:25:26.000000000 +0200
+++ samba-4.8.2/docs/manpages/findsmb.1	2018-05-16 12:14:58.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: findsmb
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "FINDSMB" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "FINDSMB" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -119,7 +119,7 @@ IP ADDR         NETBIOS NAME   WORKGROUP
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBnmbd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/idmap_ad.8 samba-4.8.2/docs/manpages/idmap_ad.8
--- samba-4.8.1/docs/manpages/idmap_ad.8	2018-04-26 09:25:27.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_ad.8	2018-05-16 12:14:58.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_ad
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_AD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_AD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_autorid.8 samba-4.8.2/docs/manpages/idmap_autorid.8
--- samba-4.8.1/docs/manpages/idmap_autorid.8	2018-04-26 09:25:27.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_autorid.8	2018-05-16 12:14:58.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_autorid
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_AUTORID" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_AUTORID" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_hash.8 samba-4.8.2/docs/manpages/idmap_hash.8
--- samba-4.8.1/docs/manpages/idmap_hash.8	2018-04-26 09:25:27.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_hash.8	2018-05-16 12:14:59.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_hash
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_HASH" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_HASH" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_ldap.8 samba-4.8.2/docs/manpages/idmap_ldap.8
--- samba-4.8.1/docs/manpages/idmap_ldap.8	2018-04-26 09:25:27.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_ldap.8	2018-05-16 12:14:59.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_ldap
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_LDAP" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_LDAP" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_nss.8 samba-4.8.2/docs/manpages/idmap_nss.8
--- samba-4.8.1/docs/manpages/idmap_nss.8	2018-04-26 09:25:27.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_nss.8	2018-05-16 12:14:59.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_nss
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_NSS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_NSS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_rfc2307.8 samba-4.8.2/docs/manpages/idmap_rfc2307.8
--- samba-4.8.1/docs/manpages/idmap_rfc2307.8	2018-04-26 09:25:28.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_rfc2307.8	2018-05-16 12:14:59.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_rfc2307
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_RFC2307" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_RFC2307" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_rid.8 samba-4.8.2/docs/manpages/idmap_rid.8
--- samba-4.8.1/docs/manpages/idmap_rid.8	2018-04-26 09:25:28.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_rid.8	2018-05-16 12:15:00.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_rid
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_RID" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_RID" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_script.8 samba-4.8.2/docs/manpages/idmap_script.8
--- samba-4.8.1/docs/manpages/idmap_script.8	2018-04-26 09:25:28.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_script.8	2018-05-16 12:15:00.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_script
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_SCRIPT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_SCRIPT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_tdb.8 samba-4.8.2/docs/manpages/idmap_tdb.8
--- samba-4.8.1/docs/manpages/idmap_tdb.8	2018-04-26 09:25:28.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_tdb.8	2018-05-16 12:15:00.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_tdb
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_TDB" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_TDB" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/idmap_tdb2.8 samba-4.8.2/docs/manpages/idmap_tdb2.8
--- samba-4.8.1/docs/manpages/idmap_tdb2.8	2018-04-26 09:25:28.000000000 +0200
+++ samba-4.8.2/docs/manpages/idmap_tdb2.8	2018-05-16 12:15:00.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: idmap_tdb2
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "IDMAP_TDB2" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "IDMAP_TDB2" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/libsmbclient.7 samba-4.8.2/docs/manpages/libsmbclient.7
--- samba-4.8.1/docs/manpages/libsmbclient.7	2018-04-26 09:25:29.000000000 +0200
+++ samba-4.8.2/docs/manpages/libsmbclient.7	2018-05-16 12:15:00.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: libsmbclient
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: 7
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "LIBSMBCLIENT" "7" "04/26/2018" "Samba 4\&.8\&.1" "7"
+.TH "LIBSMBCLIENT" "7" "05/16/2018" "Samba 4\&.8\&.2" "7"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -86,7 +86,7 @@ parameter was not included in the URL\&.
 Watch this space for future updates\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/lmhosts.5 samba-4.8.2/docs/manpages/lmhosts.5
--- samba-4.8.1/docs/manpages/lmhosts.5	2018-04-26 09:25:29.000000000 +0200
+++ samba-4.8.2/docs/manpages/lmhosts.5	2018-05-16 12:15:01.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: lmhosts
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: File Formats and Conventions
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "LMHOSTS" "5" "04/26/2018" "Samba 4\&.8\&.1" "File Formats and Conventions"
+.TH "LMHOSTS" "5" "05/16/2018" "Samba 4\&.8\&.2" "File Formats and Conventions"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -112,7 +112,7 @@ or
 /usr/local/samba/lib\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbclient\fR(1),
diff -Npur samba-4.8.1/docs/manpages/log2pcap.1 samba-4.8.2/docs/manpages/log2pcap.1
--- samba-4.8.1/docs/manpages/log2pcap.1	2018-04-26 09:25:29.000000000 +0200
+++ samba-4.8.2/docs/manpages/log2pcap.1	2018-05-16 12:15:01.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: log2pcap
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "LOG2PCAP" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "LOG2PCAP" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -107,7 +107,7 @@ Convert to pcap using text2pcap:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "BUGS"
 .PP
 Only SMB data is extracted from the samba logs, no LDAP, NetBIOS lookup or other data\&.
diff -Npur samba-4.8.1/docs/manpages/mvxattr.1 samba-4.8.2/docs/manpages/mvxattr.1
--- samba-4.8.1/docs/manpages/mvxattr.1	2018-04-26 09:25:29.000000000 +0200
+++ samba-4.8.2/docs/manpages/mvxattr.1	2018-05-16 12:15:01.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: mvxattr
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "MVXATTR" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "MVXATTR" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -76,7 +76,7 @@ Force overwriting of destination xattr\&
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/net.8 samba-4.8.2/docs/manpages/net.8
--- samba-4.8.1/docs/manpages/net.8	2018-04-26 09:25:30.000000000 +0200
+++ samba-4.8.2/docs/manpages/net.8	2018-05-16 12:15:01.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: net
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "NET" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "NET" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/nmbd.8 samba-4.8.2/docs/manpages/nmbd.8
--- samba-4.8.1/docs/manpages/nmbd.8	2018-04-26 09:25:30.000000000 +0200
+++ samba-4.8.2/docs/manpages/nmbd.8	2018-05-16 12:15:02.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: nmbd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "NMBD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "NMBD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -278,7 +278,7 @@ The debug log level of nmbd may be raise
 (SIGUSR[1|2] signals are no longer used since Samba 2\&.2)\&. This is to allow transient problems to be diagnosed, whilst still running at a normally low log level\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBinetd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/nmblookup.1 samba-4.8.2/docs/manpages/nmblookup.1
--- samba-4.8.1/docs/manpages/nmblookup.1	2018-04-26 09:25:30.000000000 +0200
+++ samba-4.8.2/docs/manpages/nmblookup.1	2018-05-16 12:15:02.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: nmblookup
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "NMBLOOKUP" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "NMBLOOKUP" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -214,7 +214,7 @@ nmblookup \-U samba\&.org \-R \*(AqIRIX#
 would query the WINS server samba\&.org for the domain master browser (1B name type) for the IRIX workgroup\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBnmbd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/ntlm_auth.1 samba-4.8.2/docs/manpages/ntlm_auth.1
--- samba-4.8.1/docs/manpages/ntlm_auth.1	2018-04-26 09:25:30.000000000 +0200
+++ samba-4.8.2/docs/manpages/ntlm_auth.1	2018-05-16 12:15:02.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: ntlm_auth
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "NTLM_AUTH" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "NTLM_AUTH" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -421,7 +421,7 @@ If you\*(Aqre experiencing problems with
 the Microsoft Knowledge Base article #239869 and follow instructions described there\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/pam_winbind.8 samba-4.8.2/docs/manpages/pam_winbind.8
--- samba-4.8.1/docs/manpages/pam_winbind.8	2018-04-26 09:25:31.000000000 +0200
+++ samba-4.8.2/docs/manpages/pam_winbind.8	2018-05-16 12:15:02.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: pam_winbind
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: 8
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "PAM_WINBIND" "8" "04/26/2018" "Samba 4\&.8\&.1" "8"
+.TH "PAM_WINBIND" "8" "05/16/2018" "Samba 4\&.8\&.2" "8"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -172,7 +172,7 @@ This is the profile path set in the prof
 \fBsmb.conf\fR(5)
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of Samba\&.
+This man page is part of version 4\&.8\&.2 of Samba\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/pam_winbind.conf.5 samba-4.8.2/docs/manpages/pam_winbind.conf.5
--- samba-4.8.1/docs/manpages/pam_winbind.conf.5	2018-04-26 09:25:31.000000000 +0200
+++ samba-4.8.2/docs/manpages/pam_winbind.conf.5	2018-05-16 12:15:02.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: pam_winbind.conf
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: 5
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "PAM_WINBIND\&.CONF" "5" "04/26/2018" "Samba 4\&.8\&.1" "5"
+.TH "PAM_WINBIND\&.CONF" "5" "05/16/2018" "Samba 4\&.8\&.2" "5"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -137,7 +137,7 @@ Defines number of days before pam_winbin
 \fBsmb.conf\fR(5)
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of Samba\&.
+This man page is part of version 4\&.8\&.2 of Samba\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/pdbedit.8 samba-4.8.2/docs/manpages/pdbedit.8
--- samba-4.8.1/docs/manpages/pdbedit.8	2018-04-26 09:25:31.000000000 +0200
+++ samba-4.8.2/docs/manpages/pdbedit.8	2018-05-16 12:15:03.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: pdbedit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "PDBEDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "PDBEDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -619,7 +619,7 @@ option "<name>" to value "<value>" from
 This command may be used only by root\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbpasswd\fR(5),
diff -Npur samba-4.8.1/docs/manpages/profiles.1 samba-4.8.2/docs/manpages/profiles.1
--- samba-4.8.1/docs/manpages/profiles.1	2018-04-26 09:25:31.000000000 +0200
+++ samba-4.8.2/docs/manpages/profiles.1	2018-05-16 12:15:03.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: profiles
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "PROFILES" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "PROFILES" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -112,7 +112,7 @@ Display brief usage message\&.
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/rpcclient.1 samba-4.8.2/docs/manpages/rpcclient.1
--- samba-4.8.1/docs/manpages/rpcclient.1	2018-04-26 09:25:31.000000000 +0200
+++ samba-4.8.2/docs/manpages/rpcclient.1	2018-05-16 12:15:03.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: rpcclient
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "RPCCLIENT" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "RPCCLIENT" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -803,7 +803,7 @@ and
 that are incompatible for some commands or services\&. Additionally, the developers are sending reports to Microsoft, and problems found or reported to Microsoft are fixed in Service Packs, which may result in incompatibilities\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/samba-regedit.8 samba-4.8.2/docs/manpages/samba-regedit.8
--- samba-4.8.1/docs/manpages/samba-regedit.8	2018-04-26 09:25:32.000000000 +0200
+++ samba-4.8.2/docs/manpages/samba-regedit.8	2018-05-16 12:15:04.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: samba-regedit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SAMBA\-REGEDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SAMBA\-REGEDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -207,7 +207,7 @@ The supplied password is the NT hash\&.
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/samba-tool.8 samba-4.8.2/docs/manpages/samba-tool.8
--- samba-4.8.1/docs/manpages/samba-tool.8	2018-04-26 09:25:32.000000000 +0200
+++ samba-4.8.2/docs/manpages/samba-tool.8	2018-05-16 12:15:04.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: samba-tool
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SAMBA\-TOOL" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SAMBA\-TOOL" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -470,7 +470,7 @@ because the repsFrom/To objects are not
 Gives usage information\&.
 .SH "VERSION"
 .PP
-This man page is complete for version 4\&.8\&.1 of the Samba suite\&.
+This man page is complete for version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/samba.7 samba-4.8.2/docs/manpages/samba.7
--- samba-4.8.1/docs/manpages/samba.7	2018-04-26 09:25:32.000000000 +0200
+++ samba-4.8.2/docs/manpages/samba.7	2018-05-16 12:15:04.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: samba
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: Miscellanea
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SAMBA" "7" "04/26/2018" "Samba 4\&.8\&.1" "Miscellanea"
+.TH "SAMBA" "7" "05/16/2018" "Samba 4\&.8\&.2" "Miscellanea"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -237,7 +237,7 @@ https://lists\&.samba\&.org
 you can find a lot of information in the archives and you can subscribe to the samba list and ask for help or discuss things\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "CONTRIBUTIONS"
 .PP
 If you wish to contribute to the Samba project, then I suggest you join the Samba mailing list at
diff -Npur samba-4.8.1/docs/manpages/samba.8 samba-4.8.2/docs/manpages/samba.8
--- samba-4.8.1/docs/manpages/samba.8	2018-04-26 09:25:32.000000000 +0200
+++ samba-4.8.2/docs/manpages/samba.8	2018-05-16 12:15:04.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: samba
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SAMBA" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SAMBA" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -198,7 +198,7 @@ The number and nature of diagnostics ava
 Most messages are reasonably self\-explanatory\&. Unfortunately, at the time this man page was created, there are too many diagnostics available in the source code to warrant describing each and every diagnostic\&. At this stage your best bet is still to grep the source code and inspect the conditions that gave rise to the diagnostics you are seeing\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBhosts_access\fR(5)
diff -Npur samba-4.8.1/docs/manpages/sharesec.1 samba-4.8.2/docs/manpages/sharesec.1
--- samba-4.8.1/docs/manpages/sharesec.1	2018-04-26 09:25:33.000000000 +0200
+++ samba-4.8.2/docs/manpages/sharesec.1	2018-05-16 12:15:04.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: sharesec
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SHARESEC" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SHARESEC" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -337,7 +337,7 @@ List all ACEs for
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/smb.conf.5 samba-4.8.2/docs/manpages/smb.conf.5
--- samba-4.8.1/docs/manpages/smb.conf.5	2018-04-26 09:25:34.000000000 +0200
+++ samba-4.8.2/docs/manpages/smb.conf.5	2018-05-16 12:15:06.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smb.conf
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: File Formats and Conventions
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMB\&.CONF" "5" "04/26/2018" "Samba 4\&.8\&.1" "File Formats and Conventions"
+.TH "SMB\&.CONF" "5" "05/16/2018" "Samba 4\&.8\&.2" "File Formats and Conventions"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -12953,7 +12953,7 @@ and
 special sections make life for an administrator easy, but the various combinations of default attributes can be tricky\&. Take extreme care when designing these sections\&. In particular, ensure that the permissions on spool directories are correct\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsamba\fR(7),
diff -Npur samba-4.8.1/docs/manpages/smbcacls.1 samba-4.8.2/docs/manpages/smbcacls.1
--- samba-4.8.1/docs/manpages/smbcacls.1	2018-04-26 09:25:34.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbcacls.1	2018-05-16 12:15:06.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbcacls
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBCACLS" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBCACLS" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -491,7 +491,7 @@ smbcacls
 couldn\*(Aqt connect to the specified server, or there was an error getting or setting the ACLs, an exit status of 1 is returned\&. If there was an error parsing any command line arguments, an exit status of 2 is returned\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/smbclient.1 samba-4.8.2/docs/manpages/smbclient.1
--- samba-4.8.1/docs/manpages/smbclient.1	2018-04-26 09:25:35.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbclient.1	2018-05-16 12:15:07.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbclient
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBCLIENT" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBCLIENT" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -1151,7 +1151,7 @@ Most diagnostics issued by the client ar
 The number and nature of diagnostics available depends on the debug level used by the client\&. If you have problems, set the debug level to 3 and peruse the log files\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/smbcontrol.1 samba-4.8.2/docs/manpages/smbcontrol.1
--- samba-4.8.1/docs/manpages/smbcontrol.1	2018-04-26 09:25:35.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbcontrol.1	2018-05-16 12:15:07.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbcontrol
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBCONTROL" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBCONTROL" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -309,7 +309,7 @@ Query the number of smbd child processes
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBnmbd\fR(8)
diff -Npur samba-4.8.1/docs/manpages/smbcquotas.1 samba-4.8.2/docs/manpages/smbcquotas.1
--- samba-4.8.1/docs/manpages/smbcquotas.1	2018-04-26 09:25:35.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbcquotas.1	2018-05-16 12:15:07.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbcquotas
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBCQUOTAS" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBCQUOTAS" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -247,7 +247,7 @@ smbcquotas
 couldn\*(Aqt connect to the specified server, or when there was an error getting or setting the quota(s), an exit status of 1 is returned\&. If there was an error parsing any command line arguments, an exit status of 2 is returned\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/smbd.8 samba-4.8.2/docs/manpages/smbd.8
--- samba-4.8.1/docs/manpages/smbd.8	2018-04-26 09:25:35.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbd.8	2018-05-16 12:15:07.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SMBD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -252,7 +252,7 @@ parameter\&. When this is set, the follo
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "DIAGNOSTICS"
 .PP
 Most diagnostics issued by the server are logged in a specified log file\&. The log file name is specified at compile time, but may be overridden on the command line\&.
diff -Npur samba-4.8.1/docs/manpages/smbget.1 samba-4.8.2/docs/manpages/smbget.1
--- samba-4.8.1/docs/manpages/smbget.1	2018-04-26 09:25:36.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbget.1	2018-05-16 12:15:08.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbget
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBGET" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBGET" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -189,7 +189,7 @@ smbget \-Rr smb://rhonwyn/
 Permission denied is returned in some cases where the cause of the error is unknown (such as an illegally formatted smb:// url or trying to get a directory without \-R turned on)\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/smbgetrc.5 samba-4.8.2/docs/manpages/smbgetrc.5
--- samba-4.8.1/docs/manpages/smbgetrc.5	2018-04-26 09:25:36.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbgetrc.5	2018-05-16 12:15:08.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbgetrc
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: File Formats and Conventions
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBGETRC" "5" "04/26/2018" "Samba 4\&.8\&.1" "File Formats and Conventions"
+.TH "SMBGETRC" "5" "05/16/2018" "Samba 4\&.8\&.2" "File Formats and Conventions"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -87,7 +87,7 @@ Number of bytes to put in a block\&.
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbget\fR(1)
diff -Npur samba-4.8.1/docs/manpages/smbpasswd.5 samba-4.8.2/docs/manpages/smbpasswd.5
--- samba-4.8.1/docs/manpages/smbpasswd.5	2018-04-26 09:25:36.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbpasswd.5	2018-05-16 12:15:08.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbpasswd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: File Formats and Conventions
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBPASSWD" "5" "04/26/2018" "Samba 4\&.8\&.1" "File Formats and Conventions"
+.TH "SMBPASSWD" "5" "05/16/2018" "Samba 4\&.8\&.2" "File Formats and Conventions"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -165,7 +165,7 @@ This field consists of the time the acco
 All other colon separated fields are ignored at this time\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbpasswd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/smbpasswd.8 samba-4.8.2/docs/manpages/smbpasswd.8
--- samba-4.8.1/docs/manpages/smbpasswd.8	2018-04-26 09:25:36.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbpasswd.8	2018-05-16 12:15:08.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbpasswd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBPASSWD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SMBPASSWD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -316,7 +316,7 @@ file and neglecting to allow "localhost"
 In addition, the smbpasswd command is only useful if Samba has been set up to use encrypted passwords\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbpasswd\fR(5),
diff -Npur samba-4.8.1/docs/manpages/smbspool.8 samba-4.8.2/docs/manpages/smbspool.8
--- samba-4.8.1/docs/manpages/smbspool.8	2018-04-26 09:25:36.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbspool.8	2018-05-16 12:15:08.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbspool
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBSPOOL" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SMBSPOOL" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -173,7 +173,7 @@ The filename argument (argv[6]) contains
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbd\fR(8)
diff -Npur samba-4.8.1/docs/manpages/smbspool_krb5_wrapper.8 samba-4.8.2/docs/manpages/smbspool_krb5_wrapper.8
--- samba-4.8.1/docs/manpages/smbspool_krb5_wrapper.8	2018-04-26 09:25:37.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbspool_krb5_wrapper.8	2018-05-16 12:15:09.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbspool_krb5_wrapper
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBSPOOL_KRB5_WRAPPE" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "SMBSPOOL_KRB5_WRAPPE" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/smbstatus.1 samba-4.8.2/docs/manpages/smbstatus.1
--- samba-4.8.1/docs/manpages/smbstatus.1	2018-04-26 09:25:37.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbstatus.1	2018-05-16 12:15:09.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbstatus
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBSTATUS" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBSTATUS" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -154,7 +154,7 @@ causes smbstatus to display numeric UIDs
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbd\fR(8)
diff -Npur samba-4.8.1/docs/manpages/smbtar.1 samba-4.8.2/docs/manpages/smbtar.1
--- samba-4.8.1/docs/manpages/smbtar.1	2018-04-26 09:25:37.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbtar.1	2018-05-16 12:15:09.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbtar
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBTAR" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBTAR" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -145,7 +145,7 @@ section for the
 command\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmbd\fR(8),
diff -Npur samba-4.8.1/docs/manpages/smbtree.1 samba-4.8.2/docs/manpages/smbtree.1
--- samba-4.8.1/docs/manpages/smbtree.1	2018-04-26 09:25:37.000000000 +0200
+++ samba-4.8.2/docs/manpages/smbtree.1	2018-05-16 12:15:09.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: smbtree
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "SMBTREE" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "SMBTREE" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -191,7 +191,7 @@ Display brief usage message\&.
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/testparm.1 samba-4.8.2/docs/manpages/testparm.1
--- samba-4.8.1/docs/manpages/testparm.1	2018-04-26 09:25:37.000000000 +0200
+++ samba-4.8.2/docs/manpages/testparm.1	2018-05-16 12:15:10.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: testparm
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "TESTPARM" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "TESTPARM" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -169,7 +169,7 @@ This is usually the name of the configur
 The program will issue a message saying whether the configuration file loaded OK or not\&. This message may be preceded by errors and warnings if the file did not load\&. If the file was loaded OK, the program then dumps all known service details to stdout\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBsmb.conf\fR(5),
diff -Npur samba-4.8.1/docs/manpages/traffic_learner.7 samba-4.8.2/docs/manpages/traffic_learner.7
--- samba-4.8.1/docs/manpages/traffic_learner.7	2018-04-26 09:25:38.000000000 +0200
+++ samba-4.8.2/docs/manpages/traffic_learner.7	2018-05-16 12:15:10.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: traffic_learner
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "TRAFFIC_LEARNER" "7" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "TRAFFIC_LEARNER" "7" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -115,7 +115,7 @@ There are two special packet types here\
 The other special packet is "\-", which represents the limit of the conversation\&. In the example, this indicates that one observed conversation ended after this particular ngram\&. This special opcode is also used at the beginning of conversations, which are indicated by the ngram "\-\et\-"\&.
 .SH "VERSION"
 .PP
-This man page is complete for version 4\&.8\&.1 of the Samba suite\&.
+This man page is complete for version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBtraffic_replay\fR(7)\&.
diff -Npur samba-4.8.1/docs/manpages/traffic_replay.7 samba-4.8.2/docs/manpages/traffic_replay.7
--- samba-4.8.1/docs/manpages/traffic_replay.7	2018-04-26 09:25:38.000000000 +0200
+++ samba-4.8.2/docs/manpages/traffic_replay.7	2018-05-16 12:15:10.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: traffic_replay
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "TRAFFIC_REPLAY" "7" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "TRAFFIC_REPLAY" "7" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -327,7 +327,7 @@ traffic_replay traffic\-model\&.txt my\-
 The users created by the test will have names like STGU\-0\-xyz\&. The groups generated have names like STGG\-0\-xyz\&.
 .SH "VERSION"
 .PP
-This man page is complete for version 4\&.8\&.1 of the Samba suite\&.
+This man page is complete for version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBtraffic_learner\fR(7)\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_acl_tdb.8 samba-4.8.2/docs/manpages/vfs_acl_tdb.8
--- samba-4.8.1/docs/manpages/vfs_acl_tdb.8	2018-04-26 09:25:38.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_acl_tdb.8	2018-05-16 12:15:10.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_acl_tdb
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_ACL_TDB" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_ACL_TDB" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_acl_xattr.8 samba-4.8.2/docs/manpages/vfs_acl_xattr.8
--- samba-4.8.1/docs/manpages/vfs_acl_xattr.8	2018-04-26 09:25:38.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_acl_xattr.8	2018-05-16 12:15:10.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_acl_xattr
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_ACL_XATTR" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_ACL_XATTR" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_aio_fork.8 samba-4.8.2/docs/manpages/vfs_aio_fork.8
--- samba-4.8.1/docs/manpages/vfs_aio_fork.8	2018-04-26 09:25:38.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_aio_fork.8	2018-05-16 12:15:11.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_aio_fork
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_AIO_FORK" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_AIO_FORK" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -62,7 +62,7 @@ Straight forward use:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_aio_pthread.8 samba-4.8.2/docs/manpages/vfs_aio_pthread.8
--- samba-4.8.1/docs/manpages/vfs_aio_pthread.8	2018-04-26 09:25:39.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_aio_pthread.8	2018-05-16 12:15:11.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_aio_pthread
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_AIO_PTHREAD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_AIO_PTHREAD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -78,7 +78,7 @@ By default this is set to 100\&.
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_audit.8 samba-4.8.2/docs/manpages/vfs_audit.8
--- samba-4.8.1/docs/manpages/vfs_audit.8	2018-04-26 09:25:39.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_audit.8	2018-05-16 12:15:11.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_audit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_AUDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_AUDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -118,7 +118,7 @@ Log operations on all shares using the L
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_btrfs.8 samba-4.8.2/docs/manpages/vfs_btrfs.8
--- samba-4.8.1/docs/manpages/vfs_btrfs.8	2018-04-26 09:25:39.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_btrfs.8	2018-05-16 12:15:11.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_btrfs
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_BTRFS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_BTRFS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -104,7 +104,7 @@ to Windows Explorer as file / directory
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_cacheprime.8 samba-4.8.2/docs/manpages/vfs_cacheprime.8
--- samba-4.8.1/docs/manpages/vfs_cacheprime.8	2018-04-26 09:25:39.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_cacheprime.8	2018-05-16 12:15:12.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_cacheprime
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_CACHEPRIME" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_CACHEPRIME" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -115,7 +115,7 @@ cacheprime
 is not a substitute for a general\-purpose readahead mechanism\&. It is intended for use only in very specific environments where disk operations must be aligned and sized to known values (as much as that is possible)\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_cap.8 samba-4.8.2/docs/manpages/vfs_cap.8
--- samba-4.8.1/docs/manpages/vfs_cap.8	2018-04-26 09:25:40.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_cap.8	2018-05-16 12:15:12.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_cap
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_CAP" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_CAP" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -63,7 +63,7 @@ On a system using GNU libiconv, use CAP
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_catia.8 samba-4.8.2/docs/manpages/vfs_catia.8
--- samba-4.8.1/docs/manpages/vfs_catia.8	2018-04-26 09:25:40.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_catia.8	2018-05-16 12:15:12.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_catia
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_CATIA" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_CATIA" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_ceph.8 samba-4.8.2/docs/manpages/vfs_ceph.8
--- samba-4.8.1/docs/manpages/vfs_ceph.8	2018-04-26 09:25:40.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_ceph.8	2018-05-16 12:15:12.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_ceph
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_CEPH" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_CEPH" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -80,7 +80,7 @@ Example: ceph:user_id = samba
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_commit.8 samba-4.8.2/docs/manpages/vfs_commit.8
--- samba-4.8.1/docs/manpages/vfs_commit.8	2018-04-26 09:25:40.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_commit.8	2018-05-16 12:15:13.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_commit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_COMMIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_COMMIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -116,7 +116,7 @@ commit
 may reduce performance\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_crossrename.8 samba-4.8.2/docs/manpages/vfs_crossrename.8
--- samba-4.8.1/docs/manpages/vfs_crossrename.8	2018-04-26 09:25:40.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_crossrename.8	2018-05-16 12:15:13.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_crossrename
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_CROSSRENAME" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_CROSSRENAME" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -89,7 +89,7 @@ To add server\-side cross\-device rename
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_default_quota.8 samba-4.8.2/docs/manpages/vfs_default_quota.8
--- samba-4.8.1/docs/manpages/vfs_default_quota.8	2018-04-26 09:25:41.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_default_quota.8	2018-05-16 12:15:13.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_default_quota
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_DEFAULT_QUOTA" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_DEFAULT_QUOTA" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -86,7 +86,7 @@ Store the default quota record in the qu
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_dirsort.8 samba-4.8.2/docs/manpages/vfs_dirsort.8
--- samba-4.8.1/docs/manpages/vfs_dirsort.8	2018-04-26 09:25:41.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_dirsort.8	2018-05-16 12:15:13.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_dirsort
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_DIRSORT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_DIRSORT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -59,7 +59,7 @@ Sort directories for all shares:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_extd_audit.8 samba-4.8.2/docs/manpages/vfs_extd_audit.8
--- samba-4.8.1/docs/manpages/vfs_extd_audit.8	2018-04-26 09:25:41.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_extd_audit.8	2018-05-16 12:15:13.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_extd_audit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_EXTD_AUDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_EXTD_AUDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -55,7 +55,7 @@ is identical to
 This module is stackable\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_fake_perms.8 samba-4.8.2/docs/manpages/vfs_fake_perms.8
--- samba-4.8.1/docs/manpages/vfs_fake_perms.8	2018-04-26 09:25:41.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_fake_perms.8	2018-05-16 12:15:14.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_fake_perms
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_FAKE_PERMS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_FAKE_PERMS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -58,7 +58,7 @@ This module is stackable\&.
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_fileid.8 samba-4.8.2/docs/manpages/vfs_fileid.8
--- samba-4.8.1/docs/manpages/vfs_fileid.8	2018-04-26 09:25:41.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_fileid.8	2018-05-16 12:15:14.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_fileid
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_FILEID" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_FILEID" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -138,7 +138,7 @@ algorithm:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_fruit.8 samba-4.8.2/docs/manpages/vfs_fruit.8
--- samba-4.8.1/docs/manpages/vfs_fruit.8	2018-04-26 09:25:42.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_fruit.8	2018-05-16 12:15:14.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_fruit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_FRUIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_FRUIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_full_audit.8 samba-4.8.2/docs/manpages/vfs_full_audit.8
--- samba-4.8.1/docs/manpages/vfs_full_audit.8	2018-04-26 09:25:42.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_full_audit.8	2018-05-16 12:15:14.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_full_audit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_FULL_AUDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_FULL_AUDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -400,7 +400,7 @@ Log file and directory open operations o
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_glusterfs.8 samba-4.8.2/docs/manpages/vfs_glusterfs.8
--- samba-4.8.1/docs/manpages/vfs_glusterfs.8	2018-04-26 09:25:42.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_glusterfs.8	2018-05-16 12:15:14.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_glusterfs
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_GLUSTERFS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_GLUSTERFS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -109,7 +109,7 @@ Defines the glusterfs volumename to use
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_gpfs.8 samba-4.8.2/docs/manpages/vfs_gpfs.8
--- samba-4.8.1/docs/manpages/vfs_gpfs.8	2018-04-26 09:25:42.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_gpfs.8	2018-05-16 12:15:15.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_gpfs
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_GPFS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_GPFS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -692,7 +692,7 @@ gpfs\&.h
 in gpfs versions newer than 3\&.2\&.1 PTF8\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_linux_xfs_sgid.8 samba-4.8.2/docs/manpages/vfs_linux_xfs_sgid.8
--- samba-4.8.1/docs/manpages/vfs_linux_xfs_sgid.8	2018-04-26 09:25:43.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_linux_xfs_sgid.8	2018-05-16 12:15:15.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_syncops
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SYNCOPS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SYNCOPS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -62,7 +62,7 @@ Add syncops functionality for [share]:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_media_harmony.8 samba-4.8.2/docs/manpages/vfs_media_harmony.8
--- samba-4.8.1/docs/manpages/vfs_media_harmony.8	2018-04-26 09:25:43.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_media_harmony.8	2018-05-16 12:15:15.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_media_harmony
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_MEDIA_HARMONY" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_MEDIA_HARMONY" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -138,7 +138,7 @@ vfs_media_harmony
 is designed to work with Avid editing applications that look in the Avid MediaFiles or OMFI MediaFiles directories for media\&. It is not designed to work as expected in all circumstances for general use\&. For example: It is possible to open a client\-specific file such as msmMMOB\&.mdb_192\&.168\&.1\&.10_userx even though it doesn\*(Aqt show up in a directory listing\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_netatalk.8 samba-4.8.2/docs/manpages/vfs_netatalk.8
--- samba-4.8.1/docs/manpages/vfs_netatalk.8	2018-04-26 09:25:43.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_netatalk.8	2018-05-16 12:15:15.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_netatalk
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_NETATALK" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_NETATALK" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -62,7 +62,7 @@ Hide \&.AppleDouble files on the [data]
 This module is largely historic and unlikely to be of use in modern networks since current Apple systems are able to mount CIFS shares natively\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_nfs4acl_xattr.8 samba-4.8.2/docs/manpages/vfs_nfs4acl_xattr.8
--- samba-4.8.1/docs/manpages/vfs_nfs4acl_xattr.8	2018-04-26 09:25:43.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_nfs4acl_xattr.8	2018-05-16 12:15:16.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_nfs4acl_xattr
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_NFS4ACL_XATTR" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_NFS4ACL_XATTR" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_offline.8 samba-4.8.2/docs/manpages/vfs_offline.8
--- samba-4.8.1/docs/manpages/vfs_offline.8	2018-04-26 09:25:43.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_offline.8	2018-05-16 12:15:16.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_offline
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_OFFLINE" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_OFFLINE" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -59,7 +59,7 @@ Mark all files in a share as offline:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_prealloc.8 samba-4.8.2/docs/manpages/vfs_prealloc.8
--- samba-4.8.1/docs/manpages/vfs_prealloc.8	2018-04-26 09:25:44.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_prealloc.8	2018-05-16 12:15:16.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_prealloc
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_PREALLOC" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_PREALLOC" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -112,7 +112,7 @@ vfs_prealloc
 is not supported on all platforms and filesystems\&. Currently only XFS filesystems on Linux and IRIX are supported\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_preopen.8 samba-4.8.2/docs/manpages/vfs_preopen.8
--- samba-4.8.1/docs/manpages/vfs_preopen.8	2018-04-26 09:25:44.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_preopen.8	2018-05-16 12:15:16.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_preopen
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_PREOPEN" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_PREOPEN" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -67,7 +67,7 @@ Number of files that should be speculati
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_readahead.8 samba-4.8.2/docs/manpages/vfs_readahead.8
--- samba-4.8.1/docs/manpages/vfs_readahead.8	2018-04-26 09:25:44.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_readahead.8	2018-05-16 12:15:16.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_readahead
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_READAHEAD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_READAHEAD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -115,7 +115,7 @@ G
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_readonly.8 samba-4.8.2/docs/manpages/vfs_readonly.8
--- samba-4.8.1/docs/manpages/vfs_readonly.8	2018-04-26 09:25:44.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_readonly.8	2018-05-16 12:15:17.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_readonly
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_READONLY" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_READONLY" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -81,7 +81,7 @@ Mark the [backup] share as read only dur
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_recycle.8 samba-4.8.2/docs/manpages/vfs_recycle.8
--- samba-4.8.1/docs/manpages/vfs_recycle.8	2018-04-26 09:25:44.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_recycle.8	2018-05-16 12:15:17.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_recycle
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_RECYCLE" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_RECYCLE" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -136,7 +136,7 @@ instead of deleting them:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_shadow_copy.8 samba-4.8.2/docs/manpages/vfs_shadow_copy.8
--- samba-4.8.1/docs/manpages/vfs_shadow_copy.8	2018-04-26 09:25:45.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_shadow_copy.8	2018-05-16 12:15:17.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_shadow_copy
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SHADOW_COPY" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SHADOW_COPY" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -167,7 +167,7 @@ vfs_shadow_copy
 is designed to be an end\-user tool only\&. It does not replace or enhance your backup and archival solutions and should in no way be considered as such\&. Additionally, if you need version control, implement a version control system\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_shadow_copy2.8 samba-4.8.2/docs/manpages/vfs_shadow_copy2.8
--- samba-4.8.1/docs/manpages/vfs_shadow_copy2.8	2018-04-26 09:25:45.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_shadow_copy2.8	2018-05-16 12:15:17.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_shadow_copy2
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SHADOW_COPY2" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SHADOW_COPY2" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -519,7 +519,7 @@ vfs_shadow_copy2
 is designed to be an end\-user tool only\&. It does not replace or enhance your backup and archival solutions and should in no way be considered as such\&. Additionally, if you need version control, implement a version control system\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_shell_snap.8 samba-4.8.2/docs/manpages/vfs_shell_snap.8
--- samba-4.8.1/docs/manpages/vfs_shell_snap.8	2018-04-26 09:25:45.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_shell_snap.8	2018-05-16 12:15:18.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_shell_snap
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SHELL_SNAP" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SHELL_SNAP" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -215,7 +215,7 @@ Samba\*(Aqs FSRVP server must be configu
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_snapper.8 samba-4.8.2/docs/manpages/vfs_snapper.8
--- samba-4.8.1/docs/manpages/vfs_snapper.8	2018-04-26 09:25:45.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_snapper.8	2018-05-16 12:15:18.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_snapper
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SNAPPER" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SNAPPER" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -85,7 +85,7 @@ Remote snapshot creation and deletion is
 The DiskShadow\&.exe FSRVP client initially authenticates as the Active Directory computer account\&. This account must therefore be granted the same permissions as the user account issuing the snapshot creation and deletion requests\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_streams_depot.8 samba-4.8.2/docs/manpages/vfs_streams_depot.8
--- samba-4.8.1/docs/manpages/vfs_streams_depot.8	2018-04-26 09:25:45.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_streams_depot.8	2018-05-16 12:15:18.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_streams_depot
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_STREAMS_DEPOT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_STREAMS_DEPOT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_streams_xattr.8 samba-4.8.2/docs/manpages/vfs_streams_xattr.8
--- samba-4.8.1/docs/manpages/vfs_streams_xattr.8	2018-04-26 09:25:46.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_streams_xattr.8	2018-05-16 12:15:18.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_streams_xattr
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_STREAMS_XATTR" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_STREAMS_XATTR" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_syncops.8 samba-4.8.2/docs/manpages/vfs_syncops.8
--- samba-4.8.1/docs/manpages/vfs_syncops.8	2018-04-26 09:25:46.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_syncops.8	2018-05-16 12:15:18.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_syncops
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_SYNCOPS" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_SYNCOPS" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -76,7 +76,7 @@ Add syncops functionality for [share]:
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_time_audit.8 samba-4.8.2/docs/manpages/vfs_time_audit.8
--- samba-4.8.1/docs/manpages/vfs_time_audit.8	2018-04-26 09:25:46.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_time_audit.8	2018-05-16 12:15:19.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_time_audit
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_TIME_AUDIT" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_TIME_AUDIT" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -72,7 +72,7 @@ This would log VFS calls that take longe
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_tsmsm.8 samba-4.8.2/docs/manpages/vfs_tsmsm.8
--- samba-4.8.1/docs/manpages/vfs_tsmsm.8	2018-04-26 09:25:46.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_tsmsm.8	2018-05-16 12:15:19.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_tsmsm
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_TSMSM" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_TSMSM" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -83,7 +83,7 @@ A GPFS mount with TSM support can be exp
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_unityed_media.8 samba-4.8.2/docs/manpages/vfs_unityed_media.8
--- samba-4.8.1/docs/manpages/vfs_unityed_media.8	2018-04-26 09:25:47.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_unityed_media.8	2018-05-16 12:15:19.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_unityed_media
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_UNITYED_MEDIA" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_UNITYED_MEDIA" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -111,7 +111,7 @@ Enable unityed_media for Mac and Windows
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_virusfilter.8 samba-4.8.2/docs/manpages/vfs_virusfilter.8
--- samba-4.8.1/docs/manpages/vfs_virusfilter.8	2018-04-26 09:25:47.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_virusfilter.8	2018-05-16 12:15:19.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_virusfilter
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
 .\"    Source: Samba 4.8
 .\"  Language: English
 .\"
-.TH "VFS_VIRUSFILTER" "8" "04/26/2018" "Samba 4\&.8" "System Administration tools"
+.TH "VFS_VIRUSFILTER" "8" "05/16/2018" "Samba 4\&.8" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_worm.8 samba-4.8.2/docs/manpages/vfs_worm.8
--- samba-4.8.1/docs/manpages/vfs_worm.8	2018-04-26 09:25:47.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_worm.8	2018-05-16 12:15:19.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_worm
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_WORM" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_WORM" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -68,7 +68,7 @@ Deny the write access to files and folde
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfs_xattr_tdb.8 samba-4.8.2/docs/manpages/vfs_xattr_tdb.8
--- samba-4.8.1/docs/manpages/vfs_xattr_tdb.8	2018-04-26 09:25:47.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_xattr_tdb.8	2018-05-16 12:15:20.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_xattr_tdb
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_XATTR_TDB" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_XATTR_TDB" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
diff -Npur samba-4.8.1/docs/manpages/vfs_zfsacl.8 samba-4.8.2/docs/manpages/vfs_zfsacl.8
--- samba-4.8.1/docs/manpages/vfs_zfsacl.8	2018-04-26 09:25:47.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfs_zfsacl.8	2018-05-16 12:15:20.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfs_zfsacl
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFS_ZFSACL" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "VFS_ZFSACL" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -215,7 +215,7 @@ A ZFS mount can be exported via Samba as
 .\}
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/vfstest.1 samba-4.8.2/docs/manpages/vfstest.1
--- samba-4.8.1/docs/manpages/vfstest.1	2018-04-26 09:25:48.000000000 +0200
+++ samba-4.8.2/docs/manpages/vfstest.1	2018-05-16 12:15:20.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: vfstest
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "VFSTEST" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "VFSTEST" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -807,7 +807,7 @@ exit
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/wbinfo.1 samba-4.8.2/docs/manpages/wbinfo.1
--- samba-4.8.1/docs/manpages/wbinfo.1	2018-04-26 09:25:48.000000000 +0200
+++ samba-4.8.2/docs/manpages/wbinfo.1	2018-05-16 12:15:20.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: wbinfo
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: User Commands
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "WBINFO" "1" "04/26/2018" "Samba 4\&.8\&.1" "User Commands"
+.TH "WBINFO" "1" "05/16/2018" "Samba 4\&.8\&.2" "User Commands"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -440,7 +440,7 @@ wbinfo
 will always return failure\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 \fBwinbindd\fR(8)
diff -Npur samba-4.8.1/docs/manpages/winbind_krb5_locator.7 samba-4.8.2/docs/manpages/winbind_krb5_locator.7
--- samba-4.8.1/docs/manpages/winbind_krb5_locator.7	2018-04-26 09:25:48.000000000 +0200
+++ samba-4.8.2/docs/manpages/winbind_krb5_locator.7	2018-05-16 12:15:20.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: winbind_krb5_locator
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: 7
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "WINBIND_KRB5_LOCATOR" "7" "04/26/2018" "Samba 4\&.8\&.1" "7"
+.TH "WINBIND_KRB5_LOCATOR" "7" "05/16/2018" "Samba 4\&.8\&.2" "7"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -57,7 +57,7 @@ After copying the locator plugin to the
 /etc/krb5\&.conf\&.
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "AUTHOR"
 .PP
 The original Samba software and related utilities were created by Andrew Tridgell\&. Samba is now developed by the Samba Team as an Open Source project similar to the way the Linux kernel is developed\&.
diff -Npur samba-4.8.1/docs/manpages/winbindd.8 samba-4.8.2/docs/manpages/winbindd.8
--- samba-4.8.1/docs/manpages/winbindd.8	2018-04-26 09:25:48.000000000 +0200
+++ samba-4.8.2/docs/manpages/winbindd.8	2018-05-16 12:15:21.000000000 +0200
@@ -2,12 +2,12 @@
 .\"     Title: winbindd
 .\"    Author: [see the "AUTHOR" section]
 .\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
-.\"      Date: 04/26/2018
+.\"      Date: 05/16/2018
 .\"    Manual: System Administration tools
-.\"    Source: Samba 4.8.1
+.\"    Source: Samba 4.8.2
 .\"  Language: English
 .\"
-.TH "WINBINDD" "8" "04/26/2018" "Samba 4\&.8\&.1" "System Administration tools"
+.TH "WINBINDD" "8" "05/16/2018" "Samba 4\&.8\&.2" "System Administration tools"
 .\" -----------------------------------------------------------------
 .\" * Define some portability stuff
 .\" -----------------------------------------------------------------
@@ -579,7 +579,7 @@ Storage for cached user and group inform
 .RE
 .SH "VERSION"
 .PP
-This man page is part of version 4\&.8\&.1 of the Samba suite\&.
+This man page is part of version 4\&.8\&.2 of the Samba suite\&.
 .SH "SEE ALSO"
 .PP
 nsswitch\&.conf(5),
diff -Npur samba-4.8.1/lib/ldb/ABI/ldb-1.3.3.sigs samba-4.8.2/lib/ldb/ABI/ldb-1.3.3.sigs
--- samba-4.8.1/lib/ldb/ABI/ldb-1.3.3.sigs	1970-01-01 01:00:00.000000000 +0100
+++ samba-4.8.2/lib/ldb/ABI/ldb-1.3.3.sigs	2018-05-16 12:09:25.000000000 +0200
@@ -0,0 +1,279 @@
+ldb_add: int (struct ldb_context *, const struct ldb_message *)
+ldb_any_comparison: int (struct ldb_context *, void *, ldb_attr_handler_t, const struct ldb_val *, const struct ldb_val *)
+ldb_asprintf_errstring: void (struct ldb_context *, const char *, ...)
+ldb_attr_casefold: char *(TALLOC_CTX *, const char *)
+ldb_attr_dn: int (const char *)
+ldb_attr_in_list: int (const char * const *, const char *)
+ldb_attr_list_copy: const char **(TALLOC_CTX *, const char * const *)
+ldb_attr_list_copy_add: const char **(TALLOC_CTX *, const char * const *, const char *)
+ldb_base64_decode: int (char *)
+ldb_base64_encode: char *(TALLOC_CTX *, const char *, int)
+ldb_binary_decode: struct ldb_val (TALLOC_CTX *, const char *)
+ldb_binary_encode: char *(TALLOC_CTX *, struct ldb_val)
+ldb_binary_encode_string: char *(TALLOC_CTX *, const char *)
+ldb_build_add_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_del_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_extended_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const char *, void *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_mod_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_rename_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, struct ldb_dn *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_search_req: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, enum ldb_scope, const char *, const char * const *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_build_search_req_ex: int (struct ldb_request **, struct ldb_context *, TALLOC_CTX *, struct ldb_dn *, enum ldb_scope, struct ldb_parse_tree *, const char * const *, struct ldb_control **, void *, ldb_request_callback_t, struct ldb_request *)
+ldb_casefold: char *(struct ldb_context *, TALLOC_CTX *, const char *, size_t)
+ldb_casefold_default: char *(void *, TALLOC_CTX *, const char *, size_t)
+ldb_check_critical_controls: int (struct ldb_control **)
+ldb_comparison_binary: int (struct ldb_context *, void *, const struct ldb_val *, const struct ldb_val *)
+ldb_comparison_fold: int (struct ldb_context *, void *, const struct ldb_val *, const struct ldb_val *)
+ldb_connect: int (struct ldb_context *, const char *, unsigned int, const char **)
+ldb_control_to_string: char *(TALLOC_CTX *, const struct ldb_control *)
+ldb_controls_except_specified: struct ldb_control **(struct ldb_control **, TALLOC_CTX *, struct ldb_control *)
+ldb_debug: void (struct ldb_context *, enum ldb_debug_level, const char *, ...)
+ldb_debug_add: void (struct ldb_context *, const char *, ...)
+ldb_debug_end: void (struct ldb_context *, enum ldb_debug_level)
+ldb_debug_set: void (struct ldb_context *, enum ldb_debug_level, const char *, ...)
+ldb_delete: int (struct ldb_context *, struct ldb_dn *)
+ldb_dn_add_base: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_add_base_fmt: bool (struct ldb_dn *, const char *, ...)
+ldb_dn_add_child: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_add_child_fmt: bool (struct ldb_dn *, const char *, ...)
+ldb_dn_alloc_casefold: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_alloc_linearized: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_canonical_ex_string: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_canonical_string: char *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_check_local: bool (struct ldb_module *, struct ldb_dn *)
+ldb_dn_check_special: bool (struct ldb_dn *, const char *)
+ldb_dn_compare: int (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_compare_base: int (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_copy: struct ldb_dn *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_escape_value: char *(TALLOC_CTX *, struct ldb_val)
+ldb_dn_extended_add_syntax: int (struct ldb_context *, unsigned int, const struct ldb_dn_extended_syntax *)
+ldb_dn_extended_filter: void (struct ldb_dn *, const char * const *)
+ldb_dn_extended_syntax_by_name: const struct ldb_dn_extended_syntax *(struct ldb_context *, const char *)
+ldb_dn_from_ldb_val: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const struct ldb_val *)
+ldb_dn_get_casefold: const char *(struct ldb_dn *)
+ldb_dn_get_comp_num: int (struct ldb_dn *)
+ldb_dn_get_component_name: const char *(struct ldb_dn *, unsigned int)
+ldb_dn_get_component_val: const struct ldb_val *(struct ldb_dn *, unsigned int)
+ldb_dn_get_extended_comp_num: int (struct ldb_dn *)
+ldb_dn_get_extended_component: const struct ldb_val *(struct ldb_dn *, const char *)
+ldb_dn_get_extended_linearized: char *(TALLOC_CTX *, struct ldb_dn *, int)
+ldb_dn_get_ldb_context: struct ldb_context *(struct ldb_dn *)
+ldb_dn_get_linearized: const char *(struct ldb_dn *)
+ldb_dn_get_parent: struct ldb_dn *(TALLOC_CTX *, struct ldb_dn *)
+ldb_dn_get_rdn_name: const char *(struct ldb_dn *)
+ldb_dn_get_rdn_val: const struct ldb_val *(struct ldb_dn *)
+ldb_dn_has_extended: bool (struct ldb_dn *)
+ldb_dn_is_null: bool (struct ldb_dn *)
+ldb_dn_is_special: bool (struct ldb_dn *)
+ldb_dn_is_valid: bool (struct ldb_dn *)
+ldb_dn_map_local: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_map_rebase_remote: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_map_remote: struct ldb_dn *(struct ldb_module *, void *, struct ldb_dn *)
+ldb_dn_minimise: bool (struct ldb_dn *)
+ldb_dn_new: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const char *)
+ldb_dn_new_fmt: struct ldb_dn *(TALLOC_CTX *, struct ldb_context *, const char *, ...)
+ldb_dn_remove_base_components: bool (struct ldb_dn *, unsigned int)
+ldb_dn_remove_child_components: bool (struct ldb_dn *, unsigned int)
+ldb_dn_remove_extended_components: void (struct ldb_dn *)
+ldb_dn_replace_components: bool (struct ldb_dn *, struct ldb_dn *)
+ldb_dn_set_component: int (struct ldb_dn *, int, const char *, const struct ldb_val)
+ldb_dn_set_extended_component: int (struct ldb_dn *, const char *, const struct ldb_val *)
+ldb_dn_update_components: int (struct ldb_dn *, const struct ldb_dn *)
+ldb_dn_validate: bool (struct ldb_dn *)
+ldb_dump_results: void (struct ldb_context *, struct ldb_result *, FILE *)
+ldb_error_at: int (struct ldb_context *, int, const char *, const char *, int)
+ldb_errstring: const char *(struct ldb_context *)
+ldb_extended: int (struct ldb_context *, const char *, void *, struct ldb_result **)
+ldb_extended_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_filter_from_tree: char *(TALLOC_CTX *, const struct ldb_parse_tree *)
+ldb_get_config_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_create_perms: unsigned int (struct ldb_context *)
+ldb_get_default_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_event_context: struct tevent_context *(struct ldb_context *)
+ldb_get_flags: unsigned int (struct ldb_context *)
+ldb_get_opaque: void *(struct ldb_context *, const char *)
+ldb_get_root_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_get_schema_basedn: struct ldb_dn *(struct ldb_context *)
+ldb_global_init: int (void)
+ldb_handle_get_event_context: struct tevent_context *(struct ldb_handle *)
+ldb_handle_new: struct ldb_handle *(TALLOC_CTX *, struct ldb_context *)
+ldb_handle_use_global_event_context: void (struct ldb_handle *)
+ldb_handler_copy: int (struct ldb_context *, void *, const struct ldb_val *, struct ldb_val *)
+ldb_handler_fold: int (struct ldb_context *, void *, const struct ldb_val *, struct ldb_val *)
+ldb_init: struct ldb_context *(TALLOC_CTX *, struct tevent_context *)
+ldb_ldif_message_redacted_string: char *(struct ldb_context *, TALLOC_CTX *, enum ldb_changetype, const struct ldb_message *)
+ldb_ldif_message_string: char *(struct ldb_context *, TALLOC_CTX *, enum ldb_changetype, const struct ldb_message *)
+ldb_ldif_parse_modrdn: int (struct ldb_context *, const struct ldb_ldif *, TALLOC_CTX *, struct ldb_dn **, struct ldb_dn **, bool *, struct ldb_dn **, struct ldb_dn **)
+ldb_ldif_read: struct ldb_ldif *(struct ldb_context *, int (*)(void *), void *)
+ldb_ldif_read_file: struct ldb_ldif *(struct ldb_context *, FILE *)
+ldb_ldif_read_file_state: struct ldb_ldif *(struct ldb_context *, struct ldif_read_file_state *)
+ldb_ldif_read_free: void (struct ldb_context *, struct ldb_ldif *)
+ldb_ldif_read_string: struct ldb_ldif *(struct ldb_context *, const char **)
+ldb_ldif_write: int (struct ldb_context *, int (*)(void *, const char *, ...), void *, const struct ldb_ldif *)
+ldb_ldif_write_file: int (struct ldb_context *, FILE *, const struct ldb_ldif *)
+ldb_ldif_write_redacted_trace_string: char *(struct ldb_context *, TALLOC_CTX *, const struct ldb_ldif *)
+ldb_ldif_write_string: char *(struct ldb_context *, TALLOC_CTX *, const struct ldb_ldif *)
+ldb_load_modules: int (struct ldb_context *, const char **)
+ldb_map_add: int (struct ldb_module *, struct ldb_request *)
+ldb_map_delete: int (struct ldb_module *, struct ldb_request *)
+ldb_map_init: int (struct ldb_module *, const struct ldb_map_attribute *, const struct ldb_map_objectclass *, const char * const *, const char *, const char *)
+ldb_map_modify: int (struct ldb_module *, struct ldb_request *)
+ldb_map_rename: int (struct ldb_module *, struct ldb_request *)
+ldb_map_search: int (struct ldb_module *, struct ldb_request *)
+ldb_match_message: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, enum ldb_scope, bool *)
+ldb_match_msg: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, struct ldb_dn *, enum ldb_scope)
+ldb_match_msg_error: int (struct ldb_context *, const struct ldb_message *, const struct ldb_parse_tree *, struct ldb_dn *, enum ldb_scope, bool *)
+ldb_match_msg_objectclass: int (const struct ldb_message *, const char *)
+ldb_mod_register_control: int (struct ldb_module *, const char *)
+ldb_modify: int (struct ldb_context *, const struct ldb_message *)
+ldb_modify_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_module_call_chain: char *(struct ldb_request *, TALLOC_CTX *)
+ldb_module_connect_backend: int (struct ldb_context *, const char *, const char **, struct ldb_module **)
+ldb_module_done: int (struct ldb_request *, struct ldb_control **, struct ldb_extended *, int)
+ldb_module_flags: uint32_t (struct ldb_context *)
+ldb_module_get_ctx: struct ldb_context *(struct ldb_module *)
+ldb_module_get_name: const char *(struct ldb_module *)
+ldb_module_get_ops: const struct ldb_module_ops *(struct ldb_module *)
+ldb_module_get_private: void *(struct ldb_module *)
+ldb_module_init_chain: int (struct ldb_context *, struct ldb_module *)
+ldb_module_load_list: int (struct ldb_context *, const char **, struct ldb_module *, struct ldb_module **)
+ldb_module_new: struct ldb_module *(TALLOC_CTX *, struct ldb_context *, const char *, const struct ldb_module_ops *)
+ldb_module_next: struct ldb_module *(struct ldb_module *)
+ldb_module_popt_options: struct poptOption **(struct ldb_context *)
+ldb_module_send_entry: int (struct ldb_request *, struct ldb_message *, struct ldb_control **)
+ldb_module_send_referral: int (struct ldb_request *, char *)
+ldb_module_set_next: void (struct ldb_module *, struct ldb_module *)
+ldb_module_set_private: void (struct ldb_module *, void *)
+ldb_modules_hook: int (struct ldb_context *, enum ldb_module_hook_type)
+ldb_modules_list_from_string: const char **(struct ldb_context *, TALLOC_CTX *, const char *)
+ldb_modules_load: int (const char *, const char *)
+ldb_msg_add: int (struct ldb_message *, const struct ldb_message_element *, int)
+ldb_msg_add_empty: int (struct ldb_message *, const char *, int, struct ldb_message_element **)
+ldb_msg_add_fmt: int (struct ldb_message *, const char *, const char *, ...)
+ldb_msg_add_linearized_dn: int (struct ldb_message *, const char *, struct ldb_dn *)
+ldb_msg_add_steal_string: int (struct ldb_message *, const char *, char *)
+ldb_msg_add_steal_value: int (struct ldb_message *, const char *, struct ldb_val *)
+ldb_msg_add_string: int (struct ldb_message *, const char *, const char *)
+ldb_msg_add_value: int (struct ldb_message *, const char *, const struct ldb_val *, struct ldb_message_element **)
+ldb_msg_canonicalize: struct ldb_message *(struct ldb_context *, const struct ldb_message *)
+ldb_msg_check_string_attribute: int (const struct ldb_message *, const char *, const char *)
+ldb_msg_copy: struct ldb_message *(TALLOC_CTX *, const struct ldb_message *)
+ldb_msg_copy_attr: int (struct ldb_message *, const char *, const char *)
+ldb_msg_copy_shallow: struct ldb_message *(TALLOC_CTX *, const struct ldb_message *)
+ldb_msg_diff: struct ldb_message *(struct ldb_context *, struct ldb_message *, struct ldb_message *)
+ldb_msg_difference: int (struct ldb_context *, TALLOC_CTX *, struct ldb_message *, struct ldb_message *, struct ldb_message **)
+ldb_msg_element_compare: int (struct ldb_message_element *, struct ldb_message_element *)
+ldb_msg_element_compare_name: int (struct ldb_message_element *, struct ldb_message_element *)
+ldb_msg_element_equal_ordered: bool (const struct ldb_message_element *, const struct ldb_message_element *)
+ldb_msg_find_attr_as_bool: int (const struct ldb_message *, const char *, int)
+ldb_msg_find_attr_as_dn: struct ldb_dn *(struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, const char *)
+ldb_msg_find_attr_as_double: double (const struct ldb_message *, const char *, double)
+ldb_msg_find_attr_as_int: int (const struct ldb_message *, const char *, int)
+ldb_msg_find_attr_as_int64: int64_t (const struct ldb_message *, const char *, int64_t)
+ldb_msg_find_attr_as_string: const char *(const struct ldb_message *, const char *, const char *)
+ldb_msg_find_attr_as_uint: unsigned int (const struct ldb_message *, const char *, unsigned int)
+ldb_msg_find_attr_as_uint64: uint64_t (const struct ldb_message *, const char *, uint64_t)
+ldb_msg_find_common_values: int (struct ldb_context *, TALLOC_CTX *, struct ldb_message_element *, struct ldb_message_element *, uint32_t)
+ldb_msg_find_duplicate_val: int (struct ldb_context *, TALLOC_CTX *, const struct ldb_message_element *, struct ldb_val **, uint32_t)
+ldb_msg_find_element: struct ldb_message_element *(const struct ldb_message *, const char *)
+ldb_msg_find_ldb_val: const struct ldb_val *(const struct ldb_message *, const char *)
+ldb_msg_find_val: struct ldb_val *(const struct ldb_message_element *, struct ldb_val *)
+ldb_msg_new: struct ldb_message *(TALLOC_CTX *)
+ldb_msg_normalize: int (struct ldb_context *, TALLOC_CTX *, const struct ldb_message *, struct ldb_message **)
+ldb_msg_remove_attr: void (struct ldb_message *, const char *)
+ldb_msg_remove_element: void (struct ldb_message *, struct ldb_message_element *)
+ldb_msg_rename_attr: int (struct ldb_message *, const char *, const char *)
+ldb_msg_sanity_check: int (struct ldb_context *, const struct ldb_message *)
+ldb_msg_sort_elements: void (struct ldb_message *)
+ldb_next_del_trans: int (struct ldb_module *)
+ldb_next_end_trans: int (struct ldb_module *)
+ldb_next_init: int (struct ldb_module *)
+ldb_next_prepare_commit: int (struct ldb_module *)
+ldb_next_read_lock: int (struct ldb_module *)
+ldb_next_read_unlock: int (struct ldb_module *)
+ldb_next_remote_request: int (struct ldb_module *, struct ldb_request *)
+ldb_next_request: int (struct ldb_module *, struct ldb_request *)
+ldb_next_start_trans: int (struct ldb_module *)
+ldb_op_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_options_find: const char *(struct ldb_context *, const char **, const char *)
+ldb_pack_data: int (struct ldb_context *, const struct ldb_message *, struct ldb_val *)
+ldb_parse_control_from_string: struct ldb_control *(struct ldb_context *, TALLOC_CTX *, const char *)
+ldb_parse_control_strings: struct ldb_control **(struct ldb_context *, TALLOC_CTX *, const char **)
+ldb_parse_tree: struct ldb_parse_tree *(TALLOC_CTX *, const char *)
+ldb_parse_tree_attr_replace: void (struct ldb_parse_tree *, const char *, const char *)
+ldb_parse_tree_copy_shallow: struct ldb_parse_tree *(TALLOC_CTX *, const struct ldb_parse_tree *)
+ldb_parse_tree_walk: int (struct ldb_parse_tree *, int (*)(struct ldb_parse_tree *, void *), void *)
+ldb_qsort: void (void * const, size_t, size_t, void *, ldb_qsort_cmp_fn_t)
+ldb_register_backend: int (const char *, ldb_connect_fn, bool)
+ldb_register_extended_match_rule: int (struct ldb_context *, const struct ldb_extended_match_rule *)
+ldb_register_hook: int (ldb_hook_fn)
+ldb_register_module: int (const struct ldb_module_ops *)
+ldb_rename: int (struct ldb_context *, struct ldb_dn *, struct ldb_dn *)
+ldb_reply_add_control: int (struct ldb_reply *, const char *, bool, void *)
+ldb_reply_get_control: struct ldb_control *(struct ldb_reply *, const char *)
+ldb_req_get_custom_flags: uint32_t (struct ldb_request *)
+ldb_req_is_untrusted: bool (struct ldb_request *)
+ldb_req_location: const char *(struct ldb_request *)
+ldb_req_mark_trusted: void (struct ldb_request *)
+ldb_req_mark_untrusted: void (struct ldb_request *)
+ldb_req_set_custom_flags: void (struct ldb_request *, uint32_t)
+ldb_req_set_location: void (struct ldb_request *, const char *)
+ldb_request: int (struct ldb_context *, struct ldb_request *)
+ldb_request_add_control: int (struct ldb_request *, const char *, bool, void *)
+ldb_request_done: int (struct ldb_request *, int)
+ldb_request_get_control: struct ldb_control *(struct ldb_request *, const char *)
+ldb_request_get_status: int (struct ldb_request *)
+ldb_request_replace_control: int (struct ldb_request *, const char *, bool, void *)
+ldb_request_set_state: void (struct ldb_request *, int)
+ldb_reset_err_string: void (struct ldb_context *)
+ldb_save_controls: int (struct ldb_control *, struct ldb_request *, struct ldb_control ***)
+ldb_schema_attribute_add: int (struct ldb_context *, const char *, unsigned int, const char *)
+ldb_schema_attribute_add_with_syntax: int (struct ldb_context *, const char *, unsigned int, const struct ldb_schema_syntax *)
+ldb_schema_attribute_by_name: const struct ldb_schema_attribute *(struct ldb_context *, const char *)
+ldb_schema_attribute_fill_with_syntax: int (struct ldb_context *, TALLOC_CTX *, const char *, unsigned int, const struct ldb_schema_syntax *, struct ldb_schema_attribute *)
+ldb_schema_attribute_remove: void (struct ldb_context *, const char *)
+ldb_schema_attribute_remove_flagged: void (struct ldb_context *, unsigned int)
+ldb_schema_attribute_set_override_handler: void (struct ldb_context *, ldb_attribute_handler_override_fn_t, void *)
+ldb_schema_set_override_GUID_index: void (struct ldb_context *, const char *, const char *)
+ldb_schema_set_override_indexlist: void (struct ldb_context *, bool)
+ldb_search: int (struct ldb_context *, TALLOC_CTX *, struct ldb_result **, struct ldb_dn *, enum ldb_scope, const char * const *, const char *, ...)
+ldb_search_default_callback: int (struct ldb_request *, struct ldb_reply *)
+ldb_sequence_number: int (struct ldb_context *, enum ldb_sequence_type, uint64_t *)
+ldb_set_create_perms: void (struct ldb_context *, unsigned int)
+ldb_set_debug: int (struct ldb_context *, void (*)(void *, enum ldb_debug_level, const char *, va_list), void *)
+ldb_set_debug_stderr: int (struct ldb_context *)
+ldb_set_default_dns: void (struct ldb_context *)
+ldb_set_errstring: void (struct ldb_context *, const char *)
+ldb_set_event_context: void (struct ldb_context *, struct tevent_context *)
+ldb_set_flags: void (struct ldb_context *, unsigned int)
+ldb_set_modules_dir: void (struct ldb_context *, const char *)
+ldb_set_opaque: int (struct ldb_context *, const char *, void *)
+ldb_set_require_private_event_context: void (struct ldb_context *)
+ldb_set_timeout: int (struct ldb_context *, struct ldb_request *, int)
+ldb_set_timeout_from_prev_req: int (struct ldb_context *, struct ldb_request *, struct ldb_request *)
+ldb_set_utf8_default: void (struct ldb_context *)
+ldb_set_utf8_fns: void (struct ldb_context *, void *, char *(*)(void *, void *, const char *, size_t))
+ldb_setup_wellknown_attributes: int (struct ldb_context *)
+ldb_should_b64_encode: int (struct ldb_context *, const struct ldb_val *)
+ldb_standard_syntax_by_name: const struct ldb_schema_syntax *(struct ldb_context *, const char *)
+ldb_strerror: const char *(int)
+ldb_string_to_time: time_t (const char *)
+ldb_string_utc_to_time: time_t (const char *)
+ldb_timestring: char *(TALLOC_CTX *, time_t)
+ldb_timestring_utc: char *(TALLOC_CTX *, time_t)
+ldb_transaction_cancel: int (struct ldb_context *)
+ldb_transaction_cancel_noerr: int (struct ldb_context *)
+ldb_transaction_commit: int (struct ldb_context *)
+ldb_transaction_prepare_commit: int (struct ldb_context *)
+ldb_transaction_start: int (struct ldb_context *)
+ldb_unpack_data: int (struct ldb_context *, const struct ldb_val *, struct ldb_message *)
+ldb_unpack_data_only_attr_list: int (struct ldb_context *, const struct ldb_val *, struct ldb_message *, const char * const *, unsigned int, unsigned int *)
+ldb_unpack_data_only_attr_list_flags: int (struct ldb_context *, const struct ldb_val *, struct ldb_message *, const char * const *, unsigned int, unsigned int, unsigned int *)
+ldb_val_dup: struct ldb_val (TALLOC_CTX *, const struct ldb_val *)
+ldb_val_equal_exact: int (const struct ldb_val *, const struct ldb_val *)
+ldb_val_map_local: struct ldb_val (struct ldb_module *, void *, const struct ldb_map_attribute *, const struct ldb_val *)
+ldb_val_map_remote: struct ldb_val (struct ldb_module *, void *, const struct ldb_map_attribute *, const struct ldb_val *)
+ldb_val_string_cmp: int (const struct ldb_val *, const char *)
+ldb_val_to_time: int (const struct ldb_val *, time_t *)
+ldb_valid_attr_name: int (const char *)
+ldb_vdebug: void (struct ldb_context *, enum ldb_debug_level, const char *, va_list)
+ldb_wait: int (struct ldb_handle *, enum ldb_wait_type)
diff -Npur samba-4.8.1/lib/ldb/ABI/pyldb-util-1.3.3.sigs samba-4.8.2/lib/ldb/ABI/pyldb-util-1.3.3.sigs
--- samba-4.8.1/lib/ldb/ABI/pyldb-util-1.3.3.sigs	1970-01-01 01:00:00.000000000 +0100
+++ samba-4.8.2/lib/ldb/ABI/pyldb-util-1.3.3.sigs	2018-05-16 12:09:25.000000000 +0200
@@ -0,0 +1,2 @@
+pyldb_Dn_FromDn: PyObject *(struct ldb_dn *)
+pyldb_Object_AsDn: bool (TALLOC_CTX *, PyObject *, struct ldb_context *, struct ldb_dn **)
diff -Npur samba-4.8.1/lib/ldb/ABI/pyldb-util.py3-1.3.3.sigs samba-4.8.2/lib/ldb/ABI/pyldb-util.py3-1.3.3.sigs
--- samba-4.8.1/lib/ldb/ABI/pyldb-util.py3-1.3.3.sigs	1970-01-01 01:00:00.000000000 +0100
+++ samba-4.8.2/lib/ldb/ABI/pyldb-util.py3-1.3.3.sigs	2018-05-16 12:09:25.000000000 +0200
@@ -0,0 +1,2 @@
+pyldb_Dn_FromDn: PyObject *(struct ldb_dn *)
+pyldb_Object_AsDn: bool (TALLOC_CTX *, PyObject *, struct ldb_context *, struct ldb_dn **)
diff -Npur samba-4.8.1/lib/ldb/ldb_tdb/ldb_index.c samba-4.8.2/lib/ldb/ldb_tdb/ldb_index.c
--- samba-4.8.1/lib/ldb/ldb_tdb/ldb_index.c	2018-03-01 21:18:10.000000000 +0100
+++ samba-4.8.2/lib/ldb/ldb_tdb/ldb_index.c	2018-05-16 12:09:25.000000000 +0200
@@ -1526,6 +1526,7 @@ static int ltdb_index_filter(struct ltdb
 	struct ldb_message *msg;
 	struct ldb_message *filtered_msg;
 	unsigned int i;
+	uint8_t previous_guid_key[LTDB_GUID_KEY_SIZE] = {};
 
 	ldb = ldb_module_get_ctx(ac->module);
 
@@ -1538,11 +1539,6 @@ static int ltdb_index_filter(struct ltdb
 		int ret;
 		bool matched;
 
-		msg = ldb_msg_new(ac);
-		if (!msg) {
-			return LDB_ERR_OPERATIONS_ERROR;
-		}
-
 		ret = ltdb_idx_to_key(ac->module, ltdb,
 				      ac, &dn_list->dn[i],
 				      &tdb_key);
@@ -1550,6 +1546,33 @@ static int ltdb_index_filter(struct ltdb
 			return ret;
 		}
 
+		if (ltdb->cache->GUID_index_attribute != NULL) {
+			/*
+			 * If we are in GUID index mode, then the dn_list is
+			 * sorted.  If we got a duplicate, forget about it, as
+			 * otherwise we would send the same entry back more
+			 * than once.
+			 *
+			 * This is needed in the truncated DN case, or if a
+			 * duplicate was forced in via
+			 * LDB_FLAG_INTERNAL_DISABLE_SINGLE_VALUE_CHECK
+			 */
+
+			if (memcmp(previous_guid_key, tdb_key.dptr,
+				   sizeof(previous_guid_key)) == 0) {
+				continue;
+			}
+
+			memcpy(previous_guid_key, tdb_key.dptr,
+			       sizeof(previous_guid_key));
+		}
+
+		msg = ldb_msg_new(ac);
+		if (!msg) {
+			return LDB_ERR_OPERATIONS_ERROR;
+		}
+
+
 		ret = ltdb_search_key(ac->module, ltdb,
 				      tdb_key, msg,
 				      LDB_UNPACK_DATA_FLAG_NO_DATA_ALLOC|
@@ -1923,9 +1946,36 @@ static int ltdb_index_add1(struct ldb_mo
 		BINARY_ARRAY_SEARCH_GTE(list->dn, list->count,
 					*key_val, ldb_val_equal_exact_ordered,
 					exact, next);
+
+		/*
+		 * Give a warning rather than fail, this could be a
+		 * duplicate value in the record allowed by a caller
+		 * forcing in the value with
+		 * LDB_FLAG_INTERNAL_DISABLE_SINGLE_VALUE_CHECK
+		 */
 		if (exact != NULL) {
-			talloc_free(list);
-			return LDB_ERR_OPERATIONS_ERROR;
+			/* This can't fail, gives a default at worst */
+			const struct ldb_schema_attribute *attr
+				= ldb_schema_attribute_by_name(
+					ldb,
+					ltdb->cache->GUID_index_attribute);
+			struct ldb_val v;
+			ret = attr->syntax->ldif_write_fn(ldb, list,
+							  exact, &v);
+			if (ret == LDB_SUCCESS) {
+				ldb_debug(ldb, LDB_DEBUG_WARNING,
+					  __location__
+					  ": duplicate attribute value in %s "
+					  "for index on %s, "
+					  "duplicate of %s %*.*s in %s",
+					  ldb_dn_get_linearized(msg->dn),
+					  el->name,
+					  ltdb->cache->GUID_index_attribute,
+					  (int)v.length,
+					  (int)v.length,
+					  v.data,
+					  ldb_dn_get_linearized(dn_key));
+			}
 		}
 
 		if (next == NULL) {
diff -Npur samba-4.8.1/lib/ldb/ldb_tdb/ldb_tdb.c samba-4.8.2/lib/ldb/ldb_tdb/ldb_tdb.c
--- samba-4.8.1/lib/ldb/ldb_tdb/ldb_tdb.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/lib/ldb/ldb_tdb/ldb_tdb.c	2018-05-16 12:09:25.000000000 +0200
@@ -410,6 +410,10 @@ static int ltdb_modified(struct ldb_modu
 		ret = ltdb_cache_reload(module);
 	}
 
+	if (ret != LDB_SUCCESS) {
+		ltdb->reindex_failed = true;
+	}
+
 	return ret;
 }
 
@@ -1404,9 +1408,17 @@ static int ltdb_start_trans(struct ldb_m
 
 	ltdb_index_transaction_start(module);
 
+	ltdb->reindex_failed = false;
+
 	return LDB_SUCCESS;
 }
 
+/*
+ * Forward declaration to allow prepare_commit to in fact abort the
+ * transaction
+ */
+static int ltdb_del_trans(struct ldb_module *module);
+
 static int ltdb_prepare_commit(struct ldb_module *module)
 {
 	int ret;
@@ -1417,6 +1429,24 @@ static int ltdb_prepare_commit(struct ld
 		return LDB_SUCCESS;
 	}
 
+	/*
+	 * Check if the last re-index failed.
+	 *
+	 * This can happen if for example a duplicate value was marked
+	 * unique.  We must not write a partial re-index into the DB.
+	 */
+	if (ltdb->reindex_failed) {
+		/*
+		 * We must instead abort the transaction so we get the
+		 * old values and old index back
+		 */
+		ltdb_del_trans(module);
+		ldb_set_errstring(ldb_module_get_ctx(module),
+				  "Failure during re-index, so "
+				  "transaction must be aborted.");
+		return LDB_ERR_OPERATIONS_ERROR;
+	}
+
 	ret = ltdb_index_transaction_commit(module);
 	if (ret != LDB_SUCCESS) {
 		tdb_transaction_cancel(ltdb->tdb);
diff -Npur samba-4.8.1/lib/ldb/ldb_tdb/ldb_tdb.h samba-4.8.2/lib/ldb/ldb_tdb/ldb_tdb.h
--- samba-4.8.1/lib/ldb/ldb_tdb/ldb_tdb.h	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/lib/ldb/ldb_tdb/ldb_tdb.h	2018-05-16 12:09:25.000000000 +0200
@@ -37,6 +37,8 @@ struct ltdb_private {
 
 	bool read_only;
 
+	bool reindex_failed;
+
 	const struct ldb_schema_syntax *GUID_index_syntax;
 };
 
diff -Npur samba-4.8.1/lib/ldb/tests/python/api.py samba-4.8.2/lib/ldb/tests/python/api.py
--- samba-4.8.1/lib/ldb/tests/python/api.py	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/lib/ldb/tests/python/api.py	2018-05-16 12:09:25.000000000 +0200
@@ -12,6 +12,9 @@ import shutil
 
 PY3 = sys.version_info > (3, 0)
 
+TDB_PREFIX = "tdb://"
+MDB_PREFIX = "mdb://"
+
 
 def tempdir():
     import tempfile
@@ -44,13 +47,36 @@ class NoContextTests(TestCase):
         encoded2 = ldb.binary_encode('test\\x')
         self.assertEqual(encoded2, encoded)
 
-class SimpleLdb(TestCase):
+
+class LdbBaseTest(TestCase):
+    def setUp(self):
+        super(LdbBaseTest, self).setUp()
+        try:
+            if self.prefix is None:
+                self.prefix = TDB_PREFIX
+        except AttributeError:
+            self.prefix = TDB_PREFIX
+
+    def tearDown(self):
+        super(LdbBaseTest, self).tearDown()
+
+    def url(self):
+        return self.prefix + self.filename
+
+    def flags(self):
+        if self.prefix == MDB_PREFIX:
+            return ldb.FLG_NOSYNC
+        else:
+            return 0
+
+
+class SimpleLdb(LdbBaseTest):
 
     def setUp(self):
         super(SimpleLdb, self).setUp()
         self.testdir = tempdir()
         self.filename = os.path.join(self.testdir, "test.ldb")
-        self.ldb = ldb.Ldb(self.filename)
+        self.ldb = ldb.Ldb(self.url(), flags=self.flags())
 
     def tearDown(self):
         shutil.rmtree(self.testdir)
@@ -58,16 +84,15 @@ class SimpleLdb(TestCase):
         # Ensure the LDB is closed now, so we close the FD
         del(self.ldb)
 
-
     def test_connect(self):
-        ldb.Ldb(self.filename)
+        ldb.Ldb(self.url(), flags=self.flags())
 
     def test_connect_none(self):
         ldb.Ldb()
 
     def test_connect_later(self):
         x = ldb.Ldb()
-        x.connect(self.filename)
+        x.connect(self.url(), flags=self.flags())
 
     def test_repr(self):
         x = ldb.Ldb()
@@ -82,7 +107,7 @@ class SimpleLdb(TestCase):
         self.assertEqual([], x.modules())
 
     def test_modules_tdb(self):
-        x = ldb.Ldb(self.filename)
+        x = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual("[<ldb module 'tdb'>]", repr(x.modules()))
 
     def test_firstmodule_none(self):
@@ -90,53 +115,53 @@ class SimpleLdb(TestCase):
         self.assertEqual(x.firstmodule, None)
 
     def test_firstmodule_tdb(self):
-        x = ldb.Ldb(self.filename)
+        x = ldb.Ldb(self.url(), flags=self.flags())
         mod = x.firstmodule
         self.assertEqual(repr(mod), "<ldb module 'tdb'>")
 
     def test_search(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search()), 0)
 
     def test_search_controls(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search(controls=["paged_results:0:5"])), 0)
 
     def test_search_attrs(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search(ldb.Dn(l, ""), ldb.SCOPE_SUBTREE, "(dc=*)", ["dc"])), 0)
 
     def test_search_string_dn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search("", ldb.SCOPE_SUBTREE, "(dc=*)", ["dc"])), 0)
 
     def test_search_attr_string(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertRaises(TypeError, l.search, attrs="dc")
         self.assertRaises(TypeError, l.search, attrs=b"dc")
 
     def test_opaque(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         l.set_opaque("my_opaque", l)
         self.assertTrue(l.get_opaque("my_opaque") is not None)
         self.assertEqual(None, l.get_opaque("unknown"))
 
     def test_search_scope_base_empty_db(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search(ldb.Dn(l, "dc=foo1"),
                           ldb.SCOPE_BASE)), 0)
 
     def test_search_scope_onelevel_empty_db(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(len(l.search(ldb.Dn(l, "dc=foo1"),
                           ldb.SCOPE_ONELEVEL)), 0)
 
     def test_delete(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertRaises(ldb.LdbError, lambda: l.delete(ldb.Dn(l, "dc=foo2")))
 
     def test_delete_w_unhandled_ctrl(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo1")
         m["b"] = [b"a"]
@@ -145,10 +170,10 @@ class SimpleLdb(TestCase):
         l.delete(m.dn)
 
     def test_contains(self):
-        name = self.filename
-        l = ldb.Ldb(name)
+        name = self.url()
+        l = ldb.Ldb(name, flags=self.flags())
         self.assertFalse(ldb.Dn(l, "dc=foo3") in l)
-        l = ldb.Ldb(name)
+        l = ldb.Ldb(name, flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo3")
         m["b"] = ["a"]
@@ -160,23 +185,23 @@ class SimpleLdb(TestCase):
             l.delete(m.dn)
 
     def test_get_config_basedn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(None, l.get_config_basedn())
 
     def test_get_root_basedn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(None, l.get_root_basedn())
 
     def test_get_schema_basedn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(None, l.get_schema_basedn())
 
     def test_get_default_basedn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(None, l.get_default_basedn())
 
     def test_add(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo4")
         m["bla"] = b"bla"
@@ -188,7 +213,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo4"))
 
     def test_search_iterator(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         s = l.search_iterator()
         s.abandon()
         try:
@@ -288,7 +313,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo5"))
 
     def test_add_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo4")
         m["bla"] = "bla"
@@ -300,7 +325,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo4"))
 
     def test_add_w_unhandled_ctrl(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo4")
         m["bla"] = b"bla"
@@ -308,7 +333,7 @@ class SimpleLdb(TestCase):
         self.assertRaises(ldb.LdbError, lambda: l.add(m,["search_options:1:2"]))
 
     def test_add_dict(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = {"dn": ldb.Dn(l, "dc=foo5"),
              "bla": b"bla"}
         self.assertEqual(len(l.search()), 0)
@@ -319,7 +344,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo5"))
 
     def test_add_dict_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = {"dn": ldb.Dn(l, "dc=foo5"),
              "bla": "bla"}
         self.assertEqual(len(l.search()), 0)
@@ -330,7 +355,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo5"))
 
     def test_add_dict_string_dn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = {"dn": "dc=foo6", "bla": b"bla"}
         self.assertEqual(len(l.search()), 0)
         l.add(m)
@@ -340,7 +365,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo6"))
 
     def test_add_dict_bytes_dn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = {"dn": b"dc=foo6", "bla": b"bla"}
         self.assertEqual(len(l.search()), 0)
         l.add(m)
@@ -350,7 +375,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=foo6"))
 
     def test_rename(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo7")
         m["bla"] = b"bla"
@@ -363,7 +388,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=bar"))
 
     def test_rename_string_dns(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=foo8")
         m["bla"] = b"bla"
@@ -377,7 +402,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=bar"))
 
     def test_empty_dn(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertEqual(0, len(l.search()))
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=empty")
@@ -394,7 +419,7 @@ class SimpleLdb(TestCase):
         self.assertEqual(0, len(rm[0]))
 
     def test_modify_delete(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=modifydelete")
         m["bla"] = [b"1234"]
@@ -417,7 +442,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=modifydelete"))
 
     def test_modify_delete_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=modifydelete")
         m.text["bla"] = ["1234"]
@@ -440,7 +465,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=modifydelete"))
 
     def test_modify_add(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=add")
         m["bla"] = [b"1234"]
@@ -458,7 +483,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=add"))
 
     def test_modify_add_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=add")
         m.text["bla"] = ["1234"]
@@ -476,7 +501,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=add"))
 
     def test_modify_replace(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=modify2")
         m["bla"] = [b"1234", b"456"]
@@ -496,7 +521,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=modify2"))
 
     def test_modify_replace_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=modify2")
         m.text["bla"] = ["1234", "456"]
@@ -516,7 +541,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=modify2"))
 
     def test_modify_flags_change(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=add")
         m["bla"] = [b"1234"]
@@ -542,7 +567,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=add"))
 
     def test_modify_flags_change_text(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         m = ldb.Message()
         m.dn = ldb.Dn(l, "dc=add")
         m.text["bla"] = ["1234"]
@@ -568,7 +593,7 @@ class SimpleLdb(TestCase):
             l.delete(ldb.Dn(l, "dc=add"))
 
     def test_transaction_commit(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         l.transaction_start()
         m = ldb.Message(ldb.Dn(l, "dc=foo9"))
         m["foo"] = [b"bar"]
@@ -577,7 +602,7 @@ class SimpleLdb(TestCase):
         l.delete(m.dn)
 
     def test_transaction_cancel(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         l.transaction_start()
         m = ldb.Message(ldb.Dn(l, "dc=foo10"))
         m["foo"] = [b"bar"]
@@ -588,12 +613,12 @@ class SimpleLdb(TestCase):
     def test_set_debug(self):
         def my_report_fn(level, text):
             pass
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         l.set_debug(my_report_fn)
 
     def test_zero_byte_string(self):
         """Testing we do not get trapped in the \0 byte in a property string."""
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         l.add({
             "dn" : b"dc=somedn",
             "objectclass" : b"user",
@@ -605,10 +630,10 @@ class SimpleLdb(TestCase):
         self.assertEqual(b"foo\0bar", res[0]["displayname"][0])
 
     def test_no_crash_broken_expr(self):
-        l = ldb.Ldb(self.filename)
+        l = ldb.Ldb(self.url(), flags=self.flags())
         self.assertRaises(ldb.LdbError,lambda: l.search("", ldb.SCOPE_SUBTREE, "&(dc=*)(dn=*)", ["dc"]))
 
-class SearchTests(TestCase):
+class SearchTests(LdbBaseTest):
     def tearDown(self):
         shutil.rmtree(self.testdir)
         super(SearchTests, self).tearDown()
@@ -621,7 +646,9 @@ class SearchTests(TestCase):
         super(SearchTests, self).setUp()
         self.testdir = tempdir()
         self.filename = os.path.join(self.testdir, "search_test.ldb")
-        self.l = ldb.Ldb(self.filename, options=["modules:rdn_name"])
+        self.l = ldb.Ldb(self.url(),
+                         flags=self.flags(),
+                         options=["modules:rdn_name"])
 
         self.l.add({"dn": "@ATTRIBUTES",
                     "DC": "CASE_INSENSITIVE"})
@@ -1030,7 +1057,6 @@ class SearchTests(TestCase):
         self.assertEqual(len(res11), 1)
 
 
-
 class IndexedSearchTests(SearchTests):
     """Test searches using the index, to ensure the index doesn't
        break things"""
@@ -1091,6 +1117,7 @@ class GUIDIndexedSearchTests(SearchTests
         self.IDXGUID = True
         self.IDXONE = True
 
+
 class GUIDIndexedDNFilterSearchTests(SearchTests):
     """Test searches using the index, to ensure the index doesn't
        break things"""
@@ -1126,7 +1153,7 @@ class GUIDAndOneLevelIndexedSearchTests(
         self.IDXONE = True
 
 
-class AddModifyTests(TestCase):
+class AddModifyTests(LdbBaseTest):
     def tearDown(self):
         shutil.rmtree(self.testdir)
         super(AddModifyTests, self).tearDown()
@@ -1138,7 +1165,9 @@ class AddModifyTests(TestCase):
         super(AddModifyTests, self).setUp()
         self.testdir = tempdir()
         self.filename = os.path.join(self.testdir, "add_test.ldb")
-        self.l = ldb.Ldb(self.filename, options=["modules:rdn_name"])
+        self.l = ldb.Ldb(self.url(),
+                         flags=self.flags(),
+                         options=["modules:rdn_name"])
         self.l.add({"dn": "DC=SAMBA,DC=ORG",
                     "name": b"samba.org",
                     "objectUUID": b"0123456789abcdef"})
@@ -1266,6 +1295,7 @@ class AddModifyTests(TestCase):
                     "x": "z", "y": "a",
                     "objectUUID": b"0123456789abcde3"})
 
+
 class IndexedAddModifyTests(AddModifyTests):
     """Test searches using the index, to ensure the index doesn't
        break things"""
@@ -1378,6 +1408,165 @@ class TransIndexedAddModifyTests(Indexed
         super(TransIndexedAddModifyTests, self).tearDown()
 
 
+class BadIndexTests(LdbBaseTest):
+    def setUp(self):
+        super(BadIndexTests, self).setUp()
+        self.testdir = tempdir()
+        self.filename = os.path.join(self.testdir, "test.ldb")
+        self.ldb = ldb.Ldb(self.url(), flags=self.flags())
+        if hasattr(self, 'IDXGUID'):
+            self.ldb.add({"dn": "@INDEXLIST",
+                          "@IDXATTR": [b"x", b"y", b"ou"],
+                          "@IDXGUID": [b"objectUUID"],
+                          "@IDX_DN_GUID": [b"GUID"]})
+        else:
+            self.ldb.add({"dn": "@INDEXLIST",
+                          "@IDXATTR": [b"x", b"y", b"ou"]})
+
+        super(BadIndexTests, self).setUp()
+
+    def test_unique(self):
+        self.ldb.add({"dn": "x=x,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde1",
+                      "y": "1"})
+        self.ldb.add({"dn": "x=y,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde2",
+                      "y": "1"})
+        self.ldb.add({"dn": "x=z,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde3",
+                      "y": "1"})
+
+        res = self.ldb.search(expression="(y=1)",
+                              base="dc=samba,dc=org")
+        self.assertEquals(len(res), 3)
+
+        # Now set this to unique index, but forget to check the result
+        try:
+            self.ldb.add({"dn": "@ATTRIBUTES",
+                        "y": "UNIQUE_INDEX"})
+            self.fail()
+        except ldb.LdbError:
+            pass
+
+        # We must still have a working index
+        res = self.ldb.search(expression="(y=1)",
+                              base="dc=samba,dc=org")
+        self.assertEquals(len(res), 3)
+
+    def test_unique_transaction(self):
+        self.ldb.add({"dn": "x=x,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde1",
+                      "y": "1"})
+        self.ldb.add({"dn": "x=y,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde2",
+                      "y": "1"})
+        self.ldb.add({"dn": "x=z,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde3",
+                      "y": "1"})
+
+        res = self.ldb.search(expression="(y=1)",
+                              base="dc=samba,dc=org")
+        self.assertEquals(len(res), 3)
+
+        self.ldb.transaction_start()
+
+        # Now set this to unique index, but forget to check the result
+        try:
+            self.ldb.add({"dn": "@ATTRIBUTES",
+                        "y": "UNIQUE_INDEX"})
+        except ldb.LdbError:
+            pass
+
+        try:
+            self.ldb.transaction_commit()
+            self.fail()
+
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_OPERATIONS_ERROR)
+
+        # We must still have a working index
+        res = self.ldb.search(expression="(y=1)",
+                              base="dc=samba,dc=org")
+
+        self.assertEquals(len(res), 3)
+
+    def test_casefold(self):
+        self.ldb.add({"dn": "x=x,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde1",
+                      "y": "a"})
+        self.ldb.add({"dn": "x=y,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde2",
+                      "y": "A"})
+        self.ldb.add({"dn": "x=z,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde3",
+                      "y": ["a", "A"]})
+
+        res = self.ldb.search(expression="(y=a)",
+                              base="dc=samba,dc=org")
+        self.assertEquals(len(res), 2)
+
+        self.ldb.add({"dn": "@ATTRIBUTES",
+                      "y": "CASE_INSENSITIVE"})
+
+        # We must still have a working index
+        res = self.ldb.search(expression="(y=a)",
+                              base="dc=samba,dc=org")
+
+        if hasattr(self, 'IDXGUID'):
+            self.assertEquals(len(res), 3)
+        else:
+            # We should not return this entry twice, but sadly
+            # we have not yet fixed
+            # https://bugzilla.samba.org/show_bug.cgi?id=13361
+            self.assertEquals(len(res), 4)
+
+    def test_casefold_transaction(self):
+        self.ldb.add({"dn": "x=x,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde1",
+                      "y": "a"})
+        self.ldb.add({"dn": "x=y,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde2",
+                      "y": "A"})
+        self.ldb.add({"dn": "x=z,dc=samba,dc=org",
+                      "objectUUID": b"0123456789abcde3",
+                      "y": ["a", "A"]})
+
+        res = self.ldb.search(expression="(y=a)",
+                              base="dc=samba,dc=org")
+        self.assertEquals(len(res), 2)
+
+        self.ldb.transaction_start()
+
+        self.ldb.add({"dn": "@ATTRIBUTES",
+                      "y": "CASE_INSENSITIVE"})
+
+        self.ldb.transaction_commit()
+
+        # We must still have a working index
+        res = self.ldb.search(expression="(y=a)",
+                              base="dc=samba,dc=org")
+
+        if hasattr(self, 'IDXGUID'):
+            self.assertEquals(len(res), 3)
+        else:
+            # We should not return this entry twice, but sadly
+            # we have not yet fixed
+            # https://bugzilla.samba.org/show_bug.cgi?id=13361
+            self.assertEquals(len(res), 4)
+
+
+    def tearDown(self):
+        super(BadIndexTests, self).tearDown()
+
+
+class GUIDBadIndexTests(BadIndexTests):
+    """Test Bad index things with GUID index mode"""
+    def setUp(self):
+        self.IDXGUID = True
+
+        super(GUIDBadIndexTests, self).setUp()
+
 
 class DnTests(TestCase):
 
@@ -1985,13 +2174,13 @@ class ModuleTests(TestCase):
         l = ldb.Ldb(self.filename)
         self.assertEqual(["init"], ops)
 
-class LdbResultTests(TestCase):
+class LdbResultTests(LdbBaseTest):
 
     def setUp(self):
         super(LdbResultTests, self).setUp()
         self.testdir = tempdir()
         self.filename = os.path.join(self.testdir, "test.ldb")
-        self.l = ldb.Ldb(self.filename)
+        self.l = ldb.Ldb(self.url(), flags=self.flags())
         self.l.add({"dn": "DC=SAMBA,DC=ORG", "name": b"samba.org"})
         self.l.add({"dn": "OU=ADMIN,DC=SAMBA,DC=ORG", "name": b"Admins"})
         self.l.add({"dn": "OU=USERS,DC=SAMBA,DC=ORG", "name": b"Users"})
@@ -2099,7 +2288,7 @@ class LdbResultTests(TestCase):
             del(self.l)
             gc.collect()
 
-            child_ldb = ldb.Ldb(self.filename)
+            child_ldb = ldb.Ldb(self.url(), flags=self.flags())
             # start a transaction
             child_ldb.transaction_start()
 
@@ -2170,7 +2359,7 @@ class LdbResultTests(TestCase):
             del(self.l)
             gc.collect()
 
-            child_ldb = ldb.Ldb(self.filename)
+            child_ldb = ldb.Ldb(self.url(), flags=self.flags())
             # start a transaction
             child_ldb.transaction_start()
 
diff -Npur samba-4.8.1/lib/ldb/tests/python/index.py samba-4.8.2/lib/ldb/tests/python/index.py
--- samba-4.8.1/lib/ldb/tests/python/index.py	1970-01-01 01:00:00.000000000 +0100
+++ samba-4.8.2/lib/ldb/tests/python/index.py	2018-05-16 12:09:25.000000000 +0200
@@ -0,0 +1,1032 @@
+#!/usr/bin/env python
+#
+# Tests for truncated index keys
+#
+#   Copyright (C) Andrew Bartlett <abartlet@samba.org> 2018
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program.  If not, see <http://www.gnu.org/licenses/>.
+#
+"""Tests for index keys
+
+This is a modified version of the test from master for databases such
+as lmdb have a maximum key length, instead just checking that the
+GUID index code still operates correctly.
+
+Many of the test names are therefore incorrect, but are retained
+to keep the code easy to backport into if more tested are added in
+master.
+
+"""
+
+import os
+from unittest import TestCase
+import sys
+import ldb
+import shutil
+
+PY3 = sys.version_info > (3, 0)
+
+TDB_PREFIX = "tdb://"
+MDB_PREFIX = "mdb://"
+
+
+def tempdir():
+    import tempfile
+    try:
+        dir_prefix = os.path.join(os.environ["SELFTEST_PREFIX"], "tmp")
+    except KeyError:
+        dir_prefix = None
+    return tempfile.mkdtemp(dir=dir_prefix)
+
+
+def contains(result, dn):
+    if result is None:
+        return False
+
+    for r in result:
+        if str(r["dn"]) == dn:
+            return True
+    return False
+
+
+class LdbBaseTest(TestCase):
+    def setUp(self):
+        super(LdbBaseTest, self).setUp()
+        try:
+            if self.prefix is None:
+                self.prefix = TDB_PREFIX
+        except AttributeError:
+            self.prefix = TDB_PREFIX
+
+    def tearDown(self):
+        super(LdbBaseTest, self).tearDown()
+
+    def url(self):
+        return self.prefix + self.filename
+
+    def flags(self):
+        if self.prefix == MDB_PREFIX:
+            return ldb.FLG_NOSYNC
+        else:
+            return 0
+
+
+class MaxIndexKeyLengthTests(LdbBaseTest):
+    def checkGuids(self, key, guids):
+        #
+        # This check relies on the current implementation where the indexes
+        # are in the same database as the data.
+        #
+        # It checks that the index record exists, unless guids is None then
+        # the record must not exist. And the it contains the expected guid
+        # entries.
+        #
+        # The caller needs to provide the GUID's in the expected order
+        #
+        res = self.l.search(
+            base=key,
+            scope=ldb.SCOPE_BASE)
+        if guids is None:
+            self.assertEqual(len(res), 0)
+            return
+        self.assertEqual(len(res), 1)
+
+        # The GUID index format has only one value
+        index = res[0]["@IDX"][0]
+        self.assertEqual(len(guids), len(index))
+        self.assertEqual(guids, index)
+
+    def tearDown(self):
+        shutil.rmtree(self.testdir)
+        super(MaxIndexKeyLengthTests, self).tearDown()
+
+        # Ensure the LDB is closed now, so we close the FD
+        del(self.l)
+
+    def setUp(self):
+        super(MaxIndexKeyLengthTests, self).setUp()
+        self.testdir = tempdir()
+        self.filename = os.path.join(self.testdir, "key_len_test.ldb")
+        # Note that the maximum key length is set to 50
+        self.l = ldb.Ldb(self.url(),
+                         options=[
+                             "modules:rdn_name",
+                             "max_key_len_for_self_test:50"])
+        self.l.add({"dn": "@ATTRIBUTES",
+                    "uniqueThing": "UNIQUE_INDEX"})
+        self.l.add({"dn": "@INDEXLIST",
+                    "@IDXATTR": [b"uniqueThing", b"notUnique"],
+                    "@IDXONE": [b"1"],
+                    "@IDXGUID": [b"objectUUID"],
+                    "@IDX_DN_GUID": [b"GUID"]})
+
+    # Test that DN's longer the maximum key length can be added
+    # and that duplicate DN's are rejected correctly
+    def test_add_long_dn_add(self):
+        #
+        # For all entries the DN index key gets truncated to
+        # @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        #
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM",
+                    "objectUUID": b"0123456789abcde0"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                    "objectUUID": b"0123456789abcde1"})
+
+        # Key is equal to max length does not get inserted into the truncated
+        # key namespace
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde5"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        # This key should not get truncated, as it's one character less than
+        # max, and will not be in the truncate name space
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde7"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde7")
+
+        try:
+            self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                        "objectUUID": b"0123456789abcde2"})
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+        try:
+            self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM",
+                        "objectUUID": b"0123456789abcde3"})
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+        try:
+            self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                        "objectUUID": b"0123456789abcde4"})
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+        try:
+            self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                        "objectUUID": b"0123456789abcde6"})
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+        try:
+            self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXX,DC=SAMBA",
+                        "objectUUID": b"0123456789abcde8"})
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+    def test_rename_truncated_dn_keys(self):
+        # For all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM",
+                    "objectUUID": b"0123456789abcde0"})
+
+        # Non conflicting rename, should succeed
+        self.l.rename("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                      "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+
+        # Conflicting rename should fail
+        try:
+            self.l.rename("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM",
+                          "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_ENTRY_ALREADY_EXISTS)
+
+    def test_delete_truncated_dn_keys(self):
+        #
+        # For all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        #
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                    "objectUUID": b"0123456789abcde1"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde5"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        # Try to delete a non existent DN with a truncated key
+        try:
+            self.l.delete("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM")
+        except ldb.LdbError as err:
+            enum = err.args[0]
+            self.assertEqual(enum, ldb.ERR_NO_SUCH_OBJECT)
+            # Ensure that non of the other truncated DN's got deleted
+            res = self.l.search(
+                base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG")
+            self.assertEqual(len(res), 1)
+
+            res = self.l.search(
+                base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+            self.assertEqual(len(res), 1)
+
+            # Ensure that the non truncated DN did not get deleted
+            res = self.l.search(
+                base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+            self.assertEqual(len(res), 1)
+
+            # Check the indexes are correct
+            self.checkGuids(
+                "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                b"0123456789abcde5")
+
+        # delete an existing entry
+        self.l.delete("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG")
+
+        # Ensure it got deleted
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG")
+        self.assertEqual(len(res), 0)
+
+        # Ensure that non of the other truncated DN's got deleted
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 1)
+
+        # Ensure the non truncated entry did not get deleted.
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 1)
+
+        # Check the indexes are correct
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        # delete an existing entry
+        self.l.delete("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+
+        # Ensure it got deleted
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 0)
+
+        # Ensure that non of the non truncated DN's got deleted
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 1)
+        # Check the indexes are correct
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        # delete an existing entry
+        self.l.delete("OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+
+        # Ensure it got deleted
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBAxxx")
+        self.assertEqual(len(res), 0)
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            None)
+
+    def test_search_truncated_dn_keys(self):
+        #
+        # For all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        #
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                    "objectUUID": b"0123456789abcde1"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde5"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM")
+        self.assertEqual(len(res), 0)
+
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 0)
+
+        # Non existent, key one less than truncation limit
+        res = self.l.search(base="OU=A_LONG_DNXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 0)
+
+    def test_search_dn_filter_truncated_dn_keys(self):
+        #
+        # For all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        #
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                    "objectUUID": b"0123456789abcde1"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde5"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM")
+        self.assertEqual(len(res), 0)
+
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXX,DC=SAMBA,DC=GOV")
+        self.assertEqual(len(res), 0)
+
+        # Non existent, key one less than truncation limit
+        res = self.l.search(
+            expression="dn=OU=A_LONG_DNXXXXXXXXXXXXXX,DC=SAMBA")
+        self.assertEqual(len(res), 0)
+
+    def test_search_one_level_truncated_dn_keys(self):
+        #
+        # Except for the base DN's
+        # all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=??,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA
+        # The base DN-s truncate to
+        #    @INDEX:@IDXDN:OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR
+        #
+        self.l.add({"dn": "OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcdef"})
+        self.l.add({"dn": "OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcd1f"})
+
+        self.l.add({"dn": "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde1"})
+        self.l.add({"dn": "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcd11"})
+
+        self.l.add({"dn": "OU=02,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde2"})
+        self.l.add({"dn": "OU=02,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcdf2"})
+
+        self.l.add({"dn": "OU=03,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde3"})
+        self.l.add({"dn": "OU=03,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcd13"})
+
+        # This key is not truncated as it's the max_key_len
+        self.l.add({"dn": "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde7"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA",
+            b"0123456789abcde7")
+
+        res = self.l.search(base="OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1",
+                            scope=ldb.SCOPE_ONELEVEL)
+        self.assertEqual(len(res), 3)
+        self.assertTrue(
+            contains(res, "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=03,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR1"))
+
+        res = self.l.search(base="OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2",
+                            scope=ldb.SCOPE_ONELEVEL)
+        self.assertEqual(len(res), 3)
+        self.assertTrue(
+            contains(res, "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=03,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA,DC=OR2"))
+
+        res = self.l.search(base="OU=A_LONG_DN_ONE_LVLX,DC=SAMBA",
+                            scope=ldb.SCOPE_ONELEVEL)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=01,OU=A_LONG_DN_ONE_LVLX,DC=SAMBA"))
+
+    def test_search_sub_tree_truncated_dn_keys(self):
+        #
+        # Except for the base DN's
+        # all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=??,OU=A_LONG_DN_SUB_TREE,DC=SAMBA
+        # The base DN-s truncate to
+        #    @INDEX:@IDXDN:OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR
+        #
+        self.l.add({"dn": "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcdef"})
+        self.l.add({"dn": "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcde4"})
+        self.l.add({"dn": "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR3",
+                    "objectUUID": b"0123456789abcde8"})
+
+        self.l.add({"dn": "OU=01,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde1"})
+        self.l.add({"dn": "OU=01,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcde5"})
+
+        self.l.add({"dn": "OU=02,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde2"})
+        self.l.add({"dn": "OU=02,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcde6"})
+
+        self.l.add({"dn": "OU=03,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde3"})
+
+        self.l.add({"dn": "OU=03,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcde7"})
+
+        self.l.add({"dn": "OU=04,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR4",
+                    "objectUUID": b"0123456789abcde9"})
+
+        res = self.l.search(base="OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 4)
+        self.assertTrue(
+            contains(res, "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=01,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=03,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR1"))
+
+        res = self.l.search(base="OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 4)
+        self.assertTrue(
+            contains(res, "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=01,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=03,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR2"))
+
+        res = self.l.search(base="OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR3",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR3"))
+
+        res = self.l.search(base="OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR4",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=04,OU=A_LONG_DN_SUB_TREE,DC=SAMBA,DC=OR4"))
+
+    def test_search_base_truncated_dn_keys(self):
+        #
+        # For all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA
+        #
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+                    "objectUUID": b"0123456789abcdef"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+                    "objectUUID": b"0123456789abcde1"})
+
+        self.l.add({"dn": "OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+                    "objectUUID": b"0123456789abcde5"})
+        self.checkGuids(
+            "@INDEX:@IDXDN:OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            b"0123456789abcde5")
+
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=ORG",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 1)
+
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXXXXX,DC=SAMBA,DC=COM",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 0)
+
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXX,DC=SAMBA,DC=GOV",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 0)
+
+        # Non existent, key one less than truncation limit
+        res = self.l.search(
+            base="OU=A_LONG_DNXXXXXXXXXXXXXX,DC=SAMBA",
+            scope=ldb.SCOPE_BASE)
+        self.assertEqual(len(res), 0)
+
+    #
+    # Test non unique index searched with truncated keys
+    #
+    def test_index_truncated_keys(self):
+        # 0        1         2         3         4         5
+        # 12345678901234567890123456789012345678901234567890
+        # @INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+
+        eq_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        lt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        # > than max length and differs in values that will be truncated
+        gt_max_b = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
+
+        # Add two entries with the same value, key length = max so no
+        # truncation.
+        self.l.add({"dn": "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": eq_max,
+                    "objectUUID": b"0123456789abcde0"})
+        self.checkGuids(
+            "@INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+            b"0123456789abcde0")
+
+        self.l.add({"dn": "OU=02,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": eq_max,
+                    "objectUUID": b"0123456789abcde1"})
+        self.checkGuids(
+            "@INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+            b"0123456789abcde0" + b"0123456789abcde1")
+
+        #
+        # An entry outside the tree
+        #
+        self.l.add({"dn": "OU=10,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG",
+                    "notUnique": eq_max,
+                    "objectUUID": b"0123456789abcd11"})
+        self.checkGuids(
+            "@INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+            b"0123456789abcd11" + b"0123456789abcde0" + b"0123456789abcde1")
+
+        # Key longer than max so should get truncated to same key as
+        # the previous two entries
+        self.l.add({"dn": "OU=03,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": gt_max,
+                    "objectUUID": b"0123456789abcde2"})
+
+        # Key longer than max so should get truncated to same key as
+        # the previous entries but differs in the chars after max length
+        self.l.add({"dn": "OU=23,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": gt_max_b,
+                    "objectUUID": b"0123456789abcd22"})
+        #
+        # An entry outside the tree
+        #
+        self.l.add({"dn": "OU=11,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG",
+                    "notUnique": gt_max,
+                    "objectUUID": b"0123456789abcd12"})
+
+        # Key shorter than max
+        #
+        self.l.add({"dn": "OU=04,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": lt_max,
+                    "objectUUID": b"0123456789abcde3"})
+        self.checkGuids(
+            "@INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+            b"0123456789abcde3")
+        #
+        # An entry outside the tree
+        #
+        self.l.add({"dn": "OU=12,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG",
+                    "notUnique": lt_max,
+                    "objectUUID": b"0123456789abcd13"})
+        self.checkGuids(
+            "@INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa",
+            b"0123456789abcd13" + b"0123456789abcde3")
+
+        #
+        # search for target is max value not truncated
+        # should return ou's 01, 02
+        #
+        expression = "(notUnique=" + eq_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 2)
+        self.assertTrue(
+            contains(res, "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        #
+        # search for target is max value not truncated
+        # search one level up the tree, scope is ONE_LEVEL
+        # So should get no matches
+        #
+        expression = "(notUnique=" + eq_max.decode('ascii') + ")"
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 0)
+        #
+        # search for target is max value not truncated
+        # search one level up the tree, scope is SUBTREE
+        # So should get 3 matches
+        #
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_SUBTREE,
+                            expression=expression)
+        self.assertEqual(len(res), 3)
+        self.assertTrue(
+            contains(res, "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=10,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG"))
+        #
+        # search for target is max value + 1 so truncated
+        # should return ou 23 as it's gt_max_b being searched for
+        #
+        expression = "(notUnique=" + gt_max_b.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=23,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        #
+        # search for target is max value + 1 so truncated
+        # should return ou 03 as it's gt_max being searched for
+        #
+        expression = "(notUnique=" + gt_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=03,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        #
+        # scope one level and one level up one level up should get no matches
+        #
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 0)
+        #
+        # scope sub tree and one level up one level up should get 2 matches
+        #
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_SUBTREE,
+                            expression=expression)
+        self.assertEqual(len(res), 2)
+        self.assertTrue(
+            contains(res, "OU=03,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=11,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG"))
+
+        #
+        # search for target is max value - 1 so not truncated
+        # should return ou 04
+        #
+        expression = "(notUnique=" + lt_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=04,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        #
+        # scope one level and one level up one level up should get no matches
+        #
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 0)
+
+        #
+        # scope sub tree and one level up one level up should get 2 matches
+        #
+        res = self.l.search(base="DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_SUBTREE,
+                            expression=expression)
+        self.assertEqual(len(res), 2)
+        self.assertTrue(
+            contains(res, "OU=04,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=12,OU=SEARCH_NON_UNIQUE01,DC=SAMBA,DC=ORG"))
+
+    #
+    # Test adding to non unique index with identical multivalued index
+    # attributes
+    #
+    def test_index_multi_valued_identical_keys(self):
+        # 0        1         2         3         4         5
+        # 12345678901234567890123456789012345678901234567890
+        # @INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+        as_eq_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        bs_eq_max = b"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+
+        try:
+            self.l.add({"dn": "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                        "notUnique": [bs_eq_max, as_eq_max, as_eq_max],
+                        "objectUUID": b"0123456789abcde0"})
+            self.fail("Exception not thrown")
+        except ldb.LdbError as e:
+            code = e.args[0]
+            self.assertEqual(ldb.ERR_ATTRIBUTE_OR_VALUE_EXISTS, code)
+
+    #
+    # Test non unique index with multivalued index attributes
+    #  searched with non truncated keys
+    #
+    def test_search_index_multi_valued_truncated_keys(self):
+        # 0        1         2         3         4         5
+        # 12345678901234567890123456789012345678901234567890
+        # @INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+
+        aa_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        ab_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
+        bb_gt_max = b"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+
+        self.l.add({"dn": "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": [aa_gt_max, ab_gt_max, bb_gt_max],
+                    "objectUUID": b"0123456789abcde0"})
+
+        expression = "(notUnique=" + aa_gt_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        expression = "(notUnique=" + ab_gt_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        expression = "(notUnique=" + bb_gt_max.decode('ascii') + ")"
+        res = self.l.search(base="OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                            scope=ldb.SCOPE_ONELEVEL,
+                            expression=expression)
+        self.assertEqual(len(res), 1)
+        self.assertTrue(
+            contains(res, "OU=01,OU=SEARCH_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+    #
+    # Test deletion of records with non unique index with multivalued index
+    # attributes
+    # replicate this to test modify with modify flags i.e. DELETE, REPLACE
+    #
+    def test_delete_index_multi_valued_truncated_keys(self):
+        # 0        1         2         3         4         5
+        # 12345678901234567890123456789012345678901234567890
+        # @INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+
+        aa_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        ab_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
+        bb_gt_max = b"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+        cc_gt_max = b"cccccccccccccccccccccccccccccccccc"
+
+        self.l.add({"dn": "OU=01,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": [aa_gt_max, ab_gt_max, bb_gt_max],
+                    "objectUUID": b"0123456789abcde0"})
+        self.l.add({"dn": "OU=02,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": [aa_gt_max, ab_gt_max, cc_gt_max],
+                    "objectUUID": b"0123456789abcde1"})
+
+        res = self.l.search(
+            base="DC=SAMBA,DC=ORG",
+            expression="(notUnique=" + aa_gt_max.decode("ascii") + ")")
+        self.assertEqual(2, len(res))
+        self.assertTrue(
+            contains(res, "OU=01,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        self.l.delete("OU=02,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG")
+
+        self.l.delete("OU=01,OU=DELETE_NON_UNIQUE,DC=SAMBA,DC=ORG")
+
+    #
+    # Test modification of records with non unique index with multivalued index
+    # attributes
+    #
+    def test_modify_index_multi_valued_truncated_keys(self):
+        # 0        1         2         3         4         5
+        # 12345678901234567890123456789012345678901234567890
+        # @INDEX:NOTUNIQUE:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
+
+        aa_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
+        ab_gt_max = b"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab"
+        bb_gt_max = b"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
+        cc_gt_max = b"cccccccccccccccccccccccccccccccccc"
+
+        self.l.add({"dn": "OU=01,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": [aa_gt_max, ab_gt_max, bb_gt_max],
+                    "objectUUID": b"0123456789abcde0"})
+        self.l.add({"dn": "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG",
+                    "notUnique": [aa_gt_max, ab_gt_max, cc_gt_max],
+                    "objectUUID": b"0123456789abcde1"})
+
+        res = self.l.search(
+            base="DC=SAMBA,DC=ORG",
+            expression="(notUnique=" + aa_gt_max.decode("ascii") + ")")
+        self.assertEquals(2, len(res))
+        self.assertTrue(
+            contains(res, "OU=01,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG"))
+
+        #
+        # Modify that does not change the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=01,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [aa_gt_max, ab_gt_max, bb_gt_max],
+            ldb.FLAG_MOD_REPLACE,
+            "notUnique")
+        self.l.modify(msg)
+        #
+        # As the modify is replacing the attribute with the same contents
+        # there should be no changes to the indexes.
+        #
+
+        #
+        # Modify that removes a value from the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=01,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [aa_gt_max, bb_gt_max],
+            ldb.FLAG_MOD_REPLACE,
+            "notUnique")
+        self.l.modify(msg)
+
+        #
+        # Modify that does a constrained delete the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [ab_gt_max],
+            ldb.FLAG_MOD_DELETE,
+            "notUnique")
+        self.l.modify(msg)
+
+        #
+        # Modify that does an unconstrained delete the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [],
+            ldb.FLAG_MOD_DELETE,
+            "notUnique")
+        self.l.modify(msg)
+
+        #
+        # Modify that adds a value to the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [cc_gt_max],
+            ldb.FLAG_MOD_ADD,
+            "notUnique")
+        self.l.modify(msg)
+
+        #
+        # Modify that adds a values to the indexed attribute
+        #
+        msg = ldb.Message()
+        msg.dn = ldb.Dn(self.l, "OU=02,OU=MODIFY_NON_UNIQUE,DC=SAMBA,DC=ORG")
+        msg["notUnique"] = ldb.MessageElement(
+            [aa_gt_max, ab_gt_max],
+            ldb.FLAG_MOD_ADD,
+            "notUnique")
+        self.l.modify(msg)
+
+    #
+    # Test Sub tree searches when checkBaseOnSearch is enabled and the
+    # DN indexes are truncated and collide.
+    #
+    def test_check_base_on_search_truncated_dn_keys(self):
+        #
+        # Except for the base DN's
+        # all entries the DN index key gets truncated to
+        #    0        1         2         3         4         5
+        #    12345678901234567890123456789012345678901234567890
+        #    @INDEX:@IDXDN:OU=??,OU=CHECK_BASE_DN_XXXX,DC=SAMBA
+        # The base DN-s truncate to
+        #    @INDEX:@IDXDN:OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR
+        #
+        checkbaseonsearch = {"dn": "@OPTIONS",
+                             "checkBaseOnSearch": b"TRUE"}
+        self.l.add(checkbaseonsearch)
+
+        self.l.add({"dn": "OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcdef"})
+        self.l.add({"dn": "OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcdee"})
+
+        self.l.add({"dn": "OU=01,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcdec"})
+        self.l.add({"dn": "OU=01,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcdeb"})
+        self.l.add({"dn": "OU=01,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR3",
+                    "objectUUID": b"0123456789abcded"})
+
+        self.l.add({"dn": "OU=02,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1",
+                    "objectUUID": b"0123456789abcde0"})
+        self.l.add({"dn": "OU=02,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2",
+                    "objectUUID": b"0123456789abcde1"})
+        self.l.add({"dn": "OU=02,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR3",
+                    "objectUUID": b"0123456789abcde2"})
+
+        res = self.l.search(base="OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 3)
+        self.assertTrue(
+            contains(res, "OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=01,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR1"))
+
+        res = self.l.search(base="OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2",
+                            scope=ldb.SCOPE_SUBTREE)
+        self.assertEqual(len(res), 3)
+        self.assertTrue(
+            contains(res, "OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=01,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2"))
+        self.assertTrue(
+            contains(res, "OU=02,OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR2"))
+
+        try:
+            res = self.l.search(base="OU=CHECK_BASE_DN_XXXX,DC=SAMBA,DC=OR3",
+                                scope=ldb.SCOPE_SUBTREE)
+            self.fail("Expected exception no thrown")
+        except ldb.LdbError as e:
+            code = e.args[0]
+            self.assertEqual(ldb.ERR_NO_SUCH_OBJECT, code)
+
+if __name__ == '__main__':
+    import unittest
+    unittest.TestProgram()
diff -Npur samba-4.8.1/lib/ldb/wscript samba-4.8.2/lib/ldb/wscript
--- samba-4.8.1/lib/ldb/wscript	2018-03-01 21:18:10.000000000 +0100
+++ samba-4.8.2/lib/ldb/wscript	2018-05-16 12:09:25.000000000 +0200
@@ -1,7 +1,7 @@
 #!/usr/bin/env python
 
 APPNAME = 'ldb'
-VERSION = '1.3.2'
+VERSION = '1.3.3'
 
 blddir = 'bin'
 
@@ -374,7 +374,7 @@ def test(ctx):
     if not os.path.exists(tmp_dir):
         os.mkdir(tmp_dir)
     pyret = samba_utils.RUN_PYTHON_TESTS(
-        ['tests/python/api.py'],
+        ['tests/python/api.py', 'tests/python/index.py'],
         extra_env={'SELFTEST_PREFIX': test_prefix})
     print("Python testsuite returned %d" % pyret)
 
diff -Npur samba-4.8.1/nsswitch/wb_common.c samba-4.8.2/nsswitch/wb_common.c
--- samba-4.8.1/nsswitch/wb_common.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/nsswitch/wb_common.c	2018-05-16 12:09:25.000000000 +0200
@@ -420,14 +420,14 @@ static int winbind_open_pipe_sock(struct
 			ctx->winbindd_fd = fd;
 			ctx->is_privileged = 1;
 		}
+
+		SAFE_FREE(response.extra_data.data);
 	}
 
 	if ((need_priv != 0) && (ctx->is_privileged == 0)) {
 		return -1;
 	}
 
-	SAFE_FREE(response.extra_data.data);
-
 	return ctx->winbindd_fd;
 #else
 	return -1;
diff -Npur samba-4.8.1/selftest/target/Samba3.pm samba-4.8.2/selftest/target/Samba3.pm
--- samba-4.8.1/selftest/target/Samba3.pm	2018-04-26 09:21:03.000000000 +0200
+++ samba-4.8.2/selftest/target/Samba3.pm	2018-05-16 12:09:25.000000000 +0200
@@ -2173,6 +2173,10 @@ sub provision($$$$$$$$$)
 	kernel oplocks = yes
 	vfs objects = streams_xattr xattr_tdb
 
+[streams_xattr]
+	copy = tmp
+	vfs objects = streams_xattr xattr_tdb
+
 [compound_find]
 	copy = tmp
 	smbd:find async delay usec = 10000
diff -Npur samba-4.8.1/source3/client/smbspool.c samba-4.8.2/source3/client/smbspool.c
--- samba-4.8.1/source3/client/smbspool.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/client/smbspool.c	2018-05-16 12:09:25.000000000 +0200
@@ -100,6 +100,11 @@ main(int argc,			/* I - Number of comman
 	const char     *dev_uri;
 	const char     *config_file = NULL;
 	TALLOC_CTX     *frame = talloc_stackframe();
+	bool device_uri_cmdline = false;
+	const char *print_file = NULL;
+	const char *print_copies = NULL;
+	int cmp;
+	int len;
 
 	null_str[0] = '\0';
 
@@ -117,7 +122,12 @@ main(int argc,			/* I - Number of comman
 		goto done;
 	}
 
-	if (argc < 7 || argc > 8) {
+	/*
+	 * We need at least 5 options if the DEVICE_URI is passed via an env
+	 * variable and printing data comes via stdin.
+	 * We don't accept more than 7 options in total, including optional.
+	 */
+	if (argc < 5 || argc > 8) {
 		fprintf(stderr,
 "Usage: %s [DEVICE_URI] job-id user title copies options [file]\n"
 "       The DEVICE_URI environment variable can also contain the\n"
@@ -129,46 +139,66 @@ main(int argc,			/* I - Number of comman
 	}
 
 	/*
-         * If we have 7 arguments, print the file named on the command-line.
-         * Otherwise, print data from stdin...
-         */
-
+	 * If we have 6 arguments find out if we have the device_uri from the
+	 * command line or the print data
+	 */
 	if (argc == 7) {
-		/*
-	         * Print from Copy stdin to a temporary file...
-	         */
+		cmp = strncmp(argv[1], "smb://", 6);
+		if (cmp == 0) {
+			device_uri_cmdline = true;
+		} else {
+			print_copies = argv[4];
+			print_file = argv[6];
+		}
+	} else if (argc == 8) {
+		device_uri_cmdline = true;
+		print_copies = argv[5];
+		print_file = argv[7];
+	}
 
-		fp = stdin;
-		copies = 1;
-	} else if ((fp = fopen(argv[7], "rb")) == NULL) {
-		perror("ERROR: Unable to open print file");
-		goto done;
-	} else {
-		char *p = argv[5];
+	if (print_file != NULL) {
 		char *endp;
 
-		copies = strtol(p, &endp, 10);
-		if (p == endp) {
+		fp = fopen(print_file, "rb");
+		if (fp == NULL) {
+			perror("ERROR: Unable to open print file");
+			goto done;
+		}
+
+		copies = strtol(print_copies, &endp, 10);
+		if (print_copies == endp) {
 			perror("ERROR: Unable to determine number of copies");
 			goto done;
 		}
+	} else {
+		fp = stdin;
+		copies = 1;
 	}
 
 	/*
-         * Find the URI...
-         */
-
-	dev_uri = getenv("DEVICE_URI");
-	if (dev_uri) {
-		strncpy(uri, dev_uri, sizeof(uri) - 1);
-	} else if (strncmp(argv[1], "smb://", 6) == 0) {
-		strncpy(uri, argv[1], sizeof(uri) - 1);
+	 * Find the URI ...
+	 */
+	if (device_uri_cmdline) {
+		dev_uri = argv[1];
 	} else {
-		fputs("ERROR: No device URI found in DEVICE_URI environment variable or arg1 !\n", stderr);
-		goto done;
+		dev_uri = getenv("DEVICE_URI");
+		if (dev_uri == NULL || strlen(dev_uri) == 0) {
+			dev_uri = "";
+		}
 	}
 
-	uri[sizeof(uri) - 1] = '\0';
+	cmp = strncmp(dev_uri, "smb://", 6);
+	if (cmp != 0) {
+		fprintf(stderr,
+			"ERROR: No valid device URI has been specified\n");
+		goto done;
+	}
+	len = snprintf(uri, sizeof(uri), "%s", dev_uri);
+	if (len >= sizeof(uri)) {
+		fprintf(stderr,
+			"ERROR: The URI is too long.\n");
+		goto done;
+	}
 
 	/*
          * Extract the destination from the URI...
diff -Npur samba-4.8.1/source3/libsmb/libsmb_server.c samba-4.8.2/source3/libsmb/libsmb_server.c
--- samba-4.8.1/source3/libsmb/libsmb_server.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/libsmb/libsmb_server.c	2018-05-16 12:09:25.000000000 +0200
@@ -500,7 +500,7 @@ SMBC_server_internal(TALLOC_CTX *ctx,
 				 lp_client_max_protocol());
 	if (!NT_STATUS_IS_OK(status)) {
 		cli_shutdown(c);
-		errno = ETIMEDOUT;
+		errno = map_errno_from_nt_status(status);
 		return NULL;
 	}
 
diff -Npur samba-4.8.1/source3/modules/vfs_ceph.c samba-4.8.2/source3/modules/vfs_ceph.c
--- samba-4.8.1/source3/modules/vfs_ceph.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/modules/vfs_ceph.c	2018-05-16 12:09:25.000000000 +0200
@@ -37,6 +37,7 @@
 #include "cephfs/libcephfs.h"
 #include "smbprofile.h"
 #include "modules/posixacl_xattr.h"
+#include "lib/util/tevent_unix.h"
 
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_VFS
@@ -481,6 +482,57 @@ static ssize_t cephwrap_pread(struct vfs
 	WRAP_RETURN(result);
 }
 
+struct cephwrap_pread_state {
+	ssize_t bytes_read;
+	struct vfs_aio_state vfs_aio_state;
+};
+
+/*
+ * Fake up an async ceph read by calling the synchronous API.
+ */
+static struct tevent_req *cephwrap_pread_send(struct vfs_handle_struct *handle,
+					      TALLOC_CTX *mem_ctx,
+					      struct tevent_context *ev,
+					      struct files_struct *fsp,
+					      void *data,
+					      size_t n, off_t offset)
+{
+	struct tevent_req *req = NULL;
+	struct cephwrap_pread_state *state = NULL;
+	int ret = -1;
+
+	DBG_DEBUG("[CEPH] %s\n", __func__);
+	req = tevent_req_create(mem_ctx, &state, struct cephwrap_pread_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	ret = ceph_read(handle->data, fsp->fh->fd, data, n, offset);
+	if (ret < 0) {
+		/* ceph returns -errno on error. */
+		tevent_req_error(req, -ret);
+		return tevent_req_post(req, ev);
+	}
+
+	state->bytes_read = ret;
+	tevent_req_done(req);
+	/* Return and schedule the completion of the call. */
+	return tevent_req_post(req, ev);
+}
+
+static ssize_t cephwrap_pread_recv(struct tevent_req *req,
+				   struct vfs_aio_state *vfs_aio_state)
+{
+	struct cephwrap_pread_state *state =
+		tevent_req_data(req, struct cephwrap_pread_state);
+
+	DBG_DEBUG("[CEPH] %s\n", __func__);
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+	*vfs_aio_state = state->vfs_aio_state;
+	return state->bytes_read;
+}
 
 static ssize_t cephwrap_write(struct vfs_handle_struct *handle, files_struct *fsp, const void *data, size_t n)
 {
@@ -509,6 +561,58 @@ static ssize_t cephwrap_pwrite(struct vf
 	WRAP_RETURN(result);
 }
 
+struct cephwrap_pwrite_state {
+	ssize_t bytes_written;
+	struct vfs_aio_state vfs_aio_state;
+};
+
+/*
+ * Fake up an async ceph write by calling the synchronous API.
+ */
+static struct tevent_req *cephwrap_pwrite_send(struct vfs_handle_struct *handle,
+					       TALLOC_CTX *mem_ctx,
+					       struct tevent_context *ev,
+					       struct files_struct *fsp,
+					       const void *data,
+					       size_t n, off_t offset)
+{
+	struct tevent_req *req = NULL;
+	struct cephwrap_pwrite_state *state = NULL;
+	int ret = -1;
+
+	DBG_DEBUG("[CEPH] %s\n", __func__);
+	req = tevent_req_create(mem_ctx, &state, struct cephwrap_pwrite_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	ret = ceph_write(handle->data, fsp->fh->fd, data, n, offset);
+	if (ret < 0) {
+		/* ceph returns -errno on error. */
+		tevent_req_error(req, -ret);
+		return tevent_req_post(req, ev);
+	}
+
+	state->bytes_written = ret;
+	tevent_req_done(req);
+	/* Return and schedule the completion of the call. */
+	return tevent_req_post(req, ev);
+}
+
+static ssize_t cephwrap_pwrite_recv(struct tevent_req *req,
+				    struct vfs_aio_state *vfs_aio_state)
+{
+	struct cephwrap_pwrite_state *state =
+		tevent_req_data(req, struct cephwrap_pwrite_state);
+
+	DBG_DEBUG("[CEPH] %s\n", __func__);
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+	*vfs_aio_state = state->vfs_aio_state;
+	return state->bytes_written;
+}
+
 static off_t cephwrap_lseek(struct vfs_handle_struct *handle, files_struct *fsp, off_t offset, int whence)
 {
 	off_t result = 0;
@@ -569,6 +673,56 @@ static int cephwrap_fsync(struct vfs_han
 	WRAP_RETURN(result);
 }
 
+/*
+ * Fake up an async ceph fsync by calling the synchronous API.
+ */
+
+static struct tevent_req *cephwrap_fsync_send(struct vfs_handle_struct *handle,
+					TALLOC_CTX *mem_ctx,
+					struct tevent_context *ev,
+					files_struct *fsp)
+{
+	struct tevent_req *req = NULL;
+	struct vfs_aio_state *state = NULL;
+	int ret = -1;
+
+	DBG_DEBUG("[CEPH] cephwrap_fsync_send\n");
+
+	req = tevent_req_create(mem_ctx, &state, struct vfs_aio_state);
+	if (req == NULL) {
+		return NULL;
+	}
+
+	/* Make sync call. */
+	ret = ceph_fsync(handle->data, fsp->fh->fd, false);
+
+	if (ret != 0) {
+		/* ceph_fsync returns -errno on error. */
+		tevent_req_error(req, -ret);
+		return tevent_req_post(req, ev);
+	}
+
+	/* Mark it as done. */
+	tevent_req_done(req);
+	/* Return and schedule the completion of the call. */
+	return tevent_req_post(req, ev);
+}
+
+static int cephwrap_fsync_recv(struct tevent_req *req,
+				struct vfs_aio_state *vfs_aio_state)
+{
+	struct vfs_aio_state *state =
+		tevent_req_data(req, struct vfs_aio_state);
+
+	DBG_DEBUG("[CEPH] cephwrap_fsync_recv\n");
+
+	if (tevent_req_is_unix_error(req, &vfs_aio_state->error)) {
+		return -1;
+	}
+	*vfs_aio_state = *state;
+	return 0;
+}
+
 #ifdef HAVE_CEPH_STATX
 #define SAMBA_STATX_ATTR_MASK	(CEPH_STATX_BASIC_STATS|CEPH_STATX_BTIME)
 
@@ -1201,30 +1355,31 @@ static struct smb_filename *cephwrap_rea
 				TALLOC_CTX *ctx,
 				const struct smb_filename *smb_fname)
 {
-	char *result;
+	char *result = NULL;
 	const char *path = smb_fname->base_name;
 	size_t len = strlen(path);
 	struct smb_filename *result_fname = NULL;
+	int r = -1;
 
-	result = SMB_MALLOC_ARRAY(char, PATH_MAX+1);
 	if (len && (path[0] == '/')) {
-		int r = asprintf(&result, "%s", path);
-		if (r < 0) return NULL;
+		r = asprintf(&result, "%s", path);
 	} else if ((len >= 2) && (path[0] == '.') && (path[1] == '/')) {
 		if (len == 2) {
-			int r = asprintf(&result, "%s",
+			r = asprintf(&result, "%s",
 					handle->conn->connectpath);
-			if (r < 0) return NULL;
 		} else {
-			int r = asprintf(&result, "%s/%s",
+			r = asprintf(&result, "%s/%s",
 					handle->conn->connectpath, &path[2]);
-			if (r < 0) return NULL;
 		}
 	} else {
-		int r = asprintf(&result, "%s/%s",
+		r = asprintf(&result, "%s/%s",
 				handle->conn->connectpath, path);
-		if (r < 0) return NULL;
 	}
+
+	if (r < 0) {
+		return NULL;
+	}
+
 	DBG_DEBUG("[CEPH] realpath(%p, %s) = %s\n", handle, path, result);
 	result_fname = synthetic_smb_fname(ctx,
 				result,
@@ -1433,13 +1588,19 @@ static struct vfs_fn_pointers ceph_fns =
 	.close_fn = cephwrap_close,
 	.read_fn = cephwrap_read,
 	.pread_fn = cephwrap_pread,
+	.pread_send_fn = cephwrap_pread_send,
+	.pread_recv_fn = cephwrap_pread_recv,
 	.write_fn = cephwrap_write,
 	.pwrite_fn = cephwrap_pwrite,
+	.pwrite_send_fn = cephwrap_pwrite_send,
+	.pwrite_recv_fn = cephwrap_pwrite_recv,
 	.lseek_fn = cephwrap_lseek,
 	.sendfile_fn = cephwrap_sendfile,
 	.recvfile_fn = cephwrap_recvfile,
 	.rename_fn = cephwrap_rename,
 	.fsync_fn = cephwrap_fsync,
+	.fsync_send_fn = cephwrap_fsync_send,
+	.fsync_recv_fn = cephwrap_fsync_recv,
 	.stat_fn = cephwrap_stat,
 	.fstat_fn = cephwrap_fstat,
 	.lstat_fn = cephwrap_lstat,
diff -Npur samba-4.8.1/source3/modules/vfs_streams_xattr.c samba-4.8.2/source3/modules/vfs_streams_xattr.c
--- samba-4.8.1/source3/modules/vfs_streams_xattr.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/modules/vfs_streams_xattr.c	2018-05-16 12:09:25.000000000 +0200
@@ -277,6 +277,7 @@ static int streams_xattr_fstat(vfs_handl
 
 	sbuf->st_ex_ino = stream_inode(sbuf, io->xattr_name);
 	sbuf->st_ex_mode &= ~S_IFMT;
+	sbuf->st_ex_mode &= ~S_IFDIR;
         sbuf->st_ex_mode |= S_IFREG;
         sbuf->st_ex_blocks = sbuf->st_ex_size / STAT_ST_BLOCKSIZE + 1;
 
@@ -331,6 +332,7 @@ static int streams_xattr_stat(vfs_handle
 
 	smb_fname->st.st_ex_ino = stream_inode(&smb_fname->st, xattr_name);
 	smb_fname->st.st_ex_mode &= ~S_IFMT;
+	smb_fname->st.st_ex_mode &= ~S_IFDIR;
         smb_fname->st.st_ex_mode |= S_IFREG;
         smb_fname->st.st_ex_blocks =
 	    smb_fname->st.st_ex_size / STAT_ST_BLOCKSIZE + 1;
diff -Npur samba-4.8.1/source3/printing/nt_printing.c samba-4.8.2/source3/printing/nt_printing.c
--- samba-4.8.1/source3/printing/nt_printing.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/printing/nt_printing.c	2018-05-16 12:09:25.000000000 +0200
@@ -1205,7 +1205,7 @@ static WERROR move_driver_file_to_downlo
 				 "to rename [%s] to [%s]: %s\n",
 				 smb_fname_old->base_name, new_name,
 				 nt_errstr(status)));
-			ret = WERR_ACCESS_DENIED;
+			ret = WERR_APP_INIT_FAILURE;
 			goto out;
 		}
 	}
diff -Npur samba-4.8.1/source3/rpcclient/cmd_srvsvc.c samba-4.8.2/source3/rpcclient/cmd_srvsvc.c
--- samba-4.8.1/source3/rpcclient/cmd_srvsvc.c	2018-01-14 21:41:58.000000000 +0100
+++ samba-4.8.2/source3/rpcclient/cmd_srvsvc.c	2018-05-16 12:09:25.000000000 +0200
@@ -883,6 +883,8 @@ static WERROR cmd_srvsvc_net_sess_enum(s
 		goto done;
 	}
 
+	d_printf("Received %d entries.\n", total_entries);
+
  done:
 	return result;
 }
diff -Npur samba-4.8.1/source3/script/tests/test_rpcclient_netsessenum.sh samba-4.8.2/source3/script/tests/test_rpcclient_netsessenum.sh
--- samba-4.8.1/source3/script/tests/test_rpcclient_netsessenum.sh	1970-01-01 01:00:00.000000000 +0100
+++ samba-4.8.2/source3/script/tests/test_rpcclient_netsessenum.sh	2018-05-16 12:09:25.000000000 +0200
@@ -0,0 +1,55 @@
+#!/bin/sh
+#
+# Blackbox tests for the rpcclient srvsvc commands
+#
+# Copyright (C) 2018 Christof Schmitt
+
+if [ $# -lt 6 ]; then
+cat <<EOF
+Usage: $0 DOMAIN ADMIN_USER ADMIN_PASSWORD SERVER RPCCLIENT SMBTORTURE3 SHARE
+EOF
+exit 1;
+fi
+
+DOMAIN="$1"
+ADMIN_USER="$2"
+ADMIN_PASSWORD="$3"
+SERVER="$4"
+RPCCLIENT="$5"
+SMBTORTURE3="$6"
+SHARE="$7"
+
+USERPASS="-U$DOMAIN/$ADMIN_USER%$ADMIN_PASSWORD"
+RPCCLIENTCMD="$RPCCLIENT $SERVER $USERPASS"
+
+incdir=$(dirname $0)/../../../testprogs/blackbox
+. $incdir/subunit.sh
+
+failed=0
+
+#
+# Verify initial number of sessions.
+#
+$RPCCLIENTCMD -c NetSessEnum | grep Received
+RC=$?
+testit "netsessenum" test $RC = 0 || failed=$(expr $failed + 1)
+
+OUT=$($RPCCLIENTCMD -c NetSessEnum | grep Received)
+test "$OUT" = "Received 1 entries."
+RC=$?
+testit "count1" test $RC -eq 0  || failed=$(expr $failed + 1)
+
+#
+# Inject smbd crash
+#
+$SMBTORTURE3 //"$SERVER"/"$SHARE" "$USERPASS" CLEANUP1
+
+#
+# Verify number of sessions after crash
+#
+OUT=$($RPCCLIENTCMD -c NetSessEnum | grep Received)
+test "$OUT" = "Received 1 entries."
+RC=$?
+testit "count2" test $RC -eq 0  || failed=$(expr $failed + 1)
+
+testok $0 $failed
diff -Npur samba-4.8.1/source3/script/tests/test_smbclient_s3.sh samba-4.8.2/source3/script/tests/test_smbclient_s3.sh
--- samba-4.8.1/source3/script/tests/test_smbclient_s3.sh	2018-04-26 09:21:03.000000000 +0200
+++ samba-4.8.2/source3/script/tests/test_smbclient_s3.sh	2018-05-16 12:09:25.000000000 +0200
@@ -1598,6 +1598,78 @@ EOF
     return 0
 }
 
+# Test xattr_stream correctly reports mode.
+# BUG: https://bugzilla.samba.org/show_bug.cgi?id=13380
+
+test_stream_directory_xattr()
+{
+    tmpfile=$PREFIX/smbclient_interactive_prompt_commands
+#
+# Test against streams_xattr
+#
+    cat > $tmpfile <<EOF
+deltree foo
+mkdir foo
+put ${PREFIX}/smbclient_interactive_prompt_commands foo:bar
+setmode foo -a
+allinfo foo:bar
+deltree foo
+quit
+EOF
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/streams_xattr -I $SERVER_IP $ADDARGS < $tmpfile 2>&1'
+    eval echo "$cmd"
+    out=`eval $cmd`
+    ret=$?
+    rm -f $tmpfile
+
+    if [ $ret != 0 ] ; then
+	echo "$out"
+	echo "failed checking attributes on xattr stream foo:bar with error $ret"
+	return 1
+    fi
+
+    echo "$out" | grep "attributes:.*80"
+    ret=$?
+    if [ $ret != 0 ] ; then
+	echo "$out"
+	echo "failed checking attributes on xattr stream foo:bar"
+	return 1
+    fi
+
+#
+# Test against streams_depot
+#
+    cat > $tmpfile <<EOF
+deltree foo
+mkdir foo
+put ${PREFIX}/smbclient_interactive_prompt_commands foo:bar
+setmode foo -a
+allinfo foo:bar
+deltree foo
+quit
+EOF
+    cmd='CLI_FORCE_INTERACTIVE=yes $SMBCLIENT "$@" -U$USERNAME%$PASSWORD //$SERVER/tmp -I $SERVER_IP $ADDARGS < $tmpfile 2>&1'
+    eval echo "$cmd"
+    out=`eval $cmd`
+    ret=$?
+    rm -f $tmpfile
+
+    if [ $ret != 0 ] ; then
+	echo "$out"
+	echo "failed checking attributes on depot stream foo:bar with error $ret"
+	return 1
+    fi
+
+    echo "$out" | grep "attributes:.*80"
+    ret=$?
+    if [ $ret != 0 ] ; then
+	echo "$out"
+	echo "failed checking attributes on depot stream foo:bar"
+	return 1
+    fi
+}
+
+#
 LOGDIR_PREFIX=test_smbclient_s3
 
 # possibly remove old logdirs:
@@ -1697,6 +1769,10 @@ testit "streams_depot can delete correct
     test_streams_depot_delete || \
     failed=`expr $failed + 1`
 
+testit "stream_xattr attributes" \
+    test_stream_directory_xattr || \
+    failed=`expr $failed + 1`
+
 testit "follow symlinks = no" \
     test_nosymlinks || \
     failed=`expr $failed + 1`
diff -Npur samba-4.8.1/source3/script/tests/test_smbspool.sh samba-4.8.2/source3/script/tests/test_smbspool.sh
--- samba-4.8.1/source3/script/tests/test_smbspool.sh	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/script/tests/test_smbspool.sh	2018-05-16 12:09:25.000000000 +0200
@@ -139,6 +139,36 @@ testit "vlp verify example.ps" \
 	test_vlp_verify \
 	|| failed=$(expr $failed + 1)
 
+testit "smbspool print example.ps via stdin" \
+	$samba_smbspool smb://$USERNAME:$PASSWORD@$SERVER_IP/print1 200 $USERNAME "Testprint" 1 "options" < $SRCDIR/testdata/printing/example.ps || \
+	failed=$(expr $failed + 1)
+
+testit "vlp verify example.ps" \
+	test_vlp_verify \
+	|| failed=$(expr $failed + 1)
+
+DEVICE_URI="smb://$USERNAME:$PASSWORD@$SERVER_IP/print1"
+export DEVICE_URI
+testit "smbspool print DEVICE_URI example.ps" \
+	$samba_smbspool 200 $USERNAME "Testprint" 1 "options" $SRCDIR/testdata/printing/example.ps || \
+	failed=$(expr $failed + 1)
+unset DEVICE_URI
+
+testit "vlp verify example.ps" \
+	test_vlp_verify \
+	|| failed=$(expr $failed + 1)
+
+DEVICE_URI="smb://$USERNAME:$PASSWORD@$SERVER_IP/print1"
+export DEVICE_URI
+testit "smbspool print DEVICE_URI example.ps via stdin" \
+	$samba_smbspool 200 $USERNAME "Testprint" 1 "options" < $SRCDIR/testdata/printing/example.ps || \
+	failed=$(expr $failed + 1)
+unset DEVICE_URI
+
+testit "vlp verify example.ps" \
+	test_vlp_verify \
+	|| failed=$(expr $failed + 1)
+
 AUTH_INFO_REQUIRED="username,password"
 export AUTH_INFO_REQUIRED
 testit "smbspool_krb5(username,password) print example.ps" \
diff -Npur samba-4.8.1/source3/selftest/tests.py samba-4.8.2/source3/selftest/tests.py
--- samba-4.8.1/source3/selftest/tests.py	2018-04-26 09:21:03.000000000 +0200
+++ samba-4.8.2/source3/selftest/tests.py	2018-05-16 12:09:25.000000000 +0200
@@ -631,6 +631,12 @@ plantestsuite("samba3.blackbox.smbclient
                "$USERNAME", "$PASSWORD", "$SERVER",
                smbclient3])
 
+plantestsuite("samba3.blackbox.rpcclient_netsessenum", "ad_member",
+              [os.path.join(samba3srcdir,
+                            "script/tests/test_rpcclient_netsessenum.sh"),
+               "$DOMAIN", "$DC_USERNAME", "$DC_PASSWORD", "$SERVER",
+               os.path.join(bindir(), "rpcclient"), smbtorture3, "tmp"])
+
 # The ktest environment uses:
 # server min protocol = SMB3_00
 # client max protocol = SMB3
diff -Npur samba-4.8.1/source3/smbd/dosmode.c samba-4.8.2/source3/smbd/dosmode.c
--- samba-4.8.1/source3/smbd/dosmode.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/smbd/dosmode.c	2018-05-16 12:09:25.000000000 +0200
@@ -681,6 +681,28 @@ uint32_t dos_mode(connection_struct *con
 		}
 	}
 
+	/*
+	 * According to MS-FSA a stream name does not have
+	 * separate DOS attribute metadata, so we must return
+	 * the DOS attribute from the base filename. With one caveat,
+	 * a non-default stream name can never be a directory.
+	 *
+	 * As this is common to all streams data stores, we handle
+	 * it here instead of inside all stream VFS modules.
+	 *
+	 * BUG: https://bugzilla.samba.org/show_bug.cgi?id=13380
+	 */
+
+	if (is_ntfs_stream_smb_fname(smb_fname)) {
+		/* is_ntfs_stream_smb_fname() returns false for a POSIX path. */
+		if (!is_ntfs_default_stream_smb_fname(smb_fname)) {
+			/*
+			 * Non-default stream name, not a posix path.
+			 */
+			result &= ~(FILE_ATTRIBUTE_DIRECTORY);
+		}
+	}
+
 	if (conn->fs_capabilities & FILE_FILE_COMPRESSION) {
 		bool compressed = false;
 		status = dos_mode_check_compressed(conn, smb_fname,
diff -Npur samba-4.8.1/source3/smbd/server.c samba-4.8.2/source3/smbd/server.c
--- samba-4.8.1/source3/smbd/server.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/smbd/server.c	2018-05-16 12:09:25.000000000 +0200
@@ -757,7 +757,7 @@ static void cleanup_timeout_fn(struct te
 	parent->cleanup_te = NULL;
 
 	messaging_send_buf(parent->msg_ctx, parent->cleanupd,
-			   MSG_SMB_UNLOCK, NULL, 0);
+			   MSG_SMB_BRL_VALIDATE, NULL, 0);
 }
 
 static void cleanupd_started(struct tevent_req *req)
diff -Npur samba-4.8.1/source3/smbd/session.c samba-4.8.2/source3/smbd/session.c
--- samba-4.8.1/source3/smbd/session.c	2018-01-14 21:41:58.000000000 +0100
+++ samba-4.8.2/source3/smbd/session.c	2018-05-16 12:09:25.000000000 +0200
@@ -139,6 +139,10 @@ static int gather_sessioninfo(const char
 		return 0;
 	}
 
+	if (!process_exists(session->pid)) {
+		return 0;
+	}
+
 	sesslist->sessions = talloc_realloc(
 		sesslist->mem_ctx, sesslist->sessions, struct sessionid,
 		sesslist->count+1);
diff -Npur samba-4.8.1/source3/smbd/smbd_cleanupd.c samba-4.8.2/source3/smbd/smbd_cleanupd.c
--- samba-4.8.1/source3/smbd/smbd_cleanupd.c	2018-01-17 09:08:39.000000000 +0100
+++ samba-4.8.2/source3/smbd/smbd_cleanupd.c	2018-05-16 12:09:25.000000000 +0200
@@ -71,7 +71,7 @@ struct tevent_req *smbd_cleanupd_send(TA
 		return tevent_req_post(req, ev);
 	}
 
-	status = messaging_register(msg, NULL, MSG_SMB_UNLOCK,
+	status = messaging_register(msg, NULL, MSG_SMB_BRL_VALIDATE,
 				    smbd_cleanupd_unlock);
 	if (tevent_req_nterror(req, status)) {
 		return tevent_req_post(req, ev);
@@ -98,8 +98,6 @@ static void smbd_cleanupd_unlock(struct
 	DBG_WARNING("Cleaning up brl and lock database after unclean "
 		    "shutdown\n");
 
-	messaging_send_all(msg, MSG_SMB_UNLOCK, NULL, 0);
-
 	brl_revalidate(msg, private_data, msg_type, server_id, data);
 }
 
diff -Npur samba-4.8.1/source3/winbindd/winbindd_samr.c samba-4.8.2/source3/winbindd/winbindd_samr.c
--- samba-4.8.1/source3/winbindd/winbindd_samr.c	2018-01-14 21:41:58.000000000 +0100
+++ samba-4.8.2/source3/winbindd/winbindd_samr.c	2018-05-16 12:09:25.000000000 +0200
@@ -28,6 +28,7 @@
 #include "winbindd_rpc.h"
 #include "lib/util_unixsids.h"
 #include "rpc_client/rpc_client.h"
+#include "rpc_client/cli_pipe.h"
 #include "../librpc/gen_ndr/ndr_samr_c.h"
 #include "rpc_client/cli_samr.h"
 #include "../librpc/gen_ndr/ndr_lsa_c.h"
@@ -40,6 +41,20 @@
 #undef DBGC_CLASS
 #define DBGC_CLASS DBGC_WINBIND
 
+/*
+ * The other end of this won't go away easily, so we can trust it
+ *
+ * It is either a long-lived process with the same lifetime as
+ * winbindd or a part of this process
+ */
+struct winbind_internal_pipes {
+	struct rpc_pipe_client *samr_pipe;
+	struct policy_handle samr_domain_hnd;
+	struct rpc_pipe_client *lsa_pipe;
+	struct policy_handle lsa_hnd;
+};
+
+
 NTSTATUS open_internal_samr_conn(TALLOC_CTX *mem_ctx,
 				 struct winbindd_domain *domain,
 				 struct rpc_pipe_client **samr_pipe,
@@ -101,6 +116,96 @@ NTSTATUS open_internal_lsa_conn(TALLOC_C
 	return status;
 }
 
+
+static NTSTATUS open_cached_internal_pipe_conn(
+	struct winbindd_domain *domain,
+	struct rpc_pipe_client **samr_pipe,
+	struct policy_handle *samr_domain_hnd,
+	struct rpc_pipe_client **lsa_pipe,
+	struct policy_handle *lsa_hnd)
+{
+	struct winbind_internal_pipes *internal_pipes = NULL;
+
+	if (domain->private_data == NULL) {
+		TALLOC_CTX *frame = talloc_stackframe();
+		NTSTATUS status;
+
+		internal_pipes = talloc_zero(frame,
+					     struct winbind_internal_pipes);
+
+		status = open_internal_samr_conn(
+			internal_pipes,
+			domain,
+			&internal_pipes->samr_pipe,
+			&internal_pipes->samr_domain_hnd);
+		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(frame);
+			return status;
+		}
+
+		status = open_internal_lsa_conn(internal_pipes,
+						&internal_pipes->lsa_pipe,
+						&internal_pipes->lsa_hnd);
+
+		if (!NT_STATUS_IS_OK(status)) {
+			TALLOC_FREE(frame);
+			return status;
+		}
+
+		domain->private_data = talloc_move(domain, &internal_pipes);
+
+		TALLOC_FREE(frame);
+
+	}
+
+	internal_pipes = talloc_get_type_abort(
+		domain->private_data, struct winbind_internal_pipes);
+
+	if (samr_domain_hnd) {
+		*samr_domain_hnd = internal_pipes->samr_domain_hnd;
+	}
+
+	if (samr_pipe) {
+		*samr_pipe = internal_pipes->samr_pipe;
+	}
+
+	if (lsa_hnd) {
+		*lsa_hnd = internal_pipes->lsa_hnd;
+	}
+
+	if (lsa_pipe) {
+		*lsa_pipe = internal_pipes->lsa_pipe;
+	}
+
+	return NT_STATUS_OK;
+}
+
+static bool reset_connection_on_error(struct winbindd_domain *domain,
+				      struct rpc_pipe_client *p,
+				      NTSTATUS status)
+{
+	struct winbind_internal_pipes *internal_pipes = NULL;
+
+	internal_pipes = talloc_get_type_abort(
+		domain->private_data, struct winbind_internal_pipes);
+
+	if (NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT) ||
+	    NT_STATUS_EQUAL(status, NT_STATUS_IO_DEVICE_ERROR))
+	{
+		TALLOC_FREE(internal_pipes);
+		domain->private_data = NULL;
+		return true;
+	}
+
+	if (!rpccli_is_connected(p)) {
+		TALLOC_FREE(internal_pipes);
+		domain->private_data = NULL;
+		return true;
+	}
+
+	return false;
+}
+
 /*********************************************************************
  SAM specific functions.
 *********************************************************************/
@@ -116,8 +221,8 @@ static NTSTATUS sam_enum_dom_groups(stru
 	struct wb_acct_info *info = NULL;
 	uint32_t num_info = 0;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_enum_dom_groups\n"));
 
@@ -130,20 +235,31 @@ static NTSTATUS sam_enum_dom_groups(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
-		goto error;
+		TALLOC_FREE(tmp_ctx);
+		return status;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_enum_dom_groups(tmp_ctx,
 				     samr_pipe,
 				     &dom_pol,
 				     &num_info,
 				     &info);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
-		goto error;
+		TALLOC_FREE(tmp_ctx);
+		return status;
 	}
 
 	if (pnum_info) {
@@ -154,10 +270,6 @@ static NTSTATUS sam_enum_dom_groups(stru
 		*pinfo = talloc_move(mem_ctx, &info);
 	}
 
-error:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -171,8 +283,8 @@ static NTSTATUS sam_query_user_list(stru
 	struct policy_handle dom_pol = { 0 };
 	uint32_t *rids = NULL;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("samr_query_user_list\n"));
 
@@ -181,18 +293,26 @@ static NTSTATUS sam_query_user_list(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_query_user_list(tmp_ctx,
 				     samr_pipe,
 				     &dom_pol,
 				     &domain->sid,
 				     &rids);
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -202,10 +322,6 @@ static NTSTATUS sam_query_user_list(stru
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
-
 	TALLOC_FREE(rids);
 	TALLOC_FREE(tmp_ctx);
 	return status;
@@ -221,8 +337,8 @@ static NTSTATUS sam_trusted_domains(stru
 	struct netr_DomainTrust *trusts = NULL;
 	uint32_t num_trusts = 0;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("samr: trusted domains\n"));
 
@@ -235,18 +351,27 @@ static NTSTATUS sam_trusted_domains(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_lsa_conn(tmp_ctx, &lsa_pipe, &lsa_policy);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						NULL,
+						NULL,
+						&lsa_pipe,
+						&lsa_policy);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = lsa_pipe->binding_handle;
-
 	status = rpc_trusted_domains(tmp_ctx,
 				     lsa_pipe,
 				     &lsa_policy,
 				     &num_trusts,
 				     &trusts);
+
+	if (!retry && reset_connection_on_error(domain, lsa_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -257,10 +382,6 @@ static NTSTATUS sam_trusted_domains(stru
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&lsa_policy)) {
-		dcerpc_lsa_Close(b, mem_ctx, &lsa_policy, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -284,8 +405,8 @@ static NTSTATUS sam_lookup_groupmem(stru
 	uint32_t *name_types = NULL;
 
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_lookup_groupmem\n"));
 
@@ -304,13 +425,16 @@ static NTSTATUS sam_lookup_groupmem(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_lookup_groupmem(tmp_ctx,
 				     samr_pipe,
 				     &dom_pol,
@@ -323,6 +447,11 @@ static NTSTATUS sam_lookup_groupmem(stru
 				     &names,
 				     &name_types);
 
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (pnum_names) {
 		*pnum_names = num_names;
 	}
@@ -340,10 +469,6 @@ static NTSTATUS sam_lookup_groupmem(stru
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -398,8 +523,8 @@ static NTSTATUS sam_enum_local_groups(st
 	struct wb_acct_info *info = NULL;
 	uint32_t num_info = 0;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("samr: enum local groups\n"));
 
@@ -412,18 +537,27 @@ static NTSTATUS sam_enum_local_groups(st
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_enum_local_groups(mem_ctx,
 				       samr_pipe,
 				       &dom_pol,
 				       &num_info,
+
 				       &info);
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -437,10 +571,6 @@ static NTSTATUS sam_enum_local_groups(st
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -459,8 +589,8 @@ static NTSTATUS sam_name_to_sid(struct w
 	struct dom_sid sid;
 	enum lsa_SidType type;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_name_to_sid\n"));
 
@@ -469,13 +599,16 @@ static NTSTATUS sam_name_to_sid(struct w
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_lsa_conn(tmp_ctx, &lsa_pipe, &lsa_policy);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						NULL,
+						NULL,
+						&lsa_pipe,
+						&lsa_policy);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = lsa_pipe->binding_handle;
-
 	status = rpc_name_to_sid(tmp_ctx,
 				 lsa_pipe,
 				 &lsa_policy,
@@ -484,6 +617,12 @@ static NTSTATUS sam_name_to_sid(struct w
 				 flags,
 				 &sid,
 				 &type);
+
+	if (!retry && reset_connection_on_error(domain, lsa_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -496,10 +635,6 @@ static NTSTATUS sam_name_to_sid(struct w
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&lsa_policy)) {
-		dcerpc_lsa_Close(b, mem_ctx, &lsa_policy, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -518,8 +653,8 @@ static NTSTATUS sam_sid_to_name(struct w
 	char *name = NULL;
 	enum lsa_SidType type;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_sid_to_name\n"));
 
@@ -543,13 +678,16 @@ static NTSTATUS sam_sid_to_name(struct w
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_lsa_conn(tmp_ctx, &lsa_pipe, &lsa_policy);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						NULL,
+						NULL,
+						&lsa_pipe,
+						&lsa_policy);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = lsa_pipe->binding_handle;
-
 	status = rpc_sid_to_name(tmp_ctx,
 				 lsa_pipe,
 				 &lsa_policy,
@@ -559,6 +697,11 @@ static NTSTATUS sam_sid_to_name(struct w
 				 &name,
 				 &type);
 
+	if (!retry && reset_connection_on_error(domain, lsa_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (ptype) {
 		*ptype = type;
 	}
@@ -572,9 +715,6 @@ static NTSTATUS sam_sid_to_name(struct w
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&lsa_policy)) {
-		dcerpc_lsa_Close(b, mem_ctx, &lsa_policy, &result);
-	}
 
 	TALLOC_FREE(tmp_ctx);
 	return status;
@@ -595,8 +735,8 @@ static NTSTATUS sam_rids_to_names(struct
 	char *domain_name = NULL;
 	char **names = NULL;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_rids_to_names for %s\n", domain->name));
 
@@ -616,13 +756,16 @@ static NTSTATUS sam_rids_to_names(struct
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_lsa_conn(tmp_ctx, &lsa_pipe, &lsa_policy);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						NULL,
+						NULL,
+						&lsa_pipe,
+						&lsa_policy);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = lsa_pipe->binding_handle;
-
 	status = rpc_rids_to_names(tmp_ctx,
 				   lsa_pipe,
 				   &lsa_policy,
@@ -633,6 +776,12 @@ static NTSTATUS sam_rids_to_names(struct
 				   &domain_name,
 				   &names,
 				   &types);
+
+	if (!retry && reset_connection_on_error(domain, lsa_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -650,10 +799,6 @@ static NTSTATUS sam_rids_to_names(struct
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&lsa_policy)) {
-		dcerpc_lsa_Close(b, mem_ctx, &lsa_policy, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -668,6 +813,7 @@ static NTSTATUS sam_lockout_policy(struc
 	TALLOC_CTX *tmp_ctx;
 	NTSTATUS status, result;
 	struct dcerpc_binding_handle *b = NULL;
+	bool retry = false;
 
 	DEBUG(3,("sam_lockout_policy\n"));
 
@@ -676,7 +822,12 @@ static NTSTATUS sam_lockout_policy(struc
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto error;
 	}
@@ -689,6 +840,12 @@ static NTSTATUS sam_lockout_policy(struc
 					     DomainLockoutInformation,
 					     &info,
 					     &result);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto error;
 	}
@@ -700,10 +857,6 @@ static NTSTATUS sam_lockout_policy(struc
 	*lockout_policy = info->info12;
 
 error:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -718,6 +871,7 @@ static NTSTATUS sam_password_policy(stru
 	TALLOC_CTX *tmp_ctx;
 	NTSTATUS status, result;
 	struct dcerpc_binding_handle *b = NULL;
+	bool retry = false;
 
 	DEBUG(3,("sam_password_policy\n"));
 
@@ -726,7 +880,12 @@ static NTSTATUS sam_password_policy(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto error;
 	}
@@ -739,6 +898,12 @@ static NTSTATUS sam_password_policy(stru
 					     DomainPasswordInformation,
 					     &info,
 					     &result);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto error;
 	}
@@ -750,10 +915,6 @@ static NTSTATUS sam_password_policy(stru
 	*passwd_policy = info->info1;
 
 error:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
-
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
@@ -770,8 +931,8 @@ static NTSTATUS sam_lookup_usergroups(st
 	struct dom_sid *user_grpsids = NULL;
 	uint32_t num_groups = 0;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_lookup_usergroups\n"));
 
@@ -786,13 +947,16 @@ static NTSTATUS sam_lookup_usergroups(st
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_lookup_usergroups(tmp_ctx,
 				       samr_pipe,
 				       &dom_pol,
@@ -800,6 +964,12 @@ static NTSTATUS sam_lookup_usergroups(st
 				       user_sid,
 				       &num_groups,
 				       &user_grpsids);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -813,9 +983,6 @@ static NTSTATUS sam_lookup_usergroups(st
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
 
 	TALLOC_FREE(tmp_ctx);
 	return status;
@@ -833,8 +1000,8 @@ static NTSTATUS sam_lookup_useraliases(s
 	uint32_t num_aliases = 0;
 	uint32_t *alias_rids = NULL;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("sam_lookup_useraliases\n"));
 
@@ -847,13 +1014,16 @@ static NTSTATUS sam_lookup_useraliases(s
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_lookup_useraliases(tmp_ctx,
 					samr_pipe,
 					&dom_pol,
@@ -861,6 +1031,12 @@ static NTSTATUS sam_lookup_useraliases(s
 					sids,
 					&num_aliases,
 					&alias_rids);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -874,9 +1050,6 @@ static NTSTATUS sam_lookup_useraliases(s
 	}
 
 done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, mem_ctx, &dom_pol, &result);
-	}
 
 	TALLOC_FREE(tmp_ctx);
 	return status;
@@ -890,8 +1063,8 @@ static NTSTATUS sam_sequence_number(stru
 	struct policy_handle dom_pol = { 0 };
 	uint32_t seq = DOM_SEQUENCE_NONE;
 	TALLOC_CTX *tmp_ctx;
-	NTSTATUS status, result;
-	struct dcerpc_binding_handle *b = NULL;
+	NTSTATUS status;
+	bool retry = false;
 
 	DEBUG(3,("samr: sequence number\n"));
 
@@ -904,18 +1077,27 @@ static NTSTATUS sam_sequence_number(stru
 		return NT_STATUS_NO_MEMORY;
 	}
 
-	status = open_internal_samr_conn(tmp_ctx, domain, &samr_pipe, &dom_pol);
+again:
+	status = open_cached_internal_pipe_conn(domain,
+						&samr_pipe,
+						&dom_pol,
+						NULL,
+						NULL);
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
 
-	b = samr_pipe->binding_handle;
-
 	status = rpc_sequence_number(tmp_ctx,
 				     samr_pipe,
 				     &dom_pol,
 				     domain->name,
 				     &seq);
+
+	if (!retry && reset_connection_on_error(domain, samr_pipe, status)) {
+		retry = true;
+		goto again;
+	}
+
 	if (!NT_STATUS_IS_OK(status)) {
 		goto done;
 	}
@@ -923,11 +1105,8 @@ static NTSTATUS sam_sequence_number(stru
 	if (pseq) {
 		*pseq = seq;
 	}
-done:
-	if (b && is_valid_policy_hnd(&dom_pol)) {
-		dcerpc_samr_Close(b, tmp_ctx, &dom_pol, &result);
-	}
 
+done:
 	TALLOC_FREE(tmp_ctx);
 	return status;
 }
diff -Npur samba-4.8.1/source4/rpc_server/lsa/lsa_lookup.c samba-4.8.2/source4/rpc_server/lsa/lsa_lookup.c
--- samba-4.8.1/source4/rpc_server/lsa/lsa_lookup.c	2018-03-01 21:18:10.000000000 +0100
+++ samba-4.8.2/source4/rpc_server/lsa/lsa_lookup.c	2018-05-16 12:09:25.000000000 +0200
@@ -533,6 +533,7 @@ static void dcesrv_lsa_LookupSids_base_d
 	status = dcerpc_lsa_LookupSids3_recv(subreq, state->mem_ctx,
 					     &state->wb.result);
 	TALLOC_FREE(subreq);
+	TALLOC_FREE(state->wb.irpc_handle);
 	if (NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
 		DEBUG(0,(__location__ ": IRPC callback failed %s\n",
 			 nt_errstr(status)));
@@ -598,7 +599,6 @@ static void dcesrv_lsa_LookupSids_base_d
  finished:
 	state->r.out.result = status;
 	dcesrv_lsa_LookupSids_base_map(state);
-	TALLOC_FREE(state);
 
 	status = dcesrv_reply(dce_call);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -660,7 +660,6 @@ NTSTATUS dcesrv_lsa_LookupSids2(struct d
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupSids_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -734,7 +733,6 @@ NTSTATUS dcesrv_lsa_LookupSids3(struct d
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupSids_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -805,7 +803,6 @@ NTSTATUS dcesrv_lsa_LookupSids(struct dc
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupSids_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -1156,6 +1153,7 @@ static void dcesrv_lsa_LookupNames_base_
 	status = dcerpc_lsa_LookupNames4_recv(subreq, state->mem_ctx,
 					      &state->wb.result);
 	TALLOC_FREE(subreq);
+	TALLOC_FREE(state->wb.irpc_handle);
 	if (NT_STATUS_EQUAL(status, NT_STATUS_IO_TIMEOUT)) {
 		DEBUG(0,(__location__ ": IRPC callback failed %s\n",
 			 nt_errstr(status)));
@@ -1221,7 +1219,6 @@ static void dcesrv_lsa_LookupNames_base_
  finished:
 	state->r.out.result = status;
 	dcesrv_lsa_LookupNames_base_map(state);
-	TALLOC_FREE(state);
 
 	status = dcesrv_reply(dce_call);
 	if (!NT_STATUS_IS_OK(status)) {
@@ -1284,7 +1281,6 @@ NTSTATUS dcesrv_lsa_LookupNames3(struct
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupNames_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -1357,7 +1353,6 @@ NTSTATUS dcesrv_lsa_LookupNames4(struct
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupNames_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -1436,7 +1431,6 @@ NTSTATUS dcesrv_lsa_LookupNames2(struct
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupNames_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
@@ -1507,7 +1501,6 @@ NTSTATUS dcesrv_lsa_LookupNames(struct d
 
 	state->r.out.result = status;
 	dcesrv_lsa_LookupNames_base_map(state);
-	TALLOC_FREE(state);
 	return status;
 }
 
