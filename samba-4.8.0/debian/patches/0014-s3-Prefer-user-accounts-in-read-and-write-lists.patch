From 3bc2e0ce72756f260bbf43f44f4f53f5e48832f1 Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Thu, 28 Jul 2016 11:52:31 -0700
Subject: [PATCH 14/16] s3: Prefer user accounts in read and write lists

Currently, objects in the write list always override the same objects in
the read list.  This includes cases where you have an individual user
account in the read list, and a group he belongs to in the write list.
This seems unintuitive, as normally user account settings take precedence
over group account settings.

Change this behavior by keeping track of the object type, and giving
preference to user account objects.
---
 source3/smbd/share_access.c | 54 +++++++++++++++++++++++++++++++++++----------
 1 file changed, 42 insertions(+), 12 deletions(-)

diff --git a/source3/smbd/share_access.c b/source3/smbd/share_access.c
index 3cbf7f318a2..1d36a30cf55 100644
--- a/source3/smbd/share_access.c
+++ b/source3/smbd/share_access.c
@@ -72,7 +72,8 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 				const char *domain,
 				const char *sharename,
 				const struct security_token *token,
-				const char *name)
+				const char *name,
+				uint32_t *sid_type)
 {
 	const char *prefix;
 	struct dom_sid sid;
@@ -102,6 +103,9 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 			DEBUG(5, ("lookup_name %s failed\n", name));
 			return False;
 		}
+		if (sid_type) {
+			*sid_type = type;
+		}
 		if (type != SID_NAME_USER) {
 			DEBUG(5, ("%s is a %s, expected a user\n",
 				  name, sid_type_lookup(type)));
@@ -118,6 +122,9 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
 				DEBUG(5, ("lookup_name %s failed\n", name));
 				return False;
 			}
+			if (sid_type) {
+				*sid_type = type;
+			}
 			if ((type != SID_NAME_DOM_GRP) &&
 			    (type != SID_NAME_ALIAS) &&
 			    (type != SID_NAME_WKN_GRP)) {
@@ -153,13 +160,15 @@ static bool token_contains_name(TALLOC_CTX *mem_ctx,
  *
  * The other use is the netgroup check when using @group or &group.
  */
-
-bool token_contains_name_in_list(const char *username,
+static bool _token_contains_name_in_list(const char *username,
 				 const char *domain,
 				 const char *sharename,
 				 const struct security_token *token,
-				 const char **list)
+				 const char **list,
+				 uint32_t *type)
 {
+	bool found = False;
+
 	if (list == NULL) {
 		return False;
 	}
@@ -168,14 +177,27 @@ bool token_contains_name_in_list(const char *username,
 		bool ret;
 
 		ret = token_contains_name(frame, username, domain, sharename,
-					  token, *list);
+					  token, *list, type);
 		TALLOC_FREE(frame);
 		if (ret) {
-			return true;
+			found = True;
+			if (type && *type == SID_NAME_USER) {
+				break;
+			}
 		}
 		list += 1;
 	}
-	return False;
+	return found;
+}
+
+bool token_contains_name_in_list(const char *username,
+				 const char *domain,
+				 const char *sharename,
+				 const struct security_token *token,
+				 const char **list)
+{
+	return _token_contains_name_in_list(username, domain, sharename, token,
+					    list, NULL);
 }
 
 /*
@@ -242,22 +264,30 @@ bool is_share_read_only_for_token(const char *username,
 {
 	int snum = SNUM(conn);
 	bool result = conn->read_only;
+	bool user_match = False;
+	uint32_t type;
 
 	if (lp_read_list(snum) != NULL) {
-		if (token_contains_name_in_list(username, domain,
+		if (_token_contains_name_in_list(username, domain,
 						lp_servicename(talloc_tos(), snum),
 						token,
-						lp_read_list(snum))) {
+						lp_read_list(snum), &type)) {
 			result = True;
+			if (type == SID_NAME_USER) {
+				user_match = True;
+			}
 		}
 	}
 
 	if (lp_write_list(snum) != NULL) {
-		if (token_contains_name_in_list(username, domain,
+		if (_token_contains_name_in_list(username, domain,
 						lp_servicename(talloc_tos(), snum),
 						token,
-						lp_write_list(snum))) {
-			result = False;
+						lp_write_list(snum), &type)) {
+			/* Prefer user accounts to groups */
+			if (type == SID_NAME_USER || !user_match) {
+				result = False;
+			}
 		}
 	}
 
-- 
2.15.1

