diff -urN db-3.2.9/dist/acconfig.h db-3.2.9+mutex/dist/acconfig.h
--- db-3.2.9/dist/acconfig.h	2005-01-23 22:08:56.157411026 +0100
+++ db-3.2.9+mutex/dist/acconfig.h	2005-01-23 22:11:23.795966554 +0100
@@ -53,6 +53,8 @@
 #undef HAVE_MUTEX_VXWORKS
 #undef HAVE_MUTEX_WIN16
 #undef HAVE_MUTEX_WIN32
+#undef HAVE_MUTEX_ARM_GCC_ASSEMBLY
+#undef HAVE_MUTEX_MIPS_GCC_ASSEMBLY
 #undef HAVE_MUTEX_X86_GCC_ASSEMBLY
 
 /* Define if building on QNX. */
diff -urN db-3.2.9/dist/aclocal/mutex.m4 db-3.2.9+mutex/dist/aclocal/mutex.m4
--- db-3.2.9/dist/aclocal/mutex.m4	2005-01-23 22:08:56.157411026 +0100
+++ db-3.2.9+mutex/dist/aclocal/mutex.m4	2005-01-23 22:09:19.893802546 +0100
@@ -91,6 +91,7 @@
 dnl POSIX.1 pthreads: pthread_XXX
 dnl
 dnl Try with and without the -lpthread library.
+if test "$db_cv_pthreadsmutexes" = yes; then
 if test "$db_cv_mutex" = no -o "$db_cv_mutex" = "posix_only"; then
 AC_TRY_RUN([
 #include <pthread.h>
@@ -142,6 +143,7 @@
 if test "$db_cv_mutex" = "posix_only"; then
 	AC_MSG_ERROR([unable to find POSIX mutex interfaces])
 fi
+fi
 
 dnl msemaphore: HPPA only
 dnl Try HPPA before general msem test, it needs special alignment.
@@ -252,6 +254,28 @@
 [db_cv_mutex="ALPHA/gcc-assembly"])
 fi
 
+# ARM/gcc: Linux
+if test "$db_cv_mutex" = no; then
+AC_TRY_COMPILE(,[
+#if defined(__arm__) && defined(__GNUC__)
+	exit(0);
+#else
+	FAIL TO COMPILE/LINK
+#endif
+], [db_cv_mutex="ARM/gcc-assembly"])
+fi
+
+# MIPS/gcc: Linux
+if test "$db_cv_mutex" = no; then
+AC_TRY_COMPILE(,[
+#if (defined(__mips) || defined(__mips__)) && defined(__GNUC__)
+	exit(0);
+#else
+       FAIL TO COMPILE/LINK
+#endif
+], [db_cv_mutex="MIPS/gcc-assembly"])
+fi
+
 dnl PaRisc/gcc: HP/UX
 if test "$db_cv_mutex" = no; then
 AC_TRY_RUN([main(){
@@ -329,7 +353,7 @@
 dnl x86/gcc: FreeBSD, NetBSD, BSD/OS, Linux
 if test "$db_cv_mutex" = no; then
 AC_TRY_RUN([main(){
-#if defined(i386) || defined(__i386__)
+#if defined(i386) || defined(__i386__) || defined(__x86_64__)
 #if defined(__GNUC__)
 	exit(0);
 #endif
@@ -338,7 +362,7 @@
 }], [db_cv_mutex="x86/gcc-assembly"])
 fi
 
-dnl ia86/gcc: Linux
+dnl ia64/gcc: Linux
 if test "$db_cv_mutex" = no; then
 AC_TRY_RUN([main(){
 #if defined(__ia64)
@@ -417,6 +441,10 @@
 			AC_DEFINE(HAVE_MUTEX_SEMA_INIT);;
 UTS/cc-assembly)	ADDITIONAL_OBJS="$ADDITIONAL_OBJS uts4.cc${o}"
 			AC_DEFINE(HAVE_MUTEX_UTS_CC_ASSEMBLY);;
+ARM/gcc-assembly)	ADDITIONAL_OBJS="mut_tas${o} $ADDITIONAL_OBJS"
+			AC_DEFINE(HAVE_MUTEX_ARM_GCC_ASSEMBLY);;
+MIPS/gcc-assembly)	ADDITIONAL_OBJS="mut_tas${o} $ADDITIONAL_OBJS"
+			AC_DEFINE(HAVE_MUTEX_MIPS_GCC_ASSEMBLY);;
 x86/gcc-assembly)	ADDITIONAL_OBJS="mut_tas${o} $ADDITIONAL_OBJS"
 			AC_DEFINE(HAVE_MUTEX_X86_GCC_ASSEMBLY);;
 esac
diff -urN db-3.2.9/dist/aclocal/options.m4 db-3.2.9+mutex/dist/aclocal/options.m4
--- db-3.2.9/dist/aclocal/options.m4	2000-07-09 16:52:15.000000000 +0200
+++ db-3.2.9+mutex/dist/aclocal/options.m4	2005-01-23 22:09:19.893802546 +0100
@@ -63,6 +63,16 @@
 	[db_cv_java="$enable_java"], [db_cv_java="no"])
 AC_MSG_RESULT($db_cv_java)
 
+AC_MSG_CHECKING(if --enable-pthreadsmutexes option specified)
+AC_ARG_ENABLE(pthreadsmutexes,
+	AC_HELP_STRING([--enable-pthreadsmutexes],
+	    [Use POSIX pthreads mutexes.]),, enableval="no")
+db_cv_pthreadsmutexes="$enableval"
+case "$enableval" in
+ no) AC_MSG_RESULT(yes);;
+yes) AC_MSG_RESULT(no);;
+esac
+
 AC_MSG_CHECKING(if --enable-posixmutexes option specified)
 AC_ARG_ENABLE(posixmutexes,
 	[  --enable-posixmutexes   Force use of POSIX standard mutexes.],
diff -urN db-3.2.9/include/mutex.h db-3.2.9+mutex/include/mutex.h
--- db-3.2.9/include/mutex.h	2005-01-23 22:08:56.158410874 +0100
+++ db-3.2.9+mutex/include/mutex.h	2005-01-23 22:09:19.893802546 +0100
@@ -648,6 +648,71 @@
 #endif
 
 /*********************************************************************
+ * ARM/gcc assembly.
+ *********************************************************************/
+#ifdef HAVE_MUTEX_ARM_GCC_ASSEMBLY
+typedef unsigned char tsl_t;
+
+#ifdef LOAD_ACTUAL_MUTEX_CODE
+/*
+ * For arm/gcc, 0 is clear, 1 is set.
+ */
+#define	MUTEX_SET(tsl) ({						\
+	int __r;							\
+	asm volatile("swpb %0, %1, [%2]"				\
+	    : "=r" (__r) 						\
+	    : "0" (1), "r" (tsl)					\
+	    : "memory"							\
+	    );								\
+	__r & 1;							\
+})
+
+#define	MUTEX_UNSET(tsl)	(*(volatile tsl_t *)(tsl) = 0)
+#define	MUTEX_INIT(tsl)		MUTEX_UNSET(tsl)
+#endif
+#endif
+
+/*********************************************************************
+ * MIPS/gcc assembly.
+ *********************************************************************/
+#ifdef HAVE_MUTEX_MIPS_GCC_ASSEMBLY
+typedef u_int32_t tsl_t;
+
+#ifndef MUTEX_ALIGN
+#define MUTEX_ALIGN sizeof(u_int32_t)
+#endif
+
+#ifdef LOAD_ACTUAL_MUTEX_CODE
+/*
+ * For gcc/MIPS.  Should return 0 if could not acquire the lock, 1 if
+ * lock was acquired properly.
+ */
+static inline int
+MUTEX_SET(tsl_t *tsl) {
+	register tsl_t *__l = tsl;
+	register tsl_t __r;
+	__asm__ __volatile__(
+		"	.set push		\n"
+		"	.set mips2		\n"
+		"	.set noreorder		\n"
+		"	.set nomacro		\n"
+		"1:	ll	%0, %1		\n"
+		"	bne	%0, $0, 1f	\n"
+		"	xori	%0, %0, 1	\n"
+		"	sc	%0, %1		\n"
+		"	beql	%0, $0, 1b	\n"
+		"	xori	%0, 1		\n"
+		"1:	.set pop		"
+		: "=&r" (__r), "+R" (*__l));
+	return __r;
+}
+
+#define		MUTEX_UNSET(tsl)	(*(volatile tsl_t *)(tsl) = 0)
+#define		MUTEX_INIT(tsl)		MUTEX_UNSET(tsl)
+#endif
+#endif
+
+/*********************************************************************
  * x86/gcc assembly.
  *********************************************************************/
 #ifdef HAVE_MUTEX_X86_GCC_ASSEMBLY
