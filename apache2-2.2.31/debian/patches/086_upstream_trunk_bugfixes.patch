  * core: NUL-terminate string returned by ap_scan_script_header_err*()
    in error case.
	http://svn.apache.org/viewvc?rev=1244211&view=rev

  * mod_dumpio: Return an error code from a previous input filter
	http://svn.apache.org/viewvc?rev=1301111&view=rev

  * mod_proxy_ajp: Reduce memory usage in case of many keep-alive requests on
    one connection. PR 52275
	http://svn.apache.org/viewvc?rev=1334343&view=rev

Index: apache2/server/util_script.c
===================================================================
--- apache2.orig/server/util_script.c	2012-06-10 02:14:52.377223678 +0200
+++ apache2/server/util_script.c	2012-06-10 10:14:22.732175142 +0200
@@ -636,6 +636,7 @@
         rv = apr_bucket_read(e, &bucket_data, &bucket_data_len,
                              APR_BLOCK_READ);
         if (rv != APR_SUCCESS || (bucket_data_len == 0)) {
+            *dst = '\0';
             return APR_STATUS_IS_TIMEUP(rv) ? -1 : 0;
         }
         src = bucket_data;
@@ -681,8 +682,10 @@
     const char *p;
     int t;
 
-    if (!strs->curpos || !*strs->curpos)
+    if (!strs->curpos || !*strs->curpos) {
+        w[0] = '\0';
         return 0;
+    }
     p = ap_strchr_c(strs->curpos, '\n');
     if (p)
         ++p;
Index: apache2/modules/debug/mod_dumpio.c
===================================================================
--- apache2.orig/modules/debug/mod_dumpio.c	2012-06-10 02:14:52.313223681 +0200
+++ apache2/modules/debug/mod_dumpio.c	2012-06-10 10:17:21.276179524 +0200
@@ -126,6 +126,7 @@
     } else {
         ap_log_error(APLOG_MARK, ptr->loglevel, 0, c->base_server,
         "mod_dumpio: %s - %d", f->frec->name, ret) ;
+        return ret;
     }
 
     return APR_SUCCESS ;
Index: apache2/modules/proxy/mod_proxy_ajp.c
===================================================================
--- apache2.orig/modules/proxy/mod_proxy_ajp.c	2012-06-10 02:14:52.345223680 +0200
+++ apache2/modules/proxy/mod_proxy_ajp.c	2012-06-10 10:25:26.588191425 +0200
@@ -654,30 +654,16 @@
     int retry;
     proxy_dir_conf *dconf = ap_get_module_config(r->per_dir_config,
                                                  &proxy_module);
-
-    /*
-     * Note: Memory pool allocation.
-     * A downstream keepalive connection is always connected to the existence
-     * (or not) of an upstream keepalive connection. If this is not done then
-     * load balancing against multiple backend servers breaks (one backend
-     * server ends up taking 100% of the load), and the risk is run of
-     * downstream keepalive connections being kept open unnecessarily. This
-     * keeps webservers busy and ties up resources.
-     *
-     * As a result, we allocate all sockets out of the upstream connection
-     * pool, and when we want to reuse a socket, we check first whether the
-     * connection ID of the current upstream connection is the same as that
-     * of the connection when the socket was opened.
-     */
-    apr_pool_t *p = r->connection->pool;
-    apr_uri_t *uri = apr_palloc(r->connection->pool, sizeof(*uri));
-
+    apr_pool_t *p = r->pool;
+    apr_uri_t *uri;
 
     if (strncasecmp(url, "ajp:", 4) != 0) {
         ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                      "proxy: AJP: declining URL %s", url);
         return DECLINED;
     }
+
+    uri = apr_palloc(p, sizeof(*uri));
     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, r->server,
                  "proxy: AJP: serving URL %s", url);
 
