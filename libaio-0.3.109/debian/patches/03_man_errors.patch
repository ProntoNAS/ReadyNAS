---
 man/aio.3              |  180 ++++++++++++++++++++++---------------------------
 man/aio_cancel.3       |   72 +++++++++----------
 man/aio_cancel64.3     |   50 ++++++-------
 man/aio_error64.3      |   54 +++++++-------
 man/aio_fsync64.3      |   46 ++++++------
 man/aio_init.3         |   50 ++++++-------
 man/aio_read64.3       |   56 +++++++--------
 man/aio_return64.3     |   46 ++++++------
 man/aio_suspend64.3    |   46 ++++++------
 man/aio_write64.3      |   52 +++++++-------
 man/io.3               |   73 +++++++++----------
 man/io_cancel.3        |   36 ++++-----
 man/io_fsync.3         |   42 +++++------
 man/io_getevents.1     |   38 +++++-----
 man/io_getevents.3     |   76 ++++++++++----------
 man/io_prep_fsync.3    |   69 +++++++++---------
 man/io_prep_pread.3    |   70 ++++++++-----------
 man/io_prep_pwrite.3   |   68 ++++++++----------
 man/io_queue_init.3    |   38 +++++-----
 man/io_queue_release.3 |   38 +++++-----
 man/io_queue_run.3     |   46 ++++++------
 man/io_queue_wait.3    |   50 ++++++-------
 man/io_set_callback.3  |   36 +++++----
 man/io_setup.1         |   30 ++++----
 man/io_submit.1        |    6 -
 man/io_submit.3        |   60 ++++++++--------
 man/lio_listio.3       |  115 ++++++++++++++-----------------
 man/lio_listio64.3     |   20 ++---
 28 files changed, 764 insertions(+), 799 deletions(-)

--- a/man/aio.3
+++ b/man/aio.3
@@ -1,11 +1,11 @@
-.TH aio 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio 3 2009-06-09 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio \- Asynchronous IO
 .SH SYNOPSIS
 .nf
 .B #include <errno.h>
 .sp
-.br 
+.br
 .B #include <aio.h>
 .sp
 .fi
@@ -16,25 +16,23 @@ new functions allow a program to initiat
 then immediately resume normal work while the I/O operations are
 executed in parallel.  This functionality is available if the
 .IR "unistd.h"
-file defines the symbol 
-.B "_POSIX_ASYNCHRONOUS_IO"
-.
+file defines the symbol
+.BR "_POSIX_ASYNCHRONOUS_IO" .
 
 These functions are part of the library with realtime functions named
-.IR "librt"
-.  They are not actually part of the 
-.IR "libc" 
+.IR "librt" .
+They are not actually part of the
+.IR "libc"
 binary.
 The implementation of these functions can be done using support in the
 kernel (if available) or using an implementation based on threads at
 userlevel.  In the latter case it might be necessary to link applications
-with the thread library 
+with the thread library
 .IR "libpthread"
-in addition to 
+in addition to
 .IR "librt"
 and
-.IR "libaio"
-.
+.IR "libaio" .
 
 All AIO operations operate on files which were opened previously.  There
 might be arbitrarily many operations running for one file.  The
@@ -42,7 +40,7 @@ asynchronous I/O operations are controll
 .IR "struct aiocb"
 It is defined in
 .IR "aio.h"
- as follows.
+as follows.
 
 .nf
 struct aiocb
@@ -71,8 +69,8 @@ struct aiocb
 };
 
 .fi
-The POSIX.1b standard mandates that the 
-.IR "struct aiocb" 
+The POSIX.1b standard mandates that the
+.IR "struct aiocb"
 structure
 contains at least the members described in the following table.  There
 might be more elements which are used by the implementation, but
@@ -86,9 +84,9 @@ fail.
 
 The device on which the file is opened must allow the seek operation.
 I.e., it is not possible to use any of the AIO operations on devices
-like terminals where an 
+like terminals where an
 .IR "lseek"
- call would lead to an error.
+call would lead to an error.
 .TP
 .IR "off_t aio_offset"
 This element specifies the offset in the file at which the operation (input
@@ -102,16 +100,15 @@ This is a pointer to the buffer with the
 where the read data is stored.
 .TP
 .IR "size_t aio_nbytes"
-This element specifies the length of the buffer pointed to by 
-.IR "aio_buf"
-.
+This element specifies the length of the buffer pointed to by
+.IR "aio_buf" .
 .TP
 .IR "int aio_reqprio"
-If the platform has defined 
+If the platform has defined
 .B "_POSIX_PRIORITIZED_IO"
 and
-.B "_POSIX_PRIORITY_SCHEDULING"
-, the AIO requests are
+.BR "_POSIX_PRIORITY_SCHEDULING" ,
+the AIO requests are
 processed based on the current scheduling priority.  The
 .IR "aio_reqprio"
 element can then be used to lower the priority of the
@@ -119,30 +116,28 @@ AIO operation.
 .TP
 .IR "struct sigevent aio_sigevent"
 This element specifies how the calling process is notified once the
-operation terminates.  If the 
+operation terminates.  If the
 .IR "sigev_notify"
 element is
-.B "SIGEV_NONE"
-, no notification is sent.  If it is 
-.B "SIGEV_SIGNAL"
-,
-the signal determined by 
+.BR "SIGEV_NONE" ,
+no notification is sent.  If it is
+.BR "SIGEV_SIGNAL" ,
+the signal determined by
 .IR "sigev_signo"
 is sent.  Otherwise,
 .IR "sigev_notify"
-must be 
-.B "SIGEV_THREAD"
-.  In this case, a thread
+must be
+.BR "SIGEV_THREAD" .
+In this case, a thread
 is created which starts executing the function pointed to by
-.IR "sigev_notify_function"
-.
+.IR "sigev_notify_function" .
 .TP
 .IR "int aio_lio_opcode"
-This element is only used by the 
+This element is only used by the
 .IR "lio_listio"
- and
+and
 .IR "lio_listio64"
- functions.  Since these functions allow an
+functions.  Since these functions allow an
 arbitrary number of operations to start at once, and each operation can be
 input or output (or nothing), the information must be stored in the
 control block.  The possible values are:
@@ -150,47 +145,42 @@ control block.  The possible values are:
 .B "LIO_READ"
 Start a read operation.  Read from the file at position
 .IR "aio_offset"
- and store the next 
+and store the next
 .IR "aio_nbytes"
- bytes in the
-buffer pointed to by 
-.IR "aio_buf"
-.
+bytes in the
+buffer pointed to by
+.IR "aio_buf" .
 .TP
 .B "LIO_WRITE"
-Start a write operation.  Write 
-.IR "aio_nbytes" 
+Start a write operation.  Write
+.IR "aio_nbytes"
 bytes starting at
 .IR "aio_buf"
-into the file starting at position 
-.IR "aio_offset"
-.
+into the file starting at position
+.IR "aio_offset" .
 .TP
 .B "LIO_NOP"
 Do nothing for this control block.  This value is useful sometimes when
-an array of 
+an array of
 .IR "struct aiocb"
 values contains holes, i.e., some of the
 values must not be handled although the whole array is presented to the
 .IR "lio_listio"
 function.
 
-When the sources are compiled using 
+When the sources are compiled using
 .B "_FILE_OFFSET_BITS == 64"
-on a
-32 bit machine, this type is in fact 
-.IR "struct aiocb64"
-, since the LFS
-interface transparently replaces the 
+on a 32 bit machine, this type is in fact
+.IR "struct aiocb64" ,
+since the LFS interface transparently replaces the
 .IR "struct aiocb"
 definition.
 .PP
 For use with the AIO functions defined in the LFS, there is a similar type
 defined which replaces the types of the appropriate members with larger
-types but otherwise is equivalent to 
-.IR "struct aiocb"
-.  Particularly,
-all member names are the same.
+types but otherwise is equivalent to
+.IR "struct aiocb" ,
+Particularly, all member names are the same.
 
 .nf
 /* The same for the 64bit offsets.  Please note that the members aio_fildes
@@ -224,9 +214,9 @@ operation.  It must be a legal descripto
 fails for obvious reasons.
 The device on which the file is opened must allow the seek operation.
 I.e., it is not possible to use any of the AIO operations on devices
-like terminals where an 
+like terminals where an
 .IR "lseek"
- call would lead to an error.
+call would lead to an error.
 .TP
 .IR "off64_t aio_offset"
 This element specifies at which offset in the file the operation (input
@@ -240,12 +230,11 @@ This is a pointer to the buffer with the
 where the read data is stored.
 .TP
 .IR "size_t aio_nbytes"
-This element specifies the length of the buffer pointed to by 
-.IR "aio_buf"
-.
+This element specifies the length of the buffer pointed to by
+.IR "aio_buf" .
 .TP
 .IR "int aio_reqprio"
-If for the platform 
+If for the platform
 .B "_POSIX_PRIORITIZED_IO"
 and
 .B "_POSIX_PRIORITY_SCHEDULING"
@@ -257,59 +246,56 @@ AIO operation.
 .TP
 .IR "struct sigevent aio_sigevent"
 This element specifies how the calling process is notified once the
-operation terminates.  If the 
-.IR "sigev_notify"
-, element is
+operation terminates.  If the
+.IR "sigev_notify" ,
+element is
 .B "SIGEV_NONE"
-no notification is sent.  If it is 
-.B "SIGEV_SIGNAL"
-,
-the signal determined by 
+no notification is sent.  If it is
+.BR "SIGEV_SIGNAL" ,
+the signal determined by
 .IR "sigev_signo"
 is sent.  Otherwise,
 .IR "sigev_notify"
- must be 
+must be
 .B "SIGEV_THREAD"
 in which case a thread
 which starts executing the function pointed to by
-.IR "sigev_notify_function"
-.
+.IR "sigev_notify_function" .
 .TP
 .IR "int aio_lio_opcode"
-This element is only used by the 
+This element is only used by the
 .IR "lio_listio"
 and
 .IR "lio_listio64"
 functions.  Since these functions allow an
 arbitrary number of operations to start at once, and since each operation can be
 input or output (or nothing), the information must be stored in the
-control block.  See the description of 
+control block.  See the description of
 .IR "struct aiocb"
 for a description
 of the possible values.
 .PP
-When the sources are compiled using 
+When the sources are compiled using
 .B "_FILE_OFFSET_BITS == 64"
-on a
-32 bit machine, this type is available under the name 
-.IR "struct aiocb64"
-, since the LFS transparently replaces the old interface.
+on a 32 bit machine, this type is available under the name
+.IR "struct aiocb64" ,
+since the LFS transparently replaces the old interface.
 .SH "RETURN VALUES"
 .SH ERRORS
 .SH "SEE ALSO"
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_cancel.3
+++ b/man/aio_cancel.3
@@ -1,4 +1,4 @@
-.TH aio_cancel 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_cancel 3 2009-06-09 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_cancel - Cancel asynchronous I/O requests
 .SH SYNOPSYS
@@ -9,7 +9,7 @@ aio_cancel - Cancel asynchronous I/O req
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_cancel (int fildes " , struct aiocb *aiocbp " )"
+.BI "int aio_cancel (int " fildes ", struct aiocb *" aiocbp ")"
 .fi
 .SH DESCRIPTION
 When one or more requests are asynchronously processed, it might be
@@ -23,7 +23,7 @@ is not capable of forcing the cancellati
 implementation to decide whether it is possible to cancel the operation
 or not.  Therefore using this function is merely a hint.
 .B "The libaio implementation does not implement the cancel operation in the"
-.B "POSIX libraries".
+.B "POSIX libraries."
 .PP
 The 
 .IR aio_cancel
@@ -31,8 +31,8 @@ function can be used to cancel one or mo
 outstanding requests.  If the 
 .IR aiocbp 
 parameter is 
-.IR NULL
-, the
+.IR NULL ,
+the
 function tries to cancel all of the outstanding requests which would process
 the file descriptor 
 .IR fildes 
@@ -40,11 +40,11 @@ the file descriptor 
 .IR aio_fildes 
 member
 is 
-.IR fildes
-).  If 
-.IR aiocbp is not 
-.IR  NULL
-,
+.IR fildes ).
+If
+.IR aiocbp
+is not
+.IR NULL ,
 .IR aio_cancel
 attempts to cancel the specific request pointed to by 
 .IR aiocbp.
@@ -64,13 +64,13 @@ a reference to this request as the param
 and a call to 
 .IR aio_return
 will return 
-.IR -1.
+.IR -1 .
 If the request wasn't canceled and is still running the error status is
 still 
-.B EINPROGRESS.
+.BR EINPROGRESS .
 When the sources are compiled with 
-.IR "_FILE_OFFSET_BITS == 64"
-, this
+.IR "_FILE_OFFSET_BITS == 64" ,
+this
 function is in fact 
 .IR aio_cancel64
 since the LFS interface
@@ -83,22 +83,20 @@ If there were
 requests which haven't terminated and which were successfully canceled.
 .TP
 .B AIO_NOTCANCELED
-If there is one or more requests left which couldn't be canceled,
-.  In this case
+If there is one or more requests left which couldn't be canceled.
+In this case
 .IR aio_error
 must be used to find out which of the, perhaps multiple, requests (in
 .IR aiocbp
 is 
-.IR NULL
-) weren't successfully canceled.  
+.IR NULL )
+weren't successfully canceled.
 .TP
 .B AIO_ALLDONE
 If all
 requests already terminated at the time 
 .IR aio_cancel 
-is called the
-return value is 
-.
+is called.
 .SH ERRORS
 If an error occurred during the execution of 
 .IR aio_cancel 
@@ -119,19 +117,19 @@ is not valid.
 .IR aio_cancel
 is not implemented.
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_cancel64.3
+++ b/man/aio_cancel64.3
@@ -1,4 +1,4 @@
-.TH aio_cancel64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_cancel64 3 2002-09-12 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_cancel64 \- Cancel asynchronous I/O requests
 .SH SYNOPSYS
@@ -9,42 +9,42 @@ aio_cancel64 \- Cancel asynchronous I/O 
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_cancel64 (int fildes, struct aiocb64 *aiocbp)"
+.BI "int aio_cancel64(int " fildes ", struct aiocb64 *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to 
 .IR aio_cancel
 with the only difference
 that the argument is a reference to a variable of type 
-.IR struct aiocb64
-.
-
+.IR "struct aiocb64" .
 When the sources are compiled with 
-.IR _FILE_OFFSET_BITS == 64
-, this
+.IR "_FILE_OFFSET_BITS == 64" ,
+this
 function is available under the name 
 .IR aio_cancel
 and so
 transparently replaces the interface for small files on 32 bit
 machines.
 .SH "RETURN VALUES"
-See aio_cancel(3).
+See
+.BR aio_cancel (3).
 .SH ERRORS
-See aio_cancel(3).
+See
+.BR aio_cancel (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_error64.3
+++ b/man/aio_error64.3
@@ -1,4 +1,4 @@
-.TH aio_error64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_error64 3 2009-06-09 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_error64 \- Return errors
 .SH SYNOPSYS
@@ -9,14 +9,14 @@ aio_error64 \- Return errors
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_error64 (const struct aiocb64 *aiocbp)"
+.BI "int aio_error64(const struct aiocb64 *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to 
 .IR aio_error
 with the only difference
 that the argument is a reference to a variable of type 
-.IR "struct aiocb64".
+.IR "struct aiocb64" .
 .PP
 When the sources are compiled with 
 .IR "_FILE_OFFSET_BITS == 64"
@@ -28,37 +28,35 @@ transparently replaces the interface for
 machines.
 .SH "RETURN VALUES"
 If the request has not yet terminated the value returned is always
-.IR "EINPROGRESS"
-.  Once the request has terminated the value
+.IR "EINPROGRESS" .
+Once the request has terminated the value
 .IR "aio_error"
 returns is either 
 .I 0
 if the request completed successfully or it returns the value which would be stored in the
 .IR "errno"
 variable if the request would have been done using
-.IR "read"
-, 
-.IR "write"
-, or 
-.IR "fsync"
-.
+.IR "read" ,
+.IR "write" ,
+or
+.IR "fsync" .
 .SH ERRORS
 See 
-.IR aio_error(3).
+.IR aio_error (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_fsync64.3
+++ b/man/aio_fsync64.3
@@ -1,4 +1,4 @@
-.TH aio_fsync64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_fsync64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_fsync64 \- Synchronize a file's complete in-core state with that on disk
 .SH SYNOPSYS
@@ -9,43 +9,43 @@ aio_fsync64 \- Synchronize a file's comp
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_fsync64 (int op, struct aiocb64 *aiocbp)"
+.BI "int aio_fsync64(int " op ", struct aiocb64 *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to 
-.IR aio_fsync
+.BR aio_fsync
 with the only difference
 that the argument is a reference to a variable of type 
-.IR "struct aiocb64".
+.IR "struct aiocb64" .
 
 When the sources are compiled with 
 .IR "_FILE_OFFSET_BITS == 64"
 this
 function is available under the name 
-.IR aio_fsync
+.BR aio_fsync
 and so
 transparently replaces the interface for small files on 32 bit
 machines.
 .SH "RETURN VALUES"
 See 
-.IR aio_fsync.
+.BR aio_fsync (3).
 .SH ERRORS
 See 
-.IR aio_fsync.
+.BR aio_fsync (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_init.3
+++ b/man/aio_init.3
@@ -1,4 +1,4 @@
-.TH  aio_init 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH  aio_init 3 2009-06-09 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_init \-  How to optimize the AIO implementation
 .SH SYNOPSYS
@@ -9,7 +9,7 @@ aio_init \-  How to optimize the AIO imp
 .B #include <aio.h>
 .sp
 .br
-.BI "void aio_init (const struct aioinit *init)"
+.BI "void aio_init (const struct aioinit *" init )
 .fi
 .SH DESCRIPTION
 
@@ -29,7 +29,7 @@ for tuning the AIO implementation accord
 This data type is used to pass the configuration or tunable parameters
 to the implementation.  The program has to initialize the members of
 this struct and pass it to the implementation using the 
-.IR aio_init
+.BR aio_init
 function.
 .TP
 .B "int aio_threads"
@@ -60,37 +60,37 @@ is completely voluntary, as it is only m
 implementation perform better.
 
 Before calling the 
-.IR aio_init
-, function the members of a variable of
+.BR aio_init ,
+function the members of a variable of
 type 
-.IR "struct aioinit"
+.BR "struct aioinit"
 must be initialized.  Then a reference to
 this variable is passed as the parameter to 
-.IR aio_init
+.BR aio_init
 which itself
 may or may not pay attention to the hints.
 
 It is a extension which follows a proposal from the SGI implementation in
-.IR Irix 6
-.  It is not covered by POSIX.1b or Unix98.
+.IR "Irix 6" .
+It is not covered by POSIX.1b or Unix98.
 .SH "RETURN VALUES"
 The function has no return value.
 .SH ERRORS
 The function has no error cases defined.
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_read64.3
+++ b/man/aio_read64.3
@@ -1,4 +1,4 @@
-.TH aio_read64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_read64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_read64 \- Initiate an asynchronous read operation
 .SH SYNOPSYS
@@ -8,53 +8,53 @@ aio_read64 \- Initiate an asynchronous r
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_read64 (struct aiocb *aiocbp)"
+.BI "int aio_read64(struct aiocb *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to the 
-.IR "aio_read"
+.BR "aio_read"
 function.  The only
 difference is that on 
 .IR "32 bit"
 machines, the file descriptor should
 be opened in the large file mode.  Internally, 
-.IR "aio_read64"
+.BR "aio_read64"
 uses
 functionality equivalent to 
-.IR "lseek64"
+.BR "lseek64"
 to position the file descriptor correctly for the reading,
 as opposed to 
-.IR "lseek"
+.BR "lseek"
 functionality used in 
-.IR "aio_read".
+.BR "aio_read" .
 
 When the sources are compiled with 
-.IR "_FILE_OFFSET_BITS == 64"
-, this
+.IR "_FILE_OFFSET_BITS == 64" ,
+this
 function is available under the name 
-.IR "aio_read"
+.BR "aio_read"
 and so transparently
 replaces the interface for small files on 32 bit machines.
 .SH "RETURN VALUES"
 See
-.IR aio_read.
+.BR aio_read (3).
 .SH ERRORS
 See
-.IR aio_read.
+.BR aio_read (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_return64.3
+++ b/man/aio_return64.3
@@ -1,4 +1,4 @@
-.TH aio_read64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_read64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_read64 \- Retrieve status of asynchronous I/O operation
 .SH SYNOPSYS
@@ -9,43 +9,43 @@ aio_read64 \- Retrieve status of asynchr
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_return64 (const struct aiocb64 *aiocbp)"
+.BI "int aio_return64(const struct aiocb64 *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to 
-.IR "aio_return"
+.BR "aio_return"
 with the only difference
 that the argument is a reference to a variable of type 
-.IR "struct aiocb64".
+.BR "struct aiocb64" .
 
 When the sources are compiled with 
 .IR "_FILE_OFFSET_BITS == 64"
 this
 function is available under the name 
-.IR "aio_return"
+.BR "aio_return"
 and so
 transparently replaces the interface for small files on 32 bit
 machines.
 .SH "RETURN VALUES"
 See 
-.IR aio_return.
+.BR aio_return (3).
 .SH ERRORS
 See
-.IR aio_return.
+.BR aio_return (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_suspend64.3
+++ b/man/aio_suspend64.3
@@ -1,4 +1,4 @@
-.TH aio_suspend64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_suspend64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_suspend64 \- Wait until one or more requests of a specific set terminates
 .SH SYNOPSYS
@@ -9,43 +9,43 @@ aio_suspend64 \- Wait until one or more 
 .B #include <aio.h>
 .sp
 .br
-.BI "int aio_suspend64 (const struct aiocb64 *const list[], int nent, const struct timespec *timeout)"
+.BI "int aio_suspend64(const struct aiocb64 *const " list "[], int " nent ", const struct timespec *" timeout ");"
 .fi
 .SH DESCRIPTION
 This function is similar to 
-.IR "aio_suspend"
+.BR "aio_suspend"
 with the only difference
 that the argument is a reference to a variable of type 
-.IR "struct aiocb64".
+.BR "struct aiocb64" .
 
 When the sources are compiled with 
 .IR "_FILE_OFFSET_BITS == 64"
 this
 function is available under the name 
-.IR "aio_suspend"
+.BR "aio_suspend"
 and so
 transparently replaces the interface for small files on 32 bit
 machines.
 .SH "RETURN VALUES"
 See
-.IR aio_suspend.
+.BR aio_suspend (3).
 .SH ERRORS
 See
-.IR aio_suspend.
+.BR aio_suspend (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_write(3),
-.BR aio_write64(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_write (3),
+.BR aio_write64 (3),
+.BR errno (3).
--- a/man/aio_write64.3
+++ b/man/aio_write64.3
@@ -1,4 +1,4 @@
-.TH aio_write64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH aio_write64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 aio_write64 \- Initiate an asynchronous write operation
 .SH SYNOPSYS
@@ -9,53 +9,53 @@ aio_write64 \- Initiate an asynchronous 
 .B #include <aio.h>
 .sp
 .br
-.BI  "int aio_write64 (struct aiocb *aiocbp)"
+.BI "int aio_write64(struct aiocb *" aiocbp ");"
 .fi
 .SH DESCRIPTION
 This function is similar to the 
-.IR "aio_write"
+.BR "aio_write"
 function.  The only
 difference is that on 
 .IR "32 bit"
 machines the file descriptor should
 be opened in the large file mode.  Internally 
-.IR "aio_write64"
+.BR "aio_write64"
 uses
 functionality equivalent to 
-.IR "lseek64"
+.BR "lseek64"
 to position the file descriptor correctly for the writing,
 as opposed to 
-.IR "lseek"
+.BR "lseek"
 functionality used in 
-.IR "aio_write".
+.BR "aio_write" .
 
 When the sources are compiled with 
 .IR "_FILE_OFFSET_BITS == 64"
 , this
 function is available under the name 
-.IR "aio_write"
+.BR "aio_write"
 and so transparently
 replaces the interface for small files on 32 bit machines.
 .SH "RETURN VALUES"
 See
-.IR aio_write.
+.BR aio_write (3).
 .SH ERRORS
 See
-.IR aio_write.
+.BR aio_write (3).
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR errno(3),
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR errno (3).
--- a/man/lio_listio.3
+++ b/man/lio_listio.3
@@ -1,4 +1,4 @@
-.TH  lio_listio 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH  lio_listio 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 lio_listio - List directed I/O
 .SH SYNOPSYS
@@ -6,7 +6,7 @@ lio_listio - List directed I/O
 .br
 .B #include <libaio.h>
 .LP
-.BI "int lio_listio (int mode, struct aiocb *const list[], int nent, struct sigevent *sig)"
+.BI "int lio_listio(int " mode ", struct aiocb *const " list "[], int " nent ", struct sigevent *" sig ");"
 .nf
 .SH DESCRIPTION
 
@@ -14,34 +14,33 @@ Besides these functions with the more or
 POSIX.1b also defines a function which can initiate more than one
 operation at a time, and which can handle freely mixed read and write
 operations.  It is therefore similar to a combination of 
-.IR readv
+.BR readv (2)
 and
-.IR "writev"
-.
+.BR writev (2).
 
 The 
-.IR "lio_listio"
+.BR "lio_listio"
 function can be used to enqueue an arbitrary
 number of read and write requests at one time.  The requests can all be
 meant for the same file, all for different files or every solution in
 between.
 
-.IR "lio_listio"
+.BR "lio_listio"
 gets the 
 .IR "nent"
 requests from the array pointed to
 by 
-.IR "list"
-.  The operation to be performed is determined by the
+.IR "list" .
+The operation to be performed is determined by the
 .IR "aio_lio_opcode"
 member in each element of 
-.IR "list"
-.  If this
+.IR "list" .
+If this
 field is 
 .B "LIO_READ"
 a read operation is enqueued, similar to a call
 of 
-.IR "aio_read"
+.BR "aio_read"
 for this element of the array (except that the way
 the termination is signalled is different, as we will see below).  If
 the 
@@ -57,10 +56,10 @@ in which case this element of 
 .IR "list"
 is simply ignored.  This
 ``operation'' is useful in situations where one has a fixed array of
-.IR "struct aiocb"
+.BR "struct aiocb"
 elements from which only a few need to be handled at
 a time.  Another situation is where the 
-.IR "lio_listio"
+.BR "lio_listio"
 call was
 canceled before all requests are processed  and the remaining requests have to be reissued.
 
@@ -68,15 +67,15 @@ The other members of each element of the
 .IR "list"
 must have values suitable for the operation as described in
 the documentation for 
-.IR "aio_read"
+.BR "aio_read"
 and 
-.IR "aio_write"
+.BR "aio_write"
 above.
 
 The 
 .IR "mode"
 argument determines how 
-.IR "lio_listio"
+.BR "lio_listio"
 behaves after
 having enqueued all the requests.  If 
 .IR "mode"
@@ -98,25 +97,24 @@ is 
 no notification is
 send.  Otherwise a signal is sent or a thread is started, just as
 described in the description for 
-.IR "aio_read"
+.BR "aio_read"
 or 
-.IR "aio_write"
-.
+.BR "aio_write" .
 
 When the sources are compiled with 
-.B "_FILE_OFFSET_BITS == 64"
-, this
+.IR "_FILE_OFFSET_BITS == 64" ,
+this
 function is in fact 
-.IR "lio_listio64"
+.BR "lio_listio64"
 since the LFS interface
 transparently replaces the normal implementation.
 .SH "RETURN VALUES"
 If 
 .IR "mode"
 is 
-.B "LIO_WAIT"
-, the return value of 
-.IR "lio_listio"
+.BR "LIO_WAIT" ,
+the return value of
+.BR "lio_listio"
 is 
 .IR 0
 when all requests completed successfully.  Otherwise the
@@ -126,10 +124,9 @@ and 
 .IR "errno"
 is set accordingly.  To find
 out which request or requests failed one has to use the 
-.IR "aio_error"
+.BR "aio_error"
 function on all the elements of the array 
-.IR "list"
-.
+.IR "list" .
 
 In case 
 .IR "mode"
@@ -140,12 +137,12 @@ is 
 if
 all requests were enqueued correctly.  The current state of the requests
 can be found using 
-.IR "aio_error"
+.BR "aio_error"
 and 
-.IR "aio_return"
+.BR "aio_return"
 as described
 above.  If 
-.IR "lio_listio"
+.BR "lio_listio"
 returns 
 .IR -1
 in this mode, the
@@ -153,16 +150,15 @@ global variable 
 .IR "errno"
 is set accordingly.  If a request did not
 yet terminate, a call to 
-.IR "aio_error"
+.BR "aio_error"
 returns 
-.B "EINPROGRESS"
-.  If
+.BR "EINPROGRESS" .
+If
 the value is different, the request is finished and the error value (or
-
-.IR 0
-) is returned and the result of the operation can be retrieved
+.IR 0 )
+is returned and the result of the operation can be retrieved
 using 
-.IR "aio_return"
+.BR "aio_return" .
 .
 .SH ERRORS
 Possible values for 
@@ -187,8 +183,7 @@ The 
 parameter is invalid or 
 .IR "nent"
 is larger than
-.B "AIO_LISTIO_MAX"
-.
+.BR "AIO_LISTIO_MAX" .
 .TP
 .B EIO
 One or more of the request's I/O operations failed.  The error status of
@@ -196,7 +191,7 @@ each request should be checked to determ
 .TP
 .B ENOSYS
 The 
-.IR "lio_listio"
+.BR "lio_listio"
 function is not supported.
 .PP
 
@@ -206,24 +201,24 @@ parameter is 
 .B "LIO_NOWAIT"
 and the caller cancels
 a request, the error status for this request returned by
-.IR "aio_error"
+.BR "aio_error"
 is 
-.B "ECANCELED"
+.BR "ECANCELED" .
 .
 .SH "SEE ALSO"
-.BR aio(3),
-.BR aio_cancel(3),
-.BR aio_cancel64(3),
-.BR aio_error(3),
-.BR aio_error64(3),
-.BR aio_fsync(3),
-.BR aio_fsync64(3),
-.BR aio_init(3),
-.BR aio_read(3),
-.BR aio_read64(3),
-.BR aio_return(3),
-.BR aio_return64(3),
-.BR aio_suspend(3),
-.BR aio_suspend64(3),
-.BR aio_write(3),
-.BR aio_write64(3)
+.BR aio (3),
+.BR aio_cancel (3),
+.BR aio_cancel64 (3),
+.BR aio_error (3),
+.BR aio_error64 (3),
+.BR aio_fsync (3),
+.BR aio_fsync64 (3),
+.BR aio_init (3),
+.BR aio_read (3),
+.BR aio_read64 (3),
+.BR aio_return (3),
+.BR aio_return64 (3),
+.BR aio_suspend (3),
+.BR aio_suspend64 (3),
+.BR aio_write (3),
+.BR aio_write64 (3).
--- a/man/io.3
+++ b/man/io.3
@@ -1,4 +1,4 @@
-.TH io 3 2002-09-12 "Linux 2.4" Linux IO"
+.TH io 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io \- Asynchronous IO
 .SH SYNOPSYS
@@ -6,7 +6,7 @@ io \- Asynchronous IO
 .B #include <errno.h>
 .sp
 .br 
-.B #include <libio.h>
+.B #include <libaio.h>
 .sp
 .fi
 .SH DESCRIPTION
@@ -17,9 +17,9 @@ then immediately resume normal work whil
 executed in parallel.  
 
 These functions are part of the library with realtime functions named
-.IR "libaio"
-.  They are not actually part of the 
-.IR "libc" 
+.IR libaio .
+They are not actually part of the 
+.I "libc"
 binary.
 The implementation of these functions can be done using support in the
 kernel.
@@ -27,9 +27,9 @@ kernel.
 All IO operations operate on files which were opened previously.  There
 might be arbitrarily many operations running for one file.  The
 asynchronous I/O operations are controlled using a data structure named
-.IR "struct iocb"
+.B "struct iocb"
 It is defined in
-.IR "libio.h"
+.I "libaio.h"
 as follows.
 
 .nf
@@ -74,7 +74,7 @@ struct iocb {
 
 .fi
 .TP
-.IR "int aio_fildes"
+.BI int " aio_fildes"
 This element specifies the file descriptor to be used for the
 operation.  It must be a legal descriptor, otherwise the operation will
 fail.
@@ -82,54 +82,51 @@ fail.
 The device on which the file is opened must allow the seek operation.
 I.e., it is not possible to use any of the IO operations on devices
 like terminals where an 
-.IR "lseek"
+.BR lseek (2)
 call would lead to an error.
 .TP
-.IR "long u.c.offset"
+.BI long " u.c.offset"
 This element specifies the offset in the file at which the operation (input
 or output) is performed.  Since the operations are carried out in arbitrary
 order and more than one operation for one file descriptor can be
 started, one cannot expect a current read/write position of the file
 descriptor.
 .TP
-.IR "void *buf"
+.BI "void *" buf
 This is a pointer to the buffer with the data to be written or the place
 where the read data is stored.
 .TP
-.IR "long u.c.nbytes"
+.BI long " u.c.nbytes"
 This element specifies the length of the buffer pointed to by 
-.IR "io_buf"
-.
+.IR io_buf .
 .TP
-.IR "int aio_reqprio"
+.BI int " aio_reqprio"
 Is not currently used.
 .TP
 .B "IO_CMD_PREAD"
 Start a read operation.  Read from the file at position
-.IR "u.c.offset"
+.I u.c.offset
 and store the next 
-.IR "u.c.nbytes"
+.I u.c.nbytes
 bytes in the
 buffer pointed to by 
-.IR "buf"
-.
+.IR buf .
 .TP
 .B "IO_CMD_PWRITE"
 Start a write operation.  Write 
-.IR "u.c.nbytes" 
+.I u.c.nbytes
 bytes starting at
-.IR "buf"
+.I buf
 into the file starting at position 
-.IR "u.c.offset"
-.
+.IR u.c.offset .
 .TP
 .B "IO_CMD_NOP"
 Do nothing for this control block.  This value is useful sometimes when
 an array of 
-.IR "struct iocb"
+.I struct iocb
 values contains holes, i.e., some of the
 values must not be handled although the whole array is presented to the
-.IR "io_submit"
+.I io_submit
 function.
 .TP 
 .B "IO_CMD_FSYNC"
@@ -336,16 +333,16 @@ int main(int argc, char *const *argv)
  */
 .fi
 .SH "SEE ALSO"
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_cancel.3
+++ b/man/io_cancel.3
@@ -1,4 +1,4 @@
-.TH io_cancel 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_cancel 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_cancel \- Cancel io requests
 .SH SYNOPSIS
@@ -9,7 +9,7 @@ io_cancel \- Cancel io requests
 .B #include <libaio.h>
 .sp
 .br
-.BI "int io_cancel(io_context_t ctx, struct iocb *iocb)"
+.BI "int io_cancel(io_context_t " ctx ", struct iocb *" iocb ");"
 .br
 .sp
 struct iocb {
@@ -33,7 +33,7 @@ have to be overwritten soon.  As an exam
 writes data in files in a situation where new incoming data would have
 to be written in a file which will be updated by an enqueued request.
 .SH "RETURN VALUES"
-0 is returned on success , otherwise returns Errno.
+\fI0\fP is returned on success, otherwise returns \fIerrno\fP.
 .SH ERRORS
 .TP
 .B EFAULT 
@@ -44,22 +44,22 @@ If aio_context specified by ctx_id is
 invalid.  
 .TP
 .B EAGAIN
-If the iocb specified was not
+If the \fIiocb\fP specified was not
 cancelled.  
 .TP
 .B ENOSYS 
-if not implemented.
+If not implemented.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_fsync.3
+++ b/man/io_fsync.3
@@ -1,10 +1,10 @@
-./" static inline int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)
-./" {
-./" 	io_prep_fsync(iocb, fd);
-./" 	io_set_callback(iocb, cb);
-./" 	return io_submit(ctx, 1, &iocb);
-./" }
-.TH io_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
+.\" static inline int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)
+.\" {
+.\" 	io_prep_fsync(iocb, fd);
+.\" 	io_set_callback(iocb, cb);
+.\" 	return io_submit(ctx, 1, &iocb);
+.\" }
+.TH io_fsync 3 2009-06-10 "Linux 2.4" Linux AIO"
 .SH NAME
 io_fsync \- Synchronize a file's complete in-core state with that on disk
 .SH SYNOPSYS
@@ -15,7 +15,7 @@ io_fsync \- Synchronize a file's complet
 .B #include <libaio.h>
 .sp
 .br
-.BI "int io_fsync(io_context_t ctx, struct iocb *iocb, io_callback_t cb, int fd)"
+.BI "int io_fsync(io_context_t " ctx ", struct iocb *" iocb ", io_callback_t " cb ", int " fd ");"
 .sp
 struct iocb {
 	void		*data;
@@ -49,7 +49,7 @@ file descriptor have terminated and the 
 means that requests for this very same file descriptor which are queued
 after the synchronization request are not affected.
 .SH "RETURN VALUES"
-Returns 0, otherwise returns errno.
+Returns \fI0\fP, otherwise returns \fIerrno\fP.
 .SH ERRORS
 .TP
 .B EFAULT
@@ -68,15 +68,15 @@ The iocb contains a file descriptor that
 .B EINVAL
 The file specified in the iocb does not support the given io operation.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_getevents(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_getevents (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_getevents.1
+++ b/man/io_getevents.1
@@ -1,22 +1,22 @@
-./"/* io_getevents:
-./" *      Attempts to read at least min_nr events and up to nr events from
-./" *      the completion queue for the aio_context specified by ctx_id.  May
-./" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
-./" *      if nr is out of range, if when is out of range.  May fail with
-./" *      -EFAULT if any of the memory specified to is invalid.  May return
-./" *      0 or < min_nr if no events are available and the timeout specified
-./" *      by when has elapsed, where when == NULL specifies an infinite
-./" *      timeout.  Note that the timeout pointed to by when is relative and
-./" *      will be updated if not NULL and the operation blocks.  Will fail
-./" *      with -ENOSYS if not implemented.
-./" */
-./"asmlinkage long sys_io_getevents(io_context_t ctx_id,
-./"                                 long min_nr,
-./"                                 long nr,
-./"                                 struct io_event *events,
-./"                                 struct timespec *timeout)
-./"
-.TH io_getevents 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.\"/* io_getevents:
+.\" *      Attempts to read at least min_nr events and up to nr events from
+.\" *      the completion queue for the aio_context specified by ctx_id.  May
+.\" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
+.\" *      if nr is out of range, if when is out of range.  May fail with
+.\" *      -EFAULT if any of the memory specified to is invalid.  May return
+.\" *      0 or < min_nr if no events are available and the timeout specified
+.\" *      by when has elapsed, where when == NULL specifies an infinite
+.\" *      timeout.  Note that the timeout pointed to by when is relative and
+.\" *      will be updated if not NULL and the operation blocks.  Will fail
+.\" *      with -ENOSYS if not implemented.
+.\" */
+.\"asmlinkage long sys_io_getevents(io_context_t ctx_id,
+.\"                                 long min_nr,
+.\"                                 long nr,
+.\"                                 struct io_event *events,
+.\"                                 struct timespec *timeout)
+.\"
+.TH io_getevents 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_getevents \- read resulting events from io requests
 .SH SYNOPSIS
--- a/man/io_getevents.3
+++ b/man/io_getevents.3
@@ -1,22 +1,22 @@
-./"/* io_getevents:
-./" *      Attempts to read at least min_nr events and up to nr events from
-./" *      the completion queue for the aio_context specified by ctx_id.  May
-./" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
-./" *      if nr is out of range, if when is out of range.  May fail with
-./" *      -EFAULT if any of the memory specified to is invalid.  May return
-./" *      0 or < min_nr if no events are available and the timeout specified
-./" *      by when has elapsed, where when == NULL specifies an infinite
-./" *      timeout.  Note that the timeout pointed to by when is relative and
-./" *      will be updated if not NULL and the operation blocks.  Will fail
-./" *      with -ENOSYS if not implemented.
-./" */
-./"asmlinkage long sys_io_getevents(io_context_t ctx_id,
-./"                                 long min_nr,
-./"                                 long nr,
-./"                                 struct io_event *events,
-./"                                 struct timespec *timeout)
-./"
-.TH io_getevents 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.\"/* io_getevents:
+.\" *      Attempts to read at least min_nr events and up to nr events from
+.\" *      the completion queue for the aio_context specified by ctx_id.  May
+.\" *      fail with -EINVAL if ctx_id is invalid, if min_nr is out of range,
+.\" *      if nr is out of range, if when is out of range.  May fail with
+.\" *      -EFAULT if any of the memory specified to is invalid.  May return
+.\" *      0 or < min_nr if no events are available and the timeout specified
+.\" *      by when has elapsed, where when == NULL specifies an infinite
+.\" *      timeout.  Note that the timeout pointed to by when is relative and
+.\" *      will be updated if not NULL and the operation blocks.  Will fail
+.\" *      with -ENOSYS if not implemented.
+.\" */
+.\"asmlinkage long sys_io_getevents(io_context_t ctx_id,
+.\"                                 long min_nr,
+.\"                                 long nr,
+.\"                                 struct io_event *events,
+.\"                                 struct timespec *timeout)
+.\"
+.TH io_getevents 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_getevents \- Read resulting events from io requests
 .SH SYNOPSIS
@@ -42,38 +42,38 @@ struct io_event {
         unsigned        PADDED(res2, __pad4);
 };
 .sp
-.BI "int io_getevents(io_context_t " ctx ",  long " nr ", struct io_event *" events "[], struct timespec *" timeout ");"
+.BI "int io_getevents(io_context_t " ctx ", long " nr ", struct io_event *" events "[], struct timespec *" timeout ");"
 
 .fi
 .SH DESCRIPTION
 Attempts to read  up to nr events from
-the completion queue for the aio_context specified by ctx.  
+the completion queue for the aio_context specified by \fIctx\fP.
 .SH "RETURN VALUES"
 May return
-0 if no events are available and the timeout specified
+\fI0\fP if no events are available and the timeout specified
 by when has elapsed, where when == NULL specifies an infinite
 timeout.  Note that the timeout pointed to by when is relative and
 will be updated if not NULL and the operation blocks.  Will fail
-with ENOSYS if not implemented.
+with \fBENOSYS\fP if not implemented.
 .SH ERRORS
 .TP
 .B EINVAL 
-if ctx_id is invalid, if min_nr is out of range,
+If ctx_id is invalid, if min_nr is out of range,
 if nr is out of range, if when is out of range.  
 .TP
 .B EFAULT 
-if any of the memory specified to is invalid.  
+If any of the memory specified to is invalid.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_prep_fsync.3
+++ b/man/io_prep_fsync.3
@@ -1,11 +1,11 @@
-./" static inline void io_prep_fsync(struct iocb *iocb, int fd)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_FSYNC;
-./" 	iocb->aio_reqprio = 0;
-./" }
-.TH io_prep_fsync 3 2002-09-12 "Linux 2.4" Linux AIO"
+.\" static inline void io_prep_fsync(struct iocb *iocb, int fd)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_FSYNC;
+.\" 	iocb->aio_reqprio = 0;
+.\" }
+.TH io_prep_fsync 3 2009-06-10 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_fsync \- Synchronize a file's complete in-core state with that on disk
 .SH SYNOPSYS
@@ -16,7 +16,7 @@ io_prep_fsync \- Synchronize a file's co
 .B #include <libaio.h>
 .br
 .sp
-.BI "static inline void io_prep_fsync(struct iocb *iocb, int fd)"
+.BI "static inline void io_prep_fsync(struct iocb *" iocb ", int " fd ");"
 .sp
 struct iocb {
 	void		*data;
@@ -28,7 +28,8 @@ struct iocb {
 .sp
 .fi
 .SH DESCRIPTION
-This is an inline convenience function for setting up an iocbv for a FSYNC request.
+This is an inline convenience function for setting up an \fIiocbv\fP for a
+\fBFSYNC\fP request.
 .br
 The file for which
 .TP 
@@ -36,33 +37,33 @@ The file for which
 is a descriptor is set up with
 the command
 .TP 
-.IR "iocb->aio_lio_opcode = IO_CMD_FSYNC:
+.IR "iocb->aio_lio_opcode = IO_CMD_FSYNC"
 .
 .PP
-The io_prep_fsync() function shall set up an IO_CMD_FSYNC operation
+The \fBio_prep_fsync\fP() function shall set up an \fBIO_CMD_FSYNC\fP operation
 to asynchronously force all I/O
 operations associated with the file indicated by the file
-descriptor aio_fildes member of the iocb structure referenced by
+descriptor \fIaio_fildes\fP member of the \fIiocb\fP structure referenced by
 the iocb argument and queued at the time of the call to
-io_submit() to the synchronized I/O completion state. The function
+\fBio_submit\fP() to the synchronized I/O completion state. The function
 call shall return when the synchronization request has been
 initiated or queued to the file or device (even when the data
 cannot be synchronized immediately).
 
 All currently queued I/O operations shall be completed as if by a call
-to fsync(); that is, as defined for synchronized I/O file
+to \fBfsync\fP(); that is, as defined for synchronized I/O file
 integrity completion. If the
-operation queued by io_prep_fsync() fails, then, as for fsync(),
+operation queued by \fBio_prep_fsync\fP() fails, then, as for \fBfsync\fP(),
 outstanding I/O operations are not guaranteed to have
 been completed.
 
-If io_prep_fsync() succeeds, then it is only the I/O that was queued
-at the time of the call to io_submit() that is guaranteed to be
+If \fBio_prep_fsync\fP() succeeds, then it is only the I/O that was queued
+at the time of the call to \fBio_submit\fP() that is guaranteed to be
 forced to the relevant completion state. The completion of
 subsequent I/O on the file descriptor is not guaranteed to be
 completed in a synchronized fashion.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function
 .IR io_submit
 must be called.
@@ -70,20 +71,20 @@ must be called.
 Simultaneous asynchronous operations using the same iocb produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_prep_pread.3
+++ b/man/io_prep_pread.3
@@ -1,14 +1,14 @@
-./" static inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_PREAD;
-./" 	iocb->aio_reqprio = 0;
-./" 	iocb->u.c.buf = buf;
-./" 	iocb->u.c.nbytes = count;
-./" 	iocb->u.c.offset = offset;
-./" }
-.TH io_prep_pread 3 2002-09-12 "Linux 2.4" Linux AIO"
+.\" static inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_PREAD;
+.\" 	iocb->aio_reqprio = 0;
+.\" 	iocb->u.c.buf = buf;
+.\" 	iocb->u.c.nbytes = count;
+.\" 	iocb->u.c.offset = offset;
+.\" }
+.TH io_prep_pread 3 2009-06-10 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pread \- Set up asynchronous read
 .SH SYNOPSYS
@@ -19,7 +19,7 @@ io_prep_pread \- Set up asynchronous rea
 .B #include <libaio.h>
 .br
 .sp
-.BI "inline void io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.BI "inline void io_prep_pread(struct iocb *" iocb ", int " fd ", void *" buf ", size_t " count ", long long " offset ");"
 "
 .sp
 struct iocb {
@@ -31,49 +31,43 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-.IR io_prep_pread 
+.B io_prep_pread
 is an inline convenience function designed to facilitate the initialization of
 the iocb for an asynchronous read operation.
 
 The first
-.TP
 .IR "iocb->u.c.nbytes = count"
 bytes of the file for which
-.TP
 .IR "iocb->aio_fildes = fd"
 is a descriptor are written to the buffer
 starting at
-.TP
-.IR "iocb->u.c.buf = buf"
-.
-.br
+.IR "iocb->u.c.buf = buf" .
 Reading starts at the absolute position
-.TP
 .IR "ioc->u.c.offset = offset"
 in the file.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function 
-.IR io_submit
+.B io_submit
 must be called.
 .PP
-Simultaneous asynchronous operations using the same iocb produce
+Simultaneous asynchronous operations using the same \fIiocb\fP produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_prep_pwrite.3
+++ b/man/io_prep_pwrite.3
@@ -1,14 +1,14 @@
-./" static inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-./" {
-./" 	memset(iocb, 0, sizeof(*iocb));
-./" 	iocb->aio_fildes = fd;
-./" 	iocb->aio_lio_opcode = IO_CMD_PWRITE;
-./" 	iocb->aio_reqprio = 0;
-./" 	iocb->u.c.buf = buf;
-./" 	iocb->u.c.nbytes = count;
-./" 	iocb->u.c.offset = offset;
-./" }
-.TH io_prep_pwrite 3 2002-09-12 "Linux 2.4" Linux AIO"
+.\" static inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
+.\" {
+.\" 	memset(iocb, 0, sizeof(*iocb));
+.\" 	iocb->aio_fildes = fd;
+.\" 	iocb->aio_lio_opcode = IO_CMD_PWRITE;
+.\" 	iocb->aio_reqprio = 0;
+.\" 	iocb->u.c.buf = buf;
+.\" 	iocb->u.c.nbytes = count;
+.\" 	iocb->u.c.offset = offset;
+.\" }
+.TH io_prep_pwrite 3 2009-06-10 "Linux 2.4" Linux AIO"
 .SH NAME
 io_prep_pwrite \- Set up iocb for asynchronous writes
 .SH SYNOPSYS
@@ -19,8 +19,8 @@ io_prep_pwrite \- Set up iocb for asynch
 .B #include <libaio.h>
 .br
 .sp
-.BI "inline void io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset)
-"
+.BI "inline void io_prep_pwrite(struct iocb *" iocb ", int " fd ", void *" buf ", size_t " count ", long long " offset ");"
+.
 .sp
 struct iocb {
 	void		*data;
@@ -31,26 +31,20 @@ struct iocb {
 };
 .fi
 .SH DESCRIPTION
-io_prep_write is a convenicence function for setting up parallel writes.
+\fBio_prep_write\fP is a convenicence function for setting up parallel writes.
 
 The first
-.TP
 .IR "iocb->u.c.nbytes = count"
 bytes of the file for which
-.TP
 .IR "iocb->aio_fildes = fd"
 is a descriptor are written from the buffer
 starting at
-.TP
-.IR "iocb->u.c.buf = buf"
-.
-.br
+.IR "iocb->u.c.buf = buf" .
 Writing starts at the absolute position
-.TP
 .IR "ioc->u.c.offset = offset"
 in the file.
 .PP
-This function returns immediately . To schedule the operation, the
+This function returns immediately. To schedule the operation, the
 function
 .IR io_submit
 must be called.
@@ -58,20 +52,20 @@ must be called.
 Simultaneous asynchronous operations using the same iocb produce
 undefined results.
 .SH "RETURN VALUES"
-None
+None.
 .SH ERRORS
-None
+None.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_queue_init.3
+++ b/man/io_queue_init.3
@@ -1,4 +1,4 @@
-.TH io_queue_init 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_init 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_queue_init \- Initialize asynchronous io state machine
 
@@ -10,7 +10,7 @@ io_queue_init \- Initialize asynchronous
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_init(int maxevents, io_context_t  *ctx );"
+.BI "int io_queue_init(int " maxevents ", io_context_t *" ctx ");"
 .sp
 .fi
 .SH DESCRIPTION
@@ -27,7 +27,7 @@ If the operation is successful, *cxtp is
 .SH "RETURN VALUES"
 On success,
 .B io_queue_init
-returns 0.  Otherwise, -error is return, where
+returns \fI0\fP.  Otherwise, -error is return, where
 error is one of the Exxx values defined in the Errors section.
 .SH ERRORS
 .TP
@@ -37,27 +37,27 @@ referenced data outside of the program's
 .TP
 .B EINVAL
 .I maxevents
-is <= 0 or 
+is <= \fI0\fP or
 .IR ctx
-is an invalid memory locattion.
+is an invalid memory location.
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .TP
 .B EAGAIN
 .IR "maxevents > max_aio_reqs"
 where max_aio_reqs is a tunable value.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_queue_release.3
+++ b/man/io_queue_release.3
@@ -1,4 +1,4 @@
-.TH io_queue_release 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_release 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_queue_release \- Release the context associated with the userspace handle
 .SH SYNOPSIS
@@ -8,41 +8,41 @@ io_queue_release \- Release the context 
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_release(io_context_t ctx)"
+.BI "int io_queue_release(io_context_t " ctx ");"
 .sp
 .SH DESCRIPTION
 .B io_queue_release
-destroys the context associated with the userspace handle.    May cancel any outstanding
+destroys the context associated with the userspace handle. May cancel any outstanding
 AIOs and block on completion.
 
 .B cts.
 .SH "RETURN VALUES"
 On success,
 .B io_queue_release
-returns 0.  Otherwise, -error is return, where
+returns \fI0\fP. Otherwise, -error is return, where
 error is one of the Exxx values defined in the Errors section.
 .SH ERRORS
 .TP
 .B EINVAL
 .I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+refers to an unitialized aio context, the \fIiocb\fP pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized \fIiocb\fP.
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_run(3),
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_run (3),
 .BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
 
--- a/man/io_queue_run.3
+++ b/man/io_queue_run.3
@@ -1,4 +1,4 @@
-.TH io_queue_run 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_run 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_queue_run \- Handle completed io requests
 .SH SYNOPSIS
@@ -9,17 +9,17 @@ io_queue_run \- Handle completed io requ
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_run(io_context_t  ctx );"
+.BI "int io_queue_run(io_context_t " ctx_id ");"
 .sp
 .fi
 .SH DESCRIPTION
 .B io_queue_run
-Attempts to read  all the events events from
-the completion queue for the aio_context specified by ctx_id.
+Attempts to read all the events events from
+the completion queue for the aio_context specified by \fIctx_id\fP.
 .SH "RETURN VALUES"
 May return
-0 if no events are available.
-Will fail with -ENOSYS if not implemented.
+\fI0\fP if no events are available.
+Will fail with -\fBENOSYS\fP if not implemented.
 .SH ERRORS
 .TP
 .B EFAULT
@@ -27,24 +27,24 @@ Will fail with -ENOSYS if not implemente
 referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
-.I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+.I ctx_id
+refers to an unitialized aio context, the \fIiocb\fP pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized iocb.
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_queue_wait.3
+++ b/man/io_queue_wait.3
@@ -1,4 +1,4 @@
-.TH io_queue_wait 2 2002-09-03 "Linux 2.4" "Linux AIO"
+.TH io_queue_wait 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_queue_wait \- Wait for io requests to complete
 .SH SYNOPSIS
@@ -9,22 +9,22 @@ io_queue_wait \- Wait for io requests to
 .B #include <libaio.h>
 .br
 .sp
-.BI "int io_queue_wait(io_context_t ctx, const struct timespec *timeout);"
+.BI "int io_queue_wait(io_context_t " ctx_id ", const struct timespec *" timeout ");"
 .fi
 .SH DESCRIPTION
-Attempts to read  an event from
-the completion queue for the aio_context specified by ctx_id.
+Attempts to read an event from
+the completion queue for the aio_context specified by \fIctx_id\fP.
 .SH "RETURN VALUES"
 May return
-0 if no events are available and the timeout specified
+\fI0\fP if no events are available and the timeout specified
 by when has elapsed, where when == NULL specifies an infinite
-timeout.  Note that the timeout pointed to by when is relative and
+\fItimeout\fP. Note that the \fItimeout\fP pointed to by when is relative and
 will be updated if not NULL and the operation blocks.  Will fail
-with -ENOSYS if not implemented.
+with -\fBENOSYS\fP if not implemented.
 .SH "RETURN VALUES"
 On success,
 .B io_queue_wait
-returns 0.  Otherwise, -error is return, where
+returns \fI0\fP. Otherwise, -error is return, where
 error is one of the Exxx values defined in the Errors section.
 .SH ERRORS
 .TP
@@ -33,24 +33,24 @@ error is one of the Exxx values defined 
 referenced data outside of the program's accessible address space.
 .TP
 .B EINVAL
-.I ctx 
-refers to an unitialized aio context, the iocb pointed to by
+.I ctx_id
+refers to an unitialized aio context, the \fIiocb\fP pointed to by
 .I iocbs 
-contains an improperly initialized iocb,
+contains an improperly initialized iocb.
 .TP
 .B ENOSYS 
-Not implemented
+Not implemented.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_set_callback(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_set_callback (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_set_callback.3
+++ b/man/io_set_callback.3
@@ -1,5 +1,5 @@
-./"static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)
-.TH io_set_callback 3 2002-09-12 "Linux 2.4" Linux AIO"
+.\"static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)
+.TH io_set_callback 3 2009-06-10 "Linux 2.4" Linux AIO"
 .SH NAME
 io_set_callback \- Set up io completion callback function
 .SH SYNOPSYS
@@ -10,7 +10,7 @@ io_set_callback \- Set up io completion 
 .B #include <libaio.h>
 .br
 .sp
-.BI "static inline void io_set_callback(struct iocb *iocb, io_callback_t cb)"
+.BI "static inline void io_set_callback(struct iocb *" iocb ", io_callback_t " cb ");"
 .sp
 struct iocb {
 	void		*data;
@@ -25,20 +25,22 @@ typedef void (*io_callback_t)(io_context
 .fi
 .SH DESCRIPTION
 The callback is not done if the caller uses raw events from 
-io_getevents, only with the library helpers
+\fBio_getevents\fP, only with the library helpers.
 .SH "RETURN VALUES"
+None.
 .SH ERRORS
+None.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_submit(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_submit (3),
+.BR errno (3).
--- a/man/io_setup.1
+++ b/man/io_setup.1
@@ -1,15 +1,15 @@
-./"/* sys_io_setup:
-./" *      Create an aio_context capable of receiving at least nr_events.
-./" *      ctxp must not point to an aio_context that already exists, and
-./" *      must be initialized to 0 prior to the call.  On successful
-./" *      creation of the aio_context, *ctxp is filled in with the resulting 
-./" *      handle.  May fail with -EINVAL if *ctxp is not initialized,
-./" *      if the specified nr_events exceeds internal limits.  May fail 
-./" *      with -EAGAIN if the specified nr_events exceeds the user's limit 
-./" *      of available events.  May fail with -ENOMEM if insufficient kernel
-./" *      resources are available.  May fail with -EFAULT if an invalid
-./" *      pointer is passed for ctxp.  Will fail with -ENOSYS if not
-./" *      implemented.
-./" */
-./" -- note: libaio is actually providing io_queue_init and io_queue_grow
-./" as separate functions.  For now io_setup is the same as io_queue_grow.
+.\"/* sys_io_setup:
+.\" *      Create an aio_context capable of receiving at least nr_events.
+.\" *      ctxp must not point to an aio_context that already exists, and
+.\" *      must be initialized to 0 prior to the call.  On successful
+.\" *      creation of the aio_context, *ctxp is filled in with the resulting 
+.\" *      handle.  May fail with -EINVAL if *ctxp is not initialized,
+.\" *      if the specified nr_events exceeds internal limits.  May fail 
+.\" *      with -EAGAIN if the specified nr_events exceeds the user's limit 
+.\" *      of available events.  May fail with -ENOMEM if insufficient kernel
+.\" *      resources are available.  May fail with -EFAULT if an invalid
+.\" *      pointer is passed for ctxp.  Will fail with -ENOSYS if not
+.\" *      implemented.
+.\" */
+.\" -- note: libaio is actually providing io_queue_init and io_queue_grow
+.\" as separate functions.  For now io_setup is the same as io_queue_grow.
--- a/man/io_submit.1
+++ b/man/io_submit.1
@@ -1,4 +1,4 @@
-.TH io_submit 2 2002-09-02 "Linux 2.4" "Linux AIO"
+.TH io_submit 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_submit \- submit io requests
 .SH SYNOPSIS
@@ -44,7 +44,7 @@ callback function.
 .I aio_lio_opcode
 is the I/O operation requested.  Callers will typically set this and the
 arguments to the I/O operation calling the
-.BR io_prep_ (3)
+.BR io_prep_ *(3)
 function corresponding to the operation.
 .sp
 .I aio_reqprio
@@ -106,4 +106,4 @@ Insufficient resources were available to
 .BR io_prep_fdsync (3),
 .BR io_prep_noop (3),
 .BR io_cancel (2),
-.BR errno (3)
+.BR errno (3).
--- a/man/io_submit.3
+++ b/man/io_submit.3
@@ -1,16 +1,16 @@
-./"/* sys_io_submit:
-./" *      Queue the nr iocbs pointed to by iocbpp for processing.  Returns
-./" *      the number of iocbs queued.  May return -EINVAL if the aio_context
-./" *      specified by ctx_id is invalid, if nr is < 0, if the iocb at
-./" *      *iocbpp[0] is not properly initialized, if the operation specified
-./" *      is invalid for the file descriptor in the iocb.  May fail with
-./" *      -EFAULT if any of the data structures point to invalid data.  May
-./" *      fail with -EBADF if the file descriptor specified in the first
-./" *      iocb is invalid.  May fail with -EAGAIN if insufficient resources
-./" *      are available to queue any iocbs.  Will return 0 if nr is 0.  Will
-./" *      fail with -ENOSYS if not implemented.
-./" */
-.TH io_submit 2 2002-09-02 "Linux 2.4" "Linux AIO"
+.\"/* sys_io_submit:
+.\" *      Queue the nr iocbs pointed to by iocbpp for processing.  Returns
+.\" *      the number of iocbs queued.  May return -EINVAL if the aio_context
+.\" *      specified by ctx_id is invalid, if nr is < 0, if the iocb at
+.\" *      *iocbpp[0] is not properly initialized, if the operation specified
+.\" *      is invalid for the file descriptor in the iocb.  May fail with
+.\" *      -EFAULT if any of the data structures point to invalid data.  May
+.\" *      fail with -EBADF if the file descriptor specified in the first
+.\" *      iocb is invalid.  May fail with -EAGAIN if insufficient resources
+.\" *      are available to queue any iocbs.  Will return 0 if nr is 0.  Will
+.\" *      fail with -ENOSYS if not implemented.
+.\" */
+.TH io_submit 2 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 io_submit \- Submit io requests
 .SH SYNOPSIS
@@ -49,12 +49,12 @@ gets the 
 .IR "nr"
 requests from the array pointed to
 by 
-.IR "iocbs"
-.  The operation to be performed is determined by the
+.IR "iocbs" .
+The operation to be performed is determined by the
 .IR "aio_lio_opcode"
 member in each element of 
-.IR "iocbs"
-.  If this
+.IR "iocbs" .
+If this
 field is 
 .B "IO_CMD_PREAD"
 a read operation is enqueued, similar to a call
@@ -120,16 +120,16 @@ The iocb contains a file descriptor that
 .B EINVAL
 The file specified in the iocb does not support the given io operation.
 .SH "SEE ALSO"
-.BR io(3),
-.BR io_cancel(3),
-.BR io_fsync(3),
-.BR io_getevents(3),
-.BR io_prep_fsync(3),
-.BR io_prep_pread(3),
-.BR io_prep_pwrite(3),
-.BR io_queue_init(3),
-.BR io_queue_release(3),
-.BR io_queue_run(3),
-.BR io_queue_wait(3),
-.BR io_set_callback(3),
-.BR errno(3)
+.BR io (3),
+.BR io_cancel (3),
+.BR io_fsync (3),
+.BR io_getevents (3),
+.BR io_prep_fsync (3),
+.BR io_prep_pread (3),
+.BR io_prep_pwrite (3),
+.BR io_queue_init (3),
+.BR io_queue_release (3),
+.BR io_queue_run (3),
+.BR io_queue_wait (3),
+.BR io_set_callback (3),
+.BR errno (3).
--- a/man/lio_listio64.3
+++ b/man/lio_listio64.3
@@ -1,4 +1,4 @@
-.TH lio_listio64 3 2002-09-12 "Linux 2.4" Linux AIO"
+.TH lio_listio64 3 2009-06-10 "Linux 2.4" "Linux AIO"
 .SH NAME
 lio_listio64 \- List directed I/O
 .SH SYNOPSYS
@@ -6,31 +6,31 @@ lio_listio64 \- List directed I/O
 .br
 .B #include <libaio.h>
 .LP
-.BI "int lio_listio64 (int mode, struct aiocb *const list[], int nent, struct sigevent *sig)"
+.BI "int lio_listio64 (int " mode ", struct aiocb *const " list "[], int " nent ", struct sigevent *" sig ");"
 .nf
 .SH DESCRIPTION
 This function is similar to the 
-.IR "code{lio_listio"
+.BR lio_listio
 function.  The only
 difference is that on 
 .IR "32 bit"
 machines, the file descriptor should
 be opened in the large file mode.  Internally, 
-.IR "lio_listio64"
+.BR lio_listio64
 uses
 functionality equivalent to 
-.IR lseek64"
+.BR lseek64
 to position the file descriptor correctly for the reading or
 writing, as opposed to 
-.IR "lseek"
+.BR lseek
 functionality used in
-.IR "lio_listio".
+.BR lio_listio .
 
 When the sources are compiled with 
-.IR "_FILE_OFFSET_BITS == 64"
-, this
+.IR "_FILE_OFFSET_BITS == 64" ,
+this
 function is available under the name 
-.IR "lio_listio"
+.BR lio_listio
 and so
 transparently replaces the interface for small files on 32 bit
 machines.
