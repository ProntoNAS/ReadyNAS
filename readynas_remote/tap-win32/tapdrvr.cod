; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.2228.2 

include listing.inc

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	g_InstanceHash
PUBLIC	g_SupportedOIDList
_DATA	SEGMENT
COMM	g_LastErrorFilename:QWORD
COMM	g_LastErrorLineNumber:DWORD
_DATA	ENDS
_BSS	SEGMENT
g_InstanceHash DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	g_NdisWrapperHandle:QWORD
_DATA	ENDS
CONST	SEGMENT
g_SupportedOIDList DD 010102H
	DD	010103H
	DD	010104H
	DD	010105H
	DD	010113H
	DD	010107H
	DD	01010aH
	DD	01010bH
	DD	01010dH
	DD	010110H
	DD	020101H
	DD	020102H
	DD	020103H
	DD	020104H
	DD	01010101H
	DD	01010102H
	DD	020105H
	DD	01020101H
	DD	01020102H
	DD	01020103H
	DD	01010103H
	DD	01010104H
	DD	01010cH
	DD	01010fH
	DD	01010eH
	DD	010112H
	DD	010111H
	DD	010108H
	DD	010109H
	DD	010106H
	DD	010116H
	DD	010115H
	DD	010114H
	DD	010101H
CONST	ENDS
PUBLIC	KeInitializeSpinLock
; Function compile flags: /Ogty
; File c:\winddk\3790\inc\ddk\wnet\ntddk.h
;	COMDAT KeInitializeSpinLock
_TEXT	SEGMENT
SpinLock$ = 8
KeInitializeSpinLock PROC NEAR				; COMDAT

; 12160:     *SpinLock = 0;

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 12161: }

  00007	c3		 ret	 0
KeInitializeSpinLock ENDP
_TEXT	ENDS
PUBLIC	NdisQueryPacket
;	COMDAT xdata
; File c:\winddk\3790\inc\ddk\wnet\ndis.h
xdata	SEGMENT
$unwind$NdisQueryPacket DD 050701H
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$NdisQueryPacket DD @imagerel(NdisQueryPacket#)
	DD	@imagerel(NdisQueryPacket#+201)
	DD	@imagerel($unwind$NdisQueryPacket#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT NdisQueryPacket
_TEXT	SEGMENT
_Packet$ = 48
_PhysicalBufferCount$ = 56
_BufferCount$ = 64
_FirstBuffer$ = 72
_TotalPacketLength$ = 80
NdisQueryPacket PROC NEAR				; COMDAT

; 7886 : {                                                                           

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	49 8b f8	 mov	 rdi, r8
  0000a	48 8b f2	 mov	 rsi, rdx
  0000d	4c 8b d1	 mov	 r10, rcx

; 7887 :     if ((_FirstBuffer) != NULL)                                             

  00010	4d 85 c9	 test	 r9, r9
  00013	74 07		 je	 SHORT $L16914

; 7888 :     {                                                                       
; 7889 :         PNDIS_BUFFER * __FirstBuffer = (_FirstBuffer);                      
; 7890 :         *(__FirstBuffer) = (_Packet)->Private.Head;                         

  00015	49 8b 42 08	 mov	 rax, QWORD PTR [r10+8]
  00019	49 89 01	 mov	 QWORD PTR [r9], rax
$L16914:

; 7891 :     }                                                                       
; 7892 :     if ((_TotalPacketLength) || (_BufferCount) || (_PhysicalBufferCount))   

  0001c	48 8b 5c 24 50	 mov	 rbx, QWORD PTR _TotalPacketLength$[rsp]
  00021	48 85 db	 test	 rbx, rbx
  00024	75 0e		 jne	 SHORT $L16917
  00026	48 85 ff	 test	 rdi, rdi
  00029	75 09		 jne	 SHORT $L16917
  0002b	48 85 f6	 test	 rsi, rsi
  0002e	0f 84 8d 00 00
	00		 je	 $L16939
$L16917:

; 7893 :     {                                                                       
; 7894 :         if (!(_Packet)->Private.ValidCounts)                                

  00034	41 80 7a 28 00	 cmp	 BYTE PTR [r10+40], 0
  00039	75 66		 jne	 SHORT $L16918

; 7895 :         {                                                                   
; 7896 :             PNDIS_BUFFER TmpBuffer = (_Packet)->Private.Head;               

  0003b	49 8b 52 08	 mov	 rdx, QWORD PTR [r10+8]

; 7897 :             UINT PTotalLength = 0, PPhysicalCount = 0, PAddedCount = 0;     

  0003f	45 33 c0	 xor	 r8d, r8d
  00042	45 8b c8	 mov	 r9d, r8d
  00045	45 8b d8	 mov	 r11d, r8d

; 7898 :             UINT PacketLength, Offset;                                      
; 7899 :                                                                             
; 7900 :             while (TmpBuffer != (PNDIS_BUFFER)NULL)                         

  00048	48 85 d2	 test	 rdx, rdx
  0004b	74 44		 je	 SHORT $L16929
  0004d	41 bc 01 00 00
	00		 mov	 r12d, 1
  00053	41 bd ff 0f 00
	00		 mov	 r13d, 4095		; 00000fffH
$L16928:

; 7901 :             {                                                               
; 7902 :                 NdisQueryBufferOffset(TmpBuffer, &Offset, &PacketLength);   

  00059	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]

; 7903 :                 PTotalLength += PacketLength;                               

  0005c	44 03 c0	 add	 r8d, eax

; 7904 :                 PPhysicalCount += (UINT)NDIS_BUFFER_TO_SPAN_PAGES(TmpBuffer);

  0005f	85 c0		 test	 eax, eax
  00061	75 05		 jne	 SHORT $L22728
  00063	41 8b c4	 mov	 eax, r12d
  00066	eb 1a		 jmp	 SHORT $L22729
$L22728:
  00068	66 8b 4a 2c	 mov	 cx, WORD PTR [rdx+44]
  0006c	66 03 4a 20	 add	 cx, WORD PTR [rdx+32]
  00070	49 23 cd	 and	 rcx, r13
  00073	8b 42 28	 mov	 eax, DWORD PTR [rdx+40]
  00076	48 8d 84 01 ff
	0f 00 00	 lea	 rax, QWORD PTR [rcx+rax+4095]
  0007e	48 c1 e8 0c	 shr	 rax, 12			; 0000000cH
$L22729:
  00082	44 03 c8	 add	 r9d, eax

; 7905 :                 ++PAddedCount;                                              

  00085	41 83 c3 01	 add	 r11d, 1

; 7906 :                 TmpBuffer = TmpBuffer->Next;                                

  00089	48 8b 12	 mov	 rdx, QWORD PTR [rdx]

; 7898 :             UINT PacketLength, Offset;                                      
; 7899 :                                                                             
; 7900 :             while (TmpBuffer != (PNDIS_BUFFER)NULL)                         

  0008c	48 85 d2	 test	 rdx, rdx
  0008f	75 c8		 jne	 SHORT $L16928
$L16929:

; 7907 :             }                                                               
; 7908 :             (_Packet)->Private.Count = PAddedCount;                         

  00091	45 89 5a 20	 mov	 DWORD PTR [r10+32], r11d

; 7909 :             (_Packet)->Private.TotalLength = PTotalLength;                  

  00095	45 89 42 04	 mov	 DWORD PTR [r10+4], r8d

; 7910 :             (_Packet)->Private.PhysicalCount = PPhysicalCount;              

  00099	45 89 0a	 mov	 DWORD PTR [r10], r9d

; 7911 :             (_Packet)->Private.ValidCounts = TRUE;                          

  0009c	41 c6 42 28 01	 mov	 BYTE PTR [r10+40], 1
$L16918:

; 7912 :         }                                                                   
; 7913 :                                                                             
; 7914 :         if (_PhysicalBufferCount)                                           

  000a1	48 85 f6	 test	 rsi, rsi
  000a4	74 05		 je	 SHORT $L16935

; 7915 :         {                                                                   
; 7916 :             PUINT __PhysicalBufferCount = (_PhysicalBufferCount);           
; 7917 :             *(__PhysicalBufferCount) = (_Packet)->Private.PhysicalCount;    

  000a6	41 8b 02	 mov	 eax, DWORD PTR [r10]
  000a9	89 06		 mov	 DWORD PTR [rsi], eax
$L16935:

; 7918 :         }                                                                   
; 7919 :         if (_BufferCount)                                                   

  000ab	48 85 ff	 test	 rdi, rdi
  000ae	74 06		 je	 SHORT $L16937

; 7920 :         {                                                                   
; 7921 :             PUINT __BufferCount = (_BufferCount);                           
; 7922 :             *(__BufferCount) = (_Packet)->Private.Count;                    

  000b0	41 8b 42 20	 mov	 eax, DWORD PTR [r10+32]
  000b4	89 07		 mov	 DWORD PTR [rdi], eax
$L16937:

; 7923 :         }                                                                   
; 7924 :         if (_TotalPacketLength)                                             

  000b6	48 85 db	 test	 rbx, rbx
  000b9	74 06		 je	 SHORT $L16939

; 7925 :         {                                                                   
; 7926 :             PUINT __TotalPacketLength = (_TotalPacketLength);               
; 7927 :             *(__TotalPacketLength) = (_Packet)->Private.TotalLength;        

  000bb	41 8b 42 04	 mov	 eax, DWORD PTR [r10+4]
  000bf	89 03		 mov	 DWORD PTR [rbx], eax
$L16939:

; 7928 :         }                                                                   
; 7929 :     }                                                                       
; 7930 : }

  000c1	41 5d		 pop	 r13
  000c3	41 5c		 pop	 r12
  000c5	5f		 pop	 rdi
  000c6	5e		 pop	 rsi
  000c7	5b		 pop	 rbx
  000c8	c3		 ret	 0
NdisQueryPacket ENDP
_TEXT	ENDS
PUBLIC	MemAlloc
EXTRN	__C_specific_handler:NEAR
EXTRN	__imp_RtlZeroMemory:NEAR
EXTRN	__imp_NdisAllocateMemoryWithTag:NEAR
;	COMDAT xdata
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\mem.c
xdata	SEGMENT
$unwind$MemAlloc DD 040709H
	DD	070035207H
	DD	030016002H
	DD	@imagerel(__C_specific_handler#)
	DD	01H
	DD	@imagerel(MemAlloc#+23)
	DD	@imagerel(MemAlloc#+85)
	DD	@imagerel(MemAlloc$filt$0#)
	DD	@imagerel(MemAlloc#+85)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemAlloc DD @imagerel(MemAlloc#)
	DD	@imagerel(MemAlloc#+98)
	DD	@imagerel($unwind$MemAlloc#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MemAlloc$filt$0 DD 050801H
	DD	050044208H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemAlloc$filt$0 DD @imagerel(MemAlloc$filt$0#)
	DD	@imagerel(MemAlloc$filt$0#+25)
	DD	@imagerel($unwind$MemAlloc$filt$0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT MemAlloc
_TEXT	SEGMENT
l_Return$ = 32
p_Size$ = 80
zero$ = 88
MemAlloc PROC NEAR					; COMDAT

; 35   : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00007	0f b6 f2	 movzx	 esi, dl
  0000a	8b f9		 mov	 edi, ecx

; 36   :   PVOID l_Return = NULL;

  0000c	33 db		 xor	 ebx, ebx
  0000e	48 89 5c 24 20	 mov	 QWORD PTR l_Return$[rsp], rbx

; 37   : 
; 38   :   if (p_Size)

  00013	85 ff		 test	 edi, edi
  00015	74 40		 je	 SHORT $L22751

; 39   :     {
; 40   :       __try
; 41   :       {
; 42   : 	if (NdisAllocateMemoryWithTag (&l_Return, p_Size, 'APAT')
; 43   : 	    == NDIS_STATUS_SUCCESS)

  00017	41 b8 54 41 50
	41		 mov	 r8d, 1095778644		; 41504154H
  0001d	8b d7		 mov	 edx, edi
  0001f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR l_Return$[rsp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisAllocateMemoryWithTag
  0002a	85 c0		 test	 eax, eax
  0002c	75 19		 jne	 SHORT $L20816

; 44   : 	  {
; 45   : 	    if (zero)

  0002e	40 84 f6	 test	 sil, sil
  00031	74 1b		 je	 SHORT $L22752

; 46   : 	      NdisZeroMemory (l_Return, p_Size);

  00033	8b d7		 mov	 edx, edi
  00035	48 8b 4c 24 20	 mov	 rcx, QWORD PTR l_Return$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 47   : 	  }
; 48   : 	else

  00040	48 8b 5c 24 20	 mov	 rbx, QWORD PTR l_Return$[rsp]
  00045	eb 0c		 jmp	 SHORT $L20818
$L20816:

; 49   : 	  l_Return = NULL;

  00047	48 89 5c 24 20	 mov	 QWORD PTR l_Return$[rsp], rbx
  0004c	eb 05		 jmp	 SHORT $L20818
$L22752:

; 47   : 	  }
; 48   : 	else

  0004e	48 8b 5c 24 20	 mov	 rbx, QWORD PTR l_Return$[rsp]
$L20818:
  00053	eb 02		 jmp	 SHORT $L22751
$L22748:
$L22749:

; 50   :       }
; 51   :       __except (EXCEPTION_EXECUTE_HANDLER)
; 52   :       {
; 53   : 	l_Return = NULL;

  00055	33 db		 xor	 ebx, ebx
$L22751:

; 54   :       }
; 55   :     }
; 56   : 
; 57   :   return l_Return;

  00057	48 8b c3	 mov	 rax, rbx
$L20809:

; 58   : }

  0005a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005e	5f		 pop	 rdi
  0005f	5e		 pop	 rsi
  00060	5b		 pop	 rbx
  00061	c3		 ret	 0
MemAlloc ENDP
; Function compile flags: /Ogty
l_Return$ = 32
p_Size$ = 80
zero$ = 88
MemAlloc$filt$0 PROC NEAR
  00070	53		 push	 rbx
  00071	56		 push	 rsi
  00072	57		 push	 rdi
  00073	55		 push	 rbp
  00074	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00078	48 8b ea	 mov	 rbp, rdx

; 51   :       __except (EXCEPTION_EXECUTE_HANDLER)

  0007b	b8 01 00 00 00	 mov	 eax, 1
$L22750:
  00080	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00084	5d		 pop	 rbp
  00085	5f		 pop	 rdi
  00086	5e		 pop	 rsi
  00087	5b		 pop	 rbx
  00088	c3		 ret	 0
MemAlloc$filt$0 ENDP
_TEXT	ENDS
PUBLIC	MemFree
EXTRN	__imp_NdisFreeMemory:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$MemFree DD 010409H
	DD	04204H
	DD	@imagerel(__C_specific_handler#)
	DD	01H
	DD	@imagerel(MemFree#+13)
	DD	@imagerel(MemFree#+24)
	DD	@imagerel(MemFree$filt$0#)
	DD	@imagerel(MemFree#+24)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemFree DD @imagerel(MemFree#)
	DD	@imagerel(MemFree#+29)
	DD	@imagerel($unwind$MemFree#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MemFree$filt$0 DD 020501H
	DD	050013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MemFree$filt$0 DD @imagerel(MemFree$filt$0#)
	DD	@imagerel(MemFree$filt$0#+19)
	DD	@imagerel($unwind$MemFree$filt$0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT MemFree
_TEXT	SEGMENT
p_Addr$ = 48
p_Size$ = 56
MemFree	PROC NEAR					; COMDAT

; 62   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 63   :   if (p_Addr && p_Size)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 0f		 je	 SHORT $L22772
  00009	85 d2		 test	 edx, edx
  0000b	74 0b		 je	 SHORT $L22772

; 64   :     {
; 65   :       __try
; 66   :       {
; 67   : #if DBG
; 68   : 	NdisZeroMemory (p_Addr, p_Size);
; 69   : #endif
; 70   : 	NdisFreeMemory (p_Addr, p_Size, 0);

  0000d	45 33 c0	 xor	 r8d, r8d
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisFreeMemory
  00016	eb 00		 jmp	 SHORT $L22772
$L22769:
$L22770:
$L22772:

; 71   :       }
; 72   :       __except (EXCEPTION_EXECUTE_HANDLER)
; 73   :       {
; 74   :       }
; 75   :     }
; 76   : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
MemFree	ENDP
; Function compile flags: /Ogty
p_Addr$ = 48
p_Size$ = 56
MemFree$filt$0 PROC NEAR
  00020	55		 push	 rbp
  00021	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00025	48 8b ea	 mov	 rbp, rdx

; 72   :       __except (EXCEPTION_EXECUTE_HANDLER)

  00028	b8 01 00 00 00	 mov	 eax, 1
$L22771:
  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5d		 pop	 rbp
  00032	c3		 ret	 0
MemFree$filt$0 ENDP
_TEXT	ENDS
PUBLIC	QueueInit
;	COMDAT xdata
xdata	SEGMENT
$unwind$QueueInit DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$QueueInit DD @imagerel(QueueInit#)
	DD	@imagerel(QueueInit#+51)
	DD	@imagerel($unwind$QueueInit#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT QueueInit
_TEXT	SEGMENT
capacity$ = 48
QueueInit PROC NEAR					; COMDAT

; 106  : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	8b d9		 mov	 ebx, ecx

; 107  :   Queue *q;
; 108  : 
; 109  :   MYASSERT (capacity > 0);
; 110  :   q = (Queue *) MemAlloc (QUEUE_BYTE_ALLOCATION (capacity), TRUE);

  00007	8d 0c dd 10 00
	00 00		 lea	 ecx, DWORD PTR [rbx*8+16]
  0000e	b2 01		 mov	 dl, 1
  00010	e8 00 00 00 00	 call	 MemAlloc

; 111  :   if (!q)

  00015	48 85 c0	 test	 rax, rax
  00018	75 06		 jne	 SHORT $L20842

; 117  :   return q;
; 118  : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx
  0001f	c3		 ret	 0
$L20842:

; 112  :     return NULL;
; 113  : 
; 114  :   q->base = q->size = 0;

  00020	33 c9		 xor	 ecx, ecx
  00022	89 48 04	 mov	 DWORD PTR [rax+4], ecx
  00025	89 08		 mov	 DWORD PTR [rax], ecx

; 115  :   q->capacity = capacity;

  00027	89 58 08	 mov	 DWORD PTR [rax+8], ebx

; 116  :   q->max_size = 0;

  0002a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 117  :   return q;
; 118  : }

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
QueueInit ENDP
_TEXT	ENDS
PUBLIC	QueueFree
;	COMDAT xdata
xdata	SEGMENT
$unwind$QueueFree DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$QueueFree DD @imagerel(QueueFree#)
	DD	@imagerel(QueueFree#+29)
	DD	@imagerel($unwind$QueueFree#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT QueueFree
_TEXT	SEGMENT
q$ = 48
QueueFree PROC NEAR					; COMDAT

; 122  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 123  :   if (q)

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 0f		 je	 SHORT $L20848

; 124  :     {
; 125  :       QUEUE_SANITY_CHECK ();
; 126  :       MemFree (q, QUEUE_BYTE_ALLOCATION (q->capacity));

  00009	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  0000c	8d 14 c5 10 00
	00 00		 lea	 edx, DWORD PTR [rax*8+16]
  00013	e8 00 00 00 00	 call	 MemFree
$L20848:

; 127  :     }
; 128  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
QueueFree ENDP
_TEXT	ENDS
PUBLIC	QueuePush
; Function compile flags: /Ogty
;	COMDAT QueuePush
_TEXT	SEGMENT
q$ = 8
item$ = 16
QueuePush PROC NEAR					; COMDAT

; 133  :   ULONG dest;
; 134  :   QUEUE_SANITY_CHECK ();
; 135  :   if (q->size == q->capacity)

  00000	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00003	44 8b 41 08	 mov	 r8d, DWORD PTR [rcx+8]
  00007	41 3b c0	 cmp	 eax, r8d
  0000a	75 03		 jne	 SHORT $L20858

; 136  :     return NULL;

  0000c	33 c0		 xor	 eax, eax

; 143  : }

  0000e	c3		 ret	 0
$L20858:

; 137  :   dest = q->base;
; 138  :   QUEUE_ADD_INDEX (dest, q->size);

  0000f	03 01		 add	 eax, DWORD PTR [rcx]
  00011	41 3b c0	 cmp	 eax, r8d
  00014	72 03		 jb	 SHORT $L20860
  00016	41 2b c0	 sub	 eax, r8d
$L20860:

; 139  :   q->data[dest] = item;

  00019	8b c0		 mov	 eax, eax
  0001b	48 89 54 c1 10	 mov	 QWORD PTR [rcx+rax*8+16], rdx

; 140  :   ++q->size;

  00020	83 41 04 01	 add	 DWORD PTR [rcx+4], 1
  00024	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]

; 141  :   UPDATE_MAX_SIZE();

  00027	3b 41 0c	 cmp	 eax, DWORD PTR [rcx+12]
  0002a	76 03		 jbe	 SHORT $L20861
  0002c	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$L20861:

; 142  :   return item;

  0002f	48 8b c2	 mov	 rax, rdx

; 143  : }

  00032	c3		 ret	 0
QueuePush ENDP
_TEXT	ENDS
PUBLIC	QueuePop
; Function compile flags: /Ogty
;	COMDAT QueuePop
_TEXT	SEGMENT
q$ = 8
QueuePop PROC NEAR					; COMDAT

; 148  :   ULONG oldbase;
; 149  :   QUEUE_SANITY_CHECK ();
; 150  :   if (!q->size)

  00000	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00003	85 c0		 test	 eax, eax
  00005	75 01		 jne	 SHORT $L20867

; 157  : }

  00007	c3		 ret	 0
$L20867:

; 151  :     return NULL;
; 152  :   oldbase = q->base;

  00008	44 8b 01	 mov	 r8d, DWORD PTR [rcx]

; 153  :   QUEUE_ADD_INDEX (q->base, 1);

  0000b	41 8d 50 01	 lea	 edx, DWORD PTR [r8+1]
  0000f	89 11		 mov	 DWORD PTR [rcx], edx
  00011	44 8b 49 08	 mov	 r9d, DWORD PTR [rcx+8]
  00015	41 3b d1	 cmp	 edx, r9d
  00018	72 05		 jb	 SHORT $L20869
  0001a	41 2b d1	 sub	 edx, r9d
  0001d	89 11		 mov	 DWORD PTR [rcx], edx
$L20869:

; 154  :   --q->size;

  0001f	83 c0 ff	 add	 eax, -1
  00022	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 155  :   UPDATE_MAX_SIZE();

  00025	3b 41 0c	 cmp	 eax, DWORD PTR [rcx+12]
  00028	76 03		 jbe	 SHORT $L20870
  0002a	89 41 0c	 mov	 DWORD PTR [rcx+12], eax
$L20870:

; 156  :   return q->data[oldbase];

  0002d	41 8b c0	 mov	 eax, r8d
  00030	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]

; 157  : }

  00035	c3		 ret	 0
QueuePop ENDP
_TEXT	ENDS
PUBLIC	QueueExtract
;	COMDAT xdata
xdata	SEGMENT
$unwind$QueueExtract DD 020201H
	DD	030017002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$QueueExtract DD @imagerel(QueueExtract#)
	DD	@imagerel(QueueExtract#+111)
	DD	@imagerel($unwind$QueueExtract#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT QueueExtract
_TEXT	SEGMENT
q$ = 24
item$ = 32
QueueExtract PROC NEAR					; COMDAT

; 161  : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	48 8b da	 mov	 rbx, rdx

; 162  :   ULONG src, dest, count, n;
; 163  :   QUEUE_SANITY_CHECK ();
; 164  :   n = 0;

  00005	45 33 d2	 xor	 r10d, r10d

; 165  :   src = dest = q->base;

  00008	44 8b 09	 mov	 r9d, DWORD PTR [rcx]
  0000b	45 8b c1	 mov	 r8d, r9d

; 166  :   count = q->size;

  0000e	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]

; 167  :   while (count--)

  00011	85 c0		 test	 eax, eax
  00013	74 55		 je	 SHORT $L20888

; 162  :   ULONG src, dest, count, n;
; 163  :   QUEUE_SANITY_CHECK ();
; 164  :   n = 0;

  00015	44 8b d8	 mov	 r11d, eax
  00018	bf ff ff ff ff	 mov	 edi, -1
$L20882:

; 168  :     {
; 169  :       if (item == q->data[src])

  0001d	41 8b c0	 mov	 eax, r8d
  00020	48 8b 54 c1 10	 mov	 rdx, QWORD PTR [rcx+rax*8+16]
  00025	48 3b da	 cmp	 rbx, rdx
  00028	75 09		 jne	 SHORT $L20884

; 170  : 	{
; 171  : 	  ++n;

  0002a	41 83 c2 01	 add	 r10d, 1

; 172  : 	  --q->size;

  0002e	01 79 04	 add	 DWORD PTR [rcx+4], edi

; 173  : 	}
; 174  :       else

  00031	eb 17		 jmp	 SHORT $L20886
$L20884:

; 175  : 	{
; 176  : 	  q->data[dest] = q->data[src];

  00033	41 8b c1	 mov	 eax, r9d
  00036	48 89 54 c1 10	 mov	 QWORD PTR [rcx+rax*8+16], rdx

; 177  : 	  QUEUE_ADD_INDEX (dest, 1);	  

  0003b	41 83 c1 01	 add	 r9d, 1
  0003f	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00042	44 3b c8	 cmp	 r9d, eax
  00045	72 03		 jb	 SHORT $L20886
  00047	44 2b c8	 sub	 r9d, eax
$L20886:

; 178  : 	}
; 179  :       QUEUE_ADD_INDEX (src, 1);

  0004a	41 83 c0 01	 add	 r8d, 1
  0004e	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  00051	44 3b c0	 cmp	 r8d, eax
  00054	72 03		 jb	 SHORT $L20887
  00056	44 2b c0	 sub	 r8d, eax
$L20887:

; 167  :   while (count--)

  00059	49 83 eb 01	 sub	 r11, 1
  0005d	75 be		 jne	 SHORT $L20882

; 180  :     }
; 181  :   if (n)

  0005f	45 85 d2	 test	 r10d, r10d
  00062	74 06		 je	 SHORT $L20888

; 182  :     return item;

  00064	48 8b c3	 mov	 rax, rbx

; 185  : }

  00067	5f		 pop	 rdi
  00068	5b		 pop	 rbx
  00069	c3		 ret	 0
$L20888:

; 183  :   else
; 184  :     return NULL;

  0006a	33 c0		 xor	 eax, eax

; 185  : }

  0006c	5f		 pop	 rdi
  0006d	5b		 pop	 rbx
  0006e	c3		 ret	 0
QueueExtract ENDP
_TEXT	ENDS
PUBLIC	HexStringToDecimalInt
; Function compile flags: /Ogty
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\macinfo.c
;	COMDAT HexStringToDecimalInt
_TEXT	SEGMENT
p_Character$ = 8
HexStringToDecimalInt PROC NEAR				; COMDAT

; 34   :   int l_Value = 0;
; 35   : 
; 36   :   if (p_Character >= 'A' && p_Character <= 'F')

  00000	83 f9 41	 cmp	 ecx, 65			; 00000041H
  00003	7c 09		 jl	 SHORT $L20904
  00005	83 f9 46	 cmp	 ecx, 70			; 00000046H
  00008	7f 04		 jg	 SHORT $L20904

; 37   :     l_Value = (p_Character - 'A') + 10;

  0000a	8d 41 c9	 lea	 eax, DWORD PTR [rcx-55]

; 44   : }

  0000d	c3		 ret	 0
$L20904:

; 38   :   else if (p_Character >= 'a' && p_Character <= 'f')

  0000e	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00011	7c 09		 jl	 SHORT $L20906
  00013	83 f9 66	 cmp	 ecx, 102		; 00000066H
  00016	7f 04		 jg	 SHORT $L20906

; 39   :     l_Value = (p_Character - 'a') + 10;

  00018	8d 41 a9	 lea	 eax, DWORD PTR [rcx-87]

; 44   : }

  0001b	c3		 ret	 0
$L20906:

; 40   :   else if (p_Character >= '0' && p_Character <= '9')

  0001c	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0001f	7c 09		 jl	 SHORT $L22825
  00021	83 f9 39	 cmp	 ecx, 57			; 00000039H
  00024	7f 04		 jg	 SHORT $L22825

; 41   :     l_Value = p_Character - '0';

  00026	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]

; 44   : }

  00029	c3		 ret	 0
$L22825:

; 42   : 
; 43   :   return l_Value;

  0002a	33 c0		 xor	 eax, eax

; 44   : }

  0002c	c3		 ret	 0
HexStringToDecimalInt ENDP
_TEXT	ENDS
PUBLIC	ParseMAC
;	COMDAT xdata
xdata	SEGMENT
$unwind$ParseMAC DD 080f01H
	DD	0f00b320fH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ParseMAC DD @imagerel(ParseMAC#)
	DD	@imagerel(ParseMAC#+226)
	DD	@imagerel($unwind$ParseMAC#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT ParseMAC
_TEXT	SEGMENT
dest$ = 96
src$ = 104
ParseMAC PROC NEAR					; COMDAT

; 48   : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	4c 8b e2	 mov	 r12, rdx
  00012	4c 8b e9	 mov	 r13, rcx

; 49   :   int c;
; 50   :   int mac_index = 0;

  00015	45 33 f6	 xor	 r14d, r14d
  00018	41 8b fe	 mov	 edi, r14d

; 51   :   BOOLEAN high_digit = FALSE;

  0001b	40 32 f6	 xor	 sil, sil

; 52   :   int delim_action = 1;

  0001e	41 bf 01 00 00
	00		 mov	 r15d, 1
  00024	41 8b df	 mov	 ebx, r15d

; 53   : 
; 54   :   MYASSERT (src);
; 55   :   MYASSERT (dest);
; 56   : 
; 57   :   CLEAR_MAC (dest);

  00027	ba 06 00 00 00	 mov	 edx, 6
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 58   : 
; 59   :   while (c = *src++)

  00032	41 0f be 04 24	 movsx	 eax, BYTE PTR [r12]
  00037	85 c0		 test	 eax, eax
  00039	74 78		 je	 SHORT $L22834
$L20921:
  0003b	49 83 c4 01	 add	 r12, 1

; 60   :     {
; 61   :       if (IsMacDelimiter (c))

  0003f	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  00042	74 5e		 je	 SHORT $L20924
  00044	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00047	74 59		 je	 SHORT $L20924
  00049	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0004c	74 54		 je	 SHORT $L20924

; 66   : 	}
; 67   :       else if (IsHexDigit (c))

  0004e	83 f8 30	 cmp	 eax, 48			; 00000030H
  00051	7c 05		 jl	 SHORT $L20928
  00053	83 f8 39	 cmp	 eax, 57			; 00000039H
  00056	7e 14		 jle	 SHORT $L20927
$L20928:
  00058	83 f8 41	 cmp	 eax, 65			; 00000041H
  0005b	7c 05		 jl	 SHORT $L20929
  0005d	83 f8 46	 cmp	 eax, 70			; 00000046H
  00060	7e 0a		 jle	 SHORT $L20927
$L20929:
  00062	83 f8 61	 cmp	 eax, 97			; 00000061H
  00065	7c 69		 jl	 SHORT $L20926
  00067	83 f8 66	 cmp	 eax, 102		; 00000066H
  0006a	7f 64		 jg	 SHORT $L20926
$L20927:

; 68   : 	{
; 69   : 	  const int digit = HexStringToDecimalInt (c);

  0006c	8b c8		 mov	 ecx, eax
  0006e	e8 00 00 00 00	 call	 HexStringToDecimalInt
  00073	8b d0		 mov	 edx, eax

; 70   : 	  if (mac_index < sizeof (MACADDR))

  00075	83 ff 06	 cmp	 edi, 6
  00078	73 56		 jae	 SHORT $L20926

; 73   : 		{
; 74   : 		  dest[mac_index] = (char)(digit);

  0007a	48 63 cf	 movsxd	 rcx, edi

; 71   : 	    {
; 72   : 	      if (!high_digit)

  0007d	40 84 f6	 test	 sil, sil
  00080	75 09		 jne	 SHORT $L20933

; 73   : 		{
; 74   : 		  dest[mac_index] = (char)(digit);

  00082	42 88 14 29	 mov	 BYTE PTR [rcx+r13], dl

; 75   : 		  high_digit = TRUE;

  00086	40 b6 01	 mov	 sil, 1

; 76   : 		  delim_action = 1;
; 77   : 		}
; 78   : 	      else

  00089	eb 1c		 jmp	 SHORT $L22842
$L20933:

; 79   : 		{
; 80   : 		  dest[mac_index] = (char)(dest[mac_index] * 16 + digit);

  0008b	49 03 cd	 add	 rcx, r13
  0008e	8a 01		 mov	 al, BYTE PTR [rcx]
  00090	c0 e0 04	 shl	 al, 4
  00093	02 c2		 add	 al, dl
  00095	88 01		 mov	 BYTE PTR [rcx], al

; 81   : 		  ++mac_index;

  00097	83 c7 01	 add	 edi, 1

; 82   : 		  high_digit = FALSE;

  0009a	40 32 f6	 xor	 sil, sil

; 83   : 		  delim_action = 0;

  0009d	41 8b de	 mov	 ebx, r14d

; 84   : 		}
; 85   : 	    }
; 86   : 	  else
; 87   : 	    return FALSE;
; 88   : 	}
; 89   :       else

  000a0	eb 08		 jmp	 SHORT $L20938
$L20924:

; 62   : 	{
; 63   : 	  mac_index += delim_action;

  000a2	03 fb		 add	 edi, ebx

; 64   : 	  high_digit = FALSE;

  000a4	40 32 f6	 xor	 sil, sil
$L22842:

; 65   : 	  delim_action = 1;

  000a7	41 8b df	 mov	 ebx, r15d
$L20938:

; 58   : 
; 59   :   while (c = *src++)

  000aa	41 0f be 04 24	 movsx	 eax, BYTE PTR [r12]
  000af	85 c0		 test	 eax, eax
  000b1	75 88		 jne	 SHORT $L20921
$L22834:

; 91   :     }
; 92   : 
; 93   :   return (mac_index + delim_action) >= sizeof (MACADDR);

  000b3	8d 0c 3b	 lea	 ecx, DWORD PTR [rbx+rdi]
  000b6	83 f9 06	 cmp	 ecx, 6
  000b9	41 0f 93 c6	 setae	 r14b
  000bd	41 8a c6	 mov	 al, r14b

; 94   : }

  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	41 5f		 pop	 r15
  000c6	41 5e		 pop	 r14
  000c8	41 5d		 pop	 r13
  000ca	41 5c		 pop	 r12
  000cc	5f		 pop	 rdi
  000cd	5e		 pop	 rsi
  000ce	5b		 pop	 rbx
  000cf	c3		 ret	 0
$L20926:

; 90   : 	return FALSE;

  000d0	32 c0		 xor	 al, al

; 94   : }

  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	41 5f		 pop	 r15
  000d8	41 5e		 pop	 r14
  000da	41 5d		 pop	 r13
  000dc	41 5c		 pop	 r12
  000de	5f		 pop	 rdi
  000df	5e		 pop	 rsi
  000e0	5b		 pop	 rbx
  000e1	c3		 ret	 0
ParseMAC ENDP
_TEXT	ENDS
PUBLIC	GenerateRandomMac
;	COMDAT xdata
xdata	SEGMENT
$unwind$GenerateRandomMac DD 070d01H
	DD	0e009420dH
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GenerateRandomMac DD @imagerel(GenerateRandomMac#)
	DD	@imagerel(GenerateRandomMac#+167)
	DD	@imagerel($unwind$GenerateRandomMac#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT GenerateRandomMac
_TEXT	SEGMENT
mac$ = 96
adapter_name$ = 104
GenerateRandomMac PROC NEAR				; COMDAT

; 116  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	48 8b da	 mov	 rbx, rdx
  00010	4c 8b f1	 mov	 r14, rcx

; 117  :   unsigned const char *cp = adapter_name;
; 118  :   unsigned char c;
; 119  :   unsigned int i = 2;

  00013	41 bd 02 00 00
	00		 mov	 r13d, 2

; 120  :   unsigned int byte = 0;

  00019	33 ff		 xor	 edi, edi

; 121  :   int brace = 0;

  0001b	33 f6		 xor	 esi, esi

; 122  :   int state = 0;

  0001d	45 33 e4	 xor	 r12d, r12d

; 123  : 
; 124  :   CLEAR_MAC (mac);

  00020	ba 06 00 00 00	 mov	 edx, 6
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 125  : 
; 126  :   mac[0] = 0x00;

  0002b	45 88 26	 mov	 BYTE PTR [r14], r12b

; 127  :   mac[1] = 0xFF;

  0002e	41 c6 46 01 ff	 mov	 BYTE PTR [r14+1], 255	; 000000ffH

; 128  : 
; 129  :   while (c = *cp++)

  00033	8a 03		 mov	 al, BYTE PTR [rbx]
  00035	84 c0		 test	 al, al
  00037	74 60		 je	 SHORT $L22850
  00039	ba 01 00 00 00	 mov	 edx, 1
$L20954:
  0003e	48 83 c3 01	 add	 rbx, 1

; 130  :     {
; 131  :       if (i >= sizeof (MACADDR))

  00042	41 83 fd 06	 cmp	 r13d, 6
  00046	73 51		 jae	 SHORT $L22850

; 132  : 	break;
; 133  :       if (c == '{')

  00048	3c 7b		 cmp	 al, 123			; 0000007bH
  0004a	75 04		 jne	 SHORT $L20958

; 134  : 	brace = 1;

  0004c	8b f2		 mov	 esi, edx

; 135  :       if (IsHexDigit (c) && brace)

  0004e	eb 43		 jmp	 SHORT $L20966
$L20958:
  00050	3c 30		 cmp	 al, 48			; 00000030H
  00052	72 04		 jb	 SHORT $L20961
  00054	3c 39		 cmp	 al, 57			; 00000039H
  00056	76 10		 jbe	 SHORT $L20960
$L20961:
  00058	3c 41		 cmp	 al, 65			; 00000041H
  0005a	72 04		 jb	 SHORT $L20962
  0005c	3c 46		 cmp	 al, 70			; 00000046H
  0005e	76 08		 jbe	 SHORT $L20960
$L20962:
  00060	3c 61		 cmp	 al, 97			; 00000061H
  00062	72 2f		 jb	 SHORT $L20966
  00064	3c 66		 cmp	 al, 102			; 00000066H
  00066	77 2b		 ja	 SHORT $L20966
$L20960:
  00068	85 f6		 test	 esi, esi
  0006a	74 27		 je	 SHORT $L20966

; 136  : 	{
; 137  : 	  const unsigned int digit = HexStringToDecimalInt (c);

  0006c	0f b6 c8	 movzx	 ecx, al
  0006f	e8 00 00 00 00	 call	 HexStringToDecimalInt

; 138  : 	  if (state)

  00074	45 85 e4	 test	 r12d, r12d
  00077	74 15		 je	 SHORT $L20964

; 139  : 	    {
; 140  : 	      byte <<= 4;

  00079	c1 e7 04	 shl	 edi, 4

; 141  : 	      byte |= digit;

  0007c	0b f8		 or	 edi, eax

; 142  : 	      mac[i++] = (unsigned char) byte;

  0007e	41 8b c5	 mov	 eax, r13d
  00081	42 88 3c 30	 mov	 BYTE PTR [rax+r14], dil
  00085	41 83 c5 01	 add	 r13d, 1

; 143  : 	      state = 0;

  00089	45 33 e4	 xor	 r12d, r12d

; 144  : 	    }
; 145  : 	  else

  0008c	eb 05		 jmp	 SHORT $L20966
$L20964:

; 146  : 	    {
; 147  : 	      byte = digit;

  0008e	8b f8		 mov	 edi, eax

; 148  : 	      state = 1;

  00090	44 8b e2	 mov	 r12d, edx
$L20966:

; 128  : 
; 129  :   while (c = *cp++)

  00093	8a 03		 mov	 al, BYTE PTR [rbx]
  00095	84 c0		 test	 al, al
  00097	75 a5		 jne	 SHORT $L20954
$L22850:

; 149  : 	    }
; 150  : 	}
; 151  :     }
; 152  : }

  00099	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0009d	41 5e		 pop	 r14
  0009f	41 5d		 pop	 r13
  000a1	41 5c		 pop	 r12
  000a3	5f		 pop	 rdi
  000a4	5e		 pop	 rsi
  000a5	5b		 pop	 rbx
  000a6	c3		 ret	 0
GenerateRandomMac ENDP
_TEXT	ENDS
PUBLIC	GenerateRelatedMAC
EXTRN	__imp_RtlCopyMemory:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$GenerateRelatedMAC DD 030601H
	DD	070024206H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$GenerateRelatedMAC DD @imagerel(GenerateRelatedMAC#)
	DD	@imagerel(GenerateRelatedMAC#+35)
	DD	@imagerel($unwind$GenerateRelatedMAC#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT GenerateRelatedMAC
_TEXT	SEGMENT
dest$ = 64
src$ = 72
delta$ = 80
GenerateRelatedMAC PROC NEAR				; COMDAT

; 155  : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00006	41 8b f8	 mov	 edi, r8d
  00009	48 8b d9	 mov	 rbx, rcx

; 156  :   COPY_MAC (dest, src);

  0000c	41 b8 06 00 00
	00		 mov	 r8d, 6
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 157  :   dest[2] += (UCHAR) delta;

  00018	40 00 7b 02	 add	 BYTE PTR [rbx+2], dil

; 158  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	5f		 pop	 rdi
  00021	5b		 pop	 rbx
  00022	c3		 ret	 0
GenerateRelatedMAC ENDP
_TEXT	ENDS
PUBLIC	SetDHCPOpt
;	COMDAT xdata
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\dhcp.c
xdata	SEGMENT
$unwind$SetDHCPOpt DD 030601H
	DD	070024206H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetDHCPOpt DD @imagerel(SetDHCPOpt#)
	DD	@imagerel(SetDHCPOpt#+73)
	DD	@imagerel($unwind$SetDHCPOpt#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetDHCPOpt
_TEXT	SEGMENT
m$ = 64
data$ = 72
len$ = 80
SetDHCPOpt PROC NEAR					; COMDAT

; 35   : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00006	41 8b f8	 mov	 edi, r8d
  00009	48 8b d9	 mov	 rbx, rcx

; 36   :   if (!m->overflow)

  0000c	80 7b 04 00	 cmp	 BYTE PTR [rbx+4], 0
  00010	75 30		 jne	 SHORT $L20992

; 37   :     {
; 38   :       if (m->optlen + len <= DHCP_OPTIONS_BUFFER_SIZE)

  00012	8b 0b		 mov	 ecx, DWORD PTR [rbx]
  00014	8d 04 39	 lea	 eax, DWORD PTR [rcx+rdi]
  00017	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0001c	77 20		 ja	 SHORT $L20990

; 39   : 	{
; 40   : 	  if (len)

  0001e	85 ff		 test	 edi, edi
  00020	74 20		 je	 SHORT $L20992

; 41   : 	    {
; 42   : 	      NdisMoveMemory (m->msg.options + m->optlen, data, len);

  00022	44 8b c7	 mov	 r8d, edi
  00025	8b c1		 mov	 eax, ecx
  00027	48 8d 8c 18 1f
	01 00 00	 lea	 rcx, QWORD PTR [rax+rbx+287]
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 43   : 	      m->optlen += len;

  00035	01 3b		 add	 DWORD PTR [rbx], edi

; 49   : 	}
; 50   :     }
; 51   : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	5f		 pop	 rdi
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
$L20990:

; 44   : 	    }
; 45   : 	}
; 46   :       else
; 47   : 	{
; 48   : 	  m->overflow = TRUE;

  0003e	c6 43 04 01	 mov	 BYTE PTR [rbx+4], 1
$L20992:

; 49   : 	}
; 50   :     }
; 51   : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	5f		 pop	 rdi
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
SetDHCPOpt ENDP
_TEXT	ENDS
PUBLIC	SetDHCPOpt0
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetDHCPOpt0 DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetDHCPOpt0 DD @imagerel(SetDHCPOpt0#)
	DD	@imagerel(SetDHCPOpt0#+29)
	DD	@imagerel($unwind$SetDHCPOpt0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetDHCPOpt0
_TEXT	SEGMENT
opt$ = 32
msg$ = 64
type$ = 72
SetDHCPOpt0 PROC NEAR					; COMDAT

; 55   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 56   :   DHCPOPT0 opt;
; 57   :   opt.type = (UCHAR) type;

  00004	88 54 24 20	 mov	 BYTE PTR opt$[rsp], dl

; 58   :   SetDHCPOpt (msg, &opt, sizeof (opt));

  00008	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000e	48 8d 54 24 20	 lea	 rdx, QWORD PTR opt$[rsp]
  00013	e8 00 00 00 00	 call	 SetDHCPOpt

; 59   : }

  00018	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0001c	c3		 ret	 0
SetDHCPOpt0 ENDP
_TEXT	ENDS
PUBLIC	SetDHCPOpt8
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetDHCPOpt8 DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetDHCPOpt8 DD @imagerel(SetDHCPOpt8#)
	DD	@imagerel(SetDHCPOpt8#+39)
	DD	@imagerel($unwind$SetDHCPOpt8#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetDHCPOpt8
_TEXT	SEGMENT
opt$ = 32
msg$ = 64
type$ = 72
data$ = 80
SetDHCPOpt8 PROC NEAR					; COMDAT

; 63   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 64   :   DHCPOPT8 opt;
; 65   :   opt.type = (UCHAR) type;

  00004	88 54 24 20	 mov	 BYTE PTR opt$[rsp], dl

; 66   :   opt.len = sizeof (opt.data);

  00008	c6 44 24 21 01	 mov	 BYTE PTR opt$[rsp+1], 1

; 67   :   opt.data = (UCHAR) data;

  0000d	44 88 44 24 22	 mov	 BYTE PTR opt$[rsp+2], r8b

; 68   :   SetDHCPOpt (msg, &opt, sizeof (opt));

  00012	41 b8 03 00 00
	00		 mov	 r8d, 3
  00018	48 8d 54 24 20	 lea	 rdx, QWORD PTR opt$[rsp]
  0001d	e8 00 00 00 00	 call	 SetDHCPOpt

; 69   : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
SetDHCPOpt8 ENDP
_TEXT	ENDS
PUBLIC	SetDHCPOpt32
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetDHCPOpt32 DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetDHCPOpt32 DD @imagerel(SetDHCPOpt32#)
	DD	@imagerel(SetDHCPOpt32#+39)
	DD	@imagerel($unwind$SetDHCPOpt32#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetDHCPOpt32
_TEXT	SEGMENT
opt$ = 32
msg$ = 64
type$ = 72
data$ = 80
SetDHCPOpt32 PROC NEAR					; COMDAT

; 73   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 74   :   DHCPOPT32 opt;
; 75   :   opt.type = (UCHAR) type;

  00004	88 54 24 20	 mov	 BYTE PTR opt$[rsp], dl

; 76   :   opt.len = sizeof (opt.data);

  00008	c6 44 24 21 04	 mov	 BYTE PTR opt$[rsp+1], 4

; 77   :   opt.data = data;

  0000d	44 89 44 24 22	 mov	 DWORD PTR opt$[rsp+2], r8d

; 78   :   SetDHCPOpt (msg, &opt, sizeof (opt));

  00012	41 b8 06 00 00
	00		 mov	 r8d, 6
  00018	48 8d 54 24 20	 lea	 rdx, QWORD PTR opt$[rsp]
  0001d	e8 00 00 00 00	 call	 SetDHCPOpt

; 79   : }

  00022	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00026	c3		 ret	 0
SetDHCPOpt32 ENDP
_TEXT	ENDS
PUBLIC	ip_checksum
; Function compile flags: /Ogty
;	COMDAT ip_checksum
_TEXT	SEGMENT
buf$ = 8
len_ip_header$ = 16
ip_checksum PROC NEAR					; COMDAT

; 87   : {

  00000	4c 8b c9	 mov	 r9, rcx

; 88   :   USHORT word16;
; 89   :   ULONG sum = 0;

  00003	45 33 c0	 xor	 r8d, r8d

; 90   :   int i;
; 91   :     
; 92   :   // make 16 bit words out of every two adjacent 8 bit words in the packet
; 93   :   // and add them up
; 94   :   for (i = 0; i < len_ip_header - 1; i += 2) {

  00006	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  00009	85 c0		 test	 eax, eax
  0000b	7e 29		 jle	 SHORT $L22915

; 88   :   USHORT word16;
; 89   :   ULONG sum = 0;

  0000d	83 c0 ff	 add	 eax, -1
  00010	d1 e8		 shr	 eax, 1
  00012	83 c0 01	 add	 eax, 1
  00015	8b d0		 mov	 edx, eax
$L21031:

; 96   :     sum += (ULONG) word16;

  00017	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 95   :     word16 = ((buf[i] << 8) & 0xFF00) + (buf[i+1] & 0xFF);

  0001b	66 c1 e0 08	 shl	 ax, 8

; 96   :     sum += (ULONG) word16;

  0001f	0f b7 c8	 movzx	 ecx, ax
  00022	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 95   :     word16 = ((buf[i] << 8) & 0xFF00) + (buf[i+1] & 0xFF);

  00027	33 c8		 xor	 ecx, eax

; 96   :     sum += (ULONG) word16;

  00029	44 03 c1	 add	 r8d, ecx

; 90   :   int i;
; 91   :     
; 92   :   // make 16 bit words out of every two adjacent 8 bit words in the packet
; 93   :   // and add them up
; 94   :   for (i = 0; i < len_ip_header - 1; i += 2) {

  0002c	49 83 c1 02	 add	 r9, 2
  00030	48 83 ea 01	 sub	 rdx, 1
  00034	75 e1		 jne	 SHORT $L21031
$L22915:

; 97   :   }
; 98   : 
; 99   :   // take only 16 bits out of the 32 bit sum and add up the carries
; 100  :   while (sum >> 16)

  00036	41 8b c0	 mov	 eax, r8d
  00039	c1 e8 10	 shr	 eax, 16			; 00000010H
  0003c	74 13		 je	 SHORT $L21037
  0003e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
$L21036:

; 101  :     sum = (sum & 0xFFFF) + (sum >> 16);

  00043	44 23 c1	 and	 r8d, ecx
  00046	44 03 c0	 add	 r8d, eax

; 97   :   }
; 98   : 
; 99   :   // take only 16 bits out of the 32 bit sum and add up the carries
; 100  :   while (sum >> 16)

  00049	41 8b c0	 mov	 eax, r8d
  0004c	c1 e8 10	 shr	 eax, 16			; 00000010H
  0004f	75 f2		 jne	 SHORT $L21036
$L21037:

; 102  : 
; 103  :   // one's complement the result
; 104  :   return ((USHORT) ~sum);

  00051	41 f7 d0	 not	 r8d
  00054	66 41 8b c0	 mov	 ax, r8w

; 105  : }

  00058	c3		 ret	 0
ip_checksum ENDP
_TEXT	ENDS
PUBLIC	udp_checksum
;	COMDAT xdata
xdata	SEGMENT
$unwind$udp_checksum DD 020201H
	DD	030017002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$udp_checksum DD @imagerel(udp_checksum#)
	DD	@imagerel(udp_checksum#+169)
	DD	@imagerel($unwind$udp_checksum#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT udp_checksum
_TEXT	SEGMENT
buf$ = 24
len_udp$ = 32
src_addr$ = 40
dest_addr$ = 48
udp_checksum PROC NEAR					; COMDAT

; 112  : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	4d 8b d8	 mov	 r11, r8
  00005	8b fa		 mov	 edi, edx
  00007	4c 8b c1	 mov	 r8, rcx

; 113  :   USHORT word16;
; 114  :   ULONG sum = 0;

  0000a	45 33 d2	 xor	 r10d, r10d

; 115  :   int i;
; 116  : 	
; 117  :   // make 16 bit words out of every two adjacent 8 bit words and 
; 118  :   // calculate the sum of all 16 bit words
; 119  :   for (i = 0; i < len_udp; i += 2){

  0000d	33 db		 xor	 ebx, ebx
  0000f	85 ff		 test	 edi, edi
  00011	7e 2c		 jle	 SHORT $L21054
$L21052:

; 120  :     word16 = ((buf[i] << 8) & 0xFF00) + ((i + 1 < len_udp) ? (buf[i+1] & 0xFF) : 0);

  00013	8d 43 01	 lea	 eax, DWORD PTR [rbx+1]
  00016	3b c7		 cmp	 eax, edi
  00018	7d 07		 jge	 SHORT $L22923
  0001a	41 0f b6 48 01	 movzx	 ecx, BYTE PTR [r8+1]
  0001f	eb 02		 jmp	 SHORT $L22924
$L22923:
  00021	33 c9		 xor	 ecx, ecx
$L22924:

; 121  :     sum += word16;

  00023	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]

; 120  :     word16 = ((buf[i] << 8) & 0xFF00) + ((i + 1 < len_udp) ? (buf[i+1] & 0xFF) : 0);

  00027	66 c1 e0 08	 shl	 ax, 8
  0002b	66 03 c1	 add	 ax, cx

; 121  :     sum += word16;

  0002e	0f b7 c0	 movzx	 eax, ax
  00031	44 03 d0	 add	 r10d, eax

; 115  :   int i;
; 116  : 	
; 117  :   // make 16 bit words out of every two adjacent 8 bit words and 
; 118  :   // calculate the sum of all 16 bit words
; 119  :   for (i = 0; i < len_udp; i += 2){

  00034	83 c3 02	 add	 ebx, 2
  00037	49 83 c0 02	 add	 r8, 2
  0003b	3b df		 cmp	 ebx, edi
  0003d	7c d4		 jl	 SHORT $L21052
$L21054:

; 122  :   }
; 123  : 
; 124  :   // add the UDP pseudo header which contains the IP source and destination addresses
; 125  :   for (i = 0; i < 4; i += 2){

  0003f	ba 02 00 00 00	 mov	 edx, 2
  00044	4c 8b c2	 mov	 r8, rdx
$L21055:

; 127  :     sum += word16;

  00047	41 0f b6 03	 movzx	 eax, BYTE PTR [r11]

; 126  :     word16 =((src_addr[i] << 8) & 0xFF00) + (src_addr[i+1] & 0xFF);

  0004b	66 c1 e0 08	 shl	 ax, 8

; 127  :     sum += word16;

  0004f	0f b7 c8	 movzx	 ecx, ax
  00052	41 0f b6 43 01	 movzx	 eax, BYTE PTR [r11+1]

; 126  :     word16 =((src_addr[i] << 8) & 0xFF00) + (src_addr[i+1] & 0xFF);

  00057	33 c8		 xor	 ecx, eax

; 127  :     sum += word16;

  00059	44 03 d1	 add	 r10d, ecx

; 122  :   }
; 123  : 
; 124  :   // add the UDP pseudo header which contains the IP source and destination addresses
; 125  :   for (i = 0; i < 4; i += 2){

  0005c	49 83 c3 02	 add	 r11, 2
  00060	49 83 e8 01	 sub	 r8, 1
  00064	75 e1		 jne	 SHORT $L21055
$L21058:

; 131  :     sum += word16; 	

  00066	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]

; 130  :     word16 =((dest_addr[i] << 8) & 0xFF00) + (dest_addr[i+1] & 0xFF);

  0006a	66 c1 e0 08	 shl	 ax, 8

; 131  :     sum += word16; 	

  0006e	0f b7 c8	 movzx	 ecx, ax
  00071	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 130  :     word16 =((dest_addr[i] << 8) & 0xFF00) + (dest_addr[i+1] & 0xFF);

  00076	33 c8		 xor	 ecx, eax

; 131  :     sum += word16; 	

  00078	44 03 d1	 add	 r10d, ecx

; 128  :   }
; 129  :   for (i = 0; i < 4; i += 2){

  0007b	49 83 c1 02	 add	 r9, 2
  0007f	48 83 ea 01	 sub	 rdx, 1
  00083	75 e1		 jne	 SHORT $L21058

; 132  :   }
; 133  : 
; 134  :   // the protocol number and the length of the UDP packet
; 135  :   sum += (USHORT) IPPROTO_UDP + (USHORT) len_udp;

  00085	0f b7 c7	 movzx	 eax, di
  00088	41 8d 44 02 11	 lea	 eax, DWORD PTR [r10+rax+17]

; 136  : 
; 137  :   // keep only the last 16 bits of the 32 bit calculated sum and add the carries
; 138  :   while (sum >> 16)

  0008d	8b c8		 mov	 ecx, eax
  0008f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00092	74 10		 je	 SHORT $L21065
  00094	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
$L21064:

; 139  :     sum = (sum & 0xFFFF) + (sum >> 16);

  00099	23 c2		 and	 eax, edx
  0009b	03 c1		 add	 eax, ecx

; 136  : 
; 137  :   // keep only the last 16 bits of the 32 bit calculated sum and add the carries
; 138  :   while (sum >> 16)

  0009d	8b c8		 mov	 ecx, eax
  0009f	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000a2	75 f5		 jne	 SHORT $L21064
$L21065:

; 140  : 		
; 141  :   // Take the one's complement of sum
; 142  :   return ((USHORT) ~sum);

  000a4	f7 d0		 not	 eax

; 143  : }

  000a6	5f		 pop	 rdi
  000a7	5b		 pop	 rbx
  000a8	c3		 ret	 0
udp_checksum ENDP
_TEXT	ENDS
PUBLIC	SetChecksumDHCPMsg
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetChecksumDHCPMsg DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetChecksumDHCPMsg DD @imagerel(SetChecksumDHCPMsg#)
	DD	@imagerel(SetChecksumDHCPMsg#+69)
	DD	@imagerel($unwind$SetChecksumDHCPMsg#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetChecksumDHCPMsg
_TEXT	SEGMENT
m$ = 48
SetChecksumDHCPMsg PROC NEAR				; COMDAT

; 151  : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b d9	 mov	 rbx, rcx

; 152  :   // Set IP checksum
; 153  :   m->msg.pre.ip.check = htons (ip_checksum ((UCHAR *) &m->msg.pre.ip, sizeof (IPHDR)));

  00008	48 8d 4b 13	 lea	 rcx, QWORD PTR [rbx+19]
  0000c	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00011	e8 00 00 00 00	 call	 ip_checksum
  00016	66 c1 c8 08	 ror	 ax, 8
  0001a	66 89 43 1d	 mov	 WORD PTR [rbx+29], ax

; 154  : 
; 155  :   // Set UDP Checksum
; 156  :   m->msg.pre.udp.check = htons (udp_checksum ((UCHAR *) &m->msg.pre.udp, 
; 157  : 					      sizeof (UDPHDR) + sizeof (DHCP) + m->optlen,
; 158  : 					      (UCHAR *)&m->msg.pre.ip.saddr,
; 159  : 					      (UCHAR *)&m->msg.pre.ip.daddr));

  0001e	4c 8d 4b 23	 lea	 r9, QWORD PTR [rbx+35]
  00022	4c 8d 43 1f	 lea	 r8, QWORD PTR [rbx+31]
  00026	8b 13		 mov	 edx, DWORD PTR [rbx]
  00028	81 c2 f8 00 00
	00		 add	 edx, 248		; 000000f8H
  0002e	48 8d 4b 27	 lea	 rcx, QWORD PTR [rbx+39]
  00032	e8 00 00 00 00	 call	 udp_checksum
  00037	66 c1 c8 08	 ror	 ax, 8
  0003b	66 89 43 2d	 mov	 WORD PTR [rbx+45], ax

; 160  : }

  0003f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00043	5b		 pop	 rbx
  00044	c3		 ret	 0
SetChecksumDHCPMsg ENDP
_TEXT	ENDS
PUBLIC	GetDHCPMessageType
; Function compile flags: /Ogty
;	COMDAT GetDHCPMessageType
_TEXT	SEGMENT
dhcp$ = 8
optlen$ = 16
GetDHCPMessageType PROC NEAR				; COMDAT

; 169  :   const UCHAR *p = (UCHAR *) (dhcp + 1);
; 170  :   int i;
; 171  : 
; 172  :   for (i = 0; i < optlen; ++i)

  00000	45 33 c0	 xor	 r8d, r8d
  00003	85 d2		 test	 edx, edx
  00005	7e 46		 jle	 SHORT $L21091
$L21089:

; 173  :     {
; 174  :       const UCHAR type = p[i];

  00007	49 63 c0	 movsxd	 rax, r8d
  0000a	44 8a 8c 08 f0
	00 00 00	 mov	 r9b, BYTE PTR [rax+rcx+240]

; 175  :       const int room = optlen - i - 1;

  00012	8b c2		 mov	 eax, edx
  00014	41 2b c0	 sub	 eax, r8d
  00017	83 e8 01	 sub	 eax, 1

; 176  :       if (type == DHCP_END)           // didn't find what we were looking for

  0001a	41 80 f9 ff	 cmp	 r9b, 255		; 000000ffH
  0001e	74 2d		 je	 SHORT $L21091

; 177  : 	return -1;
; 178  :       else if (type == DHCP_PAD)      // no-operation

  00020	45 84 c9	 test	 r9b, r9b
  00023	74 1f		 je	 SHORT $L21090

; 179  : 	;
; 180  :       else if (type == DHCP_MSG_TYPE) // what we are looking for

  00025	41 80 f9 35	 cmp	 r9b, 53			; 00000035H
  00029	74 28		 je	 SHORT $L22957

; 186  : 	    }
; 187  : 	  return -1;
; 188  : 	}
; 189  :       else                            // some other message
; 190  : 	{
; 191  : 	  if (room >= 1)

  0002b	83 f8 01	 cmp	 eax, 1
  0002e	7c 14		 jl	 SHORT $L21090

; 192  : 	    {
; 193  : 	      const int len = p[i+1]; // get message length

  00030	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]

; 194  : 	      i += (len + 1);         // advance to next message

  00034	48 63 c0	 movsxd	 rax, eax
  00037	0f b6 84 08 f0
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+240]
  0003f	45 8d 44 00 01	 lea	 r8d, DWORD PTR [r8+rax+1]
$L21090:

; 169  :   const UCHAR *p = (UCHAR *) (dhcp + 1);
; 170  :   int i;
; 171  : 
; 172  :   for (i = 0; i < optlen; ++i)

  00044	41 83 c0 01	 add	 r8d, 1
  00048	44 3b c2	 cmp	 r8d, edx
  0004b	7c ba		 jl	 SHORT $L21089
$L21091:

; 195  : 	    }
; 196  : 	}
; 197  :     }
; 198  :   return -1;

  0004d	b8 ff ff ff ff	 mov	 eax, -1

; 199  : }

  00052	c3		 ret	 0
$L22957:

; 181  : 	{
; 182  : 	  if (room >= 2)

  00053	83 f8 02	 cmp	 eax, 2
  00056	7c f5		 jl	 SHORT $L21091

; 183  : 	    {
; 184  : 	      if (p[i+1] == 1)        // message length should be 1

  00058	41 8d 40 01	 lea	 eax, DWORD PTR [r8+1]
  0005c	48 63 c0	 movsxd	 rax, eax
  0005f	80 bc 08 f0 00
	00 00 01	 cmp	 BYTE PTR [rax+rcx+240], 1
  00067	75 e4		 jne	 SHORT $L21091

; 185  : 		return p[i+2];        // return message type

  00069	41 8d 40 02	 lea	 eax, DWORD PTR [r8+2]
  0006d	48 63 c0	 movsxd	 rax, eax
  00070	0f b6 84 08 f0
	00 00 00	 movzx	 eax, BYTE PTR [rax+rcx+240]

; 199  : }

  00078	c3		 ret	 0
GetDHCPMessageType ENDP
_TEXT	ENDS
PUBLIC	DHCPMessageOurs
;	COMDAT xdata
xdata	SEGMENT
$unwind$DHCPMessageOurs DD 020201H
	DD	060017002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DHCPMessageOurs DD @imagerel(DHCPMessageOurs#)
	DD	@imagerel(DHCPMessageOurs#+196)
	DD	@imagerel($unwind$DHCPMessageOurs#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT DHCPMessageOurs
_TEXT	SEGMENT
p_Adapter$ = 24
eth$ = 32
ip$ = 40
udp$ = 48
dhcp$ = 56
DHCPMessageOurs PROC NEAR				; COMDAT

; 207  : {

  00000	56		 push	 rsi
  00001	57		 push	 rdi
  00002	4c 8b d1	 mov	 r10, rcx

; 208  :   // Must be UDPv4 protocol
; 209  :   if (!(eth->proto == htons (ETH_P_IP) && ip->protocol == IPPROTO_UDP))

  00005	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  00009	66 c1 c8 08	 ror	 ax, 8
  0000d	66 39 42 0c	 cmp	 WORD PTR [rdx+12], ax
  00011	0f 85 a8 00 00
	00		 jne	 $L21118
  00017	41 80 78 09 11	 cmp	 BYTE PTR [r8+9], 17	; 00000011H
  0001c	0f 85 9d 00 00
	00		 jne	 $L21118

; 211  : 
; 212  :   // Source MAC must be our adapter
; 213  :   if (!MAC_EQUAL (eth->src, p_Adapter->m_MAC))

  00022	4c 8d 42 06	 lea	 r8, QWORD PTR [rdx+6]
  00026	49 8d 7a 10	 lea	 rdi, QWORD PTR [r10+16]
  0002a	33 c0		 xor	 eax, eax
  0002c	49 8b f0	 mov	 rsi, r8
  0002f	41 bb 06 00 00
	00		 mov	 r11d, 6
  00035	49 8b cb	 mov	 rcx, r11
  00038	f3 a6		 repe cmpsb
  0003a	74 05		 je	 SHORT $L22970
  0003c	1b c0		 sbb	 eax, eax
  0003e	83 d8 ff	 sbb	 eax, -1
$L22970:
  00041	85 c0		 test	 eax, eax

; 214  :     return FALSE;

  00043	75 7a		 jne	 SHORT $L21118

; 215  : 
; 216  :   // Dest MAC must be either broadcast or our virtual DHCP server
; 217  :   if (!(MAC_EQUAL (eth->dest, p_Adapter->m_MAC_Broadcast)
; 218  : 	|| MAC_EQUAL (eth->dest, p_Adapter->m_dhcp_server_mac)))

  00045	49 8d 7a 70	 lea	 rdi, QWORD PTR [r10+112]
  00049	33 c0		 xor	 eax, eax
  0004b	48 8b f2	 mov	 rsi, rdx
  0004e	49 8b cb	 mov	 rcx, r11
  00051	f3 a6		 repe cmpsb
  00053	74 05		 je	 SHORT $L22969
  00055	1b c0		 sbb	 eax, eax
  00057	83 d8 ff	 sbb	 eax, -1
$L22969:
  0005a	85 c0		 test	 eax, eax
  0005c	74 1c		 je	 SHORT $L21123
  0005e	49 8d ba 85 00
	00 00		 lea	 rdi, QWORD PTR [r10+133]
  00065	33 c0		 xor	 eax, eax
  00067	48 8b f2	 mov	 rsi, rdx
  0006a	49 8b cb	 mov	 rcx, r11
  0006d	f3 a6		 repe cmpsb
  0006f	74 05		 je	 SHORT $L22968
  00071	1b c0		 sbb	 eax, eax
  00073	83 d8 ff	 sbb	 eax, -1
$L22968:
  00076	85 c0		 test	 eax, eax

; 219  :     return FALSE;

  00078	75 45		 jne	 SHORT $L21118
$L21123:

; 220  : 
; 221  :   // Port numbers must be correct
; 222  :   if (!(udp->dest == htons (BOOTPS_PORT)
; 223  : 	&& udp->source == htons (BOOTPC_PORT)))

  0007a	66 b8 43 00	 mov	 ax, 67			; 00000043H
  0007e	66 c1 c8 08	 ror	 ax, 8
  00082	66 41 39 41 02	 cmp	 WORD PTR [r9+2], ax
  00087	75 36		 jne	 SHORT $L21118
  00089	66 b8 44 00	 mov	 ax, 68			; 00000044H
  0008d	66 c1 c8 08	 ror	 ax, 8
  00091	66 41 39 01	 cmp	 WORD PTR [r9], ax
  00095	75 28		 jne	 SHORT $L21118

; 224  :     return FALSE;
; 225  : 
; 226  :   // Hardware address must be MAC addr sized
; 227  :   if (!(dhcp->hlen == sizeof (MACADDR)))

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR dhcp$[rsp]
  0009c	80 78 02 06	 cmp	 BYTE PTR [rax+2], 6

; 228  :     return FALSE;

  000a0	75 1d		 jne	 SHORT $L21118

; 229  : 
; 230  :   // Hardware address must match our adapter
; 231  :   if (!MAC_EQUAL (eth->src, dhcp->chaddr))

  000a2	48 8d 78 1c	 lea	 rdi, QWORD PTR [rax+28]
  000a6	33 c0		 xor	 eax, eax
  000a8	49 8b f0	 mov	 rsi, r8
  000ab	49 8b cb	 mov	 rcx, r11
  000ae	f3 a6		 repe cmpsb
  000b0	74 05		 je	 SHORT $L22967
  000b2	1b c0		 sbb	 eax, eax
  000b4	83 d8 ff	 sbb	 eax, -1
$L22967:
  000b7	85 c0		 test	 eax, eax
  000b9	0f 94 c0	 sete	 al

; 232  :     return FALSE;
; 233  : 
; 234  :   return TRUE;
; 235  : }

  000bc	5f		 pop	 rdi
  000bd	5e		 pop	 rsi
  000be	c3		 ret	 0
$L21118:

; 210  :     return FALSE;

  000bf	32 c0		 xor	 al, al

; 232  :     return FALSE;
; 233  : 
; 234  :   return TRUE;
; 235  : }

  000c1	5f		 pop	 rdi
  000c2	5e		 pop	 rsi
  000c3	c3		 ret	 0
DHCPMessageOurs ENDP
_TEXT	ENDS
PUBLIC	BuildDHCPPre
;	COMDAT xdata
xdata	SEGMENT
$unwind$BuildDHCPPre DD 080f01H
	DD	0f00b320fH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$BuildDHCPPre DD @imagerel(BuildDHCPPre#)
	DD	@imagerel(BuildDHCPPre#+394)
	DD	@imagerel($unwind$BuildDHCPPre#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT BuildDHCPPre
_TEXT	SEGMENT
a$ = 96
p$ = 104
eth$ = 112
ip$ = 120
udp$ = 128
dhcp$ = 136
optlen$ = 144
type$ = 152
BuildDHCPPre PROC NEAR					; COMDAT

; 252  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	4d 8b e8	 mov	 r13, r8
  00012	48 8b da	 mov	 rbx, rdx
  00015	4c 8b e1	 mov	 r12, rcx

; 253  :   // Should we broadcast or direct to a specific MAC / IP address?
; 254  :   const BOOLEAN broadcast = (type == DHCPNAK
; 255  : 			     || MAC_EQUAL (eth->dest, a->m_MAC_Broadcast));

  00018	41 bf 06 00 00
	00		 mov	 r15d, 6
  0001e	44 8b b4 24 98
	00 00 00	 mov	 r14d, DWORD PTR type$[rsp]
  00026	45 3b f7	 cmp	 r14d, r15d
  00029	74 1f		 je	 SHORT $L22982
  0002b	49 8d 7c 24 70	 lea	 rdi, QWORD PTR [r12+112]
  00030	33 c0		 xor	 eax, eax
  00032	49 8b f5	 mov	 rsi, r13
  00035	49 8b cf	 mov	 rcx, r15
  00038	f3 a6		 repe cmpsb
  0003a	74 05		 je	 SHORT $L22984
  0003c	1b c0		 sbb	 eax, eax
  0003e	83 d8 ff	 sbb	 eax, -1
$L22984:
  00041	85 c0		 test	 eax, eax
  00043	74 05		 je	 SHORT $L22982
  00045	40 32 ff	 xor	 dil, dil
  00048	eb 03		 jmp	 SHORT $L22983
$L22982:
  0004a	40 b7 01	 mov	 dil, 1
$L22983:

; 256  :   // Build ethernet header
; 257  : 
; 258  :   COPY_MAC (p->eth.src, a->m_dhcp_server_mac);

  0004d	49 8d 94 24 85
	00 00 00	 lea	 rdx, QWORD PTR [r12+133]
  00055	48 8d 4b 06	 lea	 rcx, QWORD PTR [rbx+6]
  00059	4d 8b c7	 mov	 r8, r15
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 261  :     COPY_MAC (p->eth.dest, a->m_MAC_Broadcast);

  00062	48 8b cb	 mov	 rcx, rbx
  00065	4d 8b c7	 mov	 r8, r15

; 259  : 
; 260  :   if (broadcast)

  00068	40 84 ff	 test	 dil, dil

; 261  :     COPY_MAC (p->eth.dest, a->m_MAC_Broadcast);

  0006b	49 8d 54 24 70	 lea	 rdx, QWORD PTR [r12+112]

; 259  : 
; 260  :   if (broadcast)

  00070	75 04		 jne	 SHORT $L22991

; 262  :   else
; 263  :     COPY_MAC (p->eth.dest, eth->src);

  00072	49 8d 55 06	 lea	 rdx, QWORD PTR [r13+6]
$L22991:
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 264  : 
; 265  :   p->eth.proto = htons (ETH_P_IP);

  0007c	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  00080	66 c1 c8 08	 ror	 ax, 8
  00084	66 89 43 0c	 mov	 WORD PTR [rbx+12], ax

; 266  : 
; 267  :   // Build IP header
; 268  : 
; 269  :   p->ip.version_len = (4 << 4) | (sizeof (IPHDR) >> 2);

  00088	c6 43 0e 45	 mov	 BYTE PTR [rbx+14], 69	; 00000045H

; 270  :   p->ip.tos = 0;

  0008c	c6 43 0f 00	 mov	 BYTE PTR [rbx+15], 0

; 271  :   p->ip.tot_len = htons (sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen);

  00090	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR optlen$[rsp]
  00097	0f b7 c1	 movzx	 eax, cx
  0009a	66 05 0c 01	 add	 ax, 268			; 0000010cH
  0009e	66 c1 c8 08	 ror	 ax, 8
  000a2	66 89 43 10	 mov	 WORD PTR [rbx+16], ax

; 272  :   p->ip.id = 0;

  000a6	66 c7 43 12 00
	00		 mov	 WORD PTR [rbx+18], 0

; 273  :   p->ip.frag_off = 0;

  000ac	66 c7 43 14 00
	00		 mov	 WORD PTR [rbx+20], 0

; 274  :   p->ip.ttl = 16;

  000b2	c6 43 16 10	 mov	 BYTE PTR [rbx+22], 16	; 00000010H

; 275  :   p->ip.protocol = IPPROTO_UDP;

  000b6	c6 43 17 11	 mov	 BYTE PTR [rbx+23], 17	; 00000011H

; 276  :   p->ip.check = 0;

  000ba	66 c7 43 18 00
	00		 mov	 WORD PTR [rbx+24], 0

; 277  :   p->ip.saddr = a->m_dhcp_server_ip;

  000c0	41 8b 84 24 80
	00 00 00	 mov	 eax, DWORD PTR [r12+128]
  000c8	89 43 1a	 mov	 DWORD PTR [rbx+26], eax

; 278  : 
; 279  :   if (broadcast)

  000cb	40 84 ff	 test	 dil, dil
  000ce	74 09		 je	 SHORT $L21163

; 280  :     p->ip.daddr = ~0;

  000d0	c7 43 1e ff ff
	ff ff		 mov	 DWORD PTR [rbx+30], -1

; 281  :   else

  000d7	eb 08		 jmp	 SHORT $L21164
$L21163:

; 282  :     p->ip.daddr = a->m_dhcp_addr;

  000d9	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  000de	89 43 1e	 mov	 DWORD PTR [rbx+30], eax
$L21164:

; 283  : 
; 284  :   // Build UDP header
; 285  : 
; 286  :   p->udp.source = htons (BOOTPS_PORT);

  000e1	66 b8 43 00	 mov	 ax, 67			; 00000043H
  000e5	66 c1 c8 08	 ror	 ax, 8
  000e9	66 89 43 22	 mov	 WORD PTR [rbx+34], ax

; 287  :   p->udp.dest = htons (BOOTPC_PORT);

  000ed	66 b8 44 00	 mov	 ax, 68			; 00000044H
  000f1	66 c1 c8 08	 ror	 ax, 8
  000f5	66 89 43 24	 mov	 WORD PTR [rbx+36], ax

; 288  :   p->udp.len = htons (sizeof (UDPHDR) + sizeof (DHCP) + optlen);

  000f9	66 81 c1 f8 00	 add	 cx, 248			; 000000f8H
  000fe	66 c1 c9 08	 ror	 cx, 8
  00102	66 89 4b 26	 mov	 WORD PTR [rbx+38], cx

; 289  :   p->udp.check = 0;

  00106	66 c7 43 28 00
	00		 mov	 WORD PTR [rbx+40], 0

; 290  : 
; 291  :   // Build DHCP response
; 292  : 
; 293  :   p->dhcp.op = BOOTREPLY;

  0010c	c6 43 2a 02	 mov	 BYTE PTR [rbx+42], 2

; 294  :   p->dhcp.htype = 1;

  00110	c6 43 2b 01	 mov	 BYTE PTR [rbx+43], 1

; 295  :   p->dhcp.hlen = sizeof (MACADDR);

  00114	c6 43 2c 06	 mov	 BYTE PTR [rbx+44], 6

; 296  :   p->dhcp.hops = 0;

  00118	c6 43 2d 00	 mov	 BYTE PTR [rbx+45], 0

; 297  :   p->dhcp.xid = dhcp->xid;

  0011c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dhcp$[rsp]
  00124	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00127	89 43 2e	 mov	 DWORD PTR [rbx+46], eax

; 298  :   p->dhcp.secs = 0;

  0012a	66 c7 43 32 00
	00		 mov	 WORD PTR [rbx+50], 0

; 299  :   p->dhcp.flags = 0;

  00130	66 c7 43 34 00
	00		 mov	 WORD PTR [rbx+52], 0

; 300  :   p->dhcp.ciaddr = 0;

  00136	33 c9		 xor	 ecx, ecx
  00138	89 4b 36	 mov	 DWORD PTR [rbx+54], ecx

; 301  : 
; 302  :   if (type == DHCPNAK)

  0013b	41 83 fe 06	 cmp	 r14d, 6
  0013f	75 05		 jne	 SHORT $L21171

; 303  :     p->dhcp.yiaddr = 0;

  00141	89 4b 3a	 mov	 DWORD PTR [rbx+58], ecx

; 304  :   else

  00144	eb 08		 jmp	 SHORT $L21172
$L21171:

; 305  :     p->dhcp.yiaddr = a->m_dhcp_addr;

  00146	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  0014b	89 43 3a	 mov	 DWORD PTR [rbx+58], eax
$L21172:

; 306  : 
; 307  :   p->dhcp.siaddr = a->m_dhcp_server_ip;

  0014e	41 8b 84 24 80
	00 00 00	 mov	 eax, DWORD PTR [r12+128]
  00156	89 43 3e	 mov	 DWORD PTR [rbx+62], eax

; 308  :   p->dhcp.giaddr = 0;

  00159	89 4b 42	 mov	 DWORD PTR [rbx+66], ecx

; 309  :   COPY_MAC (p->dhcp.chaddr, eth->src);

  0015c	49 8d 55 06	 lea	 rdx, QWORD PTR [r13+6]
  00160	48 8d 4b 46	 lea	 rcx, QWORD PTR [rbx+70]
  00164	4d 8b c7	 mov	 r8, r15
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 310  :   p->dhcp.magic = htonl (0x63825363);

  0016d	b8 63 53 82 63	 mov	 eax, 1669485411		; 63825363H
  00172	0f c8		 bswap	 eax
  00174	89 83 16 01 00
	00		 mov	 DWORD PTR [rbx+278], eax

; 311  : }

  0017a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0017e	41 5f		 pop	 r15
  00180	41 5e		 pop	 r14
  00182	41 5d		 pop	 r13
  00184	41 5c		 pop	 r12
  00186	5f		 pop	 rdi
  00187	5e		 pop	 rsi
  00188	5b		 pop	 rbx
  00189	c3		 ret	 0
BuildDHCPPre ENDP
_TEXT	ENDS
PUBLIC	InstanceHashValue
; Function compile flags: /Ogty
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\instance.c
;	COMDAT InstanceHashValue
_TEXT	SEGMENT
addr$ = 8
InstanceHashValue PROC NEAR				; COMDAT

; 52   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 53   :   UCHAR *p = (UCHAR *) &addr;
; 54   : 
; 55   :   if (sizeof (addr) == 4)
; 56   :     return p[0] ^ p[1] ^ p[2] ^ p[3];
; 57   :   else if (sizeof (addr) == 8)
; 58   :     return p[0] ^ p[1] ^ p[2] ^ p[3] ^ p[4] ^ p[5] ^ p[6] ^ p[7];

  00005	0f b6 d1	 movzx	 edx, cl
  00008	0f b6 44 24 09	 movzx	 eax, BYTE PTR addr$[rsp+1]
  0000d	33 d0		 xor	 edx, eax
  0000f	0f b6 44 24 0a	 movzx	 eax, BYTE PTR addr$[rsp+2]
  00014	33 d0		 xor	 edx, eax
  00016	0f b6 4c 24 0b	 movzx	 ecx, BYTE PTR addr$[rsp+3]
  0001b	33 d1		 xor	 edx, ecx
  0001d	0f b6 4c 24 0c	 movzx	 ecx, BYTE PTR addr$[rsp+4]
  00022	33 d1		 xor	 edx, ecx
  00024	0f b6 4c 24 0d	 movzx	 ecx, BYTE PTR addr$[rsp+5]
  00029	33 d1		 xor	 edx, ecx
  0002b	0f b6 4c 24 0e	 movzx	 ecx, BYTE PTR addr$[rsp+6]
  00030	33 d1		 xor	 edx, ecx
  00032	0f b6 4c 24 0f	 movzx	 ecx, BYTE PTR addr$[rsp+7]
  00037	33 d1		 xor	 edx, ecx
  00039	8b c2		 mov	 eax, edx

; 59   :   else
; 60   :     {
; 61   :       MYASSERT (0);
; 62   :     }
; 63   : }

  0003b	c3		 ret	 0
InstanceHashValue ENDP
_TEXT	ENDS
PUBLIC	InitInstanceList
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitInstanceList DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitInstanceList DD @imagerel(InitInstanceList#)
	DD	@imagerel(InitInstanceList#+77)
	DD	@imagerel($unwind$InitInstanceList#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT InitInstanceList
_TEXT	SEGMENT
InitInstanceList PROC NEAR				; COMDAT

; 67   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 68   :   MYASSERT (g_InstanceHash == NULL);
; 69   :   g_InstanceHash = MemAlloc (sizeof (INSTANCE_HASH), TRUE);

  00004	b2 01		 mov	 dl, 1
  00006	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0000b	e8 00 00 00 00	 call	 MemAlloc
  00010	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_InstanceHash, rax

; 70   :   if (g_InstanceHash)

  00017	48 85 c0	 test	 rax, rax
  0001a	74 2a		 je	 SHORT $L21261

; 71   :     {
; 72   :       int i;
; 73   :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  0001c	45 33 c0	 xor	 r8d, r8d
  0001f	49 8b c8	 mov	 rcx, r8
  00022	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00027	eb 07		 jmp	 SHORT $L21263
$L23003:
  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_InstanceHash
$L21263:

; 74   : 	INIT_MUTEX (&g_InstanceHash->buckets[i].lock);

  00030	44 89 44 01 08	 mov	 DWORD PTR [rcx+rax+8], r8d

; 71   :     {
; 72   :       int i;
; 73   :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  00035	48 83 c1 10	 add	 rcx, 16			; 00000010H
  00039	48 83 ea 01	 sub	 rdx, 1
  0003d	75 ea		 jne	 SHORT $L23003

; 75   :       return TRUE;

  0003f	b0 01		 mov	 al, 1

; 79   : }

  00041	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00045	c3		 ret	 0
$L21261:

; 76   :     }
; 77   :   else
; 78   :     return FALSE;

  00046	32 c0		 xor	 al, al

; 79   : }

  00048	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004c	c3		 ret	 0
InitInstanceList ENDP
_TEXT	ENDS
PUBLIC	NInstances
EXTRN	__imp_NdisMSleep:NEAR
EXTRN	__imp_KeGetCurrentIrql:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$NInstances DD 070d01H
	DD	0e009420dH
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$NInstances DD @imagerel(NInstances#)
	DD	@imagerel(NInstances#+193)
	DD	@imagerel($unwind$NInstances#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT NInstances
_TEXT	SEGMENT
NInstances PROC NEAR					; COMDAT

; 83   : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 84   :   int i, n = 0;

  0000d	33 ff		 xor	 edi, edi

; 85   : 
; 86   :   if (g_InstanceHash)

  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_InstanceHash
  00016	48 85 c0	 test	 rax, rax
  00019	0f 84 92 00 00
	00		 je	 $L21275

; 87   :     {
; 88   :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  0001f	8b f7		 mov	 esi, edi
  00021	41 bc 01 00 00
	00		 mov	 r12d, 1
  00027	41 bd 10 27 00
	00		 mov	 r13d, 10000		; 00002710H
  0002d	41 be 00 01 00
	00		 mov	 r14d, 256		; 00000100H
$L21273:

; 89   : 	{
; 90   : 	  BOOLEAN got_lock;
; 91   : 	  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[i];

  00033	48 63 de	 movsxd	 rbx, esi
  00036	48 c1 e3 04	 shl	 rbx, 4
  0003a	48 03 d8	 add	 rbx, rax

; 92   : 	  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);

  0003d	41 8b c4	 mov	 eax, r12d
  00040	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00045	83 c0 01	 add	 eax, 1
  00048	83 f8 01	 cmp	 eax, 1
  0004b	74 28		 je	 SHORT $L23016
$L21279:
  0004d	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  00058	3c 02		 cmp	 al, 2
  0005a	73 42		 jae	 SHORT $L21283
  0005c	41 8b cd	 mov	 ecx, r13d
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  00065	41 8b c4	 mov	 eax, r12d
  00068	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0006d	83 c0 01	 add	 eax, 1
  00070	83 f8 01	 cmp	 eax, 1
  00073	75 d8		 jne	 SHORT $L21279
$L23016:

; 93   : 
; 94   : 	  if (got_lock)
; 95   : 	    {
; 96   : 	      INSTANCE *current;
; 97   : 	      for (current = ib->list; current != NULL; current = current->next)

  00075	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00078	48 85 c0	 test	 rax, rax
  0007b	74 0b		 je	 SHORT $L21288
$L21286:

; 98   : 		++n;

  0007d	83 c7 01	 add	 edi, 1

; 93   : 
; 94   : 	  if (got_lock)
; 95   : 	    {
; 96   : 	      INSTANCE *current;
; 97   : 	      for (current = ib->list; current != NULL; current = current->next)

  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 85 c0	 test	 rax, rax
  00086	75 f5		 jne	 SHORT $L21286
$L21288:

; 99   : 	      RELEASE_MUTEX (&ib->lock);

  00088	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1

; 87   :     {
; 88   :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  0008d	83 c6 01	 add	 esi, 1
  00090	41 3b f6	 cmp	 esi, r14d
  00093	7d 1c		 jge	 SHORT $L21275
  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_InstanceHash
  0009c	eb 95		 jmp	 SHORT $L21273
$L21283:

; 100  : 	    }
; 101  : 	  else
; 102  : 	    return -1;

  0009e	b8 ff ff ff ff	 mov	 eax, -1

; 107  : }

  000a3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a7	41 5e		 pop	 r14
  000a9	41 5d		 pop	 r13
  000ab	41 5c		 pop	 r12
  000ad	5f		 pop	 rdi
  000ae	5e		 pop	 rsi
  000af	5b		 pop	 rbx
  000b0	c3		 ret	 0
$L21275:

; 103  : 	}
; 104  :     }
; 105  : 
; 106  :   return n;

  000b1	8b c7		 mov	 eax, edi

; 107  : }

  000b3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b7	41 5e		 pop	 r14
  000b9	41 5d		 pop	 r13
  000bb	41 5c		 pop	 r12
  000bd	5f		 pop	 rdi
  000be	5e		 pop	 rsi
  000bf	5b		 pop	 rbx
  000c0	c3		 ret	 0
NInstances ENDP
_TEXT	ENDS
PUBLIC	InstanceMaxBucketSize
;	COMDAT xdata
xdata	SEGMENT
$unwind$InstanceMaxBucketSize DD 080f01H
	DD	0f00b320fH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InstanceMaxBucketSize DD @imagerel(InstanceMaxBucketSize#)
	DD	@imagerel(InstanceMaxBucketSize#+208)
	DD	@imagerel($unwind$InstanceMaxBucketSize#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT InstanceMaxBucketSize
_TEXT	SEGMENT
InstanceMaxBucketSize PROC NEAR				; COMDAT

; 111  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 112  :   int i, n = 0;

  0000f	33 f6		 xor	 esi, esi

; 113  : 
; 114  :   if (g_InstanceHash)

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_InstanceHash
  00018	48 85 c0	 test	 rax, rax
  0001b	0f 84 9d 00 00
	00		 je	 $L21298

; 115  :     {
; 116  :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  00021	45 33 e4	 xor	 r12d, r12d
  00024	41 bd 01 00 00
	00		 mov	 r13d, 1
  0002a	41 be 10 27 00
	00		 mov	 r14d, 10000		; 00002710H
  00030	41 bf 00 01 00
	00		 mov	 r15d, 256		; 00000100H
$L21296:

; 117  : 	{
; 118  : 	  BOOLEAN got_lock;
; 119  : 	  int bucket_size = 0;

  00036	33 ff		 xor	 edi, edi

; 120  : 	  INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[i];

  00038	49 63 dc	 movsxd	 rbx, r12d
  0003b	48 c1 e3 04	 shl	 rbx, 4
  0003f	48 03 d8	 add	 rbx, rax

; 121  : 	  ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);

  00042	41 8b c5	 mov	 eax, r13d
  00045	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0004a	83 c0 01	 add	 eax, 1
  0004d	83 f8 01	 cmp	 eax, 1
  00050	74 28		 je	 SHORT $L23034
$L21303:
  00052	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  0005d	3c 02		 cmp	 al, 2
  0005f	73 48		 jae	 SHORT $L21307
  00061	41 8b ce	 mov	 ecx, r14d
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  0006a	41 8b c5	 mov	 eax, r13d
  0006d	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00072	83 c0 01	 add	 eax, 1
  00075	83 f8 01	 cmp	 eax, 1
  00078	75 d8		 jne	 SHORT $L21303
$L23034:

; 122  : 
; 123  : 	  if (got_lock)
; 124  : 	    {
; 125  : 	      INSTANCE *current;
; 126  : 	      for (current = ib->list; current != NULL; current = current->next)

  0007a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0007d	48 85 c0	 test	 rax, rax
  00080	74 0b		 je	 SHORT $L21312
$L21310:

; 127  : 		  ++bucket_size;

  00082	83 c7 01	 add	 edi, 1

; 122  : 
; 123  : 	  if (got_lock)
; 124  : 	    {
; 125  : 	      INSTANCE *current;
; 126  : 	      for (current = ib->list; current != NULL; current = current->next)

  00085	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00088	48 85 c0	 test	 rax, rax
  0008b	75 f5		 jne	 SHORT $L21310
$L21312:

; 128  : 	      if (bucket_size > n)

  0008d	3b fe		 cmp	 edi, esi
  0008f	0f 4f f7	 cmovg	 esi, edi

; 129  : 		n = bucket_size;
; 130  : 	      RELEASE_MUTEX (&ib->lock);

  00092	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1

; 115  :     {
; 116  :       for (i = 0; i < N_INSTANCE_BUCKETS; ++i)

  00097	41 83 c4 01	 add	 r12d, 1
  0009b	45 3b e7	 cmp	 r12d, r15d
  0009e	7d 1e		 jge	 SHORT $L21298
  000a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_InstanceHash
  000a7	eb 8d		 jmp	 SHORT $L21296
$L21307:

; 131  : 	    }
; 132  : 	  else
; 133  : 	    return -1;

  000a9	b8 ff ff ff ff	 mov	 eax, -1

; 138  : }

  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	41 5f		 pop	 r15
  000b4	41 5e		 pop	 r14
  000b6	41 5d		 pop	 r13
  000b8	41 5c		 pop	 r12
  000ba	5f		 pop	 rdi
  000bb	5e		 pop	 rsi
  000bc	5b		 pop	 rbx
  000bd	c3		 ret	 0
$L21298:

; 134  : 	}
; 135  :     }
; 136  : 
; 137  :   return n;

  000be	8b c6		 mov	 eax, esi

; 138  : }

  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	41 5f		 pop	 r15
  000c6	41 5e		 pop	 r14
  000c8	41 5d		 pop	 r13
  000ca	41 5c		 pop	 r12
  000cc	5f		 pop	 rdi
  000cd	5e		 pop	 rsi
  000ce	5b		 pop	 rbx
  000cf	c3		 ret	 0
InstanceMaxBucketSize ENDP
_TEXT	ENDS
PUBLIC	FreeInstanceList
;	COMDAT xdata
xdata	SEGMENT
$unwind$FreeInstanceList DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FreeInstanceList DD @imagerel(FreeInstanceList#)
	DD	@imagerel(FreeInstanceList#+42)
	DD	@imagerel($unwind$FreeInstanceList#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT FreeInstanceList
_TEXT	SEGMENT
FreeInstanceList PROC NEAR				; COMDAT

; 142  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 143  :   if (g_InstanceHash)

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_InstanceHash
  0000b	48 85 c9	 test	 rcx, rcx
  0000e	74 15		 je	 SHORT $L21318

; 144  :     {
; 145  :       MYASSERT (NInstances() == 0);
; 146  :       MemFree (g_InstanceHash, sizeof (INSTANCE_HASH));

  00010	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00015	e8 00 00 00 00	 call	 MemFree

; 147  :       g_InstanceHash = NULL;

  0001a	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR g_InstanceHash, 0
$L21318:

; 148  :     }
; 149  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
FreeInstanceList ENDP
_TEXT	ENDS
PUBLIC	AddAdapterToInstanceList
;	COMDAT xdata
xdata	SEGMENT
$unwind$AddAdapterToInstanceList DD 060b01H
	DD	0d007320bH
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AddAdapterToInstanceList DD @imagerel(AddAdapterToInstanceList#)
	DD	@imagerel(AddAdapterToInstanceList#+164)
	DD	@imagerel($unwind$AddAdapterToInstanceList#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AddAdapterToInstanceList
_TEXT	SEGMENT
p_Adapter$ = 80
AddAdapterToInstanceList PROC NEAR			; COMDAT

; 153  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b f1	 mov	 rsi, rcx

; 154  :   BOOLEAN got_lock;
; 155  :   BOOLEAN ret = FALSE;

  0000e	40 32 ff	 xor	 dil, dil

; 156  :   const int hash = InstanceHashValue(INSTANCE_KEY(p_Adapter));

  00011	48 8b 8e 88 02
	00 00		 mov	 rcx, QWORD PTR [rsi+648]
  00018	e8 00 00 00 00	 call	 InstanceHashValue

; 157  :   INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[hash];

  0001d	48 63 d8	 movsxd	 rbx, eax
  00020	48 c1 e3 04	 shl	 rbx, 4
  00024	48 03 1d 00 00
	00 00		 add	 rbx, QWORD PTR g_InstanceHash

; 158  : 
; 159  :   DEBUGP (("[TAP] AddAdapterToInstanceList hash=%d\n", hash));
; 160  : 
; 161  :   ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);

  0002b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00031	41 8b c5	 mov	 eax, r13d
  00034	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00039	41 03 c5	 add	 eax, r13d
  0003c	41 3b c5	 cmp	 eax, r13d
  0003f	74 2e		 je	 SHORT $L23056
  00041	41 bc 10 27 00
	00		 mov	 r12d, 10000		; 00002710H
$L21331:
  00047	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  00052	3c 02		 cmp	 al, 2
  00054	73 3f		 jae	 SHORT $L23057
  00056	41 8b cc	 mov	 ecx, r12d
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  0005f	41 8b c5	 mov	 eax, r13d
  00062	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00067	83 c0 01	 add	 eax, 1
  0006a	83 f8 01	 cmp	 eax, 1
  0006d	75 d8		 jne	 SHORT $L21331
$L23056:

; 162  : 
; 163  :   if (got_lock)
; 164  :     {
; 165  :       INSTANCE *i = MemAlloc (sizeof (INSTANCE), FALSE);

  0006f	32 d2		 xor	 dl, dl
  00071	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00076	e8 00 00 00 00	 call	 MemAlloc

; 166  :       if (i)

  0007b	48 85 c0	 test	 rax, rax
  0007e	74 10		 je	 SHORT $L21338

; 167  : 	{
; 168  : 	  MYASSERT (p_Adapter);
; 169  : 	  i->m_Adapter = p_Adapter;

  00080	48 89 70 08	 mov	 QWORD PTR [rax+8], rsi

; 170  : 	  i->next = ib->list;

  00084	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00087	48 89 08	 mov	 QWORD PTR [rax], rcx

; 171  : 	  ib->list = i;

  0008a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 172  : 	  ret = TRUE;

  0008d	40 b7 01	 mov	 dil, 1
$L21338:

; 173  : 	}
; 174  :       RELEASE_MUTEX (&ib->lock);

  00090	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
$L23057:

; 175  :     }
; 176  : 
; 177  :   return ret;

  00095	40 8a c7	 mov	 al, dil

; 178  : }

  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	41 5d		 pop	 r13
  0009e	41 5c		 pop	 r12
  000a0	5f		 pop	 rdi
  000a1	5e		 pop	 rsi
  000a2	5b		 pop	 rbx
  000a3	c3		 ret	 0
AddAdapterToInstanceList ENDP
_TEXT	ENDS
PUBLIC	RemoveAdapterFromInstanceList
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveAdapterFromInstanceList DD 060b01H
	DD	0d007320bH
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveAdapterFromInstanceList DD @imagerel(RemoveAdapterFromInstanceList#)
	DD	@imagerel(RemoveAdapterFromInstanceList#+204)
	DD	@imagerel($unwind$RemoveAdapterFromInstanceList#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT RemoveAdapterFromInstanceList
_TEXT	SEGMENT
p_Adapter$ = 80
RemoveAdapterFromInstanceList PROC NEAR			; COMDAT

; 182  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b f1	 mov	 rsi, rcx

; 183  :   BOOLEAN got_lock;
; 184  :   BOOLEAN ret = FALSE;

  0000e	45 32 e4	 xor	 r12b, r12b

; 185  :   INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[InstanceHashValue(INSTANCE_KEY(p_Adapter))];

  00011	48 8b 8e 88 02
	00 00		 mov	 rcx, QWORD PTR [rsi+648]
  00018	e8 00 00 00 00	 call	 InstanceHashValue
  0001d	48 63 f8	 movsxd	 rdi, eax
  00020	48 c1 e7 04	 shl	 rdi, 4
  00024	48 03 3d 00 00
	00 00		 add	 rdi, QWORD PTR g_InstanceHash

; 186  : 
; 187  :   ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);

  0002b	41 bd 01 00 00
	00		 mov	 r13d, 1
  00031	41 8b c5	 mov	 eax, r13d
  00034	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00039	41 03 c5	 add	 eax, r13d
  0003c	41 3b c5	 cmp	 eax, r13d
  0003f	74 2c		 je	 SHORT $L23072
  00041	bb 10 27 00 00	 mov	 ebx, 10000		; 00002710H
$L21348:
  00046	f0 83 47 08 ff	 lock add DWORD PTR [rdi+8], -1
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  00051	3c 02		 cmp	 al, 2
  00053	73 68		 jae	 SHORT $L23073
  00055	8b cb		 mov	 ecx, ebx
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  0005d	41 8b c5	 mov	 eax, r13d
  00060	f0 0f c1 47 08	 lock xadd DWORD PTR [rdi+8], eax
  00065	83 c0 01	 add	 eax, 1
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 d9		 jne	 SHORT $L21348
$L23072:

; 188  : 
; 189  :   if (got_lock)
; 190  :     {
; 191  :       INSTANCE *current, *prev=NULL;

  0006d	33 c9		 xor	 ecx, ecx

; 192  :       for (current = ib->list; current != NULL; current = current->next)

  0006f	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
  00072	48 85 db	 test	 rbx, rbx
  00075	74 41		 je	 SHORT $L21359
$L21357:

; 193  : 	{
; 194  : 	  if (current->m_Adapter == p_Adapter) // found match

  00077	48 39 73 08	 cmp	 QWORD PTR [rbx+8], rsi
  0007b	74 0d		 je	 SHORT $L23070

; 203  : 	      break;
; 204  : 	    }
; 205  : 	  prev = current;

  0007d	48 8b cb	 mov	 rcx, rbx

; 192  :       for (current = ib->list; current != NULL; current = current->next)

  00080	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
  00083	48 85 db	 test	 rbx, rbx
  00086	75 ef		 jne	 SHORT $L21357

; 193  : 	{
; 194  : 	  if (current->m_Adapter == p_Adapter) // found match

  00088	eb 2e		 jmp	 SHORT $L21359
$L23070:

; 197  : 		prev->next = current->next;

  0008a	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 195  : 	    {
; 196  : 	      if (prev)

  0008d	48 85 c9	 test	 rcx, rcx
  00090	74 05		 je	 SHORT $L21361

; 197  : 		prev->next = current->next;

  00092	48 89 01	 mov	 QWORD PTR [rcx], rax

; 198  : 	      else

  00095	eb 03		 jmp	 SHORT $L21362
$L21361:

; 199  : 		ib->list = current->next;

  00097	48 89 07	 mov	 QWORD PTR [rdi], rax
$L21362:

; 200  : 	      MemFree (current->m_Adapter, sizeof (TapAdapter));

  0009a	ba f8 02 00 00	 mov	 edx, 760		; 000002f8H
  0009f	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000a3	e8 00 00 00 00	 call	 MemFree

; 201  : 	      MemFree (current, sizeof (INSTANCE));

  000a8	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	e8 00 00 00 00	 call	 MemFree

; 202  : 	      ret = TRUE;

  000b5	41 b4 01	 mov	 r12b, 1
$L21359:

; 206  : 	}
; 207  :       RELEASE_MUTEX (&ib->lock);

  000b8	f0 83 47 08 ff	 lock add DWORD PTR [rdi+8], -1
$L23073:

; 208  :     }
; 209  : 
; 210  :   return ret;

  000bd	41 8a c4	 mov	 al, r12b

; 211  : }

  000c0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c4	41 5d		 pop	 r13
  000c6	41 5c		 pop	 r12
  000c8	5f		 pop	 rdi
  000c9	5e		 pop	 rsi
  000ca	5b		 pop	 rbx
  000cb	c3		 ret	 0
RemoveAdapterFromInstanceList ENDP
_TEXT	ENDS
PUBLIC	LookupAdapterInInstanceList
;	COMDAT xdata
xdata	SEGMENT
$unwind$LookupAdapterInInstanceList DD 060b01H
	DD	0d007320bH
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$LookupAdapterInInstanceList DD @imagerel(LookupAdapterInInstanceList#)
	DD	@imagerel(LookupAdapterInInstanceList#+187)
	DD	@imagerel($unwind$LookupAdapterInInstanceList#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT LookupAdapterInInstanceList
_TEXT	SEGMENT
p_DeviceObject$ = 80
LookupAdapterInInstanceList PROC NEAR			; COMDAT

; 215  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	48 8b f1	 mov	 rsi, rcx

; 216  :   BOOLEAN got_lock;
; 217  :   TapAdapterPointer ret = NULL;

  0000e	33 ff		 xor	 edi, edi

; 218  :   INSTANCE_BUCKET *ib = &g_InstanceHash->buckets[InstanceHashValue((PVOID)p_DeviceObject)];

  00010	e8 00 00 00 00	 call	 InstanceHashValue
  00015	48 63 d8	 movsxd	 rbx, eax
  00018	48 c1 e3 04	 shl	 rbx, 4
  0001c	48 03 1d 00 00
	00 00		 add	 rbx, QWORD PTR g_InstanceHash

; 219  : 
; 220  :   ACQUIRE_MUTEX_ADAPTIVE (&ib->lock, got_lock);

  00023	41 bd 01 00 00
	00		 mov	 r13d, 1
  00029	41 8b c5	 mov	 eax, r13d
  0002c	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  00031	41 03 c5	 add	 eax, r13d
  00034	41 3b c5	 cmp	 eax, r13d
  00037	74 2e		 je	 SHORT $L23089
  00039	41 bc 10 27 00
	00		 mov	 r12d, 10000		; 00002710H
$L21375:
  0003f	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  0004a	3c 02		 cmp	 al, 2
  0004c	73 5e		 jae	 SHORT $L23090
  0004e	41 8b cc	 mov	 ecx, r12d
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  00057	41 8b c5	 mov	 eax, r13d
  0005a	f0 0f c1 43 08	 lock xadd DWORD PTR [rbx+8], eax
  0005f	83 c0 01	 add	 eax, 1
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 d8		 jne	 SHORT $L21375
$L23089:

; 221  : 
; 222  :   if (got_lock)
; 223  :     {
; 224  :       INSTANCE *current, *prev=NULL;

  00067	48 8b d7	 mov	 rdx, rdi

; 225  :       for (current = ib->list; current != NULL; current = current->next)

  0006a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0006d	48 85 c9	 test	 rcx, rcx
  00070	74 35		 je	 SHORT $L21386
$L21384:

; 226  : 	{
; 227  : 	  if (p_DeviceObject == INSTANCE_KEY (current->m_Adapter)) // found match

  00072	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00076	48 3b b0 88 02
	00 00		 cmp	 rsi, QWORD PTR [rax+648]
  0007d	74 0d		 je	 SHORT $L23087

; 237  : 	      break;
; 238  : 	    }
; 239  : 	  prev = current;

  0007f	48 8b d1	 mov	 rdx, rcx

; 225  :       for (current = ib->list; current != NULL; current = current->next)

  00082	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00085	48 85 c9	 test	 rcx, rcx
  00088	75 e8		 jne	 SHORT $L21384

; 226  : 	{
; 227  : 	  if (p_DeviceObject == INSTANCE_KEY (current->m_Adapter)) // found match

  0008a	eb 1b		 jmp	 SHORT $L21386
$L23087:

; 228  : 	    {
; 229  : 	      // move it to head of list
; 230  : 	      if (prev)

  0008c	48 85 d2	 test	 rdx, rdx
  0008f	74 0f		 je	 SHORT $L21389

; 231  : 		{
; 232  : 		  prev->next = current->next;

  00091	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00094	48 89 02	 mov	 QWORD PTR [rdx], rax

; 233  : 		  current->next = ib->list;

  00097	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0009a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 234  : 		  ib->list = current;

  0009d	48 89 0b	 mov	 QWORD PTR [rbx], rcx
$L21389:

; 235  : 		}
; 236  : 	      ret = ib->list->m_Adapter;

  000a0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000a3	48 8b 78 08	 mov	 rdi, QWORD PTR [rax+8]
$L21386:

; 240  : 	}
; 241  :       RELEASE_MUTEX (&ib->lock);

  000a7	f0 83 43 08 ff	 lock add DWORD PTR [rbx+8], -1
$L23090:

; 242  :     }
; 243  : 
; 244  :   return ret;

  000ac	48 8b c7	 mov	 rax, rdi

; 245  : }

  000af	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b3	41 5d		 pop	 r13
  000b5	41 5c		 pop	 r12
  000b7	5f		 pop	 rdi
  000b8	5e		 pop	 rsi
  000b9	5b		 pop	 rbx
  000ba	c3		 ret	 0
LookupAdapterInInstanceList ENDP
_TEXT	ENDS
PUBLIC	TapDriverUnload
;	COMDAT xdata
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.c
xdata	SEGMENT
$unwind$TapDriverUnload DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapDriverUnload DD @imagerel(TapDriverUnload#)
	DD	@imagerel(TapDriverUnload#+14)
	DD	@imagerel($unwind$TapDriverUnload#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT TapDriverUnload
_TEXT	SEGMENT
p_DriverObject$ = 48
TapDriverUnload PROC NEAR				; COMDAT

; 257  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 258  :   DEBUGP (("[TAP] version [%d.%d] %s %s unloaded, instances=%d, imbs=%d\n",
; 259  : 	   TAP_DRIVER_MAJOR_VERSION,
; 260  : 	   TAP_DRIVER_MINOR_VERSION,
; 261  : 	   __DATE__,
; 262  : 	   __TIME__,
; 263  : 	   NInstances(),
; 264  : 	   InstanceMaxBucketSize()));
; 265  : 
; 266  :   FreeInstanceList ();

  00004	e8 00 00 00 00	 call	 FreeInstanceList

; 267  : 
; 268  :   //==============================
; 269  :   // Free debugging text space
; 270  :   //==============================
; 271  : #if DBG
; 272  :   MyDebugFree ();
; 273  : #endif
; 274  : }

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
TapDriverUnload ENDP
_TEXT	ENDS
PUBLIC	AdapterFreeResources
EXTRN	__imp_NdisMDeregisterAdapterShutdownHandler:NEAR
EXTRN	__imp_RtlFreeAnsiString:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterFreeResources DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterFreeResources DD @imagerel(AdapterFreeResources#)
	DD	@imagerel(AdapterFreeResources#+53)
	DD	@imagerel($unwind$AdapterFreeResources#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AdapterFreeResources
_TEXT	SEGMENT
p_Adapter$ = 48
AdapterFreeResources PROC NEAR				; COMDAT

; 605  : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b d9	 mov	 rbx, rcx

; 606  :   MYASSERT (!p_Adapter->m_CalledAdapterFreeResources);
; 607  :   p_Adapter->m_CalledAdapterFreeResources = TRUE;

  00008	c6 83 9c 01 00
	00 01		 mov	 BYTE PTR [rbx+412], 1

; 608  : 
; 609  :   if (p_Adapter->m_NameAnsi.Buffer)

  0000f	48 83 7b 08 00	 cmp	 QWORD PTR [rbx+8], 0
  00014	74 06		 je	 SHORT $L21574

; 610  :     RtlFreeAnsiString (&p_Adapter->m_NameAnsi);

  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeAnsiString
$L21574:

; 611  :   
; 612  :   if (p_Adapter->m_RegisteredAdapterShutdownHandler)

  0001c	80 bb 9d 01 00
	00 00		 cmp	 BYTE PTR [rbx+413], 0
  00023	74 0a		 je	 SHORT $L21575

; 613  :     NdisMDeregisterAdapterShutdownHandler (p_Adapter->m_MiniportAdapterHandle);

  00025	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMDeregisterAdapterShutdownHandler
$L21575:

; 614  : 
; 615  :   if (p_Adapter->m_MCLockAllocated)
; 616  :     NdisFreeSpinLock (&l_Adapter->m_MCLock);
; 617  : }

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
AdapterFreeResources ENDP
_TEXT	ENDS
PUBLIC	TapDeviceFreeResources
EXTRN	__imp_RtlFreeUnicodeString:NEAR
EXTRN	__imp_NdisMDeregisterDevice:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapDeviceFreeResources DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapDeviceFreeResources DD @imagerel(TapDeviceFreeResources#)
	DD	@imagerel(TapDeviceFreeResources#+97)
	DD	@imagerel($unwind$TapDeviceFreeResources#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT TapDeviceFreeResources
_TEXT	SEGMENT
p_Extension$ = 48
TapDeviceFreeResources PROC NEAR			; COMDAT

; 661  : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b d9	 mov	 rbx, rcx

; 662  :   MYASSERT (p_Extension);
; 663  :   MYASSERT (!p_Extension->m_CalledTapDeviceFreeResources);
; 664  :   p_Extension->m_CalledTapDeviceFreeResources = TRUE;

  00008	c6 43 79 01	 mov	 BYTE PTR [rbx+121], 1

; 665  : 
; 666  :   if (p_Extension->m_PacketQueue)

  0000c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0000f	48 85 c9	 test	 rcx, rcx
  00012	74 05		 je	 SHORT $L21583

; 667  :     QueueFree (p_Extension->m_PacketQueue);

  00014	e8 00 00 00 00	 call	 QueueFree
$L21583:

; 668  :   if (p_Extension->m_IrpQueue)

  00019	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 05		 je	 SHORT $L21584

; 669  :     QueueFree (p_Extension->m_IrpQueue);

  00022	e8 00 00 00 00	 call	 QueueFree
$L21584:

; 670  : 
; 671  :   if (p_Extension->m_CreatedUnicodeLinkName)

  00027	80 7b 60 00	 cmp	 BYTE PTR [rbx+96], 0
  0002b	74 0a		 je	 SHORT $L21585

; 672  :     RtlFreeUnicodeString (&p_Extension->m_UnicodeLinkName);

  0002d	48 8d 4b 50	 lea	 rcx, QWORD PTR [rbx+80]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeUnicodeString
$L21585:

; 673  : 
; 674  :   //==========================================================
; 675  :   // According to DDK docs, the device is not actually deleted
; 676  :   // until its reference count falls to zero.  That means we
; 677  :   // still need to gracefully fail TapDeviceHook requests
; 678  :   // after this point, otherwise ugly things would happen if
; 679  :   // the device was disabled (e.g. in the network connections
; 680  :   // control panel) while a userspace app still held an open
; 681  :   // file handle to it.
; 682  :   //==========================================================
; 683  :   
; 684  :   if (p_Extension->m_TapDevice)

  00037	48 83 7b 10 00	 cmp	 QWORD PTR [rbx+16], 0
  0003c	74 0a		 je	 SHORT $L21586

; 685  :     {
; 686  :       BOOLEAN status;
; 687  :       status = (NdisMDeregisterDevice (p_Extension->m_TapDeviceHandle)
; 688  : 		== NDIS_STATUS_SUCCESS);

  0003e	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMDeregisterDevice
$L21586:

; 689  :       DEBUGP (("[TAP] Deregistering TAP device, status=%d\n", (int)status));
; 690  :     }
; 691  : 
; 692  :   if (p_Extension->m_TapName)

  00048	48 8b 4b 48	 mov	 rcx, QWORD PTR [rbx+72]
  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 0a		 je	 SHORT $L21590

; 693  :     MemFree (p_Extension->m_TapName, NAME_BUFFER_SIZE);

  00051	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00056	e8 00 00 00 00	 call	 MemFree
$L21590:

; 694  :   
; 695  :   if (p_Extension->m_AllocatedSpinlocks)
; 696  :     NdisFreeSpinLock (&p_Extension->m_QueueLock);
; 697  : }

  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
TapDeviceFreeResources ENDP
_TEXT	ENDS
PUBLIC	AdapterReset
; Function compile flags: /Ogty
;	COMDAT AdapterReset
_TEXT	SEGMENT
p_AddressingReset$ = 8
p_AdapterContext$ = 16
AdapterReset PROC NEAR					; COMDAT

; 953  :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 954  :   DEBUGP (("[%s] is resetting\n", NAME (l_Adapter)));
; 955  :   return NDIS_STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 956  : }

  00002	c3		 ret	 0
AdapterReset ENDP
_TEXT	ENDS
PUBLIC	AdapterReceive
; Function compile flags: /Ogty
;	COMDAT AdapterReceive
_TEXT	SEGMENT
p_Packet$ = 8
p_Transferred$ = 16
p_AdapterContext$ = 24
p_ReceiveContext$ = 32
p_Offset$ = 40
p_ToTransfer$ = 48
AdapterReceive PROC NEAR				; COMDAT

; 966  :   return NDIS_STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 967  : }

  00002	c3		 ret	 0
AdapterReceive ENDP
_TEXT	ENDS
PUBLIC	AdapterQuery
;	COMDAT AdapterQuery
AdapterQuery	SEGMENT
$SG21727 DB	'Leaf Networks Adapter', 00H
AdapterQuery	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterQuery DD 091201H
	DD	0240112H
	DD	0e009f00bH
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterQuery DD @imagerel(AdapterQuery#)
	DD	@imagerel(AdapterQuery#+710)
	DD	@imagerel($unwind$AdapterQuery#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AdapterQuery
_TEXT	SEGMENT
l_Query$ = 32
p_AdapterContext$ = 352
p_OID$ = 360
p_Buffer$ = 368
p_BufferLength$ = 376
p_BytesWritten$ = 384
p_BytesNeeded$ = 392
AdapterQuery PROC NEAR					; COMDAT

; 978  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00012	45 8b f1	 mov	 r14d, r9d
  00015	4d 8b e0	 mov	 r12, r8
  00018	8b da		 mov	 ebx, edx
  0001a	48 8b f1	 mov	 rsi, rcx

; 979  :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 980  :   TapAdapterQuery l_Query, *l_QueryPtr = &l_Query;

  0001d	4c 8d 6c 24 20	 lea	 r13, QWORD PTR l_Query$[rsp]

; 981  :   NDIS_STATUS l_Status = NDIS_STATUS_SUCCESS;

  00022	45 33 ff	 xor	 r15d, r15d

; 982  :   UINT l_QueryLength = 4;

  00025	bf 04 00 00 00	 mov	 edi, 4

; 983  :   BOOLEAN lock_succeeded;
; 984  : 
; 985  :   NdisZeroMemory (&l_Query, sizeof (l_Query));

  0002a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0002f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR l_Query$[rsp]
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 986  : 
; 987  :   switch (p_OID)

  0003a	b8 01 02 01 00	 mov	 eax, 66049		; 00010201H
  0003f	3b d8		 cmp	 ebx, eax
  00041	0f 87 d6 00 00
	00		 ja	 $L23126
  00047	0f 84 c8 01 00
	00		 je	 $L21781
  0004d	8d 83 ff fe fe
	ff		 lea	 eax, DWORD PTR [rbx-65793]
  00053	83 f8 16	 cmp	 eax, 22			; 00000016H
  00056	0f 87 b9 01 00
	00		 ja	 $L21781
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, $L23131
  00063	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, $L23132
  0006e	48 03 c1	 add	 rax, rcx
  00071	ff e0		 jmp	 rax
$L23132:
$L21725:

; 988  :     {
; 989  :       //===================================================================
; 990  :       //                       Vendor & Driver version Info
; 991  :       //===================================================================
; 992  :     case OID_GEN_VENDOR_DESCRIPTION:
; 993  :       l_QueryPtr = (TapAdapterQueryPointer) PRODUCT_STRING;

  00073	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:$SG21727

; 994  :       l_QueryLength = strlen (PRODUCT_STRING) + 1;

  0007a	bf 16 00 00 00	 mov	 edi, 22			; 00000016H

; 995  :       break;

  0007f	eb 52		 jmp	 SHORT $L23130
$L21728:

; 996  : 
; 997  :     case OID_GEN_VENDOR_ID:
; 998  :       l_Query.m_Long = 0xffffff;

  00081	c7 44 24 20 ff
	ff ff 00	 mov	 DWORD PTR l_Query$[rsp], 16777215 ; 00ffffffH

; 999  :       break;

  00089	eb 48		 jmp	 SHORT $L23130
$L21729:

; 1000 : 
; 1001 :     case OID_GEN_DRIVER_VERSION:
; 1002 :       l_Query.m_Short =
; 1003 : 	(((USHORT) TAP_NDIS_MAJOR_VERSION) << 8 | (USHORT)
; 1004 : 	 TAP_NDIS_MINOR_VERSION);

  0008b	66 c7 44 24 20
	00 05		 mov	 WORD PTR l_Query$[rsp], 1280 ; 00000500H

; 1005 :       l_QueryLength = sizeof (unsigned short);

  00092	bf 02 00 00 00	 mov	 edi, 2

; 1006 :       break;

  00097	eb 3a		 jmp	 SHORT $L23130
$L21733:

; 1007 : 
; 1008 :     case OID_GEN_VENDOR_DRIVER_VERSION:
; 1009 :       l_Query.m_Long =
; 1010 : 	(((USHORT) TAP_DRIVER_MAJOR_VERSION) << 8 | (USHORT)
; 1011 : 	 TAP_DRIVER_MINOR_VERSION);

  00099	c7 44 24 20 04
	08 00 00	 mov	 DWORD PTR l_Query$[rsp], 2052 ; 00000804H

; 1012 :       break;

  000a1	eb 30		 jmp	 SHORT $L23130
$L21744:

; 1048 : 
; 1049 :       //===================================================================
; 1050 :       //                       Device & Protocol Options
; 1051 :       //===================================================================
; 1052 :     case OID_GEN_SUPPORTED_LIST:
; 1053 :       l_QueryPtr = (TapAdapterQueryPointer) g_SupportedOIDList;

  000a3	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:g_SupportedOIDList

; 1054 :       l_QueryLength = sizeof (g_SupportedOIDList);

  000aa	bf 88 00 00 00	 mov	 edi, 136		; 00000088H

; 1055 :       break;

  000af	eb 22		 jmp	 SHORT $L23130
$L21746:

; 1056 : 
; 1057 :     case OID_GEN_MAC_OPTIONS:
; 1058 :       // This MUST be here !!!
; 1059 :       l_Query.m_Long = (NDIS_MAC_OPTION_RECEIVE_SERIALIZED
; 1060 : 			| NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA
; 1061 : 			| NDIS_MAC_OPTION_NO_LOOPBACK
; 1062 : 			| NDIS_MAC_OPTION_TRANSFERS_NOT_PEND);

  000b1	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR l_Query$[rsp], 15 ; 0000000fH

; 1063 : 
; 1064 :       break;

  000b9	eb 18		 jmp	 SHORT $L23130
$L21747:

; 1065 : 
; 1066 :     case OID_GEN_CURRENT_PACKET_FILTER:
; 1067 :       l_Query.m_Long =
; 1068 : 	(NDIS_PACKET_TYPE_ALL_LOCAL |
; 1069 : 	 NDIS_PACKET_TYPE_BROADCAST |
; 1070 : 	 NDIS_PACKET_TYPE_DIRECTED | NDIS_PACKET_TYPE_ALL_FUNCTIONAL);

  000bb	c7 44 24 20 89
	20 00 00	 mov	 DWORD PTR l_Query$[rsp], 8329 ; 00002089H

; 1071 : 
; 1072 :       break;

  000c3	eb 0e		 jmp	 SHORT $L23130
$L21749:

; 1073 : 
; 1074 :     case OID_GEN_PROTOCOL_OPTIONS:
; 1075 :       l_Query.m_Long = 0;
; 1076 :       break;
; 1077 : 
; 1078 :       //==================================================================
; 1079 :       //                            Device Info
; 1080 :       //==================================================================
; 1081 :     case OID_GEN_MEDIA_CONNECT_STATUS:
; 1082 :       l_Query.m_Long = l_Adapter->m_MediaState
; 1083 : 	? NdisMediaStateConnected : NdisMediaStateDisconnected;

  000c5	41 8b c7	 mov	 eax, r15d
  000c8	80 7e 45 00	 cmp	 BYTE PTR [rsi+69], 0
  000cc	0f 94 c0	 sete	 al
$L23145:

; 1032 : 
; 1033 :     case OID_GEN_XMIT_OK:
; 1034 :       l_Query.m_Long = l_Adapter->m_Tx;

  000cf	89 44 24 20	 mov	 DWORD PTR l_Query$[rsp], eax
$L23130:

; 1200 :     }
; 1201 : 
; 1202 :   if (l_Status != NDIS_STATUS_SUCCESS)
; 1203 :     ;
; 1204 :   else if (l_QueryLength > p_BufferLength)

  000d3	41 3b fe	 cmp	 edi, r14d
  000d6	0f 86 5f 01 00
	00		 jbe	 $L21787

; 1205 :     {
; 1206 :       l_Status = NDIS_STATUS_INVALID_LENGTH;
; 1207 :       *p_BytesNeeded = l_QueryLength;

  000dc	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  000e4	89 38		 mov	 DWORD PTR [rax], edi

; 1212 : 
; 1213 :   return l_Status;

  000e6	b8 14 00 01 c0	 mov	 eax, -1073676268	; c0010014H

; 1208 :     }
; 1209 :   else

  000eb	e9 67 01 00 00	 jmp	 $L21789
$L21752:

; 1084 :       break;
; 1085 : 
; 1086 :     case OID_GEN_HARDWARE_STATUS:
; 1087 :       l_Query.m_HardwareStatus = NdisHardwareStatusReady;
; 1088 :       l_QueryLength = sizeof (NDIS_HARDWARE_STATUS);
; 1089 :       break;
; 1090 : 
; 1091 :     case OID_GEN_MEDIA_SUPPORTED:
; 1092 :     case OID_GEN_MEDIA_IN_USE:
; 1093 :       l_Query.m_Medium = l_Adapter->m_Medium;

  000f0	8b 46 38	 mov	 eax, DWORD PTR [rsi+56]

; 1094 :       l_QueryLength = sizeof (NDIS_MEDIUM);
; 1095 :       break;

  000f3	eb da		 jmp	 SHORT $L23145
$L21756:

; 1096 : 
; 1097 :     case OID_GEN_PHYSICAL_MEDIUM:
; 1098 :       l_Query.m_PhysicalMedium = NdisPhysicalMediumUnspecified;
; 1099 :       l_QueryLength = sizeof (NDIS_PHYSICAL_MEDIUM);
; 1100 :       break;
; 1101 :       
; 1102 :     case OID_GEN_LINK_SPEED:
; 1103 :       l_Query.m_Long = 100000; // rate / 100 bps

  000f5	c7 44 24 20 a0
	86 01 00	 mov	 DWORD PTR l_Query$[rsp], 100000 ; 000186a0H

; 1104 :       break;

  000fd	eb d4		 jmp	 SHORT $L23130
$L21760:

; 1111 : 
; 1112 :       //==================================================================
; 1113 :       //                             Limits
; 1114 :       //==================================================================
; 1115 : 
; 1116 :     case OID_GEN_MAXIMUM_SEND_PACKETS:
; 1117 :       l_Query.m_Long = 1;

  000ff	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR l_Query$[rsp], 1

; 1118 :       break;

  00107	eb ca		 jmp	 SHORT $L23130
$L21762:

; 1123 : 
; 1124 :     case OID_GEN_CURRENT_LOOKAHEAD:
; 1125 :       l_Query.m_Long = l_Adapter->m_Lookahead;

  00109	8b 46 3c	 mov	 eax, DWORD PTR [rsi+60]

; 1126 :       break;

  0010c	eb c1		 jmp	 SHORT $L23145
$L21763:

; 1127 : 
; 1128 :     case OID_GEN_MAXIMUM_LOOKAHEAD:
; 1129 :     case OID_GEN_MAXIMUM_TOTAL_SIZE:
; 1130 :     case OID_GEN_RECEIVE_BUFFER_SPACE:
; 1131 :     case OID_GEN_RECEIVE_BLOCK_SIZE:
; 1132 :       l_Query.m_Long = DEFAULT_PACKET_LOOKAHEAD;

  0010e	c7 44 24 20 ea
	05 00 00	 mov	 DWORD PTR l_Query$[rsp], 1514 ; 000005eaH

; 1133 :       break;

  00116	eb bb		 jmp	 SHORT $L23130
$L21765:

; 1134 : 
; 1135 :     case OID_GEN_MAXIMUM_FRAME_SIZE:
; 1136 :     case OID_GEN_TRANSMIT_BLOCK_SIZE:
; 1137 :     case OID_GEN_TRANSMIT_BUFFER_SPACE:
; 1138 :       l_Query.m_Long = l_Adapter->m_MTU;

  00118	8b 46 40	 mov	 eax, DWORD PTR [rsi+64]

; 1139 :       break;

  0011b	eb b2		 jmp	 SHORT $L23145
$L23126:

; 986  : 
; 987  :   switch (p_OID)

  0011d	b8 04 01 01 01	 mov	 eax, 16843012		; 01010104H
  00122	3b d8		 cmp	 ebx, eax
  00124	0f 87 a8 00 00
	00		 ja	 $L23127
  0012a	0f 84 95 00 00
	00		 je	 $L21761
  00130	b8 04 01 02 00	 mov	 eax, 131332		; 00020104H
  00135	3b d8		 cmp	 ebx, eax
  00137	77 44		 ja	 SHORT $L23128
  00139	74 3a		 je	 SHORT $L21743
  0013b	81 eb 02 02 01
	00		 sub	 ebx, 66050		; 00010202H
  00141	0f 84 a8 00 00
	00		 je	 $L21737
  00147	81 eb ff fe 00
	00		 sub	 ebx, 65279		; 0000feffH
  0014d	74 1e		 je	 SHORT $L21740
  0014f	83 eb 01	 sub	 ebx, 1
  00152	74 11		 je	 SHORT $L21741
  00154	83 eb 01	 sub	 ebx, 1
  00157	0f 85 b8 00 00
	00		 jne	 $L21781

; 1040 : 
; 1041 :     case OID_GEN_XMIT_ERROR:
; 1042 :       l_Query.m_Long = l_Adapter->m_TxErr;

  0015d	8b 46 2c	 mov	 eax, DWORD PTR [rsi+44]

; 1043 :       break;

  00160	e9 6a ff ff ff	 jmp	 $L23145
$L21741:

; 1036 : 
; 1037 :     case OID_GEN_RCV_OK:
; 1038 :       l_Query.m_Long = l_Adapter->m_Rx;

  00165	8b 46 20	 mov	 eax, DWORD PTR [rsi+32]

; 1039 :       break;

  00168	e9 62 ff ff ff	 jmp	 $L23145
$L21740:

; 1032 : 
; 1033 :     case OID_GEN_XMIT_OK:
; 1034 :       l_Query.m_Long = l_Adapter->m_Tx;

  0016d	8b 46 24	 mov	 eax, DWORD PTR [rsi+36]

; 1035 :       break;

  00170	e9 5a ff ff ff	 jmp	 $L23145
$L21743:

; 1044 : 
; 1045 :     case OID_GEN_RCV_ERROR:
; 1046 :       l_Query.m_Long = l_Adapter->m_RxErr;

  00175	8b 46 28	 mov	 eax, DWORD PTR [rsi+40]

; 1047 :       break;

  00178	e9 52 ff ff ff	 jmp	 $L23145
$L23128:

; 986  : 
; 987  :   switch (p_OID)

  0017d	81 fb 05 01 02
	00		 cmp	 ebx, 131333		; 00020105H
  00183	74 6a		 je	 SHORT $L21737
  00185	81 fb 00 02 02
	00		 cmp	 ebx, 131584		; 00020200H
  0018b	0f 86 84 00 00
	00		 jbe	 $L21781
  00191	81 fb 0c 02 02
	00		 cmp	 ebx, 131596		; 0002020cH
  00197	76 7c		 jbe	 SHORT $L21781
  00199	81 fb 00 01 01
	01		 cmp	 ebx, 16843008		; 01010100H
  0019f	76 74		 jbe	 SHORT $L21781
  001a1	81 fb 02 01 01
	01		 cmp	 ebx, 16843010		; 01010102H
  001a7	77 6c		 ja	 SHORT $L21781

; 1105 : 
; 1106 :     case OID_802_3_PERMANENT_ADDRESS:
; 1107 :     case OID_802_3_CURRENT_ADDRESS:
; 1108 :       COPY_MAC (l_Query.m_MacAddress, l_Adapter->m_MAC);

  001a9	48 8d 56 10	 lea	 rdx, QWORD PTR [rsi+16]
  001ad	bf 06 00 00 00	 mov	 edi, 6
  001b2	4c 8b c7	 mov	 r8, rdi
  001b5	48 8d 4c 24 20	 lea	 rcx, QWORD PTR l_Query$[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1109 :       l_QueryLength = sizeof (MACADDR);
; 1110 :       break;

  001c0	e9 0e ff ff ff	 jmp	 $L23130
$L21761:

; 1119 : 
; 1120 :     case OID_802_3_MAXIMUM_LIST_SIZE:
; 1121 :       l_Query.m_Long = NIC_MAX_MCAST_LIST;

  001c5	c7 44 24 20 20
	00 00 00	 mov	 DWORD PTR l_Query$[rsp], 32 ; 00000020H

; 1122 :       break;

  001cd	e9 01 ff ff ff	 jmp	 $L23130
$L23127:

; 986  : 
; 987  :   switch (p_OID)

  001d2	b8 01 02 01 fc	 mov	 eax, -67042815		; fc010201H
  001d7	3b d8		 cmp	 ebx, eax
  001d9	77 1e		 ja	 SHORT $L23129
  001db	74 38		 je	 SHORT $L21781
  001dd	81 eb 01 01 02
	01		 sub	 ebx, 16908545		; 01020101H
  001e3	74 0a		 je	 SHORT $L21737
  001e5	83 eb 01	 sub	 ebx, 1
  001e8	74 05		 je	 SHORT $L21737
  001ea	83 eb 01	 sub	 ebx, 1
  001ed	75 26		 jne	 SHORT $L21781
$L21737:

; 1013 : 
; 1014 :       //=================================================================
; 1015 :       //                             Statistics
; 1016 :       //=================================================================
; 1017 :     case OID_GEN_RCV_NO_BUFFER:
; 1018 :       l_Query.m_Long = 0;
; 1019 :       break;
; 1020 : 
; 1021 :     case OID_802_3_RCV_ERROR_ALIGNMENT:
; 1022 :       l_Query.m_Long = 0;
; 1023 :       break;
; 1024 : 
; 1025 :     case OID_802_3_XMIT_ONE_COLLISION:
; 1026 :       l_Query.m_Long = 0;
; 1027 :       break;
; 1028 : 
; 1029 :     case OID_802_3_XMIT_MORE_COLLISIONS:
; 1030 :       l_Query.m_Long = 0;

  001ef	44 89 7c 24 20	 mov	 DWORD PTR l_Query$[rsp], r15d

; 1031 :       break;

  001f4	e9 da fe ff ff	 jmp	 $L23130
$L23129:

; 986  : 
; 987  :   switch (p_OID)

  001f9	81 fb 10 02 01
	fc		 cmp	 ebx, -67042800		; fc010210H
  001ff	74 14		 je	 SHORT $L21781
  00201	81 fb 00 01 01
	fd		 cmp	 ebx, -50265856		; fd010100H
  00207	74 13		 je	 SHORT $L21767
  00209	81 fb 02 01 01
	fd		 cmp	 ebx, -50265854		; fd010102H
  0020f	0f 84 be fe ff
	ff		 je	 $L23130
$L21781:

; 1212 : 
; 1213 :   return l_Status;

  00215	b8 17 00 01 c0	 mov	 eax, -1073676265	; c0010017H

; 1164 :     case OID_PNP_QUERY_POWER:
; 1165 :       break;
; 1166 : 
; 1167 :       // Required OIDs that we don't support
; 1168 : 
; 1169 :     case OID_GEN_SUPPORTED_GUIDS:
; 1170 :     case OID_GEN_MEDIA_CAPABILITIES:
; 1171 :     case OID_TCP_TASK_OFFLOAD:
; 1172 :     case OID_FFP_SUPPORT:
; 1173 :       l_Status = NDIS_STATUS_INVALID_OID;
; 1174 :       break;
; 1175 : 
; 1176 :       // Optional stats OIDs
; 1177 : 
; 1178 :     case OID_GEN_DIRECTED_BYTES_XMIT:
; 1179 :     case OID_GEN_DIRECTED_FRAMES_XMIT:
; 1180 :     case OID_GEN_MULTICAST_BYTES_XMIT:
; 1181 :     case OID_GEN_MULTICAST_FRAMES_XMIT:
; 1182 :     case OID_GEN_BROADCAST_BYTES_XMIT:
; 1183 :     case OID_GEN_BROADCAST_FRAMES_XMIT:
; 1184 :     case OID_GEN_DIRECTED_BYTES_RCV:
; 1185 :     case OID_GEN_DIRECTED_FRAMES_RCV:
; 1186 :     case OID_GEN_MULTICAST_BYTES_RCV:
; 1187 :     case OID_GEN_MULTICAST_FRAMES_RCV:
; 1188 :     case OID_GEN_BROADCAST_BYTES_RCV:
; 1189 :     case OID_GEN_BROADCAST_FRAMES_RCV:
; 1190 :       l_Status = NDIS_STATUS_INVALID_OID;
; 1191 :       break;
; 1192 : 
; 1193 :       //===================================================================
; 1194 :       //                          Not Handled
; 1195 :       //===================================================================
; 1196 :     default:
; 1197 :       DEBUGP (("[%s] Unhandled OID %lx\n", NAME (l_Adapter), p_OID));
; 1198 :       l_Status = NDIS_STATUS_INVALID_OID;
; 1199 :       break;

  0021a	eb 3b		 jmp	 SHORT $L21789
$L21767:

; 1140 : 
; 1141 :     case OID_PNP_CAPABILITIES:
; 1142 :       do
; 1143 : 	{
; 1144 : 	  PNDIS_PNP_CAPABILITIES pPNPCapabilities;
; 1145 : 	  PNDIS_PM_WAKE_UP_CAPABILITIES pPMstruct;
; 1146 : 
; 1147 : 	  if (p_BufferLength >= sizeof (NDIS_PNP_CAPABILITIES))

  0021c	41 83 fe 10	 cmp	 r14d, 16		; 00000010H
  00220	72 0f		 jb	 SHORT $L21773

; 1148 : 	    {
; 1149 : 	      pPNPCapabilities = (PNDIS_PNP_CAPABILITIES) (p_Buffer);
; 1150 : 
; 1151 : 	      //
; 1152 : 	      // Setting up the buffer to be returned
; 1153 : 	      // to the Protocol above the Passthru miniport
; 1154 : 	      //
; 1155 : 	      pPMstruct = &pPNPCapabilities->WakeUpCapabilities;
; 1156 : 	      pPMstruct->MinMagicPacketWakeUp = NdisDeviceStateUnspecified;

  00222	45 89 7c 24 04	 mov	 DWORD PTR [r12+4], r15d

; 1157 : 	      pPMstruct->MinPatternWakeUp = NdisDeviceStateUnspecified;

  00227	45 89 7c 24 08	 mov	 DWORD PTR [r12+8], r15d

; 1158 : 	      pPMstruct->MinLinkChangeWakeUp = NdisDeviceStateUnspecified;

  0022c	45 89 7c 24 0c	 mov	 DWORD PTR [r12+12], r15d
$L21773:

; 1159 : 	    }
; 1160 : 	  l_QueryLength = sizeof (NDIS_PNP_CAPABILITIES);

  00231	bf 10 00 00 00	 mov	 edi, 16			; 00000010H

; 1161 : 	}
; 1162 :       while (FALSE);
; 1163 :       break;

  00236	e9 98 fe ff ff	 jmp	 $L23130
$L21787:

; 1210 :     NdisMoveMemory (p_Buffer, (PVOID) l_QueryPtr,
; 1211 : 		    (*p_BytesWritten = l_QueryLength));

  0023b	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR p_BytesWritten$[rsp]
  00243	89 39		 mov	 DWORD PTR [rcx], edi
  00245	44 8b c7	 mov	 r8d, edi
  00248	49 8b d5	 mov	 rdx, r13
  0024b	49 8b cc	 mov	 rcx, r12
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1212 : 
; 1213 :   return l_Status;

  00254	41 8b c7	 mov	 eax, r15d
$L21789:

; 1214 : }

  00257	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  0025e	41 5f		 pop	 r15
  00260	41 5e		 pop	 r14
  00262	41 5d		 pop	 r13
  00264	41 5c		 pop	 r12
  00266	5f		 pop	 rdi
  00267	5e		 pop	 rsi
  00268	5b		 pop	 rbx
  00269	c3		 ret	 0
  0026a	8b ff		 npad	 2
$L23131:
  0026c	30 00 00 00	 DD	 $L21744
  00270	7c 01 00 00	 DD	 $L21737
  00274	7d 00 00 00	 DD	 $L21752
  00278	7d 00 00 00	 DD	 $L21752
  0027c	9b 00 00 00	 DD	 $L21763
  00280	a5 00 00 00	 DD	 $L21765
  00284	82 00 00 00	 DD	 $L21756
  00288	a5 00 00 00	 DD	 $L21765
  0028c	9b 00 00 00	 DD	 $L21763
  00290	a5 00 00 00	 DD	 $L21765
  00294	9b 00 00 00	 DD	 $L21763
  00298	0e 00 00 00	 DD	 $L21728
  0029c	00 00 00 00	 DD	 $L21725
  002a0	48 00 00 00	 DD	 $L21747
  002a4	96 00 00 00	 DD	 $L21762
  002a8	18 00 00 00	 DD	 $L21729
  002ac	9b 00 00 00	 DD	 $L21763
  002b0	7c 01 00 00	 DD	 $L21737
  002b4	3e 00 00 00	 DD	 $L21746
  002b8	52 00 00 00	 DD	 $L21749
  002bc	8c 00 00 00	 DD	 $L21760
  002c0	26 00 00 00	 DD	 $L21733
  002c4	a2 01 00 00	 DD	 $L21781
AdapterQuery ENDP
_TEXT	ENDS
PUBLIC	AdapterModify
EXTRN	__imp_KeAcquireSpinLockRaiseToDpc:NEAR
EXTRN	__imp_KeReleaseSpinLock:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterModify DD 070d01H
	DD	0e009620dH
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterModify DD @imagerel(AdapterModify#)
	DD	@imagerel(AdapterModify#+681)
	DD	@imagerel($unwind$AdapterModify#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AdapterModify
_TEXT	SEGMENT
tv192 = 32
p_AdapterContext$ = 112
p_OID$ = 120
p_Buffer$ = 128
p_BufferLength$ = 136
p_BytesRead$ = 144
p_BytesNeeded$ = 152
AdapterModify PROC NEAR					; COMDAT

; 1223 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	4d 8b e0	 mov	 r12, r8
  00010	48 8b f1	 mov	 rsi, rcx

; 1224 :   TapAdapterQueryPointer l_Query = (TapAdapterQueryPointer) p_Buffer;
; 1225 :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 1226 :   NDIS_STATUS l_Status = NDIS_STATUS_INVALID_OID;
; 1227 :   ULONG l_Long;
; 1228 : 
; 1229 :   switch (p_OID)

  00013	b8 19 01 01 00	 mov	 eax, 65817		; 00010119H
  00018	3b d0		 cmp	 edx, eax
  0001a	0f 87 cf 00 00
	00		 ja	 $L23153
  00020	74 1a		 je	 SHORT $L21853
  00022	81 ea 0e 01 01
	00		 sub	 edx, 65806		; 0001010eH
  00028	0f 84 92 00 00
	00		 je	 $L21830
  0002e	83 ea 01	 sub	 edx, 1
  00031	74 24		 je	 SHORT $L21837
  00033	83 ea 09	 sub	 edx, 9
  00036	0f 85 db 00 00
	00		 jne	 $L21889
$L21853:

; 1298 : 	}
; 1299 :       break;
; 1300 : 
; 1301 :     case OID_GEN_NETWORK_LAYER_ADDRESSES:
; 1302 :       l_Status = NDIS_STATUS_SUCCESS;

  0003c	33 c9		 xor	 ecx, ecx

; 1303 :       *p_BytesRead = *p_BytesNeeded = 0;

  0003e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  00046	89 08		 mov	 DWORD PTR [rax], ecx
  00048	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  00050	89 08		 mov	 DWORD PTR [rax], ecx

; 1304 :       break;

  00052	e9 40 02 00 00	 jmp	 $L23162
$L21837:

; 1279 : 
; 1280 :     case OID_GEN_CURRENT_LOOKAHEAD:
; 1281 :       if (p_BufferLength < sizeof (ULONG))

  00057	41 83 f9 04	 cmp	 r9d, 4
  0005b	73 26		 jae	 SHORT $L21839

; 1282 : 	{
; 1283 : 	  l_Status = NDIS_STATUS_INVALID_LENGTH;

  0005d	ba 14 00 01 c0	 mov	 edx, -1073676268	; c0010014H

; 1284 : 	  *p_BytesNeeded = 4;

  00062	41 b8 04 00 00
	00		 mov	 r8d, 4
  00068	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  00070	44 89 00	 mov	 DWORD PTR [rax], r8d

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  00073	8b c2		 mov	 eax, edx

; 1392 : }

  00075	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00079	41 5e		 pop	 r14
  0007b	41 5d		 pop	 r13
  0007d	41 5c		 pop	 r12
  0007f	5f		 pop	 rdi
  00080	5e		 pop	 rsi
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$L21839:

; 1285 : 	}
; 1286 :       else if (l_Query->m_Long > DEFAULT_PACKET_LOOKAHEAD
; 1287 : 	       || l_Query->m_Long <= 0)

  00083	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  00087	3d ea 05 00 00	 cmp	 eax, 1514		; 000005eaH
  0008c	77 1d		 ja	 SHORT $L21844
  0008e	85 c0		 test	 eax, eax
  00090	76 19		 jbe	 SHORT $L21844

; 1290 : 	}
; 1291 :       else
; 1292 : 	{
; 1293 : 	  DEBUGP (("[%s] Setting [OID_GEN_CURRENT_LOOKAHEAD] to [%d]\n",
; 1294 : 		   NAME (l_Adapter), l_Query->m_Long));
; 1295 : 	  l_Adapter->m_Lookahead = l_Query->m_Long;

  00092	89 46 3c	 mov	 DWORD PTR [rsi+60], eax

; 1296 : 	  l_Status = NDIS_STATUS_SUCCESS;
; 1297 : 	  *p_BytesRead = sizeof (ULONG);

  00095	41 b8 04 00 00
	00		 mov	 r8d, 4
  0009b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  000a3	44 89 00	 mov	 DWORD PTR [rax], r8d
  000a6	e9 ea 01 00 00	 jmp	 $L23163
$L21844:

; 1288 : 	{
; 1289 : 	  l_Status = NDIS_STATUS_INVALID_DATA;

  000ab	ba 15 00 01 c0	 mov	 edx, -1073676267	; c0010015H

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  000b0	8b c2		 mov	 eax, edx

; 1392 : }

  000b2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b6	41 5e		 pop	 r14
  000b8	41 5d		 pop	 r13
  000ba	41 5c		 pop	 r12
  000bc	5f		 pop	 rdi
  000bd	5e		 pop	 rsi
  000be	5b		 pop	 rbx
  000bf	c3		 ret	 0
$L21830:

; 1263 : 	}
; 1264 :       break;
; 1265 : 
; 1266 :     case OID_GEN_CURRENT_PACKET_FILTER:
; 1267 :       l_Status = NDIS_STATUS_INVALID_LENGTH;

  000c0	ba 14 00 01 c0	 mov	 edx, -1073676268	; c0010014H

; 1268 :       *p_BytesNeeded = 4;

  000c5	41 b8 04 00 00
	00		 mov	 r8d, 4
  000cb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  000d3	44 89 00	 mov	 DWORD PTR [rax], r8d

; 1269 : 
; 1270 :       if (p_BufferLength >= sizeof (ULONG))

  000d6	45 3b c8	 cmp	 r9d, r8d
  000d9	0f 82 ba 01 00
	00		 jb	 $L21825

; 1271 : 	{
; 1272 : 	  DEBUGP
; 1273 : 	    (("[%s] Setting [OID_GEN_CURRENT_PACKET_FILTER] to [0x%02lx]\n",
; 1274 : 	      NAME (l_Adapter), l_Query->m_Long));
; 1275 : 	  l_Status = NDIS_STATUS_SUCCESS;
; 1276 : 	  *p_BytesRead = sizeof (ULONG);

  000df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  000e7	44 89 00	 mov	 DWORD PTR [rax], r8d

; 1277 : 	}
; 1278 :       break;

  000ea	e9 a6 01 00 00	 jmp	 $L23163
$L23153:

; 1224 :   TapAdapterQueryPointer l_Query = (TapAdapterQueryPointer) p_Buffer;
; 1225 :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 1226 :   NDIS_STATUS l_Status = NDIS_STATUS_INVALID_OID;
; 1227 :   ULONG l_Long;
; 1228 : 
; 1229 :   switch (p_OID)

  000ef	81 fa 03 01 01
	01		 cmp	 edx, 16843011		; 01010103H
  000f5	0f 84 e0 00 00
	00		 je	 $L21815
  000fb	81 fa 01 01 01
	fd		 cmp	 edx, -50265855		; fd010101H
  00101	74 3f		 je	 SHORT $L21857
  00103	81 fa 02 01 01
	fd		 cmp	 edx, -50265854		; fd010102H
  00109	76 0c		 jbe	 SHORT $L21889
  0010b	81 fa 04 01 01
	fd		 cmp	 edx, -50265852		; fd010104H

; 1374 : 	}
; 1375 :       break;
; 1376 : 
; 1377 :     case OID_PNP_REMOVE_WAKE_UP_PATTERN:
; 1378 :     case OID_PNP_ADD_WAKE_UP_PATTERN:
; 1379 :       l_Status = NDIS_STATUS_SUCCESS;
; 1380 :       *p_BytesRead = *p_BytesNeeded = 0;
; 1381 :       break;

  00111	0f 86 25 ff ff
	ff		 jbe	 $L21853
$L21889:

; 1382 : 
; 1383 :     default:
; 1384 :       DEBUGP (("[%s] Can't set value for OID %lx\n", NAME (l_Adapter),
; 1385 : 	       p_OID));
; 1386 :       l_Status = NDIS_STATUS_INVALID_OID;

  00117	ba 17 00 01 c0	 mov	 edx, -1073676265	; c0010017H

; 1387 :       *p_BytesRead = *p_BytesNeeded = 0;

  0011c	33 c9		 xor	 ecx, ecx
  0011e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  00126	89 08		 mov	 DWORD PTR [rax], ecx
  00128	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  00130	89 08		 mov	 DWORD PTR [rax], ecx

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  00132	8b c2		 mov	 eax, edx

; 1392 : }

  00134	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00138	41 5e		 pop	 r14
  0013a	41 5d		 pop	 r13
  0013c	41 5c		 pop	 r12
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	5b		 pop	 rbx
  00141	c3		 ret	 0
$L21857:

; 1305 : 
; 1306 :     case OID_GEN_TRANSPORT_HEADER_OFFSET:
; 1307 :       l_Status = NDIS_STATUS_SUCCESS;
; 1308 :       *p_BytesRead = *p_BytesNeeded = 0;
; 1309 :       break;
; 1310 : 
; 1311 :     case OID_PNP_SET_POWER:
; 1312 :       do
; 1313 : 	{
; 1314 : 	  NDIS_DEVICE_POWER_STATE NewDeviceState;
; 1315 : 
; 1316 : 	  NewDeviceState = (*(PNDIS_DEVICE_POWER_STATE) p_Buffer);

  00142	41 8b 0c 24	 mov	 ecx, DWORD PTR [r12]

; 1317 : 
; 1318 : 	  switch (NewDeviceState)

  00146	8b c1		 mov	 eax, ecx
  00148	83 e8 01	 sub	 eax, 1
  0014b	74 27		 je	 SHORT $L21866
  0014d	83 e8 01	 sub	 eax, 1
  00150	74 1c		 je	 SHORT $L21867
  00152	83 e8 01	 sub	 eax, 1
  00155	74 11		 je	 SHORT $L21868
  00157	83 e8 01	 sub	 eax, 1
  0015a	74 06		 je	 SHORT $L21869

; 1332 : 	    default:
; 1333 : 	      l_Adapter->m_DeviceState = '?';

  0015c	c6 46 46 3f	 mov	 BYTE PTR [rsi+70], 63	; 0000003fH

; 1334 : 	      break;

  00160	eb 16		 jmp	 SHORT $L21863
$L21869:

; 1329 : 	    case NdisDeviceStateD3:
; 1330 : 	      l_Adapter->m_DeviceState = '3';

  00162	c6 46 46 33	 mov	 BYTE PTR [rsi+70], 51	; 00000033H

; 1331 : 	      break;

  00166	eb 10		 jmp	 SHORT $L21863
$L21868:

; 1326 : 	    case NdisDeviceStateD2:
; 1327 : 	      l_Adapter->m_DeviceState = '2';

  00168	c6 46 46 32	 mov	 BYTE PTR [rsi+70], 50	; 00000032H

; 1328 : 	      break;

  0016c	eb 0a		 jmp	 SHORT $L21863
$L21867:

; 1322 : 	      break;
; 1323 : 	    case NdisDeviceStateD1:
; 1324 : 	      l_Adapter->m_DeviceState = '1';

  0016e	c6 46 46 31	 mov	 BYTE PTR [rsi+70], 49	; 00000031H

; 1325 : 	      break;

  00172	eb 04		 jmp	 SHORT $L21863
$L21866:

; 1319 : 	    {
; 1320 : 	    case NdisDeviceStateD0:
; 1321 : 	      l_Adapter->m_DeviceState = '0';

  00174	c6 46 46 30	 mov	 BYTE PTR [rsi+70], 48	; 00000030H
$L21863:

; 1335 : 	    }
; 1336 : 
; 1337 : 	  l_Status = NDIS_STATUS_FAILURE;
; 1338 : 
; 1339 : 	  //
; 1340 : 	  // Check for invalid length
; 1341 : 	  //
; 1342 : 	  if (p_BufferLength < sizeof (NDIS_DEVICE_POWER_STATE))

  00178	41 83 f9 04	 cmp	 r9d, 4
  0017c	73 32		 jae	 SHORT $L21874

; 1343 : 	    {
; 1344 : 	      l_Status = NDIS_STATUS_INVALID_LENGTH;

  0017e	ba 14 00 01 c0	 mov	 edx, -1073676268	; c0010014H

; 1371 : 	{
; 1372 : 	  *p_BytesRead = 0;

  00183	33 c9		 xor	 ecx, ecx
  00185	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  0018d	89 08		 mov	 DWORD PTR [rax], ecx

; 1373 : 	  *p_BytesNeeded = sizeof (NDIS_DEVICE_POWER_STATE);

  0018f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00195	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  0019d	44 89 00	 mov	 DWORD PTR [rax], r8d

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  001a0	8b c2		 mov	 eax, edx

; 1392 : }

  001a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a6	41 5e		 pop	 r14
  001a8	41 5d		 pop	 r13
  001aa	41 5c		 pop	 r12
  001ac	5f		 pop	 rdi
  001ad	5e		 pop	 rsi
  001ae	5b		 pop	 rbx
  001af	c3		 ret	 0
$L21874:

; 1345 : 	      break;
; 1346 : 	    }
; 1347 : 
; 1348 : 	  if (NewDeviceState > NdisDeviceStateD0)

  001b0	83 f9 01	 cmp	 ecx, 1
  001b3	0f 9e c0	 setle	 al
  001b6	88 46 16	 mov	 BYTE PTR [rsi+22], al

; 1349 : 	    {
; 1350 : 	      l_Adapter->m_InterfaceIsRunning = FALSE;
; 1351 : 	      DEBUGP (("[%s] Power management device state OFF\n",
; 1352 : 		       NAME (l_Adapter)));
; 1353 : 	    }
; 1354 : 	  else
; 1355 : 	    {
; 1356 : 	      l_Adapter->m_InterfaceIsRunning = TRUE;
; 1357 : 	      DEBUGP (("[%s] Power management device state ON\n",
; 1358 : 		       NAME (l_Adapter)));
; 1359 : 	    }
; 1360 : 
; 1361 : 	  l_Status = NDIS_STATUS_SUCCESS;

  001b9	33 c9		 xor	 ecx, ecx

; 1362 : 	}
; 1363 :       while (FALSE);
; 1364 : 
; 1365 :       if (l_Status == NDIS_STATUS_SUCCESS)
; 1366 : 	{
; 1367 : 	  *p_BytesRead = sizeof (NDIS_DEVICE_POWER_STATE);

  001bb	41 b8 04 00 00
	00		 mov	 r8d, 4
  001c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  001c9	44 89 00	 mov	 DWORD PTR [rax], r8d

; 1368 : 	  *p_BytesNeeded = 0;

  001cc	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p_BytesNeeded$[rsp]
  001d4	89 08		 mov	 DWORD PTR [rax], ecx

; 1369 : 	}
; 1370 :       else

  001d6	e9 bc 00 00 00	 jmp	 $L23162
$L21815:

; 1230 :     {
; 1231 :       //==================================================================
; 1232 :       //                            Device Info
; 1233 :       //==================================================================
; 1234 :     case OID_802_3_MULTICAST_LIST:
; 1235 :       DEBUGP (("[%s] Setting [OID_802_3_MULTICAST_LIST]\n",
; 1236 : 	       NAME (l_Adapter)));
; 1237 : 
; 1238 :       *p_BytesNeeded = sizeof (ETH_ADDR);

  001db	41 b8 06 00 00
	00		 mov	 r8d, 6
  001e1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p_BytesNeeded$[rsp]
  001e9	44 89 01	 mov	 DWORD PTR [rcx], r8d

; 1239 :       *p_BytesRead = p_BufferLength;

  001ec	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR p_BytesRead$[rsp]
  001f4	44 89 08	 mov	 DWORD PTR [rax], r9d

; 1240 : 
; 1241 :       if (p_BufferLength % sizeof (ETH_ADDR))

  001f7	45 8b e9	 mov	 r13d, r9d
  001fa	33 d2		 xor	 edx, edx
  001fc	49 8b c5	 mov	 rax, r13
  001ff	49 f7 f0	 div	 r8
  00202	48 89 44 24 20	 mov	 QWORD PTR tv192[rsp], rax
  00207	48 85 d2	 test	 rdx, rdx
  0020a	74 15		 je	 SHORT $L21818

; 1242 : 	l_Status = NDIS_STATUS_INVALID_LENGTH;

  0020c	ba 14 00 01 c0	 mov	 edx, -1073676268	; c0010014H

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  00211	8b c2		 mov	 eax, edx

; 1392 : }

  00213	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00217	41 5e		 pop	 r14
  00219	41 5d		 pop	 r13
  0021b	41 5c		 pop	 r12
  0021d	5f		 pop	 rdi
  0021e	5e		 pop	 rsi
  0021f	5b		 pop	 rbx
  00220	c3		 ret	 0
$L21818:

; 1243 :       else if (p_BufferLength > sizeof (MC_LIST))

  00221	41 be c0 00 00
	00		 mov	 r14d, 192		; 000000c0H
  00227	45 3b ce	 cmp	 r9d, r14d
  0022a	76 18		 jbe	 SHORT $L21822

; 1244 : 	{
; 1245 : 	  l_Status = NDIS_STATUS_MULTICAST_FULL;

  0022c	ba 09 00 01 c0	 mov	 edx, -1073676279	; c0010009H

; 1246 : 	  *p_BytesNeeded = sizeof (MC_LIST);

  00231	44 89 31	 mov	 DWORD PTR [rcx], r14d

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  00234	8b c2		 mov	 eax, edx

; 1392 : }

  00236	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0023a	41 5e		 pop	 r14
  0023c	41 5d		 pop	 r13
  0023e	41 5c		 pop	 r12
  00240	5f		 pop	 rdi
  00241	5e		 pop	 rsi
  00242	5b		 pop	 rbx
  00243	c3		 ret	 0
$L21822:

; 1247 : 	}
; 1248 :       else
; 1249 : 	{
; 1250 : 	  NdisAcquireSpinLock (&l_Adapter->m_MCLock);

  00244	48 8d be a0 01
	00 00		 lea	 rdi, QWORD PTR [rsi+416]
  0024b	48 8b cf	 mov	 rcx, rdi
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00254	88 86 a8 01 00
	00		 mov	 BYTE PTR [rsi+424], al

; 1251 : 
; 1252 : 	  NdisZeroMemory(&l_Adapter->m_MCList, sizeof (MC_LIST));

  0025a	48 8d 9e b8 01
	00 00		 lea	 rbx, QWORD PTR [rsi+440]
  00261	49 8b d6	 mov	 rdx, r14
  00264	48 8b cb	 mov	 rcx, rbx
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 1253 :         
; 1254 : 	  NdisMoveMemory(&l_Adapter->m_MCList,
; 1255 : 			 p_Buffer,
; 1256 : 			 p_BufferLength);

  0026d	4d 8b c5	 mov	 r8, r13
  00270	49 8b d4	 mov	 rdx, r12
  00273	48 8b cb	 mov	 rcx, rbx
  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1257 : 
; 1258 : 	  l_Adapter->m_MCListSize = p_BufferLength / sizeof (ETH_ADDR);

  0027c	8b 44 24 20	 mov	 eax, DWORD PTR tv192[rsp]
  00280	89 86 b4 01 00
	00		 mov	 DWORD PTR [rsi+436], eax

; 1259 :         
; 1260 : 	  NdisReleaseSpinLock (&l_Adapter->m_MCLock);

  00286	8a 96 a8 01 00
	00		 mov	 dl, BYTE PTR [rsi+424]
  0028c	48 8b cf	 mov	 rcx, rdi
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock
$L23163:

; 1261 : 
; 1262 : 	  l_Status = NDIS_STATUS_SUCCESS;

  00295	33 c9		 xor	 ecx, ecx
$L23162:
  00297	8b d1		 mov	 edx, ecx
$L21825:

; 1388 :       break;
; 1389 :     }
; 1390 : 
; 1391 :   return l_Status;

  00299	8b c2		 mov	 eax, edx

; 1392 : }

  0029b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0029f	41 5e		 pop	 r14
  002a1	41 5d		 pop	 r13
  002a3	41 5c		 pop	 r12
  002a5	5f		 pop	 rdi
  002a6	5e		 pop	 rsi
  002a7	5b		 pop	 rbx
  002a8	c3		 ret	 0
AdapterModify ENDP
_TEXT	ENDS
PUBLIC	CompleteIRP
EXTRN	__imp_IofCompleteRequest:NEAR
;	COMDAT CompleteIRP
CompleteIRP	SEGMENT
$SG22312 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
CompleteIRP	ENDS
;	COMDAT CompleteIRP
CompleteIRP	SEGMENT
$SG22308 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
CompleteIRP	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompleteIRP DD 041609H
	DD	070125216H
	DD	030106011H
	DD	@imagerel(__C_specific_handler#)
	DD	02H
	DD	@imagerel(CompleteIRP#+109)
	DD	@imagerel(CompleteIRP#+132)
	DD	@imagerel(CompleteIRP$filt$0#)
	DD	@imagerel(CompleteIRP#+132)
	DD	@imagerel(CompleteIRP#+222)
	DD	@imagerel(CompleteIRP#+247)
	DD	@imagerel(CompleteIRP$filt$1#)
	DD	@imagerel(CompleteIRP#+247)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompleteIRP DD @imagerel(CompleteIRP#)
	DD	@imagerel(CompleteIRP#+297)
	DD	@imagerel($unwind$CompleteIRP#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompleteIRP$filt$1 DD 050801H
	DD	050044208H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompleteIRP$filt$1 DD @imagerel(CompleteIRP$filt$1#)
	DD	@imagerel(CompleteIRP$filt$1#+25)
	DD	@imagerel($unwind$CompleteIRP$filt$1#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CompleteIRP$filt$0 DD 050801H
	DD	050044208H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CompleteIRP$filt$0 DD @imagerel(CompleteIRP$filt$0#)
	DD	@imagerel(CompleteIRP$filt$0#+25)
	DD	@imagerel($unwind$CompleteIRP$filt$0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT CompleteIRP
_TEXT	SEGMENT
l_Status$ = 32
p_IRP$ = 80
p_PacketBuffer$ = 88
PriorityBoost$ = 96
CompleteIRP PROC NEAR					; COMDAT

; 2371 : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00016	48 8b f2	 mov	 rsi, rdx
  00019	48 8b d9	 mov	 rbx, rcx

; 2372 :   NTSTATUS l_Status = STATUS_UNSUCCESSFUL;

  0001c	bf 01 00 00 c0	 mov	 edi, -1073741823	; c0000001H
  00021	89 7c 24 20	 mov	 DWORD PTR l_Status$[rsp], edi

; 2373 : 
; 2374 :   int offset;
; 2375 :   int len;
; 2376 : 
; 2377 :   MYASSERT (p_IRP);
; 2378 :   MYASSERT (p_PacketBuffer);
; 2379 : 
; 2380 :   IoSetCancelRoutine (p_IRP, NULL);  // Disable cancel routine

  00025	45 33 c0	 xor	 r8d, r8d
  00028	49 8b c0	 mov	 rax, r8
  0002b	48 87 43 68	 xchg	 QWORD PTR [rbx+104], rax

; 2381 : 
; 2382 :   //-------------------------------------------
; 2383 :   // While p_PacketBuffer always contains a
; 2384 :   // full ethernet packet, including the
; 2385 :   // ethernet header, in point-to-point mode,
; 2386 :   // we only want to return the IPv4
; 2387 :   // component.
; 2388 :   //-------------------------------------------
; 2389 : 
; 2390 :   if (p_PacketBuffer->m_SizeFlags & TP_TUN)

  0002f	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  00031	8b c1		 mov	 eax, ecx
  00033	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00038	74 0f		 je	 SHORT $L22299

; 2391 :     {
; 2392 :       offset = ETHERNET_HEADER_SIZE;

  0003a	b8 0e 00 00 00	 mov	 eax, 14			; 0000000eH

; 2393 :       len = (int) (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK) - ETHERNET_HEADER_SIZE;

  0003f	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
  00045	2b c8		 sub	 ecx, eax

; 2394 :     }
; 2395 :   else

  00047	eb 09		 jmp	 SHORT $L22303
$L22299:

; 2396 :     {
; 2397 :       offset = 0;

  00049	41 8b c0	 mov	 eax, r8d

; 2398 :       len = (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK);

  0004c	81 e1 ff ff ff
	7f		 and	 ecx, 2147483647		; 7fffffffH
$L22303:

; 2399 :     }
; 2400 : 
; 2401 :   if (len < 0 || (int) p_IRP->IoStatus.Information < len)

  00052	85 c9		 test	 ecx, ecx
  00054	7c 65		 jl	 SHORT $L22306
  00056	39 4b 38	 cmp	 DWORD PTR [rbx+56], ecx
  00059	7c 60		 jl	 SHORT $L22306

; 2406 :     }
; 2407 :   else
; 2408 :     {
; 2409 :       p_IRP->IoStatus.Information = len;

  0005b	48 63 c9	 movsxd	 rcx, ecx
  0005e	48 89 4b 38	 mov	 QWORD PTR [rbx+56], rcx

; 2410 :       p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;

  00062	41 8b f8	 mov	 edi, r8d
  00065	89 7c 24 20	 mov	 DWORD PTR l_Status$[rsp], edi
  00069	44 89 43 30	 mov	 DWORD PTR [rbx+48], r8d

; 2411 : 
; 2412 :       __try
; 2413 : 	{
; 2414 : 	  NdisMoveMemory (p_IRP->AssociatedIrp.SystemBuffer,
; 2415 : 			  p_PacketBuffer->m_Data + offset,
; 2416 : 			  len);

  0006d	48 63 c0	 movsxd	 rax, eax
  00070	48 8d 54 30 04	 lea	 rdx, QWORD PTR [rax+rsi+4]
  00075	4c 8b c1	 mov	 r8, rcx
  00078	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory
  00082	eb 5a		 jmp	 SHORT $L23174
$L23171:
$L23172:

; 2417 : 	}
; 2418 :       __except (EXCEPTION_EXECUTE_HANDLER)
; 2419 : 	{
; 2420 : 	  NOTE_ERROR ();

  00084	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22312
  0008b	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00092	c7 05 00 00 00
	00 74 09 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2420 ; 00000974H

; 2421 : 	  p_IRP->IoStatus.Status = STATUS_UNSUCCESSFUL;

  0009c	bf 01 00 00 c0	 mov	 edi, -1073741823	; c0000001H
  000a1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR p_IRP$[rsp]
  000a6	89 7b 30	 mov	 DWORD PTR [rbx+48], edi

; 2422 : 	  p_IRP->IoStatus.Information = 0;

  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	4c 89 43 38	 mov	 QWORD PTR [rbx+56], r8
  000b0	48 8b 74 24 58	 mov	 rsi, QWORD PTR p_PacketBuffer$[rsp]
  000b5	8b 7c 24 20	 mov	 edi, DWORD PTR l_Status$[rsp]
  000b9	eb 23		 jmp	 SHORT $L23174
$L22306:

; 2402 :     {
; 2403 :       p_IRP->IoStatus.Information = 0;

  000bb	4c 89 43 38	 mov	 QWORD PTR [rbx+56], r8

; 2404 :       p_IRP->IoStatus.Status = STATUS_BUFFER_OVERFLOW;

  000bf	c7 43 30 05 00
	00 80		 mov	 DWORD PTR [rbx+48], -2147483643 ; 80000005H

; 2405 :       NOTE_ERROR ();

  000c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22308
  000cd	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  000d4	c7 05 00 00 00
	00 65 09 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2405 ; 00000965H
$L23174:

; 2423 : 	}
; 2424 :     }
; 2425 : 
; 2426 :   __try
; 2427 :     {
; 2428 :       NdisFreeMemory (p_PacketBuffer,
; 2429 : 		      TAP_PACKET_SIZE (p_PacketBuffer->m_SizeFlags & TP_SIZE_MASK),
; 2430 : 		      0);

  000de	8b 16		 mov	 edx, DWORD PTR [rsi]
  000e0	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  000e6	83 c2 04	 add	 edx, 4
  000e9	45 33 c0	 xor	 r8d, r8d
  000ec	48 8b ce	 mov	 rcx, rsi
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisFreeMemory
  000f5	eb 09		 jmp	 SHORT $L23178
$L23175:
$L23176:

; 2431 :     }
; 2432 :   __except (EXCEPTION_EXECUTE_HANDLER)

  000f7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR p_IRP$[rsp]
  000fc	8b 7c 24 20	 mov	 edi, DWORD PTR l_Status$[rsp]
$L23178:

; 2433 :     {
; 2434 :     }
; 2435 :   
; 2436 :   if (l_Status == STATUS_SUCCESS)

  00100	85 ff		 test	 edi, edi
  00102	75 10		 jne	 SHORT $L22317

; 2437 :     {
; 2438 :       IoCompleteRequest (p_IRP, PriorityBoost);

  00104	0f b6 54 24 60	 movzx	 edx, BYTE PTR PriorityBoost$[rsp]
  00109	48 8b cb	 mov	 rcx, rbx
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2439 :     }
; 2440 :   else

  00112	eb 0b		 jmp	 SHORT $L22318
$L22317:

; 2441 :     IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00114	32 d2		 xor	 dl, dl
  00116	48 8b cb	 mov	 rcx, rbx
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
$L22318:

; 2442 : 
; 2443 :   return l_Status;

  0011f	8b c7		 mov	 eax, edi
$L22288:

; 2444 : }

  00121	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	5b		 pop	 rbx
  00128	c3		 ret	 0
CompleteIRP ENDP
; Function compile flags: /Ogty
l_Status$ = 32
p_IRP$ = 80
p_PacketBuffer$ = 88
PriorityBoost$ = 96
CompleteIRP$filt$1 PROC NEAR
  00130	53		 push	 rbx
  00131	56		 push	 rsi
  00132	57		 push	 rdi
  00133	55		 push	 rbp
  00134	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00138	48 8b ea	 mov	 rbp, rdx

; 2432 :   __except (EXCEPTION_EXECUTE_HANDLER)

  0013b	b8 01 00 00 00	 mov	 eax, 1
$L23177:
  00140	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00144	5d		 pop	 rbp
  00145	5f		 pop	 rdi
  00146	5e		 pop	 rsi
  00147	5b		 pop	 rbx
  00148	c3		 ret	 0
CompleteIRP$filt$1 ENDP
; Function compile flags: /Ogty
l_Status$ = 32
p_IRP$ = 80
p_PacketBuffer$ = 88
PriorityBoost$ = 96
CompleteIRP$filt$0 PROC NEAR
  00150	53		 push	 rbx
  00151	56		 push	 rsi
  00152	57		 push	 rdi
  00153	55		 push	 rbp
  00154	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00158	48 8b ea	 mov	 rbp, rdx

; 2418 :       __except (EXCEPTION_EXECUTE_HANDLER)

  0015b	b8 01 00 00 00	 mov	 eax, 1
$L23173:
  00160	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00164	5d		 pop	 rbp
  00165	5f		 pop	 rdi
  00166	5e		 pop	 rsi
  00167	5b		 pop	 rbx
  00168	c3		 ret	 0
CompleteIRP$filt$0 ENDP
_TEXT	ENDS
PUBLIC	CancelIRP
EXTRN	__imp_IoReleaseCancelSpinLock:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$CancelIRP DD 060b01H
	DD	0d007320bH
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CancelIRP DD @imagerel(CancelIRP#)
	DD	@imagerel(CancelIRP#+152)
	DD	@imagerel($unwind$CancelIRP#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT CancelIRP
_TEXT	SEGMENT
p_Extension$ = 80
p_IRP$ = 88
callback$ = 96
CancelIRP PROC NEAR					; COMDAT

; 2468 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000b	45 0f b6 e8	 movzx	 r13d, r8b
  0000f	48 8b fa	 mov	 rdi, rdx
  00012	4c 8b e1	 mov	 r12, rcx

; 2469 :   BOOLEAN exists = FALSE;
; 2470 : 
; 2471 :   MYASSERT (p_IRP);
; 2472 : 
; 2473 :   if (p_Extension)

  00015	4d 85 e4	 test	 r12, r12
  00018	74 79		 je	 SHORT $L22334

; 2474 :     {
; 2475 :       NdisAcquireSpinLock (&p_Extension->m_QueueLock);

  0001a	49 8d 5c 24 28	 lea	 rbx, QWORD PTR [r12+40]
  0001f	48 8b cb	 mov	 rcx, rbx
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00028	41 88 44 24 30	 mov	 BYTE PTR [r12+48], al

; 2476 :       exists = (QueueExtract (p_Extension->m_IrpQueue, p_IRP) == p_IRP);

  0002d	48 8b d7	 mov	 rdx, rdi
  00030	49 8b 4c 24 08	 mov	 rcx, QWORD PTR [r12+8]
  00035	e8 00 00 00 00	 call	 QueueExtract
  0003a	48 3b c7	 cmp	 rax, rdi
  0003d	40 0f 94 c6	 sete	 sil

; 2477 :       NdisReleaseSpinLock (&p_Extension->m_QueueLock);

  00041	41 8a 54 24 30	 mov	 dl, BYTE PTR [r12+48]
  00046	48 8b cb	 mov	 rcx, rbx
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2481 : 
; 2482 :   if (exists)

  0004f	40 84 f6	 test	 sil, sil
  00052	74 15		 je	 SHORT $L22336
$L23202:

; 2483 :     {
; 2484 :       IoSetCancelRoutine (p_IRP, NULL);

  00054	33 c0		 xor	 eax, eax
  00056	48 87 47 68	 xchg	 QWORD PTR [rdi+104], rax

; 2485 :       p_IRP->IoStatus.Status = STATUS_CANCELLED;

  0005a	c7 47 30 20 01
	00 c0		 mov	 DWORD PTR [rdi+48], -1073741536 ; c0000120H

; 2486 :       p_IRP->IoStatus.Information = 0;

  00061	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$L22336:

; 2487 :     }
; 2488 :      
; 2489 :   if (callback)

  00069	45 84 ed	 test	 r13b, r13b
  0006c	74 09		 je	 SHORT $L22344

; 2490 :     IoReleaseCancelSpinLock (p_IRP->CancelIrql);

  0006e	8a 4f 45	 mov	 cl, BYTE PTR [rdi+69]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoReleaseCancelSpinLock
$L22344:

; 2491 : 
; 2492 :   if (exists)

  00077	40 84 f6	 test	 sil, sil
  0007a	74 0b		 je	 SHORT $L22345

; 2493 :     IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  0007c	32 d2		 xor	 dl, dl
  0007e	48 8b cf	 mov	 rcx, rdi
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
$L22345:

; 2494 : }

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	41 5d		 pop	 r13
  0008d	41 5c		 pop	 r12
  0008f	5f		 pop	 rdi
  00090	5e		 pop	 rsi
  00091	5b		 pop	 rbx
  00092	c3		 ret	 0
$L22334:

; 2478 :     }
; 2479 :   else
; 2480 :     exists = TRUE;

  00093	40 b6 01	 mov	 sil, 1

; 2481 : 
; 2482 :   if (exists)

  00096	eb bc		 jmp	 SHORT $L23202
CancelIRP ENDP
_TEXT	ENDS
PUBLIC	FlushQueues
;	COMDAT xdata
xdata	SEGMENT
$unwind$FlushQueues DD 050901H
	DD	0c0054209H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$FlushQueues DD @imagerel(FlushQueues#)
	DD	@imagerel(FlushQueues#+223)
	DD	@imagerel($unwind$FlushQueues#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT FlushQueues
_TEXT	SEGMENT
p_Extension$ = 80
FlushQueues PROC NEAR					; COMDAT

; 2501 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b d9	 mov	 rbx, rcx

; 2502 :   PIRP l_IRP;
; 2503 :   TapPacketPointer l_PacketBuffer;
; 2504 :   int n_IRP=0, n_Packet=0;
; 2505 : 
; 2506 :   MYASSERT (p_Extension);
; 2507 :   MYASSERT (p_Extension->m_TapDevice);
; 2508 : 
; 2509 :   while (TRUE)
; 2510 :     {
; 2511 :       NdisAcquireSpinLock (&p_Extension->m_QueueLock);

  0000c	48 8d 7b 28	 lea	 rdi, QWORD PTR [rbx+40]
  00010	48 8b cf	 mov	 rcx, rdi
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00019	88 43 30	 mov	 BYTE PTR [rbx+48], al

; 2512 :       l_IRP = QueuePop (p_Extension->m_IrpQueue);

  0001c	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00020	e8 00 00 00 00	 call	 QueuePop
  00025	48 8b f0	 mov	 rsi, rax

; 2513 :       NdisReleaseSpinLock (&p_Extension->m_QueueLock);

  00028	8a 53 30	 mov	 dl, BYTE PTR [rbx+48]
  0002b	48 8b cf	 mov	 rcx, rdi
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2514 :       if (l_IRP)

  00034	48 85 f6	 test	 rsi, rsi
  00037	74 36		 je	 SHORT $L22356
$L22354:

; 2515 : 	{
; 2516 : 	  ++n_IRP;
; 2517 : 	  CancelIRP (NULL, l_IRP, FALSE);

  00039	45 32 c0	 xor	 r8b, r8b
  0003c	48 8b d6	 mov	 rdx, rsi
  0003f	33 c9		 xor	 ecx, ecx
  00041	e8 00 00 00 00	 call	 CancelIRP

; 2502 :   PIRP l_IRP;
; 2503 :   TapPacketPointer l_PacketBuffer;
; 2504 :   int n_IRP=0, n_Packet=0;
; 2505 : 
; 2506 :   MYASSERT (p_Extension);
; 2507 :   MYASSERT (p_Extension->m_TapDevice);
; 2508 : 
; 2509 :   while (TRUE)
; 2510 :     {
; 2511 :       NdisAcquireSpinLock (&p_Extension->m_QueueLock);

  00046	48 8b cf	 mov	 rcx, rdi
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  0004f	88 43 30	 mov	 BYTE PTR [rbx+48], al

; 2512 :       l_IRP = QueuePop (p_Extension->m_IrpQueue);

  00052	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00056	e8 00 00 00 00	 call	 QueuePop
  0005b	48 8b f0	 mov	 rsi, rax

; 2513 :       NdisReleaseSpinLock (&p_Extension->m_QueueLock);

  0005e	8a 53 30	 mov	 dl, BYTE PTR [rbx+48]
  00061	48 8b cf	 mov	 rcx, rdi
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2514 :       if (l_IRP)

  0006a	48 85 f6	 test	 rsi, rsi
  0006d	75 ca		 jne	 SHORT $L22354
$L22356:

; 2518 : 	}
; 2519 :       else
; 2520 : 	break;
; 2521 :     }
; 2522 : 
; 2523 :   while (TRUE)
; 2524 :     {
; 2525 :       NdisAcquireSpinLock (&p_Extension->m_QueueLock);

  0006f	48 8b cf	 mov	 rcx, rdi
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00078	88 43 30	 mov	 BYTE PTR [rbx+48], al

; 2526 :       l_PacketBuffer = QueuePop (p_Extension->m_PacketQueue);

  0007b	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0007e	e8 00 00 00 00	 call	 QueuePop
  00083	48 8b f0	 mov	 rsi, rax

; 2527 :       NdisReleaseSpinLock (&p_Extension->m_QueueLock);

  00086	8a 53 30	 mov	 dl, BYTE PTR [rbx+48]
  00089	48 8b cf	 mov	 rcx, rdi
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2528 :       if (l_PacketBuffer)

  00092	48 85 f6	 test	 rsi, rsi
  00095	74 3e		 je	 SHORT $L22362
  00097	41 bc ff ff ff
	7f		 mov	 r12d, 2147483647	; 7fffffffH
$L22360:

; 2529 : 	{
; 2530 : 	  ++n_Packet;
; 2531 : 	  MemFree (l_PacketBuffer, TAP_PACKET_SIZE (l_PacketBuffer->m_SizeFlags & TP_SIZE_MASK));

  0009d	8b 16		 mov	 edx, DWORD PTR [rsi]
  0009f	41 23 d4	 and	 edx, r12d
  000a2	83 c2 04	 add	 edx, 4
  000a5	48 8b ce	 mov	 rcx, rsi
  000a8	e8 00 00 00 00	 call	 MemFree

; 2518 : 	}
; 2519 :       else
; 2520 : 	break;
; 2521 :     }
; 2522 : 
; 2523 :   while (TRUE)
; 2524 :     {
; 2525 :       NdisAcquireSpinLock (&p_Extension->m_QueueLock);

  000ad	48 8b cf	 mov	 rcx, rdi
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  000b6	88 43 30	 mov	 BYTE PTR [rbx+48], al

; 2526 :       l_PacketBuffer = QueuePop (p_Extension->m_PacketQueue);

  000b9	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  000bc	e8 00 00 00 00	 call	 QueuePop
  000c1	48 8b f0	 mov	 rsi, rax

; 2527 :       NdisReleaseSpinLock (&p_Extension->m_QueueLock);

  000c4	8a 53 30	 mov	 dl, BYTE PTR [rbx+48]
  000c7	48 8b cf	 mov	 rcx, rdi
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2528 :       if (l_PacketBuffer)

  000d0	48 85 f6	 test	 rsi, rsi
  000d3	75 c8		 jne	 SHORT $L22360
$L22362:

; 2532 : 	}
; 2533 :       else
; 2534 : 	break;
; 2535 :     }
; 2536 : 
; 2537 :   DEBUGP ((
; 2538 : 	   "[%s] [TAP] FlushQueues n_IRP=[%d,%d,%d] n_Packet=[%d,%d,%d]\n",
; 2539 : 	   p_Extension->m_TapName,
; 2540 : 	   n_IRP,
; 2541 : 	   p_Extension->m_IrpQueue->max_size,
; 2542 : 	   IRP_QUEUE_SIZE,
; 2543 : 	   n_Packet,
; 2544 : 	   p_Extension->m_PacketQueue->max_size,
; 2545 : 	   PACKET_QUEUE_SIZE
; 2546 : 	   ));
; 2547 : }

  000d5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d9	41 5c		 pop	 r12
  000db	5f		 pop	 rdi
  000dc	5e		 pop	 rsi
  000dd	5b		 pop	 rbx
  000de	c3		 ret	 0
FlushQueues ENDP
_TEXT	ENDS
PUBLIC	SetMediaStatus
;	COMDAT xdata
xdata	SEGMENT
$unwind$SetMediaStatus DD 030601H
	DD	070024206H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SetMediaStatus DD @imagerel(SetMediaStatus#)
	DD	@imagerel(SetMediaStatus#+82)
	DD	@imagerel($unwind$SetMediaStatus#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SetMediaStatus
_TEXT	SEGMENT
p_Adapter$ = 64
state$ = 72
SetMediaStatus PROC NEAR				; COMDAT

; 2555 : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00006	0f b6 fa	 movzx	 edi, dl
  00009	48 8b d9	 mov	 rbx, rcx

; 2556 :   if (p_Adapter->m_MediaState != state && !p_Adapter->m_MediaStateAlwaysConnected)

  0000c	40 38 7b 45	 cmp	 BYTE PTR [rbx+69], dil
  00010	74 39		 je	 SHORT $L22370
  00012	80 7b 44 00	 cmp	 BYTE PTR [rbx+68], 0
  00016	75 33		 jne	 SHORT $L22370

; 2559 : 	NdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,
; 2560 : 			     NDIS_STATUS_MEDIA_CONNECT, NULL, 0);

  00018	45 33 c0	 xor	 r8d, r8d
  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00022	48 8b c8	 mov	 rcx, rax

; 2557 :     {
; 2558 :       if (state)

  00025	40 84 ff	 test	 dil, dil

; 2559 : 	NdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,
; 2560 : 			     NDIS_STATUS_MEDIA_CONNECT, NULL, 0);

  00028	ba 0b 00 01 40	 mov	 edx, 1073807371		; 4001000bH

; 2557 :     {
; 2558 :       if (state)

  0002d	75 05		 jne	 SHORT $L23226

; 2561 :       else
; 2562 : 	NdisMIndicateStatus (p_Adapter->m_MiniportAdapterHandle,
; 2563 : 			     NDIS_STATUS_MEDIA_DISCONNECT, NULL, 0);

  0002f	ba 0c 00 01 40	 mov	 edx, 1073807372		; 4001000cH
$L23226:
  00034	ff 90 b0 02 00
	00		 call	 QWORD PTR [rax+688]

; 2564 : 
; 2565 :       NdisMIndicateStatusComplete (p_Adapter->m_MiniportAdapterHandle);

  0003a	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0003e	48 8b c8	 mov	 rcx, rax
  00041	ff 90 b8 02 00
	00		 call	 QWORD PTR [rax+696]

; 2566 :       p_Adapter->m_MediaState = state;

  00047	40 88 7b 45	 mov	 BYTE PTR [rbx+69], dil
$L22370:

; 2567 :     }
; 2568 : }

  0004b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004f	5f		 pop	 rdi
  00050	5b		 pop	 rbx
  00051	c3		 ret	 0
SetMediaStatus ENDP
_TEXT	ENDS
PUBLIC	CheckIfDhcpAndTunMode
;	COMDAT xdata
xdata	SEGMENT
$unwind$CheckIfDhcpAndTunMode DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CheckIfDhcpAndTunMode DD @imagerel(CheckIfDhcpAndTunMode#)
	DD	@imagerel(CheckIfDhcpAndTunMode#+70)
	DD	@imagerel($unwind$CheckIfDhcpAndTunMode#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT CheckIfDhcpAndTunMode
_TEXT	SEGMENT
p_Adapter$ = 48
CheckIfDhcpAndTunMode PROC NEAR				; COMDAT

; 2578 : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b d9	 mov	 rbx, rcx

; 2579 :   if (p_Adapter->m_tun && p_Adapter->m_dhcp_enabled)

  00008	80 7b 47 00	 cmp	 BYTE PTR [rbx+71], 0
  0000c	74 32		 je	 SHORT $L22384
  0000e	80 7b 76 00	 cmp	 BYTE PTR [rbx+118], 0
  00012	74 2c		 je	 SHORT $L22384

; 2580 :     {
; 2581 :       if ((p_Adapter->m_dhcp_server_ip & p_Adapter->m_remoteNetmask) == p_Adapter->m_remoteNetwork)

  00014	8b 83 80 00 00
	00		 mov	 eax, DWORD PTR [rbx+128]
  0001a	23 43 50	 and	 eax, DWORD PTR [rbx+80]
  0001d	3b 43 4c	 cmp	 eax, DWORD PTR [rbx+76]
  00020	75 1e		 jne	 SHORT $L22384

; 2582 : 	{
; 2583 : 	  COPY_MAC (p_Adapter->m_dhcp_server_mac, p_Adapter->m_TapToUser.dest);

  00022	48 8d 53 54	 lea	 rdx, QWORD PTR [rbx+84]
  00026	48 8d 8b 85 00
	00 00		 lea	 rcx, QWORD PTR [rbx+133]
  0002d	41 b8 06 00 00
	00		 mov	 r8d, 6
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 2584 : 	  p_Adapter->m_dhcp_server_arp = FALSE;

  00039	c6 83 84 00 00
	00 00		 mov	 BYTE PTR [rbx+132], 0
$L22384:

; 2585 : 	}
; 2586 :     }
; 2587 : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
CheckIfDhcpAndTunMode ENDP
_TEXT	ENDS
PUBLIC	InjectPacket
;	COMDAT InjectPacket
InjectPacket	SEGMENT
$SG22444 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
InjectPacket	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InjectPacket DD 020509H
	DD	030017205H
	DD	@imagerel(__C_specific_handler#)
	DD	01H
	DD	@imagerel(InjectPacket#+8)
	DD	@imagerel(InjectPacket#+83)
	DD	@imagerel(InjectPacket$filt$0#)
	DD	@imagerel(InjectPacket#+83)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InjectPacket DD @imagerel(InjectPacket#)
	DD	@imagerel(InjectPacket#+113)
	DD	@imagerel($unwind$InjectPacket#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InjectPacket$filt$0 DD 030601H
	DD	050028206H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InjectPacket$filt$0 DD @imagerel(InjectPacket$filt$0#)
	DD	@imagerel(InjectPacket$filt$0#+21)
	DD	@imagerel($unwind$InjectPacket$filt$0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT InjectPacket
_TEXT	SEGMENT
p_Adapter$ = 80
packet$ = 88
len$ = 96
InjectPacket PROC NEAR					; COMDAT

; 2665 : {

  00000	53		 push	 rbx
  00001	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00005	48 8b d9	 mov	 rbx, rcx

; 2666 :   MYASSERT (len >= ETHERNET_HEADER_SIZE);
; 2667 : 
; 2668 :   __try
; 2669 :     {
; 2670 :       //------------------------------------------------------------
; 2671 :       // NdisMEthIndicateReceive and NdisMEthIndicateReceiveComplete
; 2672 :       // could potentially be called reentrantly both here and in
; 2673 :       // TapDeviceHook/IRP_MJ_WRITE.
; 2674 :       //
; 2675 :       // The DDK docs imply that this is okay.
; 2676 :       //------------------------------------------------------------
; 2677 :       NdisMEthIndicateReceive
; 2678 : 	(p_Adapter->m_MiniportAdapterHandle,
; 2679 : 	 (NDIS_HANDLE) p_Adapter,
; 2680 : 	 packet,
; 2681 : 	 ETHERNET_HEADER_SIZE,
; 2682 : 	 packet + ETHERNET_HEADER_SIZE,
; 2683 : 	 len - ETHERNET_HEADER_SIZE,
; 2684 : 	 len - ETHERNET_HEADER_SIZE);

  00008	4c 8b 53 18	 mov	 r10, QWORD PTR [rbx+24]
  0000c	41 8d 40 f2	 lea	 eax, DWORD PTR [r8-14]
  00010	4c 8d 42 0e	 lea	 r8, QWORD PTR [rdx+14]
  00014	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00018	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0001c	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  00021	c7 44 24 20 0e
	00 00 00	 mov	 DWORD PTR [rsp+32], 14	; 0000000eH
  00029	4c 8b ca	 mov	 r9, rdx
  0002c	4c 8b c2	 mov	 r8, rdx
  0002f	48 8b d3	 mov	 rdx, rbx
  00032	49 8b 8a 90 01
	00 00		 mov	 rcx, QWORD PTR [r10+400]
  00039	41 ff 92 80 02
	00 00		 call	 QWORD PTR [r10+640]

; 2685 :       
; 2686 :       NdisMEthIndicateReceiveComplete (p_Adapter->m_MiniportAdapterHandle);

  00040	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00044	48 8b 88 90 01
	00 00		 mov	 rcx, QWORD PTR [rax+400]
  0004b	ff 90 98 02 00
	00		 call	 QWORD PTR [rax+664]
  00051	eb 18		 jmp	 SHORT $L23244
$L23241:
$L23242:

; 2687 :     }
; 2688 :   __except (EXCEPTION_EXECUTE_HANDLER)
; 2689 :     {
; 2690 :       DEBUGP (("[%s] NdisMEthIndicateReceive failed in InjectPacket\n",
; 2691 : 	       NAME (p_Adapter)));
; 2692 :       NOTE_ERROR ();

  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22444
  0005a	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00061	c7 05 00 00 00
	00 84 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2692 ; 00000a84H
$L23244:

; 2693 :     }
; 2694 : }

  0006b	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
InjectPacket ENDP
; Function compile flags: /Ogty
p_Adapter$ = 80
packet$ = 88
len$ = 96
InjectPacket$filt$0 PROC NEAR
  00080	53		 push	 rbx
  00081	55		 push	 rbp
  00082	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00086	48 8b ea	 mov	 rbp, rdx

; 2688 :   __except (EXCEPTION_EXECUTE_HANDLER)

  00089	b8 01 00 00 00	 mov	 eax, 1
$L23243:
  0008e	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00092	5d		 pop	 rbp
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
InjectPacket$filt$0 ENDP
_TEXT	ENDS
PUBLIC	ResetTapAdapterState
;	COMDAT xdata
xdata	SEGMENT
$unwind$ResetTapAdapterState DD 040701H
	DD	070033207H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ResetTapAdapterState DD @imagerel(ResetTapAdapterState#)
	DD	@imagerel(ResetTapAdapterState#+130)
	DD	@imagerel($unwind$ResetTapAdapterState#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT ResetTapAdapterState
_TEXT	SEGMENT
p_Adapter$ = 64
ResetTapAdapterState PROC NEAR				; COMDAT

; 2701 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00007	48 8b d9	 mov	 rbx, rcx

; 2702 :   // Point-To-Point
; 2703 :   p_Adapter->m_tun = FALSE;

  0000a	c6 43 47 00	 mov	 BYTE PTR [rbx+71], 0

; 2704 :   p_Adapter->m_localIP = 0;

  0000e	33 f6		 xor	 esi, esi
  00010	89 73 48	 mov	 DWORD PTR [rbx+72], esi

; 2705 :   p_Adapter->m_remoteNetwork = 0;

  00013	89 73 4c	 mov	 DWORD PTR [rbx+76], esi

; 2706 :   p_Adapter->m_remoteNetmask = 0;

  00016	89 73 50	 mov	 DWORD PTR [rbx+80], esi

; 2707 :   NdisZeroMemory (&p_Adapter->m_TapToUser, sizeof (p_Adapter->m_TapToUser));

  00019	48 8d 4b 54	 lea	 rcx, QWORD PTR [rbx+84]
  0001d	bf 0e 00 00 00	 mov	 edi, 14			; 0000000eH
  00022	48 8b d7	 mov	 rdx, rdi
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2708 :   NdisZeroMemory (&p_Adapter->m_UserToTap, sizeof (p_Adapter->m_UserToTap));

  0002b	48 8d 4b 62	 lea	 rcx, QWORD PTR [rbx+98]
  0002f	48 8b d7	 mov	 rdx, rdi
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2709 : 
; 2710 :   // DHCP Masq
; 2711 :   p_Adapter->m_dhcp_enabled = FALSE;

  00038	40 88 73 76	 mov	 BYTE PTR [rbx+118], sil

; 2712 :   p_Adapter->m_dhcp_server_arp = FALSE;

  0003c	40 88 b3 84 00
	00 00		 mov	 BYTE PTR [rbx+132], sil

; 2713 :   p_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;

  00043	89 b3 90 01 00
	00		 mov	 DWORD PTR [rbx+400], esi

; 2714 :   p_Adapter->m_dhcp_addr = 0;

  00049	89 73 78	 mov	 DWORD PTR [rbx+120], esi

; 2715 :   p_Adapter->m_dhcp_netmask = 0;

  0004c	89 73 7c	 mov	 DWORD PTR [rbx+124], esi

; 2716 :   p_Adapter->m_dhcp_server_ip = 0;

  0004f	89 b3 80 00 00
	00		 mov	 DWORD PTR [rbx+128], esi

; 2717 :   p_Adapter->m_dhcp_lease_time = 0;

  00055	89 b3 8c 00 00
	00		 mov	 DWORD PTR [rbx+140], esi

; 2718 :   p_Adapter->m_dhcp_received_discover = FALSE;

  0005b	40 88 b3 94 01
	00 00		 mov	 BYTE PTR [rbx+404], sil

; 2719 :   p_Adapter->m_dhcp_bad_requests = 0;

  00062	89 b3 98 01 00
	00		 mov	 DWORD PTR [rbx+408], esi

; 2720 :   NdisZeroMemory (p_Adapter->m_dhcp_server_mac, sizeof (MACADDR));

  00068	48 8d 8b 85 00
	00 00		 lea	 rcx, QWORD PTR [rbx+133]
  0006f	ba 06 00 00 00	 mov	 edx, 6
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2721 : }

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5f		 pop	 rdi
  0007f	5e		 pop	 rsi
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
ResetTapAdapterState ENDP
_TEXT	ENDS
PUBLIC	AllowNonAdmin
EXTRN	__imp_ZwOpenFile:NEAR
EXTRN	__imp_ZwSetSecurityObject:NEAR
EXTRN	__imp_ZwClose:NEAR
EXTRN	__imp_RtlCreateSecurityDescriptor:NEAR
;	COMDAT AllowNonAdmin
AllowNonAdmin	SEGMENT
$SG22459 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AllowNonAdmin	ENDS
;	COMDAT AllowNonAdmin
AllowNonAdmin	SEGMENT
$SG22462 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AllowNonAdmin	ENDS
;	COMDAT AllowNonAdmin
AllowNonAdmin	SEGMENT
$SG22469 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AllowNonAdmin	ENDS
;	COMDAT AllowNonAdmin
AllowNonAdmin	SEGMENT
$SG22472 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AllowNonAdmin	ENDS
;	COMDAT AllowNonAdmin
AllowNonAdmin	SEGMENT
$SG22475 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AllowNonAdmin	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AllowNonAdmin DD 050a01H
	DD	012010aH
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AllowNonAdmin DD @imagerel(AllowNonAdmin#)
	DD	@imagerel(AllowNonAdmin#+334)
	DD	@imagerel($unwind$AllowNonAdmin#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AllowNonAdmin
_TEXT	SEGMENT
hand$ = 48
isb$ = 56
sd$ = 72
oa$ = 96
p_Extension$ = 176
AllowNonAdmin PROC NEAR					; COMDAT

; 2729 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000a	48 8b d9	 mov	 rbx, rcx

; 2730 :   NTSTATUS stat;
; 2731 :   SECURITY_DESCRIPTOR sd;
; 2732 :   OBJECT_ATTRIBUTES oa;
; 2733 :   IO_STATUS_BLOCK isb;
; 2734 :   HANDLE hand = NULL;

  0000d	33 ff		 xor	 edi, edi
  0000f	48 89 7c 24 30	 mov	 QWORD PTR hand$[rsp], rdi

; 2735 : 
; 2736 :   NdisZeroMemory (&sd, sizeof (sd));

  00014	ba 14 00 00 00	 mov	 edx, 20			; 00000014H
  00019	48 8d 4c 24 48	 lea	 rcx, QWORD PTR sd$[rsp]
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2737 :   NdisZeroMemory (&oa, sizeof (oa));

  00024	be 30 00 00 00	 mov	 esi, 48			; 00000030H
  00029	48 8b d6	 mov	 rdx, rsi
  0002c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR oa$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2738 :   NdisZeroMemory (&isb, sizeof (isb));

  00037	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0003c	48 8d 4c 24 38	 lea	 rcx, QWORD PTR isb$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 2739 : 
; 2740 :   if (!p_Extension->m_CreatedUnicodeLinkName)

  00047	40 38 7b 60	 cmp	 BYTE PTR [rbx+96], dil
  0004b	75 16		 jne	 SHORT $L22458

; 2741 :     {
; 2742 :       DEBUGP (("[TAP] AllowNonAdmin: UnicodeLinkName is uninitialized\n"));
; 2743 :       NOTE_ERROR ();

  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22459
  00054	c7 05 00 00 00
	00 b7 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2743 ; 00000ab7H

; 2744 :       return;

  0005e	e9 d9 00 00 00	 jmp	 $L23268
$L22458:

; 2745 :     }
; 2746 : 
; 2747 :   stat = RtlCreateSecurityDescriptor (&sd, SECURITY_DESCRIPTOR_REVISION);

  00063	ba 01 00 00 00	 mov	 edx, 1
  00068	48 8d 4c 24 48	 lea	 rcx, QWORD PTR sd$[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCreateSecurityDescriptor

; 2748 :   if (stat != STATUS_SUCCESS)

  00073	85 c0		 test	 eax, eax
  00075	74 16		 je	 SHORT $L22461

; 2749 :     {
; 2750 :       DEBUGP (("[TAP] AllowNonAdmin: RtlCreateSecurityDescriptor failed\n"));
; 2751 :       NOTE_ERROR ();

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22462
  0007e	c7 05 00 00 00
	00 bf 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2751 ; 00000abfH

; 2752 :       return;

  00088	e9 af 00 00 00	 jmp	 $L23268
$L22461:

; 2753 :     }
; 2754 : 
; 2755 :   InitializeObjectAttributes (
; 2756 :     &oa,
; 2757 :     &p_Extension->m_UnicodeLinkName,
; 2758 :     OBJ_KERNEL_HANDLE,
; 2759 :     NULL,
; 2760 :     NULL
; 2761 :     );

  0008d	89 74 24 60	 mov	 DWORD PTR oa$[rsp], esi
  00091	48 89 7c 24 68	 mov	 QWORD PTR oa$[rsp+8], rdi
  00096	c7 44 24 78 00
	02 00 00	 mov	 DWORD PTR oa$[rsp+24], 512 ; 00000200H
  0009e	48 8d 43 50	 lea	 rax, QWORD PTR [rbx+80]
  000a2	48 89 44 24 70	 mov	 QWORD PTR oa$[rsp+16], rax
  000a7	48 89 bc 24 80
	00 00 00	 mov	 QWORD PTR oa$[rsp+32], rdi
  000af	48 89 bc 24 88
	00 00 00	 mov	 QWORD PTR oa$[rsp+40], rdi

; 2762 : 
; 2763 :   stat = ZwOpenFile (
; 2764 :     &hand,
; 2765 :     WRITE_DAC,
; 2766 :     &oa,
; 2767 :     &isb,
; 2768 :     0,
; 2769 :     0
; 2770 :     );

  000b7	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  000bb	89 7c 24 20	 mov	 DWORD PTR [rsp+32], edi
  000bf	4c 8d 4c 24 38	 lea	 r9, QWORD PTR isb$[rsp]
  000c4	4c 8d 44 24 60	 lea	 r8, QWORD PTR oa$[rsp]
  000c9	ba 00 00 04 00	 mov	 edx, 262144		; 00040000H
  000ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR hand$[rsp]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwOpenFile

; 2771 :   if (stat != STATUS_SUCCESS)

  000d9	85 c0		 test	 eax, eax
  000db	74 13		 je	 SHORT $L22468

; 2772 :     {
; 2773 :       DEBUGP (("[TAP] AllowNonAdmin: ZwOpenFile failed, status=0x%08x\n", (unsigned int)stat));
; 2774 :       NOTE_ERROR ();

  000dd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22469
  000e4	c7 05 00 00 00
	00 d6 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2774 ; 00000ad6H

; 2775 :       return;

  000ee	eb 4c		 jmp	 SHORT $L23268
$L22468:

; 2776 :     }
; 2777 : 
; 2778 :   stat = ZwSetSecurityObject (hand, DACL_SECURITY_INFORMATION, &sd);

  000f0	4c 8d 44 24 48	 lea	 r8, QWORD PTR sd$[rsp]
  000f5	ba 04 00 00 00	 mov	 edx, 4
  000fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hand$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwSetSecurityObject

; 2779 :   if (stat != STATUS_SUCCESS)

  00105	85 c0		 test	 eax, eax
  00107	74 13		 je	 SHORT $L22471

; 2780 :     {
; 2781 :       DEBUGP (("[TAP] AllowNonAdmin: ZwSetSecurityObject failed\n"));
; 2782 :       NOTE_ERROR ();

  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22472
  00110	c7 05 00 00 00
	00 de 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2782 ; 00000adeH

; 2783 :       return;

  0011a	eb 20		 jmp	 SHORT $L23268
$L22471:

; 2784 :     }
; 2785 : 
; 2786 :   stat = ZwClose (hand);

  0011c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hand$[rsp]
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ZwClose

; 2787 :   if (stat != STATUS_SUCCESS)

  00127	85 c0		 test	 eax, eax
  00129	74 18		 je	 SHORT $L22474

; 2788 :     {
; 2789 :       DEBUGP (("[TAP] AllowNonAdmin: ZwClose failed\n"));
; 2790 :       NOTE_ERROR ();

  0012b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22475
  00132	c7 05 00 00 00
	00 e6 0a 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2790 ; 00000ae6H
$L23268:
  0013c	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
$L22474:

; 2791 :       return;
; 2792 :     }
; 2793 : 
; 2794 :   DEBUGP (("[TAP] AllowNonAdmin: SUCCEEDED\n"));
; 2795 : }

  00143	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0014a	5f		 pop	 rdi
  0014b	5e		 pop	 rsi
  0014c	5b		 pop	 rbx
  0014d	c3		 ret	 0
AllowNonAdmin ENDP
_TEXT	ENDS
PUBLIC	IPv4PacketSizeVerify
; Function compile flags: /Ogty
;	COMDAT IPv4PacketSizeVerify
_TEXT	SEGMENT
data$ = 8
length$ = 16
tun$ = 24
prefix$ = 32
counter$ = 40
IPv4PacketSizeVerify PROC NEAR				; COMDAT

; 2804 :   const IPHDR *ip;
; 2805 :   int len = length;

  00000	44 8b ca	 mov	 r9d, edx

; 2806 : 
; 2807 :   if (tun)

  00003	45 84 c0	 test	 r8b, r8b
  00006	75 1b		 jne	 SHORT $L22501

; 2808 :     {
; 2809 :       ip = (IPHDR *) data;
; 2810 :     }
; 2811 :   else
; 2812 :     {
; 2813 :       if (length >= sizeof (ETH_HEADER))

  00008	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  0000b	72 34		 jb	 SHORT $L22493

; 2814 : 	{
; 2815 : 	  const ETH_HEADER *eth = (ETH_HEADER *) data;
; 2816 : 
; 2817 : 	  if (eth->proto != htons (ETH_P_IP))

  0000d	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  00011	66 c1 c8 08	 ror	 ax, 8
  00015	66 39 41 0c	 cmp	 WORD PTR [rcx+12], ax
  00019	75 26		 jne	 SHORT $L22493

; 2818 : 	    return;
; 2819 : 
; 2820 : 	  ip = (IPHDR *) (data + sizeof (ETH_HEADER));

  0001b	48 83 c1 0e	 add	 rcx, 14			; 0000000eH

; 2821 : 	  len -= sizeof (ETH_HEADER);

  0001f	44 8d 4a f2	 lea	 r9d, DWORD PTR [rdx-14]
$L22501:

; 2822 : 	}
; 2823 :       else
; 2824 : 	return;
; 2825 :     }
; 2826 : 
; 2827 :   if (len >= sizeof (IPHDR))

  00023	41 83 f9 14	 cmp	 r9d, 20			; 00000014H
  00027	72 18		 jb	 SHORT $L22493

; 2828 :     {
; 2829 :       const int totlen = ntohs (ip->tot_len);

  00029	66 8b 41 02	 mov	 ax, WORD PTR [rcx+2]
  0002d	66 c1 c8 08	 ror	 ax, 8

; 2830 : 
; 2831 :       DEBUGP (("[TAP] IPv4PacketSizeVerify %s len=%d totlen=%d\n", prefix, len, totlen));
; 2832 : 
; 2833 :       if (len != totlen)

  00031	0f b7 c0	 movzx	 eax, ax
  00034	44 3b c8	 cmp	 r9d, eax
  00037	74 08		 je	 SHORT $L22493

; 2834 : 	++(*counter);

  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR counter$[rsp]
  0003e	83 00 01	 add	 DWORD PTR [rax], 1
$L22493:

; 2835 :     }
; 2836 : }

  00041	c3		 ret	 0
IPv4PacketSizeVerify ENDP
_TEXT	ENDS
PUBLIC	SendDHCPMsg
;	COMDAT xdata
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\dhcp.c
xdata	SEGMENT
$unwind$SendDHCPMsg DD 080f01H
	DD	0f00b720fH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SendDHCPMsg DD @imagerel(SendDHCPMsg#)
	DD	@imagerel(SendDHCPMsg#+318)
	DD	@imagerel($unwind$SendDHCPMsg#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT SendDHCPMsg
_TEXT	SEGMENT
a$ = 128
type$ = 136
eth$ = 144
ip$ = 152
udp$ = 160
dhcp$ = 168
SendDHCPMsg PROC NEAR					; COMDAT

; 323  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	4d 8b e9	 mov	 r13, r9
  00012	4d 8b f0	 mov	 r14, r8
  00015	8b f2		 mov	 esi, edx
  00017	4c 8b e1	 mov	 r12, rcx

; 324  :   DHCPMsg *pkt;
; 325  : 
; 326  :   if (!(type == DHCPOFFER || type == DHCPACK || type == DHCPNAK))

  0001a	83 fe 02	 cmp	 esi, 2
  0001d	74 0e		 je	 SHORT $L21189
  0001f	83 fe 05	 cmp	 esi, 5
  00022	74 09		 je	 SHORT $L21189
  00024	83 fe 06	 cmp	 esi, 6
  00027	0f 85 01 01 00
	00		 jne	 $L21192
$L21189:

; 327  :     {
; 328  :       DEBUGP (("[TAP] SendDHCPMsg: Bad DHCP type: %d\n", type));
; 329  :       return;
; 330  :     }
; 331  : 
; 332  :   pkt = (DHCPMsg *) MemAlloc (sizeof (DHCPMsg), TRUE);

  0002d	b2 01		 mov	 dl, 1
  0002f	41 bf 1f 02 00
	00		 mov	 r15d, 543		; 0000021fH
  00035	41 8b cf	 mov	 ecx, r15d
  00038	e8 00 00 00 00	 call	 MemAlloc
  0003d	48 8b f8	 mov	 rdi, rax

; 333  : 
; 334  :   if (pkt)

  00040	48 85 ff	 test	 rdi, rdi
  00043	0f 84 e5 00 00
	00		 je	 $L21192

; 335  :     {
; 336  :       //-----------------------
; 337  :       // Build DHCP options
; 338  :       //-----------------------
; 339  : 
; 340  :       // Message Type
; 341  :       SetDHCPOpt8 (pkt, DHCP_MSG_TYPE, type);

  00049	44 8b c6	 mov	 r8d, esi
  0004c	ba 35 00 00 00	 mov	 edx, 53			; 00000035H
  00051	48 8b cf	 mov	 rcx, rdi
  00054	e8 00 00 00 00	 call	 SetDHCPOpt8

; 342  : 
; 343  :       // Server ID
; 344  :       SetDHCPOpt32 (pkt, DHCP_SERVER_ID, a->m_dhcp_server_ip);

  00059	45 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR [r12+128]
  00061	ba 36 00 00 00	 mov	 edx, 54			; 00000036H
  00066	48 8b cf	 mov	 rcx, rdi
  00069	e8 00 00 00 00	 call	 SetDHCPOpt32

; 345  : 
; 346  :       if (type == DHCPOFFER || type == DHCPACK)

  0006e	83 fe 02	 cmp	 esi, 2
  00071	74 05		 je	 SHORT $L21194
  00073	83 fe 05	 cmp	 esi, 5
  00076	75 42		 jne	 SHORT $L21193
$L21194:

; 347  : 	{
; 348  : 	  // Lease Time
; 349  : 	  SetDHCPOpt32 (pkt, DHCP_LEASE_TIME, htonl (a->m_dhcp_lease_time));

  00078	45 8b 84 24 8c
	00 00 00	 mov	 r8d, DWORD PTR [r12+140]
  00080	41 0f c8	 bswap	 r8d
  00083	ba 33 00 00 00	 mov	 edx, 51			; 00000033H
  00088	48 8b cf	 mov	 rcx, rdi
  0008b	e8 00 00 00 00	 call	 SetDHCPOpt32

; 350  : 
; 351  : 	  // Netmask
; 352  : 	  SetDHCPOpt32 (pkt, DHCP_NETMASK, a->m_dhcp_netmask);

  00090	45 8b 44 24 7c	 mov	 r8d, DWORD PTR [r12+124]
  00095	ba 01 00 00 00	 mov	 edx, 1
  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	e8 00 00 00 00	 call	 SetDHCPOpt32

; 353  : 
; 354  : 	  // Other user-defined options
; 355  : 	  SetDHCPOpt (pkt,
; 356  : 		      a->m_dhcp_user_supplied_options_buffer,
; 357  : 		      a->m_dhcp_user_supplied_options_buffer_len);

  000a2	49 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR [r12+144]
  000aa	45 8b 84 24 90
	01 00 00	 mov	 r8d, DWORD PTR [r12+400]
  000b2	48 8b cf	 mov	 rcx, rdi
  000b5	e8 00 00 00 00	 call	 SetDHCPOpt
$L21193:

; 358  : 	}
; 359  : 
; 360  :       // End
; 361  :       SetDHCPOpt0 (pkt, DHCP_END);

  000ba	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  000bf	48 8b cf	 mov	 rcx, rdi
  000c2	e8 00 00 00 00	 call	 SetDHCPOpt0

; 362  : 
; 363  :       if (!DHCPMSG_OVERFLOW (pkt))

  000c7	80 7f 04 00	 cmp	 BYTE PTR [rdi+4], 0
  000cb	75 56		 jne	 SHORT $L21195

; 364  : 	{
; 365  : 	  // The initial part of the DHCP message (not including options) gets built here
; 366  : 	  BuildDHCPPre (a,
; 367  : 			&pkt->msg.pre,
; 368  : 			eth,
; 369  : 			ip,
; 370  : 			udp,
; 371  : 			dhcp,
; 372  : 			DHCPMSG_LEN_OPT (pkt),
; 373  : 			type);

  000cd	48 8d 5f 05	 lea	 rbx, QWORD PTR [rdi+5]
  000d1	89 74 24 38	 mov	 DWORD PTR [rsp+56], esi
  000d5	8b 07		 mov	 eax, DWORD PTR [rdi]
  000d7	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  000db	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR dhcp$[rsp]
  000e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR udp$[rsp]
  000f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f5	4d 8b cd	 mov	 r9, r13
  000f8	4d 8b c6	 mov	 r8, r14
  000fb	48 8b d3	 mov	 rdx, rbx
  000fe	49 8b cc	 mov	 rcx, r12
  00101	e8 00 00 00 00	 call	 BuildDHCPPre

; 374  : 
; 375  : 	  SetChecksumDHCPMsg (pkt);

  00106	48 8b cf	 mov	 rcx, rdi
  00109	e8 00 00 00 00	 call	 SetChecksumDHCPMsg

; 376  : 
; 377  : 	  DUMP_PACKET ("DHCPMsg",
; 378  : 		       DHCPMSG_BUF (pkt),
; 379  : 		       DHCPMSG_LEN_FULL (pkt));
; 380  : 
; 381  : 	  // Return DHCP response to kernel
; 382  : 	  InjectPacket (a,
; 383  : 			DHCPMSG_BUF (pkt),
; 384  : 			DHCPMSG_LEN_FULL (pkt));

  0010e	44 8b 07	 mov	 r8d, DWORD PTR [rdi]
  00111	41 81 c0 1a 01
	00 00		 add	 r8d, 282		; 0000011aH
  00118	48 8b d3	 mov	 rdx, rbx
  0011b	49 8b cc	 mov	 rcx, r12
  0011e	e8 00 00 00 00	 call	 InjectPacket
$L21195:

; 385  : 	}
; 386  :       else
; 387  : 	{
; 388  : 	  DEBUGP (("[TAP] SendDHCPMsg: DHCP buffer overflow\n"));
; 389  : 	}
; 390  : 
; 391  :       MemFree (pkt, sizeof (DHCPMsg));

  00123	41 8b d7	 mov	 edx, r15d
  00126	48 8b cf	 mov	 rcx, rdi
  00129	e8 00 00 00 00	 call	 MemFree
$L21192:

; 392  :     }
; 393  : }

  0012e	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00132	41 5f		 pop	 r15
  00134	41 5e		 pop	 r14
  00136	41 5d		 pop	 r13
  00138	41 5c		 pop	 r12
  0013a	5f		 pop	 rdi
  0013b	5e		 pop	 rsi
  0013c	5b		 pop	 rbx
  0013d	c3		 ret	 0
SendDHCPMsg ENDP
_TEXT	ENDS
PUBLIC	ProcessDHCP
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessDHCP DD 070d01H
	DD	0e009620dH
	DD	0c005d007H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessDHCP DD @imagerel(ProcessDHCP#)
	DD	@imagerel(ProcessDHCP#+321)
	DD	@imagerel($unwind$ProcessDHCP#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT ProcessDHCP
_TEXT	SEGMENT
p_Adapter$ = 112
eth$ = 120
ip$ = 128
udp$ = 136
dhcp$ = 144
optlen$ = 152
ProcessDHCP PROC NEAR					; COMDAT

; 410  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000d	4d 8b e9	 mov	 r13, r9
  00010	4d 8b e0	 mov	 r12, r8
  00013	4c 8b f2	 mov	 r14, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 411  :   int msg_type;
; 412  : 
; 413  :   // Sanity check IP header
; 414  :   if (!(ntohs (ip->tot_len) == sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP) + optlen
; 415  : 	&& (ntohs (ip->frag_off) & IP_OFFMASK) == 0))

  00019	66 41 8b 44 24
	02		 mov	 ax, WORD PTR [r12+2]
  0001f	66 c1 c8 08	 ror	 ax, 8
  00023	4c 0f b7 d0	 movzx	 r10, ax
  00027	8b bc 24 98 00
	00 00		 mov	 edi, DWORD PTR optlen$[rsp]
  0002e	48 63 c7	 movsxd	 rax, edi
  00031	48 05 0c 01 00
	00		 add	 rax, 268		; 0000010cH
  00037	4c 3b d0	 cmp	 r10, rax
  0003a	0f 85 f1 00 00
	00		 jne	 $L21221
  00040	66 41 8b 44 24
	06		 mov	 ax, WORD PTR [r12+6]
  00046	66 c1 c8 08	 ror	 ax, 8
  0004a	66 25 ff 1f	 and	 ax, 8191		; 00001fffH
  0004e	0f 85 dd 00 00
	00		 jne	 $L21221

; 417  : 
; 418  :   // Does this message belong to us?
; 419  :   if (!DHCPMessageOurs (p_Adapter, eth, ip, udp, dhcp))

  00054	48 8b b4 24 90
	00 00 00	 mov	 rsi, QWORD PTR dhcp$[rsp]
  0005c	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00061	e8 00 00 00 00	 call	 DHCPMessageOurs
  00066	84 c0		 test	 al, al
  00068	75 0e		 jne	 SHORT $L21222

; 452  : 
; 453  :   return TRUE;
; 454  : }

  0006a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006e	41 5e		 pop	 r14
  00070	41 5d		 pop	 r13
  00072	41 5c		 pop	 r12
  00074	5f		 pop	 rdi
  00075	5e		 pop	 rsi
  00076	5b		 pop	 rbx
  00077	c3		 ret	 0
$L21222:

; 420  :     return FALSE;
; 421  : 
; 422  :   msg_type = GetDHCPMessageType (dhcp, optlen);

  00078	8b d7		 mov	 edx, edi
  0007a	48 8b ce	 mov	 rcx, rsi
  0007d	e8 00 00 00 00	 call	 GetDHCPMessageType
  00082	8b f8		 mov	 edi, eax

; 423  : 
; 424  :   // Drop non-BOOTREQUEST messages
; 425  :   if (dhcp->op != BOOTREQUEST)

  00084	80 3e 01	 cmp	 BYTE PTR [rsi], 1

; 426  :     return TRUE;

  00087	0f 85 a4 00 00
	00		 jne	 $L21221

; 427  : 
; 428  :   // Drop any messages except DHCPDISCOVER or DHCPREQUEST
; 429  :   if (!(msg_type == DHCPDISCOVER || msg_type == DHCPREQUEST))

  0008d	83 ff 01	 cmp	 edi, 1
  00090	74 46		 je	 SHORT $L21225
  00092	83 ff 03	 cmp	 edi, 3

; 430  :     return TRUE;

  00095	0f 85 96 00 00
	00		 jne	 $L21221

; 431  : 
; 432  :   // Should we reply with DHCPOFFER, DHCPACK, or DHCPNAK?
; 433  :   if (msg_type == DHCPREQUEST
; 434  :       && ((dhcp->ciaddr && dhcp->ciaddr != p_Adapter->m_dhcp_addr)
; 435  : 	  || !p_Adapter->m_dhcp_received_discover
; 436  : 	  || p_Adapter->m_dhcp_bad_requests >= BAD_DHCPREQUEST_NAK_THRESHOLD))

  0009b	8b 46 0c	 mov	 eax, DWORD PTR [rsi+12]
  0009e	85 c0		 test	 eax, eax
  000a0	74 05		 je	 SHORT $L21227
  000a2	3b 43 78	 cmp	 eax, DWORD PTR [rbx+120]
  000a5	75 12		 jne	 SHORT $L21226
$L21227:
  000a7	80 bb 94 01 00
	00 00		 cmp	 BYTE PTR [rbx+404], 0
  000ae	74 09		 je	 SHORT $L21226
  000b0	83 bb 98 01 00
	00 03		 cmp	 DWORD PTR [rbx+408], 3
  000b7	72 1f		 jb	 SHORT $L21225
$L21226:

; 437  :     SendDHCPMsg (p_Adapter,
; 438  : 		 DHCPNAK,
; 439  : 		 eth, ip, udp, dhcp);

  000b9	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  000be	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000c3	4d 8b cc	 mov	 r9, r12
  000c6	4d 8b c6	 mov	 r8, r14
  000c9	ba 06 00 00 00	 mov	 edx, 6
  000ce	48 8b cb	 mov	 rcx, rbx
  000d1	e8 00 00 00 00	 call	 SendDHCPMsg

; 440  :   else

  000d6	eb 4a		 jmp	 SHORT $L23300
$L21225:

; 441  :     SendDHCPMsg (p_Adapter,
; 442  : 		 (msg_type == DHCPDISCOVER ? DHCPOFFER : DHCPACK),
; 443  : 		 eth, ip, udp, dhcp);

  000d8	ba 05 00 00 00	 mov	 edx, 5
  000dd	b8 02 00 00 00	 mov	 eax, 2
  000e2	83 ff 01	 cmp	 edi, 1
  000e5	0f 44 d0	 cmove	 edx, eax
  000e8	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  000ed	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  000f2	4d 8b cc	 mov	 r9, r12
  000f5	4d 8b c6	 mov	 r8, r14
  000f8	48 8b cb	 mov	 rcx, rbx
  000fb	e8 00 00 00 00	 call	 SendDHCPMsg

; 444  : 
; 445  :   // Remember if we received a DHCPDISCOVER
; 446  :   if (msg_type == DHCPDISCOVER)

  00100	83 ff 01	 cmp	 edi, 1
  00103	75 18		 jne	 SHORT $L21229

; 447  :     p_Adapter->m_dhcp_received_discover = TRUE;

  00105	40 88 bb 94 01
	00 00		 mov	 BYTE PTR [rbx+404], dil

; 416  :     return TRUE;

  0010c	40 8a c7	 mov	 al, dil

; 452  : 
; 453  :   return TRUE;
; 454  : }

  0010f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00113	41 5e		 pop	 r14
  00115	41 5d		 pop	 r13
  00117	41 5c		 pop	 r12
  00119	5f		 pop	 rdi
  0011a	5e		 pop	 rsi
  0011b	5b		 pop	 rbx
  0011c	c3		 ret	 0
$L21229:

; 448  : 
; 449  :   // Is this a bad DHCPREQUEST?
; 450  :   if (msg_type == DHCPREQUEST && dhcp->ciaddr != p_Adapter->m_dhcp_addr)

  0011d	83 ff 03	 cmp	 edi, 3
  00120	75 0f		 jne	 SHORT $L21221
$L23300:
  00122	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  00125	39 46 0c	 cmp	 DWORD PTR [rsi+12], eax
  00128	74 07		 je	 SHORT $L21221

; 451  :     ++p_Adapter->m_dhcp_bad_requests;

  0012a	83 83 98 01 00
	00 01		 add	 DWORD PTR [rbx+408], 1
$L21221:

; 416  :     return TRUE;

  00131	b0 01		 mov	 al, 1

; 452  : 
; 453  :   return TRUE;
; 454  : }

  00133	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00137	41 5e		 pop	 r14
  00139	41 5d		 pop	 r13
  0013b	41 5c		 pop	 r12
  0013d	5f		 pop	 rdi
  0013e	5e		 pop	 rsi
  0013f	5b		 pop	 rbx
  00140	c3		 ret	 0
ProcessDHCP ENDP
_TEXT	ENDS
PUBLIC	DestroyTapDevice
;	COMDAT xdata
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.c
xdata	SEGMENT
$unwind$DestroyTapDevice DD 030601H
	DD	070024206H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DestroyTapDevice DD @imagerel(DestroyTapDevice#)
	DD	@imagerel(DestroyTapDevice#+68)
	DD	@imagerel($unwind$DestroyTapDevice#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT DestroyTapDevice
_TEXT	SEGMENT
p_Extension$ = 64
DestroyTapDevice PROC NEAR				; COMDAT

; 621  : {

  00000	53		 push	 rbx
  00001	57		 push	 rdi
  00002	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00006	48 8b d9	 mov	 rbx, rcx

; 622  :   DEBUGP (("[%s] Destroying tap device\n", p_Extension->m_TapName));
; 623  : 
; 624  :   //======================================
; 625  :   // Let clients know we are shutting down
; 626  :   //======================================
; 627  :   p_Extension->m_TapIsRunning = FALSE;

  00009	c6 43 78 00	 mov	 BYTE PTR [rbx+120], 0

; 628  :   p_Extension->m_TapOpens = 0;

  0000d	c7 43 20 00 00
	00 00		 mov	 DWORD PTR [rbx+32], 0

; 629  :   p_Extension->m_Halt = TRUE;

  00014	c6 43 40 01	 mov	 BYTE PTR [rbx+64], 1

; 630  : 
; 631  :   //=====================================
; 632  :   // If we are concurrently executing in
; 633  :   // TapDeviceHook or AdapterTransmit,
; 634  :   // give those calls time to finish.
; 635  :   // Note that we must be running at IRQL
; 636  :   // < DISPATCH_LEVEL in order to call
; 637  :   // NdisMSleep.
; 638  :   //=====================================
; 639  :   NdisMSleep (500000);

  00018	bf 20 a1 07 00	 mov	 edi, 500000		; 0007a120H
  0001d	8b cf		 mov	 ecx, edi
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep

; 640  : 
; 641  :   //===========================================================
; 642  :   // Exhaust IRP and packet queues.  Any pending IRPs will
; 643  :   // be cancelled, causing user-space to get this error
; 644  :   // on overlapped reads:
; 645  :   //   The I/O operation has been aborted because of either a
; 646  :   //   thread exit or an application request.   (code=995)
; 647  :   // It's important that user-space close the device handle
; 648  :   // when this code is returned, so that when we finally
; 649  :   // do a NdisMDeregisterDevice, the device reference count
; 650  :   // is 0.  Otherwise the driver will not unload even if the
; 651  :   // the last adapter has been halted.
; 652  :   //===========================================================
; 653  :   FlushQueues (p_Extension);

  00025	48 8b cb	 mov	 rcx, rbx
  00028	e8 00 00 00 00	 call	 FlushQueues

; 654  :   NdisMSleep (500000); // give user space time to respond to IRP cancel

  0002d	8b cf		 mov	 ecx, edi
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep

; 655  : 
; 656  :   TapDeviceFreeResources (p_Extension);

  00035	48 8b cb	 mov	 rcx, rbx
  00038	e8 00 00 00 00	 call	 TapDeviceFreeResources

; 657  : }

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	5f		 pop	 rdi
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
DestroyTapDevice ENDP
_TEXT	ENDS
PUBLIC	CancelIRPCallback
;	COMDAT xdata
xdata	SEGMENT
$unwind$CancelIRPCallback DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CancelIRPCallback DD @imagerel(CancelIRPCallback#)
	DD	@imagerel(CancelIRPCallback#+61)
	DD	@imagerel($unwind$CancelIRPCallback#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT CancelIRPCallback
_TEXT	SEGMENT
p_DeviceObject$ = 48
p_IRP$ = 56
CancelIRPCallback PROC NEAR				; COMDAT

; 2459 : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b da	 mov	 rbx, rdx

; 2460 :   TapAdapterPointer l_Adapter = LookupAdapterInInstanceList (p_DeviceObject);

  00008	e8 00 00 00 00	 call	 LookupAdapterInInstanceList

; 2461 :   CancelIRP (l_Adapter ? &l_Adapter->m_Extension : NULL, p_IRP, TRUE);

  0000d	48 85 c0	 test	 rax, rax
  00010	74 18		 je	 SHORT $L23321
  00012	48 8d 88 78 02
	00 00		 lea	 rcx, QWORD PTR [rax+632]
  00019	41 b0 01	 mov	 r8b, 1
  0001c	48 8b d3	 mov	 rdx, rbx
  0001f	e8 00 00 00 00	 call	 CancelIRP

; 2462 : }

  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
$L23321:

; 2461 :   CancelIRP (l_Adapter ? &l_Adapter->m_Extension : NULL, p_IRP, TRUE);

  0002a	33 c9		 xor	 ecx, ecx
  0002c	41 b0 01	 mov	 r8b, 1
  0002f	48 8b d3	 mov	 rdx, rbx
  00032	e8 00 00 00 00	 call	 CancelIRP

; 2462 : }

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
CancelIRPCallback ENDP
_TEXT	ENDS
PUBLIC	ProcessARP
;	COMDAT xdata
xdata	SEGMENT
$unwind$ProcessARP DD 091001H
	DD	0f00c4210H
	DD	0d008e00aH
	DD	07004c006H
	DD	050026003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ProcessARP DD @imagerel(ProcessARP#)
	DD	@imagerel(ProcessARP#+461)
	DD	@imagerel($unwind$ProcessARP#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT ProcessARP
_TEXT	SEGMENT
p_Adapter$ = 112
src$ = 120
adapter_ip$ = 128
ip_network$ = 136
ip_netmask$ = 144
mac$ = 152
ProcessARP PROC NEAR					; COMDAT

; 2600 : {

  00000	53		 push	 rbx
  00001	55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00010	45 8b f0	 mov	 r14d, r8d
  00013	4c 8b e2	 mov	 r12, rdx
  00016	4c 8b f9	 mov	 r15, rcx

; 2601 :   //-----------------------------------------------
; 2602 :   // Is this the kind of packet we are looking for?
; 2603 :   //-----------------------------------------------
; 2604 :   if (src->m_Proto == htons (ETH_P_ARP)
; 2605 :       && MAC_EQUAL (src->m_MAC_Source, p_Adapter->m_MAC)
; 2606 :       && MAC_EQUAL (src->m_ARP_MAC_Source, p_Adapter->m_MAC)
; 2607 :       && MAC_EQUAL (src->m_MAC_Destination, p_Adapter->m_MAC_Broadcast)
; 2608 :       && src->m_ARP_Operation == htons (ARP_REQUEST)
; 2609 :       && src->m_MAC_AddressType == htons (MAC_ADDR_TYPE)
; 2610 :       && src->m_MAC_AddressSize == sizeof (MACADDR)
; 2611 :       && src->m_PROTO_AddressType == htons (ETH_P_IP)
; 2612 :       && src->m_PROTO_AddressSize == sizeof (IPADDR)
; 2613 :       && src->m_ARP_IP_Source == adapter_ip
; 2614 :       && (src->m_ARP_IP_Destination & ip_netmask) == ip_network
; 2615 :       && src->m_ARP_IP_Destination != adapter_ip)

  00019	66 41 bd 06 08	 mov	 r13w, 2054		; 00000806H
  0001e	66 41 c1 cd 08	 ror	 r13w, 8
  00023	66 45 39 6c 24
	0c		 cmp	 WORD PTR [r12+12], r13w
  00029	0f 85 8b 01 00
	00		 jne	 $L22408
  0002f	49 8d 6f 10	 lea	 rbp, QWORD PTR [r15+16]
  00033	49 8d 74 24 06	 lea	 rsi, QWORD PTR [r12+6]
  00038	33 c0		 xor	 eax, eax
  0003a	48 8b fd	 mov	 rdi, rbp
  0003d	ba 06 00 00 00	 mov	 edx, 6
  00042	48 8b ca	 mov	 rcx, rdx
  00045	f3 a6		 repe cmpsb
  00047	74 05		 je	 SHORT $L23334
  00049	1b c0		 sbb	 eax, eax
  0004b	83 d8 ff	 sbb	 eax, -1
$L23334:
  0004e	85 c0		 test	 eax, eax
  00050	0f 85 64 01 00
	00		 jne	 $L22408
  00056	49 8d 74 24 16	 lea	 rsi, QWORD PTR [r12+22]
  0005b	33 c0		 xor	 eax, eax
  0005d	48 8b fd	 mov	 rdi, rbp
  00060	48 8b ca	 mov	 rcx, rdx
  00063	f3 a6		 repe cmpsb
  00065	74 05		 je	 SHORT $L23333
  00067	1b c0		 sbb	 eax, eax
  00069	83 d8 ff	 sbb	 eax, -1
$L23333:
  0006c	85 c0		 test	 eax, eax
  0006e	0f 85 46 01 00
	00		 jne	 $L22408
  00074	49 8d 7f 70	 lea	 rdi, QWORD PTR [r15+112]
  00078	33 c0		 xor	 eax, eax
  0007a	49 8b f4	 mov	 rsi, r12
  0007d	48 8b ca	 mov	 rcx, rdx
  00080	f3 a6		 repe cmpsb
  00082	74 05		 je	 SHORT $L23332
  00084	1b c0		 sbb	 eax, eax
  00086	83 d8 ff	 sbb	 eax, -1
$L23332:
  00089	85 c0		 test	 eax, eax
  0008b	0f 85 29 01 00
	00		 jne	 $L22408
  00091	66 bb 01 00	 mov	 bx, 1
  00095	66 c1 cb 08	 ror	 bx, 8
  00099	66 41 39 5c 24
	14		 cmp	 WORD PTR [r12+20], bx
  0009f	0f 85 15 01 00
	00		 jne	 $L22408
  000a5	66 41 39 5c 24
	0e		 cmp	 WORD PTR [r12+14], bx
  000ab	0f 85 09 01 00
	00		 jne	 $L22408
  000b1	41 80 7c 24 12
	06		 cmp	 BYTE PTR [r12+18], 6
  000b7	0f 85 fd 00 00
	00		 jne	 $L22408
  000bd	66 bf 00 08	 mov	 di, 2048		; 00000800H
  000c1	66 c1 cf 08	 ror	 di, 8
  000c5	66 41 39 7c 24
	10		 cmp	 WORD PTR [r12+16], di
  000cb	0f 85 e9 00 00
	00		 jne	 $L22408
  000d1	41 80 7c 24 13
	04		 cmp	 BYTE PTR [r12+19], 4
  000d7	0f 85 dd 00 00
	00		 jne	 $L22408
  000dd	45 39 74 24 1c	 cmp	 DWORD PTR [r12+28], r14d
  000e2	0f 85 d2 00 00
	00		 jne	 $L22408
  000e8	41 8b 4c 24 26	 mov	 ecx, DWORD PTR [r12+38]
  000ed	8b c1		 mov	 eax, ecx
  000ef	23 84 24 90 00
	00 00		 and	 eax, DWORD PTR ip_netmask$[rsp]
  000f6	41 3b c1	 cmp	 eax, r9d
  000f9	0f 85 bb 00 00
	00		 jne	 $L22408
  000ff	41 3b ce	 cmp	 ecx, r14d
  00102	0f 84 b2 00 00
	00		 je	 $L22408

; 2616 :     {
; 2617 :       ARP_PACKET *arp = (ARP_PACKET *) MemAlloc (sizeof (ARP_PACKET), TRUE);

  00108	b2 01		 mov	 dl, 1
  0010a	b9 2a 00 00 00	 mov	 ecx, 42			; 0000002aH
  0010f	e8 00 00 00 00	 call	 MemAlloc
  00114	48 8b f0	 mov	 rsi, rax

; 2618 :       if (arp)

  00117	48 85 f6	 test	 rsi, rsi
  0011a	0f 84 96 00 00
	00		 je	 $L22412

; 2619 : 	{
; 2620 : 	  //----------------------------------------------
; 2621 : 	  // Initialize ARP reply fields
; 2622 : 	  //----------------------------------------------
; 2623 : 	  arp->m_Proto = htons (ETH_P_ARP);

  00120	66 44 89 6e 0c	 mov	 WORD PTR [rsi+12], r13w

; 2624 : 	  arp->m_MAC_AddressType = htons (MAC_ADDR_TYPE);

  00125	66 89 5e 0e	 mov	 WORD PTR [rsi+14], bx

; 2625 : 	  arp->m_PROTO_AddressType = htons (ETH_P_IP);

  00129	66 89 7e 10	 mov	 WORD PTR [rsi+16], di

; 2626 : 	  arp->m_MAC_AddressSize = sizeof (MACADDR);

  0012d	c6 46 12 06	 mov	 BYTE PTR [rsi+18], 6

; 2627 : 	  arp->m_PROTO_AddressSize = sizeof (IPADDR);

  00131	c6 46 13 04	 mov	 BYTE PTR [rsi+19], 4

; 2628 : 	  arp->m_ARP_Operation = htons (ARP_REPLY);

  00135	66 b9 02 00	 mov	 cx, 2
  00139	66 c1 c9 08	 ror	 cx, 8
  0013d	66 89 4e 14	 mov	 WORD PTR [rsi+20], cx

; 2629 : 
; 2630 : 	  //----------------------------------------------
; 2631 : 	  // ARP addresses
; 2632 : 	  //----------------------------------------------      
; 2633 : 	  COPY_MAC (arp->m_MAC_Source, mac);

  00141	48 8d 4e 06	 lea	 rcx, QWORD PTR [rsi+6]
  00145	bf 06 00 00 00	 mov	 edi, 6
  0014a	4c 8b c7	 mov	 r8, rdi
  0014d	48 8b 9c 24 98
	00 00 00	 mov	 rbx, QWORD PTR mac$[rsp]
  00155	48 8b d3	 mov	 rdx, rbx
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 2634 : 	  COPY_MAC (arp->m_MAC_Destination, p_Adapter->m_MAC);

  0015e	4c 8b c7	 mov	 r8, rdi
  00161	48 8b d5	 mov	 rdx, rbp
  00164	48 8b ce	 mov	 rcx, rsi
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 2635 : 	  COPY_MAC (arp->m_ARP_MAC_Source, mac);

  0016d	48 8d 4e 16	 lea	 rcx, QWORD PTR [rsi+22]
  00171	4c 8b c7	 mov	 r8, rdi
  00174	48 8b d3	 mov	 rdx, rbx
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 2636 : 	  COPY_MAC (arp->m_ARP_MAC_Destination, p_Adapter->m_MAC);

  0017d	48 8d 4e 20	 lea	 rcx, QWORD PTR [rsi+32]
  00181	4c 8b c7	 mov	 r8, rdi
  00184	48 8b d5	 mov	 rdx, rbp
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 2637 : 	  arp->m_ARP_IP_Source = src->m_ARP_IP_Destination;

  0018d	41 8b 44 24 26	 mov	 eax, DWORD PTR [r12+38]
  00192	89 46 1c	 mov	 DWORD PTR [rsi+28], eax

; 2638 : 	  arp->m_ARP_IP_Destination = adapter_ip;

  00195	44 89 76 26	 mov	 DWORD PTR [rsi+38], r14d

; 2639 : 
; 2640 : 	  DUMP_PACKET ("ProcessARP",
; 2641 : 		       (unsigned char *) arp,
; 2642 : 		       sizeof (ARP_PACKET));
; 2643 : 
; 2644 : 	  InjectPacket (p_Adapter, (UCHAR *) arp, sizeof (ARP_PACKET));

  00199	bb 2a 00 00 00	 mov	 ebx, 42			; 0000002aH
  0019e	44 8b c3	 mov	 r8d, ebx
  001a1	48 8b d6	 mov	 rdx, rsi
  001a4	49 8b cf	 mov	 rcx, r15
  001a7	e8 00 00 00 00	 call	 InjectPacket

; 2645 : 
; 2646 : 	  MemFree (arp, sizeof (ARP_PACKET));

  001ac	8b d3		 mov	 edx, ebx
  001ae	48 8b ce	 mov	 rcx, rsi
  001b1	e8 00 00 00 00	 call	 MemFree
$L22412:

; 2647 : 	}
; 2648 : 
; 2649 :       return TRUE;

  001b6	b0 01		 mov	 al, 1
  001b8	eb 02		 jmp	 SHORT $L22426
$L22408:

; 2650 :     }
; 2651 :   else
; 2652 :     return FALSE;

  001ba	32 c0		 xor	 al, al
$L22426:

; 2653 : }

  001bc	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001c0	41 5f		 pop	 r15
  001c2	41 5e		 pop	 r14
  001c4	41 5d		 pop	 r13
  001c6	41 5c		 pop	 r12
  001c8	5f		 pop	 rdi
  001c9	5e		 pop	 rsi
  001ca	5d		 pop	 rbp
  001cb	5b		 pop	 rbx
  001cc	c3		 ret	 0
ProcessARP ENDP
_TEXT	ENDS
PUBLIC	AdapterHalt
;	COMDAT AdapterHalt
AdapterHalt	SEGMENT
$SG21570 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AdapterHalt	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterHalt DD 020501H
	DD	030013205H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterHalt DD @imagerel(AdapterHalt#)
	DD	@imagerel(AdapterHalt#+70)
	DD	@imagerel($unwind$AdapterHalt#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT AdapterHalt
_TEXT	SEGMENT
p_AdapterContext$ = 48
AdapterHalt PROC NEAR					; COMDAT

; 576  : {

  00000	53		 push	 rbx
  00001	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00005	48 8b d9	 mov	 rbx, rcx

; 577  :   BOOLEAN status;
; 578  : 
; 579  :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 580  : 
; 581  :   NOTE_ERROR ();

  00008	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21570
  0000f	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00016	c7 05 00 00 00
	00 45 02 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 581 ; 00000245H

; 582  : 
; 583  :   l_Adapter->m_InterfaceIsRunning = FALSE;

  00020	c6 43 16 00	 mov	 BYTE PTR [rbx+22], 0

; 584  : 
; 585  :   DEBUGP (("[%s] is being halted\n", NAME (l_Adapter)));
; 586  :   
; 587  :   DestroyTapDevice (&l_Adapter->m_Extension);

  00024	48 8d 8b 78 02
	00 00		 lea	 rcx, QWORD PTR [rbx+632]
  0002b	e8 00 00 00 00	 call	 DestroyTapDevice

; 588  : 
; 589  :   // Free resources
; 590  :   DEBUGP (("[%s] Freeing Resources\n", NAME (l_Adapter)));
; 591  :   AdapterFreeResources (l_Adapter);

  00030	48 8b cb	 mov	 rcx, rbx
  00033	e8 00 00 00 00	 call	 AdapterFreeResources

; 592  : 
; 593  :   status = RemoveAdapterFromInstanceList (l_Adapter);

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	e8 00 00 00 00	 call	 RemoveAdapterFromInstanceList

; 594  :   DEBUGP (("[TAP] RemoveAdapterFromInstanceList returned %d\n", (int) status));
; 595  : 
; 596  :   DEBUGP (("[TAP] version [%d.%d] %s %s AdapterHalt returning\n",
; 597  : 	   TAP_DRIVER_MAJOR_VERSION,
; 598  : 	   TAP_DRIVER_MINOR_VERSION,
; 599  : 	   __DATE__,
; 600  : 	   __TIME__));
; 601  : }

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx
  00045	c3		 ret	 0
AdapterHalt ENDP
_TEXT	ENDS
PUBLIC	AdapterTransmit
EXTRN	__imp_MmMapLockedPages:NEAR
;	COMDAT AdapterTransmit
; File c:\winddk\3790\inc\ddk\wnet\ndis.h
AdapterTransmit	SEGMENT
$SG21939 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AdapterTransmit	ENDS
;	COMDAT AdapterTransmit
AdapterTransmit	SEGMENT
$SG21942 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AdapterTransmit	ENDS
;	COMDAT AdapterTransmit
AdapterTransmit	SEGMENT
$SG21943 DB	'TX', 00H
AdapterTransmit	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterTransmit DD 081009H
	DD	0150110H
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
	DD	@imagerel(__C_specific_handler#)
	DD	02H
	DD	@imagerel(AdapterTransmit#+245)
	DD	@imagerel(AdapterTransmit#+973)
	DD	@imagerel(AdapterTransmit$filt$0#)
	DD	@imagerel(AdapterTransmit#+973)
	DD	@imagerel(AdapterTransmit#+1000)
	DD	@imagerel(AdapterTransmit#+1151)
	DD	@imagerel(AdapterTransmit$filt$0#)
	DD	@imagerel(AdapterTransmit#+1151)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterTransmit DD @imagerel(AdapterTransmit#)
	DD	@imagerel(AdapterTransmit#+1181)
	DD	@imagerel($unwind$AdapterTransmit#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterTransmit$filt$0 DD 080e01H
	DD	0500a520eH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterTransmit$filt$0 DD @imagerel(AdapterTransmit$filt$0#)
	DD	@imagerel(AdapterTransmit$filt$0#+41)
	DD	@imagerel($unwind$AdapterTransmit$filt$0#)
; Function compile flags: /Ogty
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.c
pdata	ENDS
;	COMDAT AdapterTransmit
_TEXT	SEGMENT
l_PacketBuffer$ = 48
l_Index$ = 56
l_IRP$ = 64
l_BufferLength$ = 72
result$ = 80
optlen$21972 = 88
newlen$21929 = 92
l_NDIS_Buffer$ = 96
ip$21947 = 104
udp$21950 = 112
eth$21945 = 120
dhcp$21967 = 128
l_Buffer$ = 136
e$21981 = 144
p_AdapterContext$ = 224
p_Packet$ = 232
p_Flags$ = 240
AdapterTransmit PROC NEAR				; COMDAT

; 1401 : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00010	48 8b d9	 mov	 rbx, rcx

; 1402 :   TapAdapterPointer l_Adapter = (TapAdapterPointer) p_AdapterContext;
; 1403 :   ULONG l_Index = 0, l_BufferLength = 0, l_PacketLength = 0;
; 1404 :   PIRP l_IRP;
; 1405 :   TapPacketPointer l_PacketBuffer;
; 1406 :   PNDIS_BUFFER l_NDIS_Buffer;
; 1407 :   PUCHAR l_Buffer;
; 1408 :   PVOID result;
; 1409 : 
; 1410 :   NdisQueryPacket (p_Packet, NULL, NULL, &l_NDIS_Buffer, &l_PacketLength);

  00013	48 8b 7a 08	 mov	 rdi, QWORD PTR [rdx+8]
  00017	80 7a 28 00	 cmp	 BYTE PTR [rdx+40], 0
  0001b	75 6b		 jne	 SHORT $L23397
  0001d	4c 8b c7	 mov	 r8, rdi
  00020	45 33 f6	 xor	 r14d, r14d
  00023	41 8b f6	 mov	 esi, r14d
  00026	45 8b d6	 mov	 r10d, r14d
  00029	45 8b de	 mov	 r11d, r14d
  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 47		 je	 SHORT $L23378
  00031	41 b9 01 00 00
	00		 mov	 r9d, 1
  00037	41 bc ff 0f 00
	00		 mov	 r12d, 4095		; 00000fffH
$L23377:
  0003d	41 8b 40 28	 mov	 eax, DWORD PTR [r8+40]
  00041	03 f0		 add	 esi, eax
  00043	85 c0		 test	 eax, eax
  00045	75 05		 jne	 SHORT $L23386
  00047	41 8b c1	 mov	 eax, r9d
  0004a	eb 1d		 jmp	 SHORT $L23387
$L23386:
  0004c	66 41 8b 48 2c	 mov	 cx, WORD PTR [r8+44]
  00051	66 41 03 48 20	 add	 cx, WORD PTR [r8+32]
  00056	49 23 cc	 and	 rcx, r12
  00059	41 8b 40 28	 mov	 eax, DWORD PTR [r8+40]
  0005d	48 8d 84 01 ff
	0f 00 00	 lea	 rax, QWORD PTR [rcx+rax+4095]
  00065	48 c1 e8 0c	 shr	 rax, 12			; 0000000cH
$L23387:
  00069	44 03 d0	 add	 r10d, eax
  0006c	41 83 c3 01	 add	 r11d, 1
  00070	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  00073	4d 85 c0	 test	 r8, r8
  00076	75 c5		 jne	 SHORT $L23377
$L23378:
  00078	44 89 5a 20	 mov	 DWORD PTR [rdx+32], r11d
  0007c	89 72 04	 mov	 DWORD PTR [rdx+4], esi
  0007f	44 89 12	 mov	 DWORD PTR [rdx], r10d
  00082	c6 42 28 01	 mov	 BYTE PTR [rdx+40], 1
  00086	eb 03		 jmp	 SHORT $L23370
$L23397:
  00088	45 33 f6	 xor	 r14d, r14d
$L23370:
  0008b	44 8b 62 04	 mov	 r12d, DWORD PTR [rdx+4]

; 1411 : 
; 1412 :   //====================================================
; 1413 :   // Here we abandon the transmission attempt if any of
; 1414 :   // the parameters is wrong or memory allocation fails
; 1415 :   // but we do not indicate failure. The packet is
; 1416 :   // silently dropped.
; 1417 :   //====================================================
; 1418 : 
; 1419 :   if (l_PacketLength < ETHERNET_HEADER_SIZE || l_PacketLength > 65535)

  0008f	41 83 fc 0e	 cmp	 r12d, 14		; 0000000eH
  00093	0f 82 ee 03 00
	00		 jb	 $exit_fail$21913
  00099	41 81 fc ff ff
	00 00		 cmp	 r12d, 65535		; 0000ffffH
  000a0	0f 87 e1 03 00
	00		 ja	 $exit_fail$21913

; 1420 :     goto exit_fail;
; 1421 :   else if (!l_Adapter->m_Extension.m_TapOpens || !l_Adapter->m_MediaState)

  000a6	83 bb 98 02 00
	00 00		 cmp	 DWORD PTR [rbx+664], 0
  000ad	0f 84 d0 03 00
	00		 je	 $exit_success$21917
  000b3	80 7b 45 00	 cmp	 BYTE PTR [rbx+69], 0
  000b7	0f 84 c6 03 00
	00		 je	 $exit_success$21917

; 1422 :     goto exit_success;              // Nothing is bound to the TAP device
; 1423 : 
; 1424 :   if (NdisAllocateMemoryWithTag (&l_PacketBuffer,
; 1425 : 				 TAP_PACKET_SIZE (l_PacketLength),
; 1426 : 				 '5PAT') != NDIS_STATUS_SUCCESS)

  000bd	41 8d 54 24 04	 lea	 edx, DWORD PTR [r12+4]
  000c2	41 b8 54 41 50
	35		 mov	 r8d, 894452052		; 35504154H
  000c8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR l_PacketBuffer$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisAllocateMemoryWithTag
  000d3	85 c0		 test	 eax, eax
  000d5	75 0a		 jne	 SHORT $exit_no_resources$21922

; 1427 :     goto exit_no_resources;
; 1428 : 
; 1429 :   if (l_PacketBuffer == NULL)

  000d7	48 8b 4c 24 30	 mov	 rcx, QWORD PTR l_PacketBuffer$[rsp]
  000dc	48 85 c9	 test	 rcx, rcx
  000df	75 0a		 jne	 SHORT $L21924
$exit_no_resources$21922:

; 1651 : 
; 1652 :  exit_no_resources:
; 1653 :   return NDIS_STATUS_RESOURCES;

  000e1	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000e6	e9 a1 03 00 00	 jmp	 $L21897
$L21924:

; 1430 :     goto exit_no_resources;
; 1431 : 
; 1432 :   l_PacketBuffer->m_SizeFlags = (l_PacketLength & TP_SIZE_MASK);

  000eb	41 8b c4	 mov	 eax, r12d
  000ee	25 ff ff ff 7f	 and	 eax, 2147483647		; 7fffffffH
  000f3	89 01		 mov	 DWORD PTR [rcx], eax

; 1433 : 
; 1434 :   //===========================
; 1435 :   // Reassemble packet contents
; 1436 :   //===========================
; 1437 : 
; 1438 :   __try
; 1439 :   {
; 1440 :     l_Index = 0;

  000f5	41 8b f6	 mov	 esi, r14d
  000f8	89 74 24 38	 mov	 DWORD PTR l_Index$[rsp], esi
$L21927:

; 1441 :     while (l_NDIS_Buffer && l_Index < l_PacketLength)

  000fc	48 85 ff	 test	 rdi, rdi
  000ff	0f 84 8c 00 00
	00		 je	 $L21928
  00105	41 3b f4	 cmp	 esi, r12d
  00108	0f 83 83 00 00
	00		 jae	 $L21928

; 1442 :       {
; 1443 : 	ULONG newlen;
; 1444 : 	NdisQueryBuffer (l_NDIS_Buffer, (PVOID *) & l_Buffer,
; 1445 : 			 &l_BufferLength);

  0010e	8a 47 0a	 mov	 al, BYTE PTR [rdi+10]
  00111	24 05		 and	 al, 5
  00113	74 06		 je	 SHORT $L23355
  00115	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00119	eb 0e		 jmp	 SHORT $L23356
$L23355:
  0011b	32 d2		 xor	 dl, dl
  0011d	48 8b cf	 mov	 rcx, rdi
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPages
  00126	48 8b d0	 mov	 rdx, rax
$L23356:
  00129	48 89 94 24 88
	00 00 00	 mov	 QWORD PTR l_Buffer$[rsp], rdx
  00131	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  00134	89 44 24 48	 mov	 DWORD PTR l_BufferLength$[rsp], eax

; 1446 : 	newlen = l_Index + l_BufferLength;

  00138	44 8d 2c 30	 lea	 r13d, DWORD PTR [rax+rsi]
  0013c	44 89 6c 24 5c	 mov	 DWORD PTR newlen$21929[rsp], r13d

; 1447 : 	if (newlen > l_PacketLength)

  00141	45 3b ec	 cmp	 r13d, r12d
  00144	76 22		 jbe	 SHORT $L21938

; 1448 : 	  {
; 1449 : 	    NOTE_ERROR ();

  00146	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21939
  0014d	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00154	c7 05 00 00 00
	00 a9 05 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1449 ; 000005a9H

; 1450 : 	    goto no_queue; /* overflow */

  0015e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  00163	e9 6a 02 00 00	 jmp	 $no_queue$21940
$L21938:

; 1451 : 	  }
; 1452 : 	NdisMoveMemory (l_PacketBuffer->m_Data + l_Index, l_Buffer,
; 1453 : 			l_BufferLength);

  00168	44 8b c0	 mov	 r8d, eax
  0016b	8b ce		 mov	 ecx, esi
  0016d	48 8b 44 24 30	 mov	 rax, QWORD PTR l_PacketBuffer$[rsp]
  00172	48 8d 4c 01 04	 lea	 rcx, QWORD PTR [rcx+rax+4]
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1454 : 	l_Index = newlen;

  0017d	41 8b f5	 mov	 esi, r13d
  00180	89 74 24 38	 mov	 DWORD PTR l_Index$[rsp], esi

; 1455 : 	NdisGetNextBuffer (l_NDIS_Buffer, &l_NDIS_Buffer);

  00184	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  00187	48 89 7c 24 60	 mov	 QWORD PTR l_NDIS_Buffer$[rsp], rdi

; 1456 :       }

  0018c	e9 6b ff ff ff	 jmp	 $L21927
$L21928:

; 1457 :     if (l_Index != l_PacketLength)

  00191	41 3b f4	 cmp	 esi, r12d
  00194	74 22		 je	 SHORT $L21941

; 1458 :       {
; 1459 : 	NOTE_ERROR ();

  00196	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21942
  0019d	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  001a4	c7 05 00 00 00
	00 b3 05 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1459 ; 000005b3H

; 1460 : 	goto no_queue; /* underflow */

  001ae	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  001b3	e9 1a 02 00 00	 jmp	 $no_queue$21940
$L21941:

; 1461 :       }
; 1462 : 
; 1463 :     DUMP_PACKET ("AdapterTransmit", l_PacketBuffer->m_Data, l_PacketLength);
; 1464 : 
; 1465 :     //=====================================================
; 1466 :     // If IPv4 packet, check whether or not packet
; 1467 :     // was truncated.
; 1468 :     //=====================================================
; 1469 : #if PACKET_TRUNCATION_CHECK
; 1470 :     IPv4PacketSizeVerify (l_PacketBuffer->m_Data, l_PacketLength, FALSE, "TX", &l_Adapter->m_TxTrunc);

  001b8	48 8d 53 34	 lea	 rdx, QWORD PTR [rbx+52]
  001bc	48 8b 44 24 30	 mov	 rax, QWORD PTR l_PacketBuffer$[rsp]
  001c1	48 8d 48 04	 lea	 rcx, QWORD PTR [rax+4]
  001c5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ca	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG21943
  001d1	45 32 c0	 xor	 r8b, r8b
  001d4	41 8b d4	 mov	 edx, r12d
  001d7	e8 00 00 00 00	 call	 IPv4PacketSizeVerify

; 1471 : #endif
; 1472 : 
; 1473 :     //=====================================================
; 1474 :     // Are we running in DHCP server masquerade mode?
; 1475 :     //
; 1476 :     // If so, catch both DHCP requests and ARP queries
; 1477 :     // to resolve the address of our virtual DHCP server.
; 1478 :     //=====================================================
; 1479 :     if (l_Adapter->m_dhcp_enabled)

  001dc	44 38 43 76	 cmp	 BYTE PTR [rbx+118], r8b
  001e0	0f 84 e1 00 00
	00		 je	 $L23398

; 1480 :       {
; 1481 : 	const ETH_HEADER *eth = (ETH_HEADER *) l_PacketBuffer->m_Data;

  001e6	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  001eb	49 8d 51 04	 lea	 rdx, QWORD PTR [r9+4]
  001ef	48 89 54 24 78	 mov	 QWORD PTR eth$21945[rsp], rdx

; 1482 : 	const IPHDR *ip = (IPHDR *) (l_PacketBuffer->m_Data + sizeof (ETH_HEADER));

  001f4	4d 8d 41 12	 lea	 r8, QWORD PTR [r9+18]
  001f8	4c 89 44 24 68	 mov	 QWORD PTR ip$21947[rsp], r8

; 1483 : 	const UDPHDR *udp = (UDPHDR *) (l_PacketBuffer->m_Data + sizeof (ETH_HEADER) + sizeof (IPHDR));

  001fd	49 8d 49 26	 lea	 rcx, QWORD PTR [r9+38]
  00201	48 89 4c 24 70	 mov	 QWORD PTR udp$21950[rsp], rcx

; 1484 : 
; 1485 : 	// ARP packet?
; 1486 : 	if (l_PacketLength == sizeof (ARP_PACKET)
; 1487 : 	    && eth->proto == htons (ETH_P_ARP)
; 1488 : 	    && l_Adapter->m_dhcp_server_arp)

  00206	41 83 fc 2a	 cmp	 r12d, 42		; 0000002aH
  0020a	75 4d		 jne	 SHORT $L21956
  0020c	66 b8 06 08	 mov	 ax, 2054		; 00000806H
  00210	66 c1 c8 08	 ror	 ax, 8
  00214	66 39 42 0c	 cmp	 WORD PTR [rdx+12], ax
  00218	75 3f		 jne	 SHORT $L21956
  0021a	80 bb 84 00 00
	00 00		 cmp	 BYTE PTR [rbx+132], 0
  00221	74 36		 je	 SHORT $L21956

; 1489 : 	  {
; 1490 : 	    if (ProcessARP (l_Adapter,
; 1491 : 			    (PARP_PACKET) l_PacketBuffer->m_Data,
; 1492 : 			    l_Adapter->m_dhcp_addr,
; 1493 : 			    l_Adapter->m_dhcp_server_ip,
; 1494 : 			    ~0,
; 1495 : 			    l_Adapter->m_dhcp_server_mac))

  00223	48 8d 83 85 00
	00 00		 lea	 rax, QWORD PTR [rbx+133]
  0022a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022f	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00237	44 8b 8b 80 00
	00 00		 mov	 r9d, DWORD PTR [rbx+128]
  0023e	44 8b 43 78	 mov	 r8d, DWORD PTR [rbx+120]
  00242	48 8b cb	 mov	 rcx, rbx
  00245	e8 00 00 00 00	 call	 ProcessARP
  0024a	84 c0		 test	 al, al
  0024c	0f 85 7b 01 00
	00		 jne	 $L23399

; 1496 : 	      goto no_queue;
; 1497 : 	  }
; 1498 : 
; 1499 : 	// DHCP packet?
; 1500 : 	else if (l_PacketLength >= sizeof (ETH_HEADER) + sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP)

  00252	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  00257	eb 73		 jmp	 SHORT $L21979
$L21956:

; 1501 : 		 && eth->proto == htons (ETH_P_IP)
; 1502 : 		 && ip->version_len == 0x45 // IPv4, 20 byte header
; 1503 : 		 && ip->protocol == IPPROTO_UDP
; 1504 : 		 && udp->dest == htons (BOOTPS_PORT))

  00259	41 bb 1a 01 00
	00		 mov	 r11d, 282		; 0000011aH
  0025f	45 3b e3	 cmp	 r12d, r11d
  00262	72 68		 jb	 SHORT $L21979
  00264	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  00268	66 c1 c8 08	 ror	 ax, 8
  0026c	66 39 42 0c	 cmp	 WORD PTR [rdx+12], ax
  00270	75 5a		 jne	 SHORT $L21979
  00272	41 80 38 45	 cmp	 BYTE PTR [r8], 69	; 00000045H
  00276	75 54		 jne	 SHORT $L21979
  00278	41 80 78 09 11	 cmp	 BYTE PTR [r8+9], 17	; 00000011H
  0027d	75 4d		 jne	 SHORT $L21979
  0027f	66 b8 43 00	 mov	 ax, 67			; 00000043H
  00283	66 c1 c8 08	 ror	 ax, 8
  00287	66 39 41 02	 cmp	 WORD PTR [rcx+2], ax
  0028b	75 3f		 jne	 SHORT $L21979

; 1505 : 	  {
; 1506 : 	    const DHCP *dhcp = (DHCP *) (l_PacketBuffer->m_Data
; 1507 : 					 + sizeof (ETH_HEADER)
; 1508 : 					 + sizeof (IPHDR)
; 1509 : 					 + sizeof (UDPHDR));

  0028d	4d 8d 51 2e	 lea	 r10, QWORD PTR [r9+46]
  00291	4c 89 94 24 80
	00 00 00	 mov	 QWORD PTR dhcp$21967[rsp], r10

; 1510 : 
; 1511 : 	    const int optlen = l_PacketLength
; 1512 : 	      - sizeof (ETH_HEADER)
; 1513 : 	      - sizeof (IPHDR)
; 1514 : 	      - sizeof (UDPHDR)
; 1515 : 	      - sizeof (DHCP);

  00299	41 8b c4	 mov	 eax, r12d
  0029c	49 2b c3	 sub	 rax, r11
  0029f	89 44 24 58	 mov	 DWORD PTR optlen$21972[rsp], eax

; 1516 : 
; 1517 : 	    if (optlen > 0) // we must have at least one DHCP option

  002a3	85 c0		 test	 eax, eax
  002a5	0f 8e 27 01 00
	00		 jle	 $no_queue$21940

; 1518 : 	      {
; 1519 : 		if (ProcessDHCP (l_Adapter, eth, ip, udp, dhcp, optlen))

  002ab	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002af	4c 89 54 24 20	 mov	 QWORD PTR [rsp+32], r10
  002b4	4c 8b c9	 mov	 r9, rcx
  002b7	48 8b cb	 mov	 rcx, rbx
  002ba	e8 00 00 00 00	 call	 ProcessDHCP
  002bf	84 c0		 test	 al, al
  002c1	0f 85 06 01 00
	00		 jne	 $L23399
$L23398:

; 1496 : 	      goto no_queue;
; 1497 : 	  }
; 1498 : 
; 1499 : 	// DHCP packet?
; 1500 : 	else if (l_PacketLength >= sizeof (ETH_HEADER) + sizeof (IPHDR) + sizeof (UDPHDR) + sizeof (DHCP)

  002c7	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
$L21979:

; 1520 : 		  goto no_queue;
; 1521 : 	      }
; 1522 : 	    else
; 1523 : 	      goto no_queue;
; 1524 : 	  }
; 1525 :       }
; 1526 : 
; 1527 :     //===============================================
; 1528 :     // In Point-To-Point mode, check to see whether
; 1529 :     // packet is ARP or IPv4 (if neither, then drop).
; 1530 :     //===============================================
; 1531 :     if (l_Adapter->m_tun)

  002cc	80 7b 47 00	 cmp	 BYTE PTR [rbx+71], 0
  002d0	0f 84 92 00 00
	00		 je	 $L21987

; 1532 :       {
; 1533 : 	ETH_HEADER *e;
; 1534 : 
; 1535 : 	if (l_PacketLength < ETHERNET_HEADER_SIZE)

  002d6	41 83 fc 0e	 cmp	 r12d, 14		; 0000000eH
  002da	0f 82 f2 00 00
	00		 jb	 $no_queue$21940

; 1536 : 	  goto no_queue;
; 1537 : 
; 1538 : 	e = (ETH_HEADER *) l_PacketBuffer->m_Data;

  002e0	49 8d 71 04	 lea	 rsi, QWORD PTR [r9+4]
  002e4	48 89 b4 24 90
	00 00 00	 mov	 QWORD PTR e$21981[rsp], rsi

; 1539 : 
; 1540 : 	switch (ntohs (e->proto))

  002ec	66 8b 46 0c	 mov	 ax, WORD PTR [rsi+12]
  002f0	66 c1 c8 08	 ror	 ax, 8
  002f4	0f b7 c8	 movzx	 ecx, ax
  002f7	81 e9 00 08 00
	00		 sub	 ecx, 2048		; 00000800H
  002fd	74 40		 je	 SHORT $L21995
  002ff	83 e9 06	 sub	 ecx, 6
  00302	0f 85 ca 00 00
	00		 jne	 $no_queue$21940

; 1541 : 	  {
; 1542 : 	  case ETH_P_ARP:
; 1543 : 
; 1544 : 	    // Make sure that packet is the
; 1545 : 	    // right size for ARP.
; 1546 : 	    if (l_PacketLength != sizeof (ARP_PACKET))

  00308	41 83 fc 2a	 cmp	 r12d, 42		; 0000002aH
  0030c	0f 85 c0 00 00
	00		 jne	 $no_queue$21940

; 1547 : 	      goto no_queue;
; 1548 : 
; 1549 : 	    ProcessARP (l_Adapter,
; 1550 : 			(PARP_PACKET) l_PacketBuffer->m_Data,
; 1551 : 			l_Adapter->m_localIP,
; 1552 : 			l_Adapter->m_remoteNetwork,
; 1553 : 			l_Adapter->m_remoteNetmask,
; 1554 : 			l_Adapter->m_TapToUser.dest);

  00312	48 8d 43 54	 lea	 rax, QWORD PTR [rbx+84]
  00316	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0031b	8b 43 50	 mov	 eax, DWORD PTR [rbx+80]
  0031e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00322	44 8b 4b 4c	 mov	 r9d, DWORD PTR [rbx+76]
  00326	44 8b 43 48	 mov	 r8d, DWORD PTR [rbx+72]
  0032a	48 8b d6	 mov	 rdx, rsi
  0032d	48 8b cb	 mov	 rcx, rbx
  00330	e8 00 00 00 00	 call	 ProcessARP

; 1555 : 
; 1556 : 	  default:
; 1557 : 	    goto no_queue;

  00335	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  0033a	e9 93 00 00 00	 jmp	 $no_queue$21940
$L21995:

; 1558 : 
; 1559 : 	  case ETH_P_IP:
; 1560 : 
; 1561 : 	    // Make sure that packet is large
; 1562 : 	    // enough to be IPv4.
; 1563 : 	    if (l_PacketLength
; 1564 : 		< ETHERNET_HEADER_SIZE + IP_HEADER_SIZE)

  0033f	41 83 fc 22	 cmp	 r12d, 34		; 00000022H
  00343	0f 82 89 00 00
	00		 jb	 $no_queue$21940

; 1565 : 	      goto no_queue;
; 1566 : 
; 1567 : 	    // Only accept directed packets,
; 1568 : 	    // not broadcasts.
; 1569 : 	    if (memcmp (e, &l_Adapter->m_TapToUser, ETHERNET_HEADER_SIZE))

  00349	48 8d 7b 54	 lea	 rdi, QWORD PTR [rbx+84]
  0034d	33 c0		 xor	 eax, eax
  0034f	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  00354	f3 a6		 repe cmpsb
  00356	74 05		 je	 SHORT $L23396
  00358	1b c0		 sbb	 eax, eax
  0035a	83 d8 ff	 sbb	 eax, -1
$L23396:
  0035d	85 c0		 test	 eax, eax
  0035f	75 71		 jne	 SHORT $no_queue$21940

; 1570 : 	      goto no_queue;
; 1571 : 
; 1572 : 	    // Packet looks like IPv4, queue it.
; 1573 : 	    l_PacketBuffer->m_SizeFlags |= TP_TUN;

  00361	41 81 09 00 00
	00 80		 or	 DWORD PTR [r9], -2147483648 ; 80000000H
$L21987:

; 1574 : 	  }
; 1575 :       }
; 1576 : 
; 1577 :     //===============================================
; 1578 :     // Push packet onto queue to wait for read from
; 1579 :     // userspace.
; 1580 :     //===============================================
; 1581 : 
; 1582 :     NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  00368	48 8d b3 a0 02
	00 00		 lea	 rsi, QWORD PTR [rbx+672]
  0036f	48 8b ce	 mov	 rcx, rsi
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00378	88 83 a8 02 00
	00		 mov	 BYTE PTR [rbx+680], al

; 1583 : 
; 1584 :     result = NULL;

  0037e	49 8b fe	 mov	 rdi, r14
  00381	48 89 7c 24 50	 mov	 QWORD PTR result$[rsp], rdi

; 1585 :     if (IS_UP (l_Adapter))

  00386	80 7b 16 00	 cmp	 BYTE PTR [rbx+22], 0
  0038a	74 22		 je	 SHORT $L22001
  0038c	80 bb f0 02 00
	00 00		 cmp	 BYTE PTR [rbx+752], 0
  00393	74 19		 je	 SHORT $L22001

; 1586 :       result = QueuePush (l_Adapter->m_Extension.m_PacketQueue, l_PacketBuffer);

  00395	48 8b 54 24 30	 mov	 rdx, QWORD PTR l_PacketBuffer$[rsp]
  0039a	48 8b 8b 78 02
	00 00		 mov	 rcx, QWORD PTR [rbx+632]
  003a1	e8 00 00 00 00	 call	 QueuePush
  003a6	48 8b f8	 mov	 rdi, rax
  003a9	48 89 7c 24 50	 mov	 QWORD PTR result$[rsp], rdi
$L22001:

; 1587 : 
; 1588 :     NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  003ae	8a 93 a8 02 00
	00		 mov	 dl, BYTE PTR [rbx+680]
  003b4	48 8b ce	 mov	 rcx, rsi
  003b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1589 : 
; 1590 :     if ((TapPacketPointer) result != l_PacketBuffer)

  003bd	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
  003c2	49 3b f9	 cmp	 rdi, r9
  003c5	74 21		 je	 SHORT $L22003

; 1591 :       {
; 1592 : 	// adapter receive overrun
; 1593 : 	INCREMENT_STAT (l_Adapter->m_TxErr);

  003c7	83 43 2c 01	 add	 DWORD PTR [rbx+44], 1
  003cb	eb 05		 jmp	 SHORT $no_queue$21940
$L23399:

; 1555 : 
; 1556 : 	  default:
; 1557 : 	    goto no_queue;

  003cd	4c 8b 4c 24 30	 mov	 r9, QWORD PTR l_PacketBuffer$[rsp]
$no_queue$21940:

; 1640 : 
; 1641 :  no_queue:
; 1642 :   NdisFreeMemory (l_PacketBuffer,
; 1643 : 		  TAP_PACKET_SIZE (l_PacketLength),
; 1644 : 		  0);

  003d2	41 8d 54 24 04	 lea	 edx, DWORD PTR [r12+4]
  003d7	45 33 c0	 xor	 r8d, r8d
  003da	49 8b c9	 mov	 rcx, r9
  003dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisFreeMemory
  003e3	e9 9b 00 00 00	 jmp	 $exit_success$21917
$L22003:

; 1594 : 	goto no_queue;
; 1595 :       }
; 1596 :     else
; 1597 :       {
; 1598 : 	INCREMENT_STAT (l_Adapter->m_Tx);

  003e8	83 43 24 01	 add	 DWORD PTR [rbx+36], 1
$L22006:

; 1599 :       }
; 1600 : 
; 1601 :     //============================================================
; 1602 :     // Cycle through IRPs and packets, try to satisfy each pending
; 1603 :     // IRP with a queued packet.
; 1604 :     //============================================================
; 1605 :     while (TRUE)
; 1606 :       {
; 1607 : 	l_IRP = NULL;

  003ec	49 8b fe	 mov	 rdi, r14
  003ef	48 89 7c 24 40	 mov	 QWORD PTR l_IRP$[rsp], rdi

; 1608 : 	l_PacketBuffer = NULL;

  003f4	4c 89 74 24 30	 mov	 QWORD PTR l_PacketBuffer$[rsp], r14

; 1609 : 
; 1610 : 	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  003f9	48 8b ce	 mov	 rcx, rsi
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00402	88 83 a8 02 00
	00		 mov	 BYTE PTR [rbx+680], al

; 1611 : 
; 1612 : 	if (IS_UP (l_Adapter)
; 1613 : 	    && QueueCount (l_Adapter->m_Extension.m_PacketQueue)
; 1614 : 	    && QueueCount (l_Adapter->m_Extension.m_IrpQueue))

  00408	80 7b 16 00	 cmp	 BYTE PTR [rbx+22], 0
  0040c	74 41		 je	 SHORT $L22010
  0040e	80 bb f0 02 00
	00 00		 cmp	 BYTE PTR [rbx+752], 0
  00415	74 38		 je	 SHORT $L22010
  00417	48 8b 83 78 02
	00 00		 mov	 rax, QWORD PTR [rbx+632]
  0041e	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00422	74 2b		 je	 SHORT $L22010
  00424	48 8b 8b 80 02
	00 00		 mov	 rcx, QWORD PTR [rbx+640]
  0042b	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  0042f	74 1e		 je	 SHORT $L22010

; 1615 : 	  {
; 1616 : 	    l_IRP = (PIRP) QueuePop (l_Adapter->m_Extension.m_IrpQueue);

  00431	e8 00 00 00 00	 call	 QueuePop
  00436	48 8b f8	 mov	 rdi, rax
  00439	48 89 7c 24 40	 mov	 QWORD PTR l_IRP$[rsp], rdi

; 1617 : 	    l_PacketBuffer = (TapPacketPointer)
; 1618 : 	      QueuePop (l_Adapter->m_Extension.m_PacketQueue);

  0043e	48 8b 8b 78 02
	00 00		 mov	 rcx, QWORD PTR [rbx+632]
  00445	e8 00 00 00 00	 call	 QueuePop
  0044a	48 89 44 24 30	 mov	 QWORD PTR l_PacketBuffer$[rsp], rax
$L22010:

; 1619 : 	  }
; 1620 : 
; 1621 : 	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  0044f	8a 93 a8 02 00
	00		 mov	 dl, BYTE PTR [rbx+680]
  00455	48 8b ce	 mov	 rcx, rsi
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 1622 : 
; 1623 : 	MYASSERT ((l_IRP != NULL) + (l_PacketBuffer != NULL) != 1);
; 1624 : 
; 1625 : 	if (l_IRP && l_PacketBuffer)

  0045e	48 85 ff	 test	 rdi, rdi
  00461	74 1a		 je	 SHORT $L22013
  00463	48 8b 54 24 30	 mov	 rdx, QWORD PTR l_PacketBuffer$[rsp]
  00468	48 85 d2	 test	 rdx, rdx
  0046b	74 10		 je	 SHORT $L22013

; 1626 : 	  {
; 1627 : 	    CompleteIRP (l_IRP,
; 1628 : 			 l_PacketBuffer, 
; 1629 : 			 IO_NETWORK_INCREMENT);

  0046d	41 b0 02	 mov	 r8b, 2
  00470	48 8b cf	 mov	 rcx, rdi
  00473	e8 00 00 00 00	 call	 CompleteIRP

; 1630 : 	  }
; 1631 : 	else
; 1632 : 	  break;
; 1633 :       }

  00478	e9 6f ff ff ff	 jmp	 $L22006
$L22013:
  0047d	eb 00		 jmp	 SHORT $L23361
$L23358:
$L23359:
$L23361:

; 1634 :   }
; 1635 :   __except (EXCEPTION_EXECUTE_HANDLER)
; 1636 :     {
; 1637 :     }
; 1638 : 
; 1639 :   return NDIS_STATUS_SUCCESS;

  0047f	33 c0		 xor	 eax, eax
  00481	eb 09		 jmp	 SHORT $L21897
$exit_success$21917:

; 1645 :   
; 1646 :  exit_success:
; 1647 :   return NDIS_STATUS_SUCCESS;

  00483	33 c0		 xor	 eax, eax
  00485	eb 05		 jmp	 SHORT $L21897
$exit_fail$21913:

; 1648 :     
; 1649 :  exit_fail:
; 1650 :   return NDIS_STATUS_FAILURE;

  00487	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
$L21897:

; 1654 : }

  0048c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00493	41 5e		 pop	 r14
  00495	41 5d		 pop	 r13
  00497	41 5c		 pop	 r12
  00499	5f		 pop	 rdi
  0049a	5e		 pop	 rsi
  0049b	5b		 pop	 rbx
  0049c	c3		 ret	 0
AdapterTransmit ENDP
; Function compile flags: /Ogty
l_PacketBuffer$ = 48
l_Index$ = 56
l_IRP$ = 64
l_BufferLength$ = 72
result$ = 80
optlen$21972 = 88
newlen$21929 = 92
l_NDIS_Buffer$ = 96
ip$21947 = 104
udp$21950 = 112
eth$21945 = 120
dhcp$21967 = 128
l_Buffer$ = 136
e$21981 = 144
p_AdapterContext$ = 224
p_Packet$ = 232
p_Flags$ = 240
AdapterTransmit$filt$0 PROC NEAR
  004a0	53		 push	 rbx
  004a1	56		 push	 rsi
  004a2	57		 push	 rdi
  004a3	41 54		 push	 r12
  004a5	41 55		 push	 r13
  004a7	41 56		 push	 r14
  004a9	55		 push	 rbp
  004aa	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  004ae	48 8b ea	 mov	 rbp, rdx

; 1635 :   __except (EXCEPTION_EXECUTE_HANDLER)

  004b1	41 b9 01 00 00
	00		 mov	 r9d, 1
  004b7	41 8b c1	 mov	 eax, r9d
$L23360:
  004ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  004be	5d		 pop	 rbp
  004bf	41 5e		 pop	 r14
  004c1	41 5d		 pop	 r13
  004c3	41 5c		 pop	 r12
  004c5	5f		 pop	 rdi
  004c6	5e		 pop	 rsi
  004c7	5b		 pop	 rbx
  004c8	c3		 ret	 0
AdapterTransmit$filt$0 ENDP
_TEXT	ENDS
PUBLIC	TapDeviceHook
EXTRN	RtlStringCchPrintfExA:NEAR
EXTRN	__imp_MmMapLockedPagesSpecifyCache:NEAR
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22057 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22067 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22075 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22101 DB	'State=%s Err=[%s/%d] #O=%d Tx=[%d,%d,%d] Rx=[%d,%d,%d] I'
	DB	'rpQ=[%d,%d,%d] PktQ=[%d,%d,%d]', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22110 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22118 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22132 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22141 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22151 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22156 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22159 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22196 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22202 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22206 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22213 DB	'RX', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22227 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22233 DB	'RX', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22243 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22246 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22166 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22172 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22176 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22191 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22278 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22264 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT TapDeviceHook
TapDeviceHook	SEGMENT
$SG22267 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
TapDeviceHook	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapDeviceHook DD 091709H
	DD	01c0117H
	DD	0e00ef010H
	DD	0c00ad00cH
	DD	060077008H
	DD	03006H
	DD	@imagerel(__C_specific_handler#)
	DD	02H
	DD	@imagerel(TapDeviceHook#+1887)
	DD	@imagerel(TapDeviceHook#+2019)
	DD	@imagerel(TapDeviceHook$filt$0#)
	DD	@imagerel(TapDeviceHook#+2019)
	DD	@imagerel(TapDeviceHook#+2100)
	DD	@imagerel(TapDeviceHook#+2226)
	DD	@imagerel(TapDeviceHook$filt$1#)
	DD	@imagerel(TapDeviceHook#+2226)
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapDeviceHook DD @imagerel(TapDeviceHook#)
	DD	@imagerel(TapDeviceHook#+3462)
	DD	@imagerel($unwind$TapDeviceHook#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapDeviceHook$filt$1 DD 0a1301H
	DD	0170113H
	DD	0f00b500cH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapDeviceHook$filt$1 DD @imagerel(TapDeviceHook$filt$1#)
	DD	@imagerel(TapDeviceHook$filt$1#+51)
	DD	@imagerel($unwind$TapDeviceHook$filt$1#)
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapDeviceHook$filt$0 DD 0a1301H
	DD	0170113H
	DD	0f00b500cH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapDeviceHook$filt$0 DD @imagerel(TapDeviceHook$filt$0#)
	DD	@imagerel(TapDeviceHook$filt$0#+51)
	DD	@imagerel($unwind$TapDeviceHook$filt$0#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT TapDeviceHook
_TEXT	SEGMENT
l_Status$ = 176
dest$22105 = 180
dest$22123 = 188
l_Adapter$ = 200
state$22078 = 208
p_DeviceObject$ = 288
p_IRP$ = 296
TapDeviceHook PROC NEAR					; COMDAT

; 1662 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00017	48 8b f2	 mov	 rsi, rdx

; 1663 :   TapAdapterPointer l_Adapter = LookupAdapterInInstanceList (p_DeviceObject);

  0001a	e8 00 00 00 00	 call	 LookupAdapterInInstanceList
  0001f	48 8b f8	 mov	 rdi, rax
  00022	48 89 bc 24 c8
	00 00 00	 mov	 QWORD PTR l_Adapter$[rsp], rdi

; 1664 :   PIO_STACK_LOCATION l_IrpSp;
; 1665 :   NTSTATUS l_Status = STATUS_SUCCESS;

  0002a	33 db		 xor	 ebx, ebx
  0002c	44 8b e3	 mov	 r12d, ebx

; 1666 :   BOOLEAN accessible;
; 1667 : 
; 1668 :   l_IrpSp = IoGetCurrentIrpStackLocation (p_IRP);

  0002f	4c 8b b6 b8 00
	00 00		 mov	 r14, QWORD PTR [rsi+184]

; 1669 : 
; 1670 :   p_IRP->IoStatus.Status = STATUS_SUCCESS;

  00036	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1671 :   p_IRP->IoStatus.Information = 0;

  00039	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 1672 : 
; 1673 :   if (!l_Adapter || l_Adapter->m_Extension.m_Halt)

  0003d	48 85 ff	 test	 rdi, rdi
  00040	0f 84 b6 0c 00
	00		 je	 $L22036
  00046	38 9f b8 02 00
	00		 cmp	 BYTE PTR [rdi+696], bl
  0004c	0f 85 aa 0c 00
	00		 jne	 $L22036

; 1688 : 	}
; 1689 :     }
; 1690 : 
; 1691 :   switch (l_IrpSp->MajorFunction)

  00052	41 0f b6 0e	 movzx	 ecx, BYTE PTR [r14]
  00056	2b cb		 sub	 ecx, ebx
  00058	0f 84 9d 0b 00
	00		 je	 $L22251
  0005e	83 e9 02	 sub	 ecx, 2
  00061	0f 84 d5 0a 00
	00		 je	 $L22269
  00067	83 e9 01	 sub	 ecx, 1
  0006a	0f 84 c3 08 00
	00		 je	 $L22161
  00070	83 e9 01	 sub	 ecx, 1
  00073	0f 84 04 06 00
	00		 je	 $L22193
  00079	83 e9 0a	 sub	 ecx, 10			; 0000000aH
  0007c	74 1b		 je	 SHORT $L22046

; 2340 :       }
; 2341 : 
; 2342 :       //------------------
; 2343 :       // Strange Request
; 2344 :       //------------------
; 2345 :     default:
; 2346 :       {
; 2347 : 	//NOTE_ERROR ();
; 2348 : 	p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  0007e	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00083	44 8b e0	 mov	 r12d, eax
  00086	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2349 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00089	32 d2		 xor	 dl, dl
  0008b	48 8b ce	 mov	 rcx, rsi
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2350 : 	break;

  00094	e9 5e 0c 00 00	 jmp	 $L22043
$L22046:

; 1692 :     {
; 1693 :       //===========================================================
; 1694 :       //                 Ioctl call handlers
; 1695 :       //===========================================================
; 1696 :     case IRP_MJ_DEVICE_CONTROL:
; 1697 :       {
; 1698 : 	switch (l_IrpSp->Parameters.DeviceIoControl.IoControlCode)

  00099	41 8b 46 18	 mov	 eax, DWORD PTR [r14+24]
  0009d	05 fc ff dd ff	 add	 eax, -2228228		; ffddfffcH
  000a2	83 f8 24	 cmp	 eax, 36			; 00000024H
  000a5	0f 87 9f 05 00
	00		 ja	 $L22158
  000ab	48 8d 0d 00 00
	00 00		 lea	 rcx, $L23454
  000b2	48 0f b6 04 01	 movzx	 rax, BYTE PTR [rcx+rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, $L23455
  000be	48 63 04 81	 movsxd	 rax, DWORD PTR [rcx+rax*4]
  000c2	48 8d 0d 00 00
	00 00		 lea	 rcx, $L23456
  000c9	48 03 c1	 add	 rax, rcx
  000cc	ff e0		 jmp	 rax
$L23456:
$L22051:

; 1699 : 	  {
; 1700 : 	  case TAP_IOCTL_GET_MAC:
; 1701 : 	    {
; 1702 : 	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
; 1703 : 		  >= sizeof (MACADDR))

  000ce	41 83 7e 08 06	 cmp	 DWORD PTR [r14+8], 6
  000d3	72 20		 jb	 SHORT $L22053

; 1704 : 		{
; 1705 : 		  COPY_MAC (p_IRP->AssociatedIrp.SystemBuffer,
; 1706 : 			    l_Adapter->m_MAC);

  000d5	48 8d 57 10	 lea	 rdx, QWORD PTR [rdi+16]
  000d9	41 be 06 00 00
	00		 mov	 r14d, 6
  000df	4d 8b c6	 mov	 r8, r14
  000e2	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1707 : 		  p_IRP->IoStatus.Information = sizeof (MACADDR);

  000ec	4c 89 76 38	 mov	 QWORD PTR [rsi+56], r14

; 1708 : 		}
; 1709 : 	      else

  000f0	e9 78 05 00 00	 jmp	 $L22048
$L22053:

; 1710 : 		{
; 1711 : 		  NOTE_ERROR ();

  000f5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22057
  000fc	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00103	c7 05 00 00 00
	00 af 06 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1711 ; 000006afH

; 1712 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;

  0010d	b8 23 00 00 c0	 mov	 eax, -1073741789	; c0000023H
  00112	44 8b e0	 mov	 r12d, eax
  00115	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1713 : 		}
; 1714 : 	      break;

  00118	e9 50 05 00 00	 jmp	 $L22048
$L22059:

; 1715 : 	    }
; 1716 : 	  case TAP_IOCTL_GET_VERSION:
; 1717 : 	    {
; 1718 : 	      const ULONG size = sizeof (ULONG) * 3;
; 1719 : 	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
; 1720 : 		  >= size)

  0011d	41 83 7e 08 0c	 cmp	 DWORD PTR [r14+8], 12	; 0000000cH
  00122	72 29		 jb	 SHORT $L22062

; 1721 : 		{
; 1722 : 		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0]
; 1723 : 		    = TAP_DRIVER_MAJOR_VERSION;

  00124	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00128	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8

; 1724 : 		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[1]
; 1725 : 		    = TAP_DRIVER_MINOR_VERSION;

  0012e	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00132	c7 40 04 04 00
	00 00		 mov	 DWORD PTR [rax+4], 4

; 1726 : 		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[2]
; 1727 : #if DBG
; 1728 : 		    = 1;
; 1729 : #else
; 1730 : 		  = 0;

  00139	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  0013d	89 58 08	 mov	 DWORD PTR [rax+8], ebx

; 1731 : #endif
; 1732 : 		  p_IRP->IoStatus.Information = size;

  00140	48 c7 46 38 0c
	00 00 00	 mov	 QWORD PTR [rsi+56], 12	; 0000000cH

; 1733 : 		}
; 1734 : 	      else

  00148	e9 20 05 00 00	 jmp	 $L22048
$L22062:

; 1735 : 		{
; 1736 : 		  NOTE_ERROR ();

  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22067
  00154	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  0015b	c7 05 00 00 00
	00 c8 06 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1736 ; 000006c8H

; 1737 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;

  00165	b8 23 00 00 c0	 mov	 eax, -1073741789	; c0000023H
  0016a	44 8b e0	 mov	 r12d, eax
  0016d	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1738 : 		}
; 1739 : 
; 1740 : 	      break;

  00170	e9 f8 04 00 00	 jmp	 $L22048
$L22069:

; 1741 : 	    }
; 1742 : 	  case TAP_IOCTL_GET_MTU:
; 1743 : 	    {
; 1744 : 	      const ULONG size = sizeof (ULONG) * 1;
; 1745 : 	      if (l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength
; 1746 : 		  >= size)

  00175	41 83 7e 08 04	 cmp	 DWORD PTR [r14+8], 4
  0017a	72 16		 jb	 SHORT $L22072

; 1747 : 		{
; 1748 : 		  ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0]
; 1749 : 		    = l_Adapter->m_MTU;

  0017c	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00180	8b 47 40	 mov	 eax, DWORD PTR [rdi+64]
  00183	89 01		 mov	 DWORD PTR [rcx], eax

; 1750 : 		  p_IRP->IoStatus.Information = size;

  00185	48 c7 46 38 04
	00 00 00	 mov	 QWORD PTR [rsi+56], 4

; 1751 : 		}
; 1752 : 	      else

  0018d	e9 db 04 00 00	 jmp	 $L22048
$L22072:

; 1753 : 		{
; 1754 : 		  NOTE_ERROR ();

  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22075
  00199	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  001a0	c7 05 00 00 00
	00 da 06 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1754 ; 000006daH

; 1755 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;

  001aa	b8 23 00 00 c0	 mov	 eax, -1073741789	; c0000023H
  001af	44 8b e0	 mov	 r12d, eax
  001b2	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1756 : 		}
; 1757 : 
; 1758 : 	      break;

  001b5	e9 b3 04 00 00	 jmp	 $L22048
$L22077:

; 1759 : 	    }
; 1760 : 	  case TAP_IOCTL_GET_INFO:
; 1761 : 	    {
; 1762 : 	      char state[16];
; 1763 : 	      if (l_Adapter->m_InterfaceIsRunning)

  001ba	b8 61 00 00 00	 mov	 eax, 97			; 00000061H
  001bf	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  001c4	80 7f 16 00	 cmp	 BYTE PTR [rdi+22], 0
  001c8	0f 45 c1	 cmovne	 eax, ecx
  001cb	88 84 24 d0 00
	00 00		 mov	 BYTE PTR state$22078[rsp], al

; 1764 : 		state[0] = 'A';
; 1765 : 	      else
; 1766 : 		state[0] = 'a';
; 1767 : 	      if (l_Adapter->m_Extension.m_TapIsRunning)

  001d2	b8 74 00 00 00	 mov	 eax, 116		; 00000074H
  001d7	b9 54 00 00 00	 mov	 ecx, 84			; 00000054H
  001dc	80 bf f0 02 00
	00 00		 cmp	 BYTE PTR [rdi+752], 0
  001e3	0f 45 c1	 cmovne	 eax, ecx
  001e6	88 84 24 d1 00
	00 00		 mov	 BYTE PTR state$22078[rsp+1], al

; 1768 : 		state[1] = 'T';
; 1769 : 	      else
; 1770 : 		state[1] = 't';
; 1771 : 	      state[2] = l_Adapter->m_DeviceState;

  001ed	8a 47 46	 mov	 al, BYTE PTR [rdi+70]
  001f0	88 84 24 d2 00
	00 00		 mov	 BYTE PTR state$22078[rsp+2], al

; 1772 : 	      if (l_Adapter->m_MediaStateAlwaysConnected)

  001f7	b8 63 00 00 00	 mov	 eax, 99			; 00000063H
  001fc	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  00201	80 7f 44 00	 cmp	 BYTE PTR [rdi+68], 0
  00205	0f 45 c1	 cmovne	 eax, ecx
  00208	88 84 24 d3 00
	00 00		 mov	 BYTE PTR state$22078[rsp+3], al

; 1773 : 		state[3] = 'C';
; 1774 : 	      else
; 1775 : 		state[3] = 'c';
; 1776 : 	      state[4] = '\0';

  0020f	c6 84 24 d4 00
	00 00 00	 mov	 BYTE PTR state$22078[rsp+4], 0

; 1777 : 
; 1778 : 	      p_IRP->IoStatus.Status = l_Status = RtlStringCchPrintfExA (
; 1779 : 	        ((LPTSTR) (p_IRP->AssociatedIrp.SystemBuffer)),
; 1780 : 		l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength,
; 1781 : 		NULL,
; 1782 : 		NULL,
; 1783 : 		STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
; 1784 : #if PACKET_TRUNCATION_CHECK
; 1785 : 		"State=%s Err=[%s/%d] #O=%d Tx=[%d,%d,%d] Rx=[%d,%d,%d] IrpQ=[%d,%d,%d] PktQ=[%d,%d,%d]",
; 1786 : #else
; 1787 : 		"State=%s Err=[%s/%d] #O=%d Tx=[%d,%d] Rx=[%d,%d] IrpQ=[%d,%d,%d] PktQ=[%d,%d,%d]",
; 1788 : #endif
; 1789 : 		state,
; 1790 : 		g_LastErrorFilename,
; 1791 : 		g_LastErrorLineNumber,
; 1792 : 		(int)l_Adapter->m_Extension.m_NumTapOpens,
; 1793 : 		(int)l_Adapter->m_Tx,
; 1794 : 		(int)l_Adapter->m_TxErr,
; 1795 : #if PACKET_TRUNCATION_CHECK
; 1796 : 		(int)l_Adapter->m_TxTrunc,
; 1797 : #endif
; 1798 : 		(int)l_Adapter->m_Rx,
; 1799 : 		(int)l_Adapter->m_RxErr,
; 1800 : #if PACKET_TRUNCATION_CHECK
; 1801 : 		(int)l_Adapter->m_RxTrunc,
; 1802 : #endif
; 1803 : 		(int)l_Adapter->m_Extension.m_IrpQueue->size,
; 1804 : 		(int)l_Adapter->m_Extension.m_IrpQueue->max_size,
; 1805 : 		(int)IRP_QUEUE_SIZE,
; 1806 : 		(int)l_Adapter->m_Extension.m_PacketQueue->size,
; 1807 : 		(int)l_Adapter->m_Extension.m_PacketQueue->max_size,
; 1808 : 		(int)PACKET_QUEUE_SIZE
; 1809 : 		);

  00217	48 8b 8f 78 02
	00 00		 mov	 rcx, QWORD PTR [rdi+632]
  0021e	4c 8b 87 80 02
	00 00		 mov	 r8, QWORD PTR [rdi+640]
  00225	41 8b 56 08	 mov	 edx, DWORD PTR [r14+8]
  00229	c7 84 24 a8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR [rsp+168], 64	; 00000040H
  00234	8b 41 0c	 mov	 eax, DWORD PTR [rcx+12]
  00237	89 84 24 a0 00
	00 00		 mov	 DWORD PTR [rsp+160], eax
  0023e	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  00241	89 84 24 98 00
	00 00		 mov	 DWORD PTR [rsp+152], eax
  00248	c7 84 24 90 00
	00 00 10 00 00
	00		 mov	 DWORD PTR [rsp+144], 16	; 00000010H
  00253	41 8b 40 0c	 mov	 eax, DWORD PTR [r8+12]
  00257	89 84 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], eax
  0025e	41 8b 40 04	 mov	 eax, DWORD PTR [r8+4]
  00262	89 84 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], eax
  00269	8b 47 30	 mov	 eax, DWORD PTR [rdi+48]
  0026c	89 44 24 78	 mov	 DWORD PTR [rsp+120], eax
  00270	8b 47 28	 mov	 eax, DWORD PTR [rdi+40]
  00273	89 44 24 70	 mov	 DWORD PTR [rsp+112], eax
  00277	8b 47 20	 mov	 eax, DWORD PTR [rdi+32]
  0027a	89 44 24 68	 mov	 DWORD PTR [rsp+104], eax
  0027e	8b 47 34	 mov	 eax, DWORD PTR [rdi+52]
  00281	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  00285	8b 47 2c	 mov	 eax, DWORD PTR [rdi+44]
  00288	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0028c	8b 47 24	 mov	 eax, DWORD PTR [rdi+36]
  0028f	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00293	8b 87 ec 02 00
	00		 mov	 eax, DWORD PTR [rdi+748]
  00299	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  0029d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR g_LastErrorLineNumber
  002a3	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  002a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR g_LastErrorFilename
  002ae	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  002b3	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR state$22078[rsp]
  002bb	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  002c0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22101
  002c7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002cc	c7 44 24 20 00
	03 00 00	 mov	 DWORD PTR [rsp+32], 768	; 00000300H
  002d4	45 33 c9	 xor	 r9d, r9d
  002d7	45 33 c0	 xor	 r8d, r8d
  002da	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  002de	e8 00 00 00 00	 call	 RtlStringCchPrintfExA
  002e3	44 8b e0	 mov	 r12d, eax
  002e6	44 89 66 30	 mov	 DWORD PTR [rsi+48], r12d

; 1810 : 
; 1811 : 	      p_IRP->IoStatus.Information
; 1812 : 		= l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

  002ea	41 8b 4e 08	 mov	 ecx, DWORD PTR [r14+8]
  002ee	48 89 4e 38	 mov	 QWORD PTR [rsi+56], rcx

; 1813 : 
; 1814 : 	      break;

  002f2	e9 76 03 00 00	 jmp	 $L22048
$L22102:

; 1815 : 	    }
; 1816 : 
; 1817 : #if DBG
; 1818 : 	  case TAP_IOCTL_GET_LOG_LINE:
; 1819 : 	    {
; 1820 : 	      if (GetDebugLine ((LPTSTR)p_IRP->AssociatedIrp.SystemBuffer,
; 1821 : 				l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength))
; 1822 : 		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;
; 1823 : 	      else
; 1824 : 		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;
; 1825 : 
; 1826 : 	      p_IRP->IoStatus.Information
; 1827 : 		= l_IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
; 1828 : 
; 1829 : 	      break;
; 1830 : 	    }
; 1831 : #endif
; 1832 : 
; 1833 : 	  case TAP_IOCTL_CONFIG_TUN:
; 1834 : 	    {
; 1835 : 	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
; 1836 : 		  (sizeof (IPADDR) * 3))

  002f7	41 83 7e 10 0c	 cmp	 DWORD PTR [r14+16], 12	; 0000000cH
  002fc	0f 82 e6 00 00
	00		 jb	 $L22104

; 1837 : 		{
; 1838 : 		  MACADDR dest;
; 1839 : 
; 1840 : 		  l_Adapter->m_tun = FALSE;

  00302	c6 47 47 00	 mov	 BYTE PTR [rdi+71], 0

; 1841 : 
; 1842 : 		  GenerateRelatedMAC (dest, l_Adapter->m_MAC, 1);

  00306	48 8d 5f 10	 lea	 rbx, QWORD PTR [rdi+16]
  0030a	41 bd 01 00 00
	00		 mov	 r13d, 1
  00310	45 8b c5	 mov	 r8d, r13d
  00313	48 8b d3	 mov	 rdx, rbx
  00316	48 8d 8c 24 b4
	00 00 00	 lea	 rcx, QWORD PTR dest$22105[rsp]
  0031e	e8 00 00 00 00	 call	 GenerateRelatedMAC

; 1843 : 
; 1844 : 		  l_Adapter->m_localIP =       ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];

  00323	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00327	8b 00		 mov	 eax, DWORD PTR [rax]
  00329	89 47 48	 mov	 DWORD PTR [rdi+72], eax

; 1845 : 		  l_Adapter->m_remoteNetwork = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];

  0032c	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00330	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00333	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 1846 : 		  l_Adapter->m_remoteNetmask = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[2];

  00336	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  0033a	8b 50 08	 mov	 edx, DWORD PTR [rax+8]
  0033d	89 57 50	 mov	 DWORD PTR [rdi+80], edx

; 1847 : 
; 1848 : 		  // sanity check on network/netmask
; 1849 : 		  if ((l_Adapter->m_remoteNetwork & l_Adapter->m_remoteNetmask) != l_Adapter->m_remoteNetwork)

  00340	8b 4f 4c	 mov	 ecx, DWORD PTR [rdi+76]
  00343	8b c1		 mov	 eax, ecx
  00345	23 c2		 and	 eax, edx
  00347	3b c1		 cmp	 eax, ecx
  00349	74 28		 je	 SHORT $L22109

; 1850 : 		    {
; 1851 : 		      NOTE_ERROR ();

  0034b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22110
  00352	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00359	c7 05 00 00 00
	00 3b 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1851 ; 0000073bH

; 1852 : 		      p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  00363	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00368	44 8b e0	 mov	 r12d, eax
  0036b	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1853 : 		      break;

  0036e	e9 fa 02 00 00	 jmp	 $L22048
$L22109:

; 1854 : 		    }
; 1855 : 
; 1856 : 		  COPY_MAC (l_Adapter->m_TapToUser.src, l_Adapter->m_MAC);

  00373	48 8d 4f 5a	 lea	 rcx, QWORD PTR [rdi+90]
  00377	41 be 06 00 00
	00		 mov	 r14d, 6
  0037d	4d 8b c6	 mov	 r8, r14
  00380	48 8b d3	 mov	 rdx, rbx
  00383	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1857 : 		  COPY_MAC (l_Adapter->m_TapToUser.dest, dest);

  00389	48 8d 4f 54	 lea	 rcx, QWORD PTR [rdi+84]
  0038d	4d 8b c6	 mov	 r8, r14
  00390	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR dest$22105[rsp]
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1858 : 		  COPY_MAC (l_Adapter->m_UserToTap.src, dest);

  0039e	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  003a2	4d 8b c6	 mov	 r8, r14
  003a5	48 8d 94 24 b4
	00 00 00	 lea	 rdx, QWORD PTR dest$22105[rsp]
  003ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1859 : 		  COPY_MAC (l_Adapter->m_UserToTap.dest, l_Adapter->m_MAC);

  003b3	48 8d 4f 62	 lea	 rcx, QWORD PTR [rdi+98]
  003b7	4d 8b c6	 mov	 r8, r14
  003ba	48 8b d3	 mov	 rdx, rbx
  003bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1860 : 
; 1861 : 		  l_Adapter->m_TapToUser.proto = l_Adapter->m_UserToTap.proto = htons (ETH_P_IP);

  003c3	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  003c7	66 c1 c8 08	 ror	 ax, 8
  003cb	66 89 47 6e	 mov	 WORD PTR [rdi+110], ax
  003cf	66 89 47 60	 mov	 WORD PTR [rdi+96], ax

; 1862 : 
; 1863 : 		  l_Adapter->m_tun = TRUE;

  003d3	c6 47 47 01	 mov	 BYTE PTR [rdi+71], 1

; 1864 : 
; 1865 : 		  CheckIfDhcpAndTunMode (l_Adapter);

  003d7	48 8b cf	 mov	 rcx, rdi
  003da	e8 00 00 00 00	 call	 CheckIfDhcpAndTunMode

; 1866 : 
; 1867 : 		  p_IRP->IoStatus.Information = 1; // Simple boolean value

  003df	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1868 : 		}
; 1869 : 	      else

  003e3	e9 85 02 00 00	 jmp	 $L22048
$L22104:

; 1870 : 		{
; 1871 : 		  NOTE_ERROR ();

  003e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22118
  003ef	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  003f6	c7 05 00 00 00
	00 4f 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1871 ; 0000074fH

; 1872 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  00400	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00405	44 8b e0	 mov	 r12d, eax
  00408	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1873 : 		}
; 1874 : 	      
; 1875 : 	      break;

  0040b	e9 5d 02 00 00	 jmp	 $L22048
$L22120:

; 1876 : 	    }
; 1877 : 
; 1878 : 	  case TAP_IOCTL_CONFIG_POINT_TO_POINT: // Obsoleted by TAP_IOCTL_CONFIG_TUN
; 1879 : 	    {
; 1880 : 	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
; 1881 : 		  (sizeof (IPADDR) * 2))

  00410	41 83 7e 10 08	 cmp	 DWORD PTR [r14+16], 8
  00415	0f 82 b0 00 00
	00		 jb	 $L22122

; 1882 : 		{
; 1883 : 		  MACADDR dest;
; 1884 : 
; 1885 : 		  l_Adapter->m_tun = FALSE;

  0041b	c6 47 47 00	 mov	 BYTE PTR [rdi+71], 0

; 1886 : 
; 1887 : 		  GenerateRelatedMAC (dest, l_Adapter->m_MAC, 1);

  0041f	48 8d 5f 10	 lea	 rbx, QWORD PTR [rdi+16]
  00423	41 bd 01 00 00
	00		 mov	 r13d, 1
  00429	45 8b c5	 mov	 r8d, r13d
  0042c	48 8b d3	 mov	 rdx, rbx
  0042f	48 8d 8c 24 bc
	00 00 00	 lea	 rcx, QWORD PTR dest$22123[rsp]
  00437	e8 00 00 00 00	 call	 GenerateRelatedMAC

; 1888 : 
; 1889 : 		  l_Adapter->m_localIP =       ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];

  0043c	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00440	8b 00		 mov	 eax, DWORD PTR [rax]
  00442	89 47 48	 mov	 DWORD PTR [rdi+72], eax

; 1890 : 		  l_Adapter->m_remoteNetwork = ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];

  00445	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00449	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0044c	89 47 4c	 mov	 DWORD PTR [rdi+76], eax

; 1891 : 		  l_Adapter->m_remoteNetmask = ~0;

  0044f	c7 47 50 ff ff
	ff ff		 mov	 DWORD PTR [rdi+80], -1

; 1892 : 
; 1893 : 		  COPY_MAC (l_Adapter->m_TapToUser.src, l_Adapter->m_MAC);

  00456	48 8d 4f 5a	 lea	 rcx, QWORD PTR [rdi+90]
  0045a	41 be 06 00 00
	00		 mov	 r14d, 6
  00460	4d 8b c6	 mov	 r8, r14
  00463	48 8b d3	 mov	 rdx, rbx
  00466	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1894 : 		  COPY_MAC (l_Adapter->m_TapToUser.dest, dest);

  0046c	48 8d 4f 54	 lea	 rcx, QWORD PTR [rdi+84]
  00470	4d 8b c6	 mov	 r8, r14
  00473	48 8d 94 24 bc
	00 00 00	 lea	 rdx, QWORD PTR dest$22123[rsp]
  0047b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1895 : 		  COPY_MAC (l_Adapter->m_UserToTap.src, dest);

  00481	48 8d 4f 68	 lea	 rcx, QWORD PTR [rdi+104]
  00485	4d 8b c6	 mov	 r8, r14
  00488	48 8d 94 24 bc
	00 00 00	 lea	 rdx, QWORD PTR dest$22123[rsp]
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1896 : 		  COPY_MAC (l_Adapter->m_UserToTap.dest, l_Adapter->m_MAC);

  00496	48 8d 4f 62	 lea	 rcx, QWORD PTR [rdi+98]
  0049a	4d 8b c6	 mov	 r8, r14
  0049d	48 8b d3	 mov	 rdx, rbx
  004a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1897 : 
; 1898 : 		  l_Adapter->m_TapToUser.proto = l_Adapter->m_UserToTap.proto = htons (ETH_P_IP);

  004a6	66 b8 00 08	 mov	 ax, 2048		; 00000800H
  004aa	66 c1 c8 08	 ror	 ax, 8
  004ae	66 89 47 6e	 mov	 WORD PTR [rdi+110], ax
  004b2	66 89 47 60	 mov	 WORD PTR [rdi+96], ax

; 1899 : 
; 1900 : 		  l_Adapter->m_tun = TRUE;

  004b6	44 88 6f 47	 mov	 BYTE PTR [rdi+71], r13b

; 1901 : 
; 1902 : 		  CheckIfDhcpAndTunMode (l_Adapter);

  004ba	48 8b cf	 mov	 rcx, rdi
  004bd	e8 00 00 00 00	 call	 CheckIfDhcpAndTunMode

; 1903 : 
; 1904 : 		  p_IRP->IoStatus.Information = 1; // Simple boolean value

  004c2	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1905 : 		}
; 1906 : 	      else

  004c6	e9 a2 01 00 00	 jmp	 $L22048
$L22122:

; 1907 : 		{
; 1908 : 		  NOTE_ERROR ();

  004cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22132
  004d2	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  004d9	c7 05 00 00 00
	00 74 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1908 ; 00000774H

; 1909 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  004e3	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  004e8	44 8b e0	 mov	 r12d, eax
  004eb	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1910 : 		}
; 1911 : 	      
; 1912 : 	      break;

  004ee	e9 7a 01 00 00	 jmp	 $L22048
$L22134:

; 1913 : 	    }
; 1914 : 
; 1915 : 	  case TAP_IOCTL_SET_MEDIA_STATUS:
; 1916 : 	    {
; 1917 : 	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
; 1918 : 		  (sizeof (ULONG) * 1))

  004f3	41 83 7e 10 04	 cmp	 DWORD PTR [r14+16], 4
  004f8	72 1d		 jb	 SHORT $L22136

; 1919 : 		{
; 1920 : 		  ULONG parm = ((PULONG) (p_IRP->AssociatedIrp.SystemBuffer))[0];

  004fa	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]

; 1921 : 		  SetMediaStatus (l_Adapter, (BOOLEAN) parm);

  004fe	8a 10		 mov	 dl, BYTE PTR [rax]
  00500	48 8b cf	 mov	 rcx, rdi
  00503	e8 00 00 00 00	 call	 SetMediaStatus

; 1922 : 		  p_IRP->IoStatus.Information = 1;

  00508	41 bd 01 00 00
	00		 mov	 r13d, 1
  0050e	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1923 : 		}
; 1924 : 	      else

  00512	e9 56 01 00 00	 jmp	 $L22048
$L22136:

; 1925 : 		{
; 1926 : 		  NOTE_ERROR ();

  00517	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22141
  0051e	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00525	c7 05 00 00 00
	00 86 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1926 ; 00000786H

; 1927 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  0052f	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00534	44 8b e0	 mov	 r12d, eax
  00537	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1928 : 		}
; 1929 : 	      break;

  0053a	e9 2e 01 00 00	 jmp	 $L22048
$L22143:

; 1930 : 	    }
; 1931 : 
; 1932 : 	  case TAP_IOCTL_CONFIG_DHCP_MASQ:
; 1933 : 	    {
; 1934 : 	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength >=
; 1935 : 		  (sizeof (IPADDR) * 4))

  0053f	41 83 7e 10 10	 cmp	 DWORD PTR [r14+16], 16	; 00000010H
  00544	72 76		 jb	 SHORT $L22145

; 1936 : 		{
; 1937 : 		  l_Adapter->m_dhcp_enabled = FALSE;

  00546	c6 47 76 00	 mov	 BYTE PTR [rdi+118], 0

; 1938 : 		  l_Adapter->m_dhcp_server_arp = FALSE;

  0054a	c6 87 84 00 00
	00 00		 mov	 BYTE PTR [rdi+132], 0

; 1939 : 		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;

  00551	89 9f 90 01 00
	00		 mov	 DWORD PTR [rdi+400], ebx

; 1940 : 
; 1941 : 		  // Adapter IP addr / netmask
; 1942 : 		  l_Adapter->m_dhcp_addr =
; 1943 : 		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[0];

  00557	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  0055b	8b 00		 mov	 eax, DWORD PTR [rax]
  0055d	89 47 78	 mov	 DWORD PTR [rdi+120], eax

; 1944 : 		  l_Adapter->m_dhcp_netmask =
; 1945 : 		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[1];

  00560	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00564	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00567	89 47 7c	 mov	 DWORD PTR [rdi+124], eax

; 1946 : 
; 1947 : 		  // IP addr of DHCP masq server
; 1948 : 		  l_Adapter->m_dhcp_server_ip =
; 1949 : 		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[2];

  0056a	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  0056e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00571	89 87 80 00 00
	00		 mov	 DWORD PTR [rdi+128], eax

; 1950 : 
; 1951 : 		  // Lease time in seconds
; 1952 : 		  l_Adapter->m_dhcp_lease_time =
; 1953 : 		    ((IPADDR*) (p_IRP->AssociatedIrp.SystemBuffer))[3];

  00577	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  0057b	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  0057e	89 87 8c 00 00
	00		 mov	 DWORD PTR [rdi+140], eax

; 1954 : 
; 1955 : 		  GenerateRelatedMAC (l_Adapter->m_dhcp_server_mac, l_Adapter->m_MAC, 2);

  00584	48 8d 57 10	 lea	 rdx, QWORD PTR [rdi+16]
  00588	48 8d 8f 85 00
	00 00		 lea	 rcx, QWORD PTR [rdi+133]
  0058f	41 b8 02 00 00
	00		 mov	 r8d, 2
  00595	e8 00 00 00 00	 call	 GenerateRelatedMAC

; 1956 : 
; 1957 : 		  l_Adapter->m_dhcp_enabled = TRUE;

  0059a	c6 47 76 01	 mov	 BYTE PTR [rdi+118], 1

; 1958 : 		  l_Adapter->m_dhcp_server_arp = TRUE;

  0059e	c6 87 84 00 00
	00 01		 mov	 BYTE PTR [rdi+132], 1

; 1959 : 
; 1960 : 		  CheckIfDhcpAndTunMode (l_Adapter);

  005a5	48 8b cf	 mov	 rcx, rdi
  005a8	e8 00 00 00 00	 call	 CheckIfDhcpAndTunMode

; 1961 : 
; 1962 : 		  p_IRP->IoStatus.Information = 1; // Simple boolean value

  005ad	41 bd 01 00 00
	00		 mov	 r13d, 1
  005b3	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1963 : 		}
; 1964 : 	      else

  005b7	e9 b1 00 00 00	 jmp	 $L22048
$L22145:

; 1965 : 		{
; 1966 : 		  NOTE_ERROR ();

  005bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22151
  005c3	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  005ca	c7 05 00 00 00
	00 ae 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1966 ; 000007aeH

; 1967 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  005d4	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  005d9	44 8b e0	 mov	 r12d, eax
  005dc	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1968 : 		}
; 1969 : 	      
; 1970 : 	      break;

  005df	e9 89 00 00 00	 jmp	 $L22048
$L22153:

; 1971 : 	    }
; 1972 : 
; 1973 : 	  case TAP_IOCTL_CONFIG_DHCP_SET_OPT:
; 1974 : 	    {
; 1975 : 	      if (l_IrpSp->Parameters.DeviceIoControl.InputBufferLength <=
; 1976 : 		  DHCP_USER_SUPPLIED_OPTIONS_BUFFER_SIZE
; 1977 : 		  && l_Adapter->m_dhcp_enabled)

  005e4	41 81 7e 10 00
	01 00 00	 cmp	 DWORD PTR [r14+16], 256	; 00000100H
  005ec	77 37		 ja	 SHORT $L22154
  005ee	80 7f 76 00	 cmp	 BYTE PTR [rdi+118], 0
  005f2	74 31		 je	 SHORT $L22154

; 1978 : 		{
; 1979 : 		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 0;

  005f4	89 9f 90 01 00
	00		 mov	 DWORD PTR [rdi+400], ebx

; 1980 : 
; 1981 : 		  NdisMoveMemory (l_Adapter->m_dhcp_user_supplied_options_buffer,
; 1982 : 				  p_IRP->AssociatedIrp.SystemBuffer,
; 1983 : 				  l_IrpSp->Parameters.DeviceIoControl.InputBufferLength);

  005fa	45 8b 46 10	 mov	 r8d, DWORD PTR [r14+16]
  005fe	48 8d 8f 90 00
	00 00		 lea	 rcx, QWORD PTR [rdi+144]
  00605	48 8b 56 18	 mov	 rdx, QWORD PTR [rsi+24]
  00609	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlCopyMemory

; 1984 : 		  
; 1985 : 		  l_Adapter->m_dhcp_user_supplied_options_buffer_len = 
; 1986 : 		    l_IrpSp->Parameters.DeviceIoControl.InputBufferLength;

  0060f	41 8b 46 10	 mov	 eax, DWORD PTR [r14+16]
  00613	89 87 90 01 00
	00		 mov	 DWORD PTR [rdi+400], eax

; 1987 : 
; 1988 : 		  p_IRP->IoStatus.Information = 1; // Simple boolean value

  00619	41 bd 01 00 00
	00		 mov	 r13d, 1
  0061f	4c 89 6e 38	 mov	 QWORD PTR [rsi+56], r13

; 1989 : 		}
; 1990 : 	      else

  00623	eb 48		 jmp	 SHORT $L22048
$L22154:

; 1991 : 		{
; 1992 : 		  NOTE_ERROR ();

  00625	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22156
  0062c	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00633	c7 05 00 00 00
	00 c8 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 1992 ; 000007c8H

; 1993 : 		  p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  0063d	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00642	44 8b e0	 mov	 r12d, eax
  00645	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 1994 : 		}
; 1995 : 	      
; 1996 : 	      break;

  00648	eb 23		 jmp	 SHORT $L22048
$L22158:

; 1997 : 	    }
; 1998 : 
; 1999 : 	  default:
; 2000 : 	    {
; 2001 : 	      NOTE_ERROR ();

  0064a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22159
  00651	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00658	c7 05 00 00 00
	00 d1 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2001 ; 000007d1H

; 2002 : 	      p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  00662	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00667	44 8b e0	 mov	 r12d, eax
  0066a	89 46 30	 mov	 DWORD PTR [rsi+48], eax
$L22048:

; 2003 : 	      break;
; 2004 : 	    }
; 2005 : 	  }
; 2006 : 
; 2007 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  0066d	32 d2		 xor	 dl, dl
  0066f	48 8b ce	 mov	 rcx, rsi
  00672	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2008 : 	break;

  00678	e9 7a 06 00 00	 jmp	 $L22043
$L22193:

; 2113 :       }
; 2114 : 
; 2115 :       //==============================================================
; 2116 :       // User mode issued a WriteFile request on the TAP file handle.
; 2117 :       // The request will always get satisfied here.  The call may
; 2118 :       // fail if there are too many pending packets (queue full).
; 2119 :       //==============================================================
; 2120 :     case IRP_MJ_WRITE:
; 2121 :       {
; 2122 : 	if (p_IRP->MdlAddress == NULL)

  0067d	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00681	48 85 c9	 test	 rcx, rcx
  00684	75 2c		 jne	 SHORT $L22195

; 2123 : 	  {
; 2124 : 	    DEBUGP (("[%s] MdlAddress is NULL for IRP_MJ_WRITE\n",
; 2125 : 		     NAME (l_Adapter)));
; 2126 : 	    NOTE_ERROR ();

  00686	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22196
  0068d	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00694	c7 05 00 00 00
	00 4e 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2126 ; 0000084eH

; 2127 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  0069e	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  006a3	44 8b e0	 mov	 r12d, eax
  006a6	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2128 : 	    p_IRP->IoStatus.Information = 0;

  006a9	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2129 : 	  }
; 2130 : 	else if ((p_IRP->AssociatedIrp.SystemBuffer =

  006ad	e9 62 02 00 00	 jmp	 $L22245
$L22195:

; 2131 : 		  MmGetSystemAddressForMdlSafe
; 2132 : 		  (p_IRP->MdlAddress, NormalPagePriority)) == NULL)

  006b2	8a 41 0a	 mov	 al, BYTE PTR [rcx+10]
  006b5	24 05		 and	 al, 5
  006b7	74 06		 je	 SHORT $L23441
  006b9	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  006bd	eb 23		 jmp	 SHORT $L23442
$L23441:
  006bf	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16	; 00000010H
  006c7	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  006cb	45 33 c9	 xor	 r9d, r9d
  006ce	41 bd 01 00 00
	00		 mov	 r13d, 1
  006d4	45 8b c5	 mov	 r8d, r13d
  006d7	32 d2		 xor	 dl, dl
  006d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
  006df	48 8b c8	 mov	 rcx, rax
$L23442:
  006e2	48 89 4e 18	 mov	 QWORD PTR [rsi+24], rcx
  006e6	48 85 c9	 test	 rcx, rcx
  006e9	75 2c		 jne	 SHORT $L22201

; 2133 : 	  {
; 2134 : 	    DEBUGP (("[%s] Could not map address in IRP_MJ_WRITE\n",
; 2135 : 		     NAME (l_Adapter)));
; 2136 : 	    NOTE_ERROR ();

  006eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22202
  006f2	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  006f9	c7 05 00 00 00
	00 58 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2136 ; 00000858H

; 2137 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_INSUFFICIENT_RESOURCES;

  00703	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00708	44 8b e0	 mov	 r12d, eax
  0070b	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2138 : 	    p_IRP->IoStatus.Information = 0;

  0070e	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2139 : 	  }
; 2140 : 	else if (!l_Adapter->m_InterfaceIsRunning)

  00712	e9 fd 01 00 00	 jmp	 $L22245
$L22201:
  00717	80 7f 16 00	 cmp	 BYTE PTR [rdi+22], 0
  0071b	75 2c		 jne	 SHORT $L22205

; 2141 : 	  {
; 2142 : 	    DEBUGP (("[%s] Interface is down in IRP_MJ_WRITE\n",
; 2143 : 		     NAME (l_Adapter)));
; 2144 : 	    NOTE_ERROR ();

  0071d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22206
  00724	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  0072b	c7 05 00 00 00
	00 60 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2144 ; 00000860H

; 2145 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00735	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  0073a	44 8b e0	 mov	 r12d, eax
  0073d	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2146 : 	    p_IRP->IoStatus.Information = 0;

  00740	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2147 : 	  }
; 2148 : 	else if (!l_Adapter->m_tun && ((l_IrpSp->Parameters.Write.Length) >= ETHERNET_HEADER_SIZE))

  00744	e9 cb 01 00 00	 jmp	 $L22245
$L22205:
  00749	8a 47 47	 mov	 al, BYTE PTR [rdi+71]
  0074c	84 c0		 test	 al, al
  0074e	0f 85 cd 00 00
	00		 jne	 $L22210
  00754	41 83 7e 08 0e	 cmp	 DWORD PTR [r14+8], 14	; 0000000eH
  00759	0f 82 c2 00 00
	00		 jb	 $L22210

; 2149 : 	  {
; 2150 : 	    __try
; 2151 : 	      {
; 2152 : 		p_IRP->IoStatus.Information = l_IrpSp->Parameters.Write.Length;

  0075f	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  00763	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 2153 : 
; 2154 : 		DUMP_PACKET ("IRP_MJ_WRITE ETH",
; 2155 : 			     (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2156 : 			     l_IrpSp->Parameters.Write.Length);
; 2157 : 
; 2158 :     //=====================================================
; 2159 :     // If IPv4 packet, check whether or not packet
; 2160 :     // was truncated.
; 2161 :     //=====================================================
; 2162 : #if PACKET_TRUNCATION_CHECK
; 2163 : 		IPv4PacketSizeVerify ((unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2164 : 				      l_IrpSp->Parameters.Write.Length,
; 2165 : 				      FALSE,
; 2166 : 				      "RX",
; 2167 : 				      &l_Adapter->m_RxTrunc);

  00767	48 8d 47 30	 lea	 rax, QWORD PTR [rdi+48]
  0076b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00770	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG22213
  00777	45 32 c0	 xor	 r8b, r8b
  0077a	41 8b 56 08	 mov	 edx, DWORD PTR [r14+8]
  0077e	e8 00 00 00 00	 call	 IPv4PacketSizeVerify

; 2168 : #endif
; 2169 : 
; 2170 : 		NdisMEthIndicateReceive
; 2171 : 		  (l_Adapter->m_MiniportAdapterHandle,
; 2172 : 		   (NDIS_HANDLE) l_Adapter,
; 2173 : 		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2174 : 		   ETHERNET_HEADER_SIZE,
; 2175 : 		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer + ETHERNET_HEADER_SIZE,
; 2176 : 		   l_IrpSp->Parameters.Write.Length - ETHERNET_HEADER_SIZE,
; 2177 : 		   l_IrpSp->Parameters.Write.Length - ETHERNET_HEADER_SIZE);

  00783	4c 8b 57 18	 mov	 r10, QWORD PTR [rdi+24]
  00787	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  0078b	8d 48 f2	 lea	 ecx, DWORD PTR [rax-14]
  0078e	4c 8b 46 18	 mov	 r8, QWORD PTR [rsi+24]
  00792	49 8d 40 0e	 lea	 rax, QWORD PTR [r8+14]
  00796	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0079a	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0079e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007a3	c7 44 24 20 0e
	00 00 00	 mov	 DWORD PTR [rsp+32], 14	; 0000000eH
  007ab	4d 8b c8	 mov	 r9, r8
  007ae	48 8b d7	 mov	 rdx, rdi
  007b1	49 8b 8a 90 01
	00 00		 mov	 rcx, QWORD PTR [r10+400]
  007b8	41 ff 92 80 02
	00 00		 call	 QWORD PTR [r10+640]

; 2178 : 		
; 2179 : 		NdisMEthIndicateReceiveComplete (l_Adapter->m_MiniportAdapterHandle);

  007bf	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  007c3	48 8b 88 90 01
	00 00		 mov	 rcx, QWORD PTR [rax+400]
  007ca	ff 90 98 02 00
	00		 call	 QWORD PTR [rax+664]

; 2180 : 
; 2181 : 		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;

  007d0	44 8b e3	 mov	 r12d, ebx
  007d3	44 89 a4 24 b0
	00 00 00	 mov	 DWORD PTR l_Status$[rsp], r12d
  007db	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  007de	e9 31 01 00 00	 jmp	 $L22245
$L23444:
$L23445:

; 2182 : 	      }
; 2183 : 	    __except (EXCEPTION_EXECUTE_HANDLER)
; 2184 : 	      {
; 2185 : 		DEBUGP (("[%s] NdisMEthIndicateReceive failed in IRP_MJ_WRITE\n",
; 2186 : 			 NAME (l_Adapter)));
; 2187 : 		NOTE_ERROR ();

  007e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22227
  007ea	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  007f1	c7 05 00 00 00
	00 8b 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2187 ; 0000088bH

; 2188 : 		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  007fb	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00800	44 8b e0	 mov	 r12d, eax
  00803	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR p_IRP$[rsp]
  0080b	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2189 : 		p_IRP->IoStatus.Information = 0;

  0080e	33 db		 xor	 ebx, ebx
  00810	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2190 : 	      }
; 2191 : 	  }
; 2192 : 	else if (l_Adapter->m_tun && ((l_IrpSp->Parameters.Write.Length) >= IP_HEADER_SIZE))

  00814	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR l_Adapter$[rsp]
  0081c	e9 f3 00 00 00	 jmp	 $L22245
$L22210:
  00821	84 c0		 test	 al, al
  00823	0f 84 c4 00 00
	00		 je	 $L22230
  00829	41 83 7e 08 14	 cmp	 DWORD PTR [r14+8], 20	; 00000014H
  0082e	0f 82 b9 00 00
	00		 jb	 $L22230

; 2193 : 	  {
; 2194 : 	    __try
; 2195 : 	      {
; 2196 : 		p_IRP->IoStatus.Information = l_IrpSp->Parameters.Write.Length;

  00834	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  00838	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 2197 : 
; 2198 : 		DUMP_PACKET2 ("IRP_MJ_WRITE P2P",
; 2199 : 			      &l_Adapter->m_UserToTap,
; 2200 : 			      (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2201 : 			      l_IrpSp->Parameters.Write.Length);
; 2202 : 
; 2203 :     //=====================================================
; 2204 :     // If IPv4 packet, check whether or not packet
; 2205 :     // was truncated.
; 2206 :     //=====================================================
; 2207 : #if PACKET_TRUNCATION_CHECK
; 2208 : 		IPv4PacketSizeVerify ((unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2209 : 				      l_IrpSp->Parameters.Write.Length,
; 2210 : 				      TRUE,
; 2211 : 				      "RX",
; 2212 : 				      &l_Adapter->m_RxTrunc);

  0083c	48 8d 47 30	 lea	 rax, QWORD PTR [rdi+48]
  00840	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00845	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG22233
  0084c	41 b0 01	 mov	 r8b, 1
  0084f	41 8b 56 08	 mov	 edx, DWORD PTR [r14+8]
  00853	e8 00 00 00 00	 call	 IPv4PacketSizeVerify

; 2213 : #endif
; 2214 : 
; 2215 : 		NdisMEthIndicateReceive
; 2216 : 		  (l_Adapter->m_MiniportAdapterHandle,
; 2217 : 		   (NDIS_HANDLE) l_Adapter,
; 2218 : 		   (unsigned char *) &l_Adapter->m_UserToTap,
; 2219 : 		   sizeof (l_Adapter->m_UserToTap),
; 2220 : 		   (unsigned char *) p_IRP->AssociatedIrp.SystemBuffer,
; 2221 : 		   l_IrpSp->Parameters.Write.Length,
; 2222 : 		   l_IrpSp->Parameters.Write.Length);

  00858	4c 8b 57 18	 mov	 r10, QWORD PTR [rdi+24]
  0085c	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  00860	4c 8d 47 62	 lea	 r8, QWORD PTR [rdi+98]
  00864	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00868	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0086c	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00870	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00875	c7 44 24 20 0e
	00 00 00	 mov	 DWORD PTR [rsp+32], 14	; 0000000eH
  0087d	4d 8b c8	 mov	 r9, r8
  00880	48 8b d7	 mov	 rdx, rdi
  00883	49 8b 8a 90 01
	00 00		 mov	 rcx, QWORD PTR [r10+400]
  0088a	41 ff 92 80 02
	00 00		 call	 QWORD PTR [r10+640]

; 2223 : 
; 2224 : 		NdisMEthIndicateReceiveComplete (l_Adapter->m_MiniportAdapterHandle);

  00891	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00895	48 8b 88 90 01
	00 00		 mov	 rcx, QWORD PTR [rax+400]
  0089c	ff 90 98 02 00
	00		 call	 QWORD PTR [rax+664]

; 2225 : 
; 2226 : 		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;

  008a2	44 8b e3	 mov	 r12d, ebx
  008a5	44 89 a4 24 b0
	00 00 00	 mov	 DWORD PTR l_Status$[rsp], r12d
  008ad	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx
  008b0	eb 62		 jmp	 SHORT $L22245
$L23448:
$L23449:

; 2227 : 	      }
; 2228 : 	    __except (EXCEPTION_EXECUTE_HANDLER)
; 2229 : 	      {
; 2230 : 		DEBUGP (("[%s] NdisMEthIndicateReceive failed in IRP_MJ_WRITE (P2P)\n",
; 2231 : 			 NAME (l_Adapter)));
; 2232 : 		NOTE_ERROR ();

  008b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22243
  008b9	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  008c0	c7 05 00 00 00
	00 b8 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2232 ; 000008b8H

; 2233 : 		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  008ca	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  008cf	44 8b e0	 mov	 r12d, eax
  008d2	48 8b b4 24 28
	01 00 00	 mov	 rsi, QWORD PTR p_IRP$[rsp]
  008da	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2234 : 		p_IRP->IoStatus.Information = 0;

  008dd	33 db		 xor	 ebx, ebx
  008df	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2235 : 	      }
; 2236 : 	  }
; 2237 : 	else

  008e3	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR l_Adapter$[rsp]
  008eb	eb 27		 jmp	 SHORT $L22245
$L22230:

; 2238 : 	  {
; 2239 : 	    DEBUGP (("[%s] Bad buffer size in IRP_MJ_WRITE, len=%d\n",
; 2240 : 		     NAME (l_Adapter),
; 2241 : 		     l_IrpSp->Parameters.Write.Length));
; 2242 : 	    NOTE_ERROR ();

  008ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22246
  008f4	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  008fb	c7 05 00 00 00
	00 c2 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2242 ; 000008c2H

; 2243 : 	    p_IRP->IoStatus.Information = 0;	// ETHERNET_HEADER_SIZE;

  00905	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2244 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_BUFFER_TOO_SMALL;

  00909	b8 23 00 00 c0	 mov	 eax, -1073741789	; c0000023H
  0090e	44 8b e0	 mov	 r12d, eax
  00911	89 46 30	 mov	 DWORD PTR [rsi+48], eax
$L22245:

; 2245 : 	  }
; 2246 : 
; 2247 : 	if (l_Status == STATUS_SUCCESS)

  00914	45 85 e4	 test	 r12d, r12d
  00917	75 06		 jne	 SHORT $L22249

; 2248 : 	  INCREMENT_STAT (l_Adapter->m_Rx);

  00919	83 47 20 01	 add	 DWORD PTR [rdi+32], 1

; 2249 : 	else

  0091d	eb 04		 jmp	 SHORT $L22250
$L22249:

; 2250 : 	  INCREMENT_STAT (l_Adapter->m_RxErr);

  0091f	83 47 28 01	 add	 DWORD PTR [rdi+40], 1
$L22250:

; 2251 : 
; 2252 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00923	32 d2		 xor	 dl, dl
  00925	48 8b ce	 mov	 rcx, rsi
  00928	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2253 : 	break;

  0092e	e9 c4 03 00 00	 jmp	 $L22043
$L22161:

; 2009 :       }
; 2010 : 
; 2011 :       //===========================================================
; 2012 :       // User mode thread issued a read request on the tap device
; 2013 :       // If there are packets waiting to be read, then the request
; 2014 :       // will be satisfied here. If not, then the request will be
; 2015 :       // queued and satisfied by any packet that is not used to
; 2016 :       // satisfy requests ahead of it.
; 2017 :       //===========================================================
; 2018 :     case IRP_MJ_READ:
; 2019 :       {
; 2020 : 	TapPacketPointer l_PacketBuffer;
; 2021 : 	BOOLEAN pending = FALSE;

  00933	45 32 ff	 xor	 r15b, r15b

; 2022 : 
; 2023 : 	// Save IRP-accessible copy of buffer length
; 2024 : 	p_IRP->IoStatus.Information = l_IrpSp->Parameters.Read.Length;

  00936	41 8b 46 08	 mov	 eax, DWORD PTR [r14+8]
  0093a	48 89 46 38	 mov	 QWORD PTR [rsi+56], rax

; 2025 : 
; 2026 : 	if (p_IRP->MdlAddress == NULL)

  0093e	48 8b 4e 08	 mov	 rcx, QWORD PTR [rsi+8]
  00942	48 85 c9	 test	 rcx, rcx
  00945	75 37		 jne	 SHORT $L22165

; 2027 : 	  {
; 2028 : 	    DEBUGP (("[%s] MdlAddress is NULL for IRP_MJ_READ\n",
; 2029 : 		     NAME (l_Adapter)));
; 2030 : 	    NOTE_ERROR ();

  00947	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22166
  0094e	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00955	c7 05 00 00 00
	00 ee 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2030 ; 000007eeH

; 2031 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_INVALID_PARAMETER;

  0095f	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  00964	44 8b e0	 mov	 r12d, eax
  00967	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2032 : 	    p_IRP->IoStatus.Information = 0;

  0096a	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2033 : 	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  0096e	32 d2		 xor	 dl, dl
  00970	48 8b ce	 mov	 rcx, rsi
  00973	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2034 : 	    break;

  00979	e9 79 03 00 00	 jmp	 $L22043
$L22165:

; 2035 : 	  }
; 2036 : 	else if ((p_IRP->AssociatedIrp.SystemBuffer =
; 2037 : 		  MmGetSystemAddressForMdlSafe
; 2038 : 		  (p_IRP->MdlAddress, NormalPagePriority)) == NULL)

  0097e	8a 41 0a	 mov	 al, BYTE PTR [rcx+10]
  00981	24 05		 and	 al, 5
  00983	74 06		 je	 SHORT $L23439
  00985	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00989	eb 20		 jmp	 SHORT $L23440
$L23439:
  0098b	c7 44 24 28 10
	00 00 00	 mov	 DWORD PTR [rsp+40], 16	; 00000010H
  00993	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00997	45 33 c9	 xor	 r9d, r9d
  0099a	41 bd 01 00 00
	00		 mov	 r13d, 1
  009a0	45 8b c5	 mov	 r8d, r13d
  009a3	32 d2		 xor	 dl, dl
  009a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_MmMapLockedPagesSpecifyCache
$L23440:
  009ab	48 89 46 18	 mov	 QWORD PTR [rsi+24], rax
  009af	48 85 c0	 test	 rax, rax
  009b2	75 37		 jne	 SHORT $L22171

; 2039 : 	  {
; 2040 : 	    DEBUGP (("[%s] Could not map address in IRP_MJ_READ\n",
; 2041 : 		     NAME (l_Adapter)));
; 2042 : 	    NOTE_ERROR ();

  009b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22172
  009bb	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  009c2	c7 05 00 00 00
	00 fa 07 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2042 ; 000007faH

; 2043 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_INSUFFICIENT_RESOURCES;

  009cc	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  009d1	44 8b e0	 mov	 r12d, eax
  009d4	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2044 : 	    p_IRP->IoStatus.Information = 0;

  009d7	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2045 : 	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  009db	32 d2		 xor	 dl, dl
  009dd	48 8b ce	 mov	 rcx, rsi
  009e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2046 : 	    break;

  009e6	e9 0c 03 00 00	 jmp	 $L22043
$L22171:

; 2047 : 	  }
; 2048 : 	else if (!l_Adapter->m_InterfaceIsRunning)

  009eb	80 7f 16 00	 cmp	 BYTE PTR [rdi+22], 0
  009ef	75 37		 jne	 SHORT $L22175

; 2049 : 	  {
; 2050 : 	    DEBUGP (("[%s] Interface is down in IRP_MJ_READ\n",
; 2051 : 		     NAME (l_Adapter)));
; 2052 : 	    NOTE_ERROR ();

  009f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22176
  009f8	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  009ff	c7 05 00 00 00
	00 04 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2052 ; 00000804H

; 2053 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00a09	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00a0e	44 8b e0	 mov	 r12d, eax
  00a11	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2054 : 	    p_IRP->IoStatus.Information = 0;

  00a14	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2055 : 	    IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00a18	32 d2		 xor	 dl, dl
  00a1a	48 8b ce	 mov	 rcx, rsi
  00a1d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2056 : 	    break;

  00a23	e9 cf 02 00 00	 jmp	 $L22043
$L22175:

; 2057 : 	  }
; 2058 : 
; 2059 : 	//==================================
; 2060 : 	// Can we provide immediate service?
; 2061 : 	//==================================
; 2062 : 
; 2063 : 	l_PacketBuffer = NULL;

  00a28	4c 8b f3	 mov	 r14, rbx

; 2064 : 
; 2065 : 	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  00a2b	4c 8d af a0 02
	00 00		 lea	 r13, QWORD PTR [rdi+672]
  00a32	49 8b cd	 mov	 rcx, r13
  00a35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00a3b	88 87 a8 02 00
	00		 mov	 BYTE PTR [rdi+680], al

; 2066 : 
; 2067 : 	if (IS_UP (l_Adapter)
; 2068 : 	    && QueueCount (l_Adapter->m_Extension.m_PacketQueue)
; 2069 : 	    && QueueCount (l_Adapter->m_Extension.m_IrpQueue) == 0)

  00a41	80 7f 16 00	 cmp	 BYTE PTR [rdi+22], 0
  00a45	74 2b		 je	 SHORT $L22179
  00a47	80 bf f0 02 00
	00 00		 cmp	 BYTE PTR [rdi+752], 0
  00a4e	74 22		 je	 SHORT $L22179
  00a50	48 8b 8f 78 02
	00 00		 mov	 rcx, QWORD PTR [rdi+632]
  00a57	83 79 04 00	 cmp	 DWORD PTR [rcx+4], 0
  00a5b	74 15		 je	 SHORT $L22179
  00a5d	48 8b 87 80 02
	00 00		 mov	 rax, QWORD PTR [rdi+640]
  00a64	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00a68	75 08		 jne	 SHORT $L22179

; 2070 : 	  {
; 2071 : 	    l_PacketBuffer = (TapPacketPointer)
; 2072 : 	      QueuePop (l_Adapter->m_Extension.m_PacketQueue);

  00a6a	e8 00 00 00 00	 call	 QueuePop
  00a6f	4c 8b f0	 mov	 r14, rax
$L22179:

; 2073 : 	  }
; 2074 : 
; 2075 : 	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  00a72	8a 97 a8 02 00
	00		 mov	 dl, BYTE PTR [rdi+680]
  00a78	49 8b cd	 mov	 rcx, r13
  00a7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2076 : 
; 2077 : 	if (l_PacketBuffer)

  00a81	4d 85 f6	 test	 r14, r14
  00a84	74 16		 je	 SHORT $L22181

; 2078 : 	  {
; 2079 : 	    l_Status = CompleteIRP (p_IRP,
; 2080 : 				    l_PacketBuffer,
; 2081 : 				    IO_NO_INCREMENT);

  00a86	45 32 c0	 xor	 r8b, r8b
  00a89	49 8b d6	 mov	 rdx, r14
  00a8c	48 8b ce	 mov	 rcx, rsi
  00a8f	e8 00 00 00 00	 call	 CompleteIRP
  00a94	44 8b e0	 mov	 r12d, eax

; 2082 : 	    break;

  00a97	e9 5b 02 00 00	 jmp	 $L22043
$L22181:

; 2083 : 	  }
; 2084 : 
; 2085 : 	//=============================
; 2086 : 	// Attempt to pend read request
; 2087 : 	//=============================
; 2088 : 
; 2089 : 	NdisAcquireSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  00a9c	49 8b cd	 mov	 rcx, r13
  00a9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAcquireSpinLockRaiseToDpc
  00aa5	88 87 a8 02 00
	00		 mov	 BYTE PTR [rdi+680], al

; 2090 : 
; 2091 : 	if (IS_UP (l_Adapter)
; 2092 : 	    && QueuePush (l_Adapter->m_Extension.m_IrpQueue, p_IRP) == (PIRP) p_IRP)

  00aab	80 7f 16 00	 cmp	 BYTE PTR [rdi+22], 0
  00aaf	74 3c		 je	 SHORT $L22183
  00ab1	80 bf f0 02 00
	00 00		 cmp	 BYTE PTR [rdi+752], 0
  00ab8	74 33		 je	 SHORT $L22183
  00aba	48 8b d6	 mov	 rdx, rsi
  00abd	48 8b 8f 80 02
	00 00		 mov	 rcx, QWORD PTR [rdi+640]
  00ac4	e8 00 00 00 00	 call	 QueuePush
  00ac9	48 3b c6	 cmp	 rax, rsi
  00acc	75 1f		 jne	 SHORT $L22183

; 2093 : 	  {
; 2094 : 	    IoSetCancelRoutine (p_IRP, CancelIRPCallback);

  00ace	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:CancelIRPCallback
  00ad5	48 87 46 68	 xchg	 QWORD PTR [rsi+104], rax

; 2095 : 	    l_Status = STATUS_PENDING;

  00ad9	41 bc 03 01 00
	00		 mov	 r12d, 259		; 00000103H

; 2096 : 	    IoMarkIrpPending (p_IRP);

  00adf	48 8b 86 b8 00
	00 00		 mov	 rax, QWORD PTR [rsi+184]
  00ae6	80 48 03 01	 or	 BYTE PTR [rax+3], 1

; 2097 : 	    pending = TRUE;

  00aea	41 b7 01	 mov	 r15b, 1
$L22183:

; 2098 : 	  }
; 2099 : 
; 2100 : 	NdisReleaseSpinLock (&l_Adapter->m_Extension.m_QueueLock);

  00aed	8a 97 a8 02 00
	00		 mov	 dl, BYTE PTR [rdi+680]
  00af3	49 8b cd	 mov	 rcx, r13
  00af6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeReleaseSpinLock

; 2101 : 
; 2102 : 	if (pending)

  00afc	45 84 ff	 test	 r15b, r15b
  00aff	0f 85 f2 01 00
	00		 jne	 $L22043

; 2103 : 	  break;
; 2104 : 
; 2105 : 	// Can't queue anymore IRP's
; 2106 : 	DEBUGP (("[%s] TAP [%s] read IRP overrun\n",
; 2107 : 		 NAME (l_Adapter), l_Adapter->m_Extension.m_TapName));
; 2108 : 	NOTE_ERROR ();

  00b05	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22191
  00b0c	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00b13	c7 05 00 00 00
	00 3c 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2108 ; 0000083cH

; 2109 : 	p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00b1d	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00b22	44 8b e0	 mov	 r12d, eax
  00b25	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2110 : 	p_IRP->IoStatus.Information = 0;

  00b28	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2111 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00b2c	32 d2		 xor	 dl, dl
  00b2e	48 8b ce	 mov	 rcx, rsi
  00b31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2112 : 	break;

  00b37	e9 bb 01 00 00	 jmp	 $L22043
$L22269:

; 2306 : 	break;
; 2307 :       }
; 2308 :       
; 2309 :       //-----------------------------------------------------------
; 2310 :       //  User mode thread called CloseHandle() on the tap device
; 2311 :       //-----------------------------------------------------------
; 2312 :     case IRP_MJ_CLOSE:
; 2313 :       {
; 2314 : 	BOOLEAN mutex_succeeded;
; 2315 : 
; 2316 : 	DEBUGP (("[%s] [TAP] release [%d.%d] close/cleanup request\n",
; 2317 : 		 NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
; 2318 : 		 TAP_DRIVER_MINOR_VERSION));
; 2319 : 
; 2320 : 	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);

  00b3c	41 b7 01	 mov	 r15b, 1
  00b3f	41 bd 01 00 00
	00		 mov	 r13d, 1
  00b45	41 8b c5	 mov	 eax, r13d
  00b48	f0 0f c1 87 b4
	02 00 00	 lock xadd DWORD PTR [rdi+692], eax
  00b50	41 03 c5	 add	 eax, r13d
  00b53	41 3b c5	 cmp	 eax, r13d
  00b56	74 39		 je	 SHORT $L22273
  00b58	41 be 10 27 00
	00		 mov	 r14d, 10000		; 00002710H
$L22272:
  00b5e	f0 83 87 b4 02
	00 00 ff	 lock add DWORD PTR [rdi+692], -1
  00b66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  00b6c	3c 02		 cmp	 al, 2
  00b6e	73 1e		 jae	 SHORT $L22274
  00b70	41 8b ce	 mov	 ecx, r14d
  00b73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  00b79	41 8b c5	 mov	 eax, r13d
  00b7c	f0 0f c1 87 b4
	02 00 00	 lock xadd DWORD PTR [rdi+692], eax
  00b84	83 c0 01	 add	 eax, 1
  00b87	83 f8 01	 cmp	 eax, 1
  00b8a	75 d2		 jne	 SHORT $L22272

; 1672 : 
; 1673 :   if (!l_Adapter || l_Adapter->m_Extension.m_Halt)

  00b8c	eb 03		 jmp	 SHORT $L22273
$L22274:

; 2306 : 	break;
; 2307 :       }
; 2308 :       
; 2309 :       //-----------------------------------------------------------
; 2310 :       //  User mode thread called CloseHandle() on the tap device
; 2311 :       //-----------------------------------------------------------
; 2312 :     case IRP_MJ_CLOSE:
; 2313 :       {
; 2314 : 	BOOLEAN mutex_succeeded;
; 2315 : 
; 2316 : 	DEBUGP (("[%s] [TAP] release [%d.%d] close/cleanup request\n",
; 2317 : 		 NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
; 2318 : 		 TAP_DRIVER_MINOR_VERSION));
; 2319 : 
; 2320 : 	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);

  00b8e	45 32 ff	 xor	 r15b, r15b
$L22273:

; 2321 : 	if (mutex_succeeded)

  00b91	45 84 ff	 test	 r15b, r15b
  00b94	74 2e		 je	 SHORT $L22276

; 2322 : 	  {
; 2323 : 	    l_Adapter->m_Extension.m_TapOpens = 0;

  00b96	89 9f 98 02 00
	00		 mov	 DWORD PTR [rdi+664], ebx

; 2324 : 	    ResetTapAdapterState (l_Adapter);

  00b9c	48 8b cf	 mov	 rcx, rdi
  00b9f	e8 00 00 00 00	 call	 ResetTapAdapterState

; 2325 : 	    FlushQueues (&l_Adapter->m_Extension);

  00ba4	48 8d 8f 78 02
	00 00		 lea	 rcx, QWORD PTR [rdi+632]
  00bab	e8 00 00 00 00	 call	 FlushQueues

; 2326 : 	    SetMediaStatus (l_Adapter, FALSE);

  00bb0	32 d2		 xor	 dl, dl
  00bb2	48 8b cf	 mov	 rcx, rdi
  00bb5	e8 00 00 00 00	 call	 SetMediaStatus

; 2327 : 	    RELEASE_MUTEX (&l_Adapter->m_Extension.m_OpenCloseMutex);

  00bba	f0 83 87 b4 02
	00 00 ff	 lock add DWORD PTR [rdi+692], -1

; 2328 : 	  }
; 2329 : 	else

  00bc2	eb 27		 jmp	 SHORT $L22277
$L22276:

; 2330 : 	  {
; 2331 : 	    DEBUGP (("[%s] TAP is presently locked (m_TapOpens=%d)\n",
; 2332 : 		     NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
; 2333 : 	    NOTE_ERROR ();

  00bc4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22278
  00bcb	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00bd2	c7 05 00 00 00
	00 1d 09 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2333 ; 0000091dH

; 2334 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00bdc	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00be1	44 8b e0	 mov	 r12d, eax
  00be4	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2335 : 	    p_IRP->IoStatus.Information = 0;

  00be7	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$L22277:

; 2336 : 	  }
; 2337 : 	
; 2338 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00beb	32 d2		 xor	 dl, dl
  00bed	48 8b ce	 mov	 rcx, rsi
  00bf0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 2339 : 	break;

  00bf6	e9 fc 00 00 00	 jmp	 $L22043
$L22251:

; 2254 :       }
; 2255 : 
; 2256 :       //--------------------------------------------------------------
; 2257 :       //   User mode thread has called CreateFile() on the tap device
; 2258 :       //--------------------------------------------------------------
; 2259 :     case IRP_MJ_CREATE:
; 2260 :       {
; 2261 : 	BOOLEAN succeeded = FALSE;

  00bfb	45 32 ff	 xor	 r15b, r15b

; 2262 : 	BOOLEAN mutex_succeeded;
; 2263 : 
; 2264 : 	DEBUGP
; 2265 : 	  (("[%s] [TAP] release [%d.%d] open request (m_TapOpens=%d)\n",
; 2266 : 	    NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
; 2267 : 	    TAP_DRIVER_MINOR_VERSION, l_Adapter->m_Extension.m_TapOpens));
; 2268 : 
; 2269 : 	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);

  00bfe	41 b4 01	 mov	 r12b, 1
  00c01	41 bd 01 00 00
	00		 mov	 r13d, 1
  00c07	41 8b c5	 mov	 eax, r13d
  00c0a	f0 0f c1 87 b4
	02 00 00	 lock xadd DWORD PTR [rdi+692], eax
  00c12	41 03 c5	 add	 eax, r13d
  00c15	41 3b c5	 cmp	 eax, r13d
  00c18	74 39		 je	 SHORT $L22256
  00c1a	41 be 10 27 00
	00		 mov	 r14d, 10000		; 00002710H
$L22255:
  00c20	f0 83 87 b4 02
	00 00 ff	 lock add DWORD PTR [rdi+692], -1
  00c28	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeGetCurrentIrql
  00c2e	3c 02		 cmp	 al, 2
  00c30	73 1e		 jae	 SHORT $L22257
  00c32	41 8b ce	 mov	 ecx, r14d
  00c35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSleep
  00c3b	41 8b c5	 mov	 eax, r13d
  00c3e	f0 0f c1 87 b4
	02 00 00	 lock xadd DWORD PTR [rdi+692], eax
  00c46	83 c0 01	 add	 eax, 1
  00c49	83 f8 01	 cmp	 eax, 1
  00c4c	75 d2		 jne	 SHORT $L22255

; 1672 : 
; 1673 :   if (!l_Adapter || l_Adapter->m_Extension.m_Halt)

  00c4e	eb 03		 jmp	 SHORT $L22256
$L22257:

; 2262 : 	BOOLEAN mutex_succeeded;
; 2263 : 
; 2264 : 	DEBUGP
; 2265 : 	  (("[%s] [TAP] release [%d.%d] open request (m_TapOpens=%d)\n",
; 2266 : 	    NAME (l_Adapter), TAP_DRIVER_MAJOR_VERSION,
; 2267 : 	    TAP_DRIVER_MINOR_VERSION, l_Adapter->m_Extension.m_TapOpens));
; 2268 : 
; 2269 : 	ACQUIRE_MUTEX_ADAPTIVE (&l_Adapter->m_Extension.m_OpenCloseMutex, mutex_succeeded);

  00c50	45 32 e4	 xor	 r12b, r12b
$L22256:

; 2270 : 	if (mutex_succeeded)

  00c53	45 84 e4	 test	 r12b, r12b
  00c56	74 6d		 je	 SHORT $L22259

; 2271 : 	  {
; 2272 : 	    if (l_Adapter->m_Extension.m_TapIsRunning && !l_Adapter->m_Extension.m_TapOpens)

  00c58	80 bf f0 02 00
	00 00		 cmp	 BYTE PTR [rdi+752], 0
  00c5f	74 1b		 je	 SHORT $L22260
  00c61	83 bf 98 02 00
	00 00		 cmp	 DWORD PTR [rdi+664], 0
  00c68	75 12		 jne	 SHORT $L22260

; 2273 : 	      {
; 2274 : 		ResetTapAdapterState (l_Adapter);

  00c6a	48 8b cf	 mov	 rcx, rdi
  00c6d	e8 00 00 00 00	 call	 ResetTapAdapterState

; 2275 : 		l_Adapter->m_Extension.m_TapOpens = 1;

  00c72	44 89 af 98 02
	00 00		 mov	 DWORD PTR [rdi+664], r13d

; 2276 : 		succeeded = TRUE;

  00c79	41 b7 01	 mov	 r15b, 1
$L22260:

; 2277 : 	      }
; 2278 : 
; 2279 : 	    if (succeeded)

  00c7c	45 84 ff	 test	 r15b, r15b
  00c7f	74 13		 je	 SHORT $L22261

; 2280 : 	      {
; 2281 : 		INCREMENT_STAT (l_Adapter->m_Extension.m_NumTapOpens);

  00c81	83 87 ec 02 00
	00 01		 add	 DWORD PTR [rdi+748], 1

; 2282 : 		p_IRP->IoStatus.Status = l_Status = STATUS_SUCCESS;

  00c88	44 8b e3	 mov	 r12d, ebx
  00c8b	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 2283 : 		p_IRP->IoStatus.Information = 0;

  00c8e	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx

; 2284 : 	      }
; 2285 : 	    else

  00c92	eb 27		 jmp	 SHORT $L22263
$L22261:

; 2286 : 	      {
; 2287 : 		DEBUGP (("[%s] TAP is presently unavailable (m_TapOpens=%d)\n",
; 2288 : 			 NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
; 2289 : 		NOTE_ERROR ();

  00c94	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22264
  00c9b	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00ca2	c7 05 00 00 00
	00 f1 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2289 ; 000008f1H

; 2290 : 		p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00cac	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00cb1	44 8b e0	 mov	 r12d, eax
  00cb4	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2291 : 		p_IRP->IoStatus.Information = 0;

  00cb7	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$L22263:

; 2292 : 	      }
; 2293 : 
; 2294 : 	    RELEASE_MUTEX (&l_Adapter->m_Extension.m_OpenCloseMutex);

  00cbb	f0 83 87 b4 02
	00 00 ff	 lock add DWORD PTR [rdi+692], -1

; 2295 : 	  }
; 2296 : 	else

  00cc3	eb 27		 jmp	 SHORT $L22266
$L22259:

; 2297 : 	  {
; 2298 : 	    DEBUGP (("[%s] TAP is presently locked (m_TapOpens=%d)\n",
; 2299 : 		     NAME (l_Adapter), l_Adapter->m_Extension.m_TapOpens));
; 2300 : 	    NOTE_ERROR ();

  00cc5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG22267
  00ccc	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00cd3	c7 05 00 00 00
	00 fc 08 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 2300 ; 000008fcH

; 2301 : 	    p_IRP->IoStatus.Status = l_Status = STATUS_UNSUCCESSFUL;

  00cdd	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
  00ce2	44 8b e0	 mov	 r12d, eax
  00ce5	89 46 30	 mov	 DWORD PTR [rsi+48], eax

; 2302 : 	    p_IRP->IoStatus.Information = 0;

  00ce8	48 89 5e 38	 mov	 QWORD PTR [rsi+56], rbx
$L22266:

; 2303 : 	  }
; 2304 : 	
; 2305 : 	IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00cec	32 d2		 xor	 dl, dl
  00cee	48 8b ce	 mov	 rcx, rsi
  00cf1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest
$L22043:

; 2351 :       }
; 2352 :     }
; 2353 : 
; 2354 :   return l_Status;

  00cf7	41 8b c4	 mov	 eax, r12d
  00cfa	eb 2a		 jmp	 SHORT $L22028
$L22036:

; 1674 :     {
; 1675 :       DEBUGP (("TapDeviceHook called when TAP device is halted, MajorFunction=%d\n",
; 1676 : 	       (int)l_IrpSp->MajorFunction));
; 1677 : 
; 1678 :       if (l_IrpSp->MajorFunction == IRP_MJ_CLOSE)

  00cfc	41 80 3e 02	 cmp	 BYTE PTR [r14], 2
  00d00	75 0f		 jne	 SHORT $L22037

; 1679 : 	{
; 1680 : 	  IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00d02	32 d2		 xor	 dl, dl
  00d04	48 8b ce	 mov	 rcx, rsi
  00d07	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 1681 : 	  return STATUS_SUCCESS;

  00d0d	33 c0		 xor	 eax, eax
  00d0f	eb 15		 jmp	 SHORT $L22028
$L22037:

; 1682 : 	}
; 1683 :       else
; 1684 : 	{
; 1685 : 	  p_IRP->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

  00d11	bb 0e 00 00 c0	 mov	 ebx, -1073741810	; c000000eH
  00d16	89 5e 30	 mov	 DWORD PTR [rsi+48], ebx

; 1686 : 	  IoCompleteRequest (p_IRP, IO_NO_INCREMENT);

  00d19	32 d2		 xor	 dl, dl
  00d1b	48 8b ce	 mov	 rcx, rsi
  00d1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 1687 : 	  return STATUS_NO_SUCH_DEVICE;

  00d24	8b c3		 mov	 eax, ebx
$L22028:

; 2355 : }

  00d26	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  00d2d	41 5f		 pop	 r15
  00d2f	41 5e		 pop	 r14
  00d31	41 5d		 pop	 r13
  00d33	41 5c		 pop	 r12
  00d35	5f		 pop	 rdi
  00d36	5e		 pop	 rsi
  00d37	5b		 pop	 rbx
  00d38	c3		 ret	 0
  00d39	8d 49 00	 npad	 3
$L23455:
  00d3c	00 00 00 00	 DD	 $L22051
  00d40	4f 00 00 00	 DD	 $L22059
  00d44	a7 00 00 00	 DD	 $L22069
  00d48	ec 00 00 00	 DD	 $L22077
  00d4c	42 03 00 00	 DD	 $L22120
  00d50	25 04 00 00	 DD	 $L22134
  00d54	71 04 00 00	 DD	 $L22143
  00d58	16 05 00 00	 DD	 $L22153
  00d5c	29 02 00 00	 DD	 $L22102
  00d60	7c 05 00 00	 DD	 $L22158
$L23454:
  00d64	00		 DB	 0
  00d65	09		 DB	 9
  00d66	09		 DB	 9
  00d67	09		 DB	 9
  00d68	01		 DB	 1
  00d69	09		 DB	 9
  00d6a	09		 DB	 9
  00d6b	09		 DB	 9
  00d6c	02		 DB	 2
  00d6d	09		 DB	 9
  00d6e	09		 DB	 9
  00d6f	09		 DB	 9
  00d70	03		 DB	 3
  00d71	09		 DB	 9
  00d72	09		 DB	 9
  00d73	09		 DB	 9
  00d74	04		 DB	 4
  00d75	09		 DB	 9
  00d76	09		 DB	 9
  00d77	09		 DB	 9
  00d78	05		 DB	 5
  00d79	09		 DB	 9
  00d7a	09		 DB	 9
  00d7b	09		 DB	 9
  00d7c	06		 DB	 6
  00d7d	09		 DB	 9
  00d7e	09		 DB	 9
  00d7f	09		 DB	 9
  00d80	09		 DB	 9
  00d81	09		 DB	 9
  00d82	09		 DB	 9
  00d83	09		 DB	 9
  00d84	07		 DB	 7
  00d85	09		 DB	 9
  00d86	09		 DB	 9
  00d87	09		 DB	 9
  00d88	08		 DB	 8
TapDeviceHook ENDP
; Function compile flags: /Ogty
l_Status$ = 176
dest$22105 = 180
dest$22123 = 188
l_Adapter$ = 200
state$22078 = 208
p_DeviceObject$ = 288
p_IRP$ = 296
TapDeviceHook$filt$1 PROC NEAR
  00d90	53		 push	 rbx
  00d91	56		 push	 rsi
  00d92	57		 push	 rdi
  00d93	41 54		 push	 r12
  00d95	41 55		 push	 r13
  00d97	41 56		 push	 r14
  00d99	41 57		 push	 r15
  00d9b	55		 push	 rbp
  00d9c	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00da3	48 8b ea	 mov	 rbp, rdx

; 2228 : 	    __except (EXCEPTION_EXECUTE_HANDLER)

  00da6	41 bd 01 00 00
	00		 mov	 r13d, 1
  00dac	41 8b c5	 mov	 eax, r13d
$L23450:
  00daf	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00db6	5d		 pop	 rbp
  00db7	41 5f		 pop	 r15
  00db9	41 5e		 pop	 r14
  00dbb	41 5d		 pop	 r13
  00dbd	41 5c		 pop	 r12
  00dbf	5f		 pop	 rdi
  00dc0	5e		 pop	 rsi
  00dc1	5b		 pop	 rbx
  00dc2	c3		 ret	 0
TapDeviceHook$filt$1 ENDP
; Function compile flags: /Ogty
l_Status$ = 176
dest$22105 = 180
dest$22123 = 188
l_Adapter$ = 200
state$22078 = 208
p_DeviceObject$ = 288
p_IRP$ = 296
TapDeviceHook$filt$0 PROC NEAR
  00dd0	53		 push	 rbx
  00dd1	56		 push	 rsi
  00dd2	57		 push	 rdi
  00dd3	41 54		 push	 r12
  00dd5	41 55		 push	 r13
  00dd7	41 56		 push	 r14
  00dd9	41 57		 push	 r15
  00ddb	55		 push	 rbp
  00ddc	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00de3	48 8b ea	 mov	 rbp, rdx

; 2183 : 	    __except (EXCEPTION_EXECUTE_HANDLER)

  00de6	41 bd 01 00 00
	00		 mov	 r13d, 1
  00dec	41 8b c5	 mov	 eax, r13d
$L23446:
  00def	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00df6	5d		 pop	 rbp
  00df7	41 5f		 pop	 r15
  00df9	41 5e		 pop	 r14
  00dfb	41 5d		 pop	 r13
  00dfd	41 5c		 pop	 r12
  00dff	5f		 pop	 rdi
  00e00	5e		 pop	 rsi
  00e01	5b		 pop	 rbx
  00e02	c3		 ret	 0
TapDeviceHook$filt$0 ENDP
_TEXT	ENDS
PUBLIC	CreateTapDevice
EXTRN	__imp_RtlAnsiStringToUnicodeString:NEAR
EXTRN	__imp_NdisMRegisterDevice:NEAR
;	COMDAT CreateTapDevice
; File c:\winddk\3790\inc\ddk\wnet\ntddk.h
CreateTapDevice	SEGMENT
$SG21634 DB	'.tap', 00H
CreateTapDevice	ENDS
;	COMDAT CreateTapDevice
CreateTapDevice	SEGMENT
$SG21635 DB	'\Device\', 00H
CreateTapDevice	ENDS
;	COMDAT CreateTapDevice
CreateTapDevice	SEGMENT
$SG21636 DB	'%s%s%s', 00H
CreateTapDevice	ENDS
;	COMDAT CreateTapDevice
CreateTapDevice	SEGMENT
$SG21644 DB	'.tap', 00H
CreateTapDevice	ENDS
;	COMDAT CreateTapDevice
CreateTapDevice	SEGMENT
$SG21645 DB	'\DosDevices\Global\', 00H
CreateTapDevice	ENDS
;	COMDAT CreateTapDevice
CreateTapDevice	SEGMENT
$SG21646 DB	'%s%s%s', 00H
CreateTapDevice	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateTapDevice DD 0a1301H
	DD	0110113H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	030015002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateTapDevice DD @imagerel(CreateTapDevice#)
	DD	@imagerel(CreateTapDevice#+716)
	DD	@imagerel($unwind$CreateTapDevice#)
; Function compile flags: /Ogty
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.c
pdata	ENDS
;	COMDAT CreateTapDevice
_TEXT	SEGMENT
l_LinkString$ = 80
l_TapString$ = 96
l_TapUnicode$ = 112
p_Extension$ = 208
p_Name$ = 216
CreateTapDevice PROC NEAR				; COMDAT

; 705  : {

  00000	53		 push	 rbx
  00001	55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00013	48 8b f2	 mov	 rsi, rdx
  00016	4c 8b e1	 mov	 r12, rcx

; 706  : # define SIZEOF_DISPATCH (sizeof(PDRIVER_DISPATCH) * (IRP_MJ_MAXIMUM_FUNCTION + 1))
; 707  :   PDRIVER_DISPATCH *l_Dispatch = NULL;
; 708  :   ANSI_STRING l_TapString, l_LinkString;
; 709  :   UNICODE_STRING l_TapUnicode;
; 710  :   BOOLEAN l_FreeTapUnicode = FALSE;
; 711  :   NTSTATUS l_Status, l_Return = NDIS_STATUS_SUCCESS;

  00019	33 db		 xor	 ebx, ebx

; 712  :   const char *l_UsableName;
; 713  : 
; 714  :   DEBUGP (("[TAP] version [%d.%d] creating tap device: %s\n",
; 715  : 	   TAP_DRIVER_MAJOR_VERSION,
; 716  : 	   TAP_DRIVER_MINOR_VERSION,
; 717  : 	   p_Name));
; 718  : 
; 719  :   NdisZeroMemory (p_Extension, sizeof (TapExtension));

  0001b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlZeroMemory

; 720  : 
; 721  :   INIT_MUTEX (&p_Extension->m_OpenCloseMutex);

  00026	41 89 5c 24 3c	 mov	 DWORD PTR [r12+60], ebx

; 722  : 
; 723  :   l_LinkString.Buffer = NULL;

  0002b	48 89 5c 24 58	 mov	 QWORD PTR l_LinkString$[rsp+8], rbx

; 724  :   l_TapString.Buffer = NULL;

  00030	48 89 5c 24 68	 mov	 QWORD PTR l_TapString$[rsp+8], rbx

; 725  : 
; 726  :   l_TapString.MaximumLength = l_LinkString.MaximumLength = NAME_BUFFER_SIZE;

  00035	66 c7 44 24 52
	50 00		 mov	 WORD PTR l_LinkString$[rsp+2], 80 ; 00000050H
  0003c	66 c7 44 24 62
	50 00		 mov	 WORD PTR l_TapString$[rsp+2], 80 ; 00000050H

; 727  : 
; 728  :   //=======================================
; 729  :   // Set TAP device entry points
; 730  :   //=======================================
; 731  : 
; 732  :   if ((l_Dispatch = MemAlloc (SIZEOF_DISPATCH, TRUE)) == NULL)

  00043	b2 01		 mov	 dl, 1
  00045	b9 e0 00 00 00	 mov	 ecx, 224		; 000000e0H
  0004a	e8 00 00 00 00	 call	 MemAlloc
  0004f	4c 8b e8	 mov	 r13, rax
  00052	41 bf 50 00 00
	00		 mov	 r15d, 80		; 00000050H
  00058	4d 85 ed	 test	 r13, r13
  0005b	75 0a		 jne	 SHORT $L21614

; 733  :     {
; 734  :       DEBUGP (("[%s] couldn't alloc TAP dispatch table\n", p_Name));
; 735  :       l_Return = NDIS_STATUS_RESOURCES;

  0005d	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 736  :       goto cleanup;

  00062	e9 1c 02 00 00	 jmp	 $L21668
$L21614:

; 737  :     }
; 738  : 
; 739  :   l_Dispatch[IRP_MJ_DEVICE_CONTROL] = TapDeviceHook;

  00067	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:TapDeviceHook
  0006e	49 89 45 70	 mov	 QWORD PTR [r13+112], rax

; 740  :   l_Dispatch[IRP_MJ_READ] = TapDeviceHook;

  00072	49 89 45 18	 mov	 QWORD PTR [r13+24], rax

; 741  :   l_Dispatch[IRP_MJ_WRITE] = TapDeviceHook;

  00076	49 89 45 20	 mov	 QWORD PTR [r13+32], rax

; 742  :   l_Dispatch[IRP_MJ_CREATE] = TapDeviceHook;

  0007a	49 89 45 00	 mov	 QWORD PTR [r13], rax

; 743  :   l_Dispatch[IRP_MJ_CLOSE] = TapDeviceHook;

  0007e	49 89 45 10	 mov	 QWORD PTR [r13+16], rax

; 744  : 
; 745  :   //==================================
; 746  :   // Find the beginning of the GUID
; 747  :   //==================================
; 748  :   l_UsableName = p_Name;
; 749  :   while (*l_UsableName != '{')

  00082	8a 06		 mov	 al, BYTE PTR [rsi]
  00084	3c 7b		 cmp	 al, 123			; 0000007bH
  00086	74 12		 je	 SHORT $L21620
$L21619:

; 750  :     {
; 751  :       if (*l_UsableName == '\0')

  00088	84 c0		 test	 al, al
  0008a	0f 84 46 01 00
	00		 je	 $L23513

; 752  : 	{
; 753  : 	  DEBUGP (("[%s] couldn't find leading '{' in name\n", p_Name));
; 754  : 	  l_Return = NDIS_STATUS_RESOURCES;
; 755  : 	  goto cleanup;
; 756  : 	}
; 757  :       ++l_UsableName;

  00090	48 83 c6 01	 add	 rsi, 1

; 744  : 
; 745  :   //==================================
; 746  :   // Find the beginning of the GUID
; 747  :   //==================================
; 748  :   l_UsableName = p_Name;
; 749  :   while (*l_UsableName != '{')

  00094	8a 06		 mov	 al, BYTE PTR [rsi]
  00096	3c 7b		 cmp	 al, 123			; 0000007bH
  00098	75 ee		 jne	 SHORT $L21619
$L21620:

; 758  :     }
; 759  : 
; 760  :   //==================================
; 761  :   // Allocate pool for TAP device name
; 762  :   //==================================
; 763  : 
; 764  :   if ((p_Extension->m_TapName = l_TapString.Buffer =
; 765  :        MemAlloc (NAME_BUFFER_SIZE, TRUE)) == NULL)

  0009a	b2 01		 mov	 dl, 1
  0009c	41 8b cf	 mov	 ecx, r15d
  0009f	e8 00 00 00 00	 call	 MemAlloc
  000a4	48 89 44 24 68	 mov	 QWORD PTR l_TapString$[rsp+8], rax
  000a9	49 89 44 24 48	 mov	 QWORD PTR [r12+72], rax
  000ae	48 85 c0	 test	 rax, rax
  000b1	75 0a		 jne	 SHORT $L21625

; 766  :     {
; 767  :       DEBUGP (("[%s] couldn't alloc TAP name buffer\n", p_Name));
; 768  :       l_Return = NDIS_STATUS_RESOURCES;

  000b3	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 769  :       goto cleanup;

  000b8	e9 c6 01 00 00	 jmp	 $L21668
$L21625:

; 770  :     }
; 771  : 
; 772  :   //================================================
; 773  :   // Allocate pool for TAP symbolic link name buffer
; 774  :   //================================================
; 775  : 
; 776  :   if ((l_LinkString.Buffer =
; 777  :        MemAlloc (NAME_BUFFER_SIZE, TRUE)) == NULL)

  000bd	b2 01		 mov	 dl, 1
  000bf	41 8b cf	 mov	 ecx, r15d
  000c2	e8 00 00 00 00	 call	 MemAlloc
  000c7	48 89 44 24 58	 mov	 QWORD PTR l_LinkString$[rsp+8], rax
  000cc	48 85 c0	 test	 rax, rax
  000cf	75 0a		 jne	 SHORT $L21629

; 778  :     {
; 779  :       DEBUGP (("[%s] couldn't alloc TAP symbolic link name buffer\n",
; 780  : 	       p_Name));
; 781  :       l_Return = NDIS_STATUS_RESOURCES;

  000d1	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 782  :       goto cleanup;

  000d6	e9 a8 01 00 00	 jmp	 $L21668
$L21629:

; 799  : 
; 800  :   if (l_Status != STATUS_SUCCESS)

  000db	48 0f b7 54 24
	62		 movzx	 rdx, WORD PTR l_TapString$[rsp+2]

; 783  :     }
; 784  : 
; 785  :   //=======================================================
; 786  :   // Set TAP device name
; 787  :   //=======================================================
; 788  : 
; 789  :   l_Status = RtlStringCchPrintfExA
; 790  :     (l_TapString.Buffer,
; 791  :      l_TapString.MaximumLength,
; 792  :      NULL,
; 793  :      NULL,
; 794  :      STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
; 795  :      "%s%s%s",
; 796  :      SYSDEVICEDIR,
; 797  :      l_UsableName,
; 798  :      TAPSUFFIX);

  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21634
  000e8	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  000ed	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21635
  000f9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21636
  00105	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010a	41 be 00 03 00
	00		 mov	 r14d, 768		; 00000300H
  00110	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00115	45 33 c9	 xor	 r9d, r9d
  00118	45 33 c0	 xor	 r8d, r8d
  0011b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR l_TapString$[rsp+8]
  00120	e8 00 00 00 00	 call	 RtlStringCchPrintfExA

; 799  : 
; 800  :   if (l_Status != STATUS_SUCCESS)

  00125	85 c0		 test	 eax, eax
  00127	74 0a		 je	 SHORT $L21638

; 801  :     {
; 802  :       DEBUGP (("[%s] couldn't format TAP device name\n",
; 803  : 	       p_Name));
; 804  :       l_Return = NDIS_STATUS_RESOURCES;

  00129	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 805  :       goto cleanup;

  0012e	e9 50 01 00 00	 jmp	 $L21668
$L21638:

; 806  :     }
; 807  :   l_TapString.Length = (USHORT) strlen (l_TapString.Buffer);

  00133	33 c0		 xor	 eax, eax
  00135	48 bd ff ff ff
	ff ff ff ff ff	 mov	 rbp, -1
  0013f	48 8b cd	 mov	 rcx, rbp
  00142	48 8b 7c 24 68	 mov	 rdi, QWORD PTR l_TapString$[rsp+8]
  00147	f2 ae		 repne scasb
  00149	48 f7 d1	 not	 rcx
  0014c	48 83 e9 01	 sub	 rcx, 1
  00150	66 89 4c 24 60	 mov	 WORD PTR l_TapString$[rsp], cx

; 825  : 
; 826  :   if (l_Status != STATUS_SUCCESS)

  00155	48 0f b7 54 24
	52		 movzx	 rdx, WORD PTR l_LinkString$[rsp+2]

; 808  : 
; 809  :   DEBUGP (("TAP DEV NAME: '%s'\n", l_TapString.Buffer));
; 810  : 
; 811  :   //=======================================================
; 812  :   // Set TAP link name
; 813  :   //=======================================================
; 814  : 
; 815  :   l_Status = RtlStringCchPrintfExA
; 816  :     (l_LinkString.Buffer,
; 817  :      l_LinkString.MaximumLength,
; 818  :      NULL,
; 819  :      NULL,
; 820  :      STRSAFE_FILL_BEHIND_NULL | STRSAFE_IGNORE_NULLS,
; 821  :      "%s%s%s",
; 822  :      USERDEVICEDIR,
; 823  :      l_UsableName,
; 824  :      TAPSUFFIX);

  0015b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21644
  00162	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00167	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0016c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21645
  00173	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00178	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21646
  0017f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00184	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00189	45 33 c9	 xor	 r9d, r9d
  0018c	45 33 c0	 xor	 r8d, r8d
  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR l_LinkString$[rsp+8]
  00194	e8 00 00 00 00	 call	 RtlStringCchPrintfExA

; 825  : 
; 826  :   if (l_Status != STATUS_SUCCESS)

  00199	85 c0		 test	 eax, eax
  0019b	74 0a		 je	 SHORT $L21648

; 827  :     {
; 828  :       DEBUGP (("[%s] couldn't format TAP device symbolic link\n",
; 829  : 	       p_Name));
; 830  :       l_Return = NDIS_STATUS_RESOURCES;

  0019d	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 831  :       goto cleanup;

  001a2	e9 dc 00 00 00	 jmp	 $L21668
$L21648:

; 832  :     }
; 833  :   l_LinkString.Length = (USHORT) strlen (l_LinkString.Buffer);

  001a7	33 c0		 xor	 eax, eax
  001a9	48 8b cd	 mov	 rcx, rbp
  001ac	48 8b 7c 24 58	 mov	 rdi, QWORD PTR l_LinkString$[rsp+8]
  001b1	f2 ae		 repne scasb
  001b3	48 f7 d1	 not	 rcx
  001b6	48 83 e9 01	 sub	 rcx, 1
  001ba	66 89 4c 24 50	 mov	 WORD PTR l_LinkString$[rsp], cx

; 834  : 
; 835  :   DEBUGP (("TAP LINK NAME: '%s'\n", l_LinkString.Buffer));
; 836  : 
; 837  :   //==================================================
; 838  :   // Convert strings to unicode
; 839  :   //==================================================
; 840  :   if (RtlAnsiStringToUnicodeString (&l_TapUnicode, &l_TapString, TRUE) !=
; 841  :       STATUS_SUCCESS)

  001bf	41 b0 01	 mov	 r8b, 1
  001c2	48 8d 54 24 60	 lea	 rdx, QWORD PTR l_TapString$[rsp]
  001c7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR l_TapUnicode$[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAnsiStringToUnicodeString
  001d2	85 c0		 test	 eax, eax
  001d4	74 0a		 je	 SHORT $L21653
$L23513:

; 842  :     {
; 843  :       DEBUGP (("[%s] couldn't alloc TAP unicode name buffer\n",
; 844  : 		p_Name));
; 845  :       l_Return = NDIS_STATUS_RESOURCES;

  001d6	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 846  :       goto cleanup;

  001db	e9 a3 00 00 00	 jmp	 $L21668
$L21653:

; 847  :     }
; 848  :   l_FreeTapUnicode = TRUE;
; 849  : 
; 850  :   if (RtlAnsiStringToUnicodeString
; 851  :       (&p_Extension->m_UnicodeLinkName, &l_LinkString, TRUE)
; 852  :       != STATUS_SUCCESS)

  001e0	49 8d 7c 24 50	 lea	 rdi, QWORD PTR [r12+80]
  001e5	41 b0 01	 mov	 r8b, 1
  001e8	48 8d 54 24 50	 lea	 rdx, QWORD PTR l_LinkString$[rsp]
  001ed	48 8b cf	 mov	 rcx, rdi
  001f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlAnsiStringToUnicodeString
  001f6	85 c0		 test	 eax, eax

; 853  :     {
; 854  :       DEBUGP
; 855  : 	(("[%s] Couldn't allocate unicode string for symbolic link name\n",
; 856  : 	 p_Name));
; 857  :       l_Return = NDIS_STATUS_RESOURCES;
; 858  :       goto cleanup;

  001f8	75 79		 jne	 SHORT $L21665

; 859  :     }
; 860  :   p_Extension->m_CreatedUnicodeLinkName = TRUE;

  001fa	41 c6 44 24 60
	01		 mov	 BYTE PTR [r12+96], 1

; 861  : 
; 862  :   //==================================================
; 863  :   // Create new TAP device with symbolic
; 864  :   // link and associate with adapter.
; 865  :   //==================================================
; 866  : 
; 867  :   l_Status = NdisMRegisterDevice
; 868  :     (g_NdisWrapperHandle,
; 869  :      &l_TapUnicode,
; 870  :      &p_Extension->m_UnicodeLinkName,
; 871  :      l_Dispatch,
; 872  :      &p_Extension->m_TapDevice,
; 873  :      &p_Extension->m_TapDeviceHandle
; 874  :      );

  00200	49 8d 74 24 10	 lea	 rsi, QWORD PTR [r12+16]
  00205	49 8d 44 24 18	 lea	 rax, QWORD PTR [r12+24]
  0020a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0020f	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00214	4d 8b cd	 mov	 r9, r13
  00217	4c 8b c7	 mov	 r8, rdi
  0021a	48 8d 54 24 70	 lea	 rdx, QWORD PTR l_TapUnicode$[rsp]
  0021f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_NdisWrapperHandle
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMRegisterDevice

; 875  : 
; 876  :   if (l_Status != STATUS_SUCCESS)

  0022c	85 c0		 test	 eax, eax

; 877  :     {
; 878  :       DEBUGP (("[%s] couldn't be created\n", p_Name));
; 879  :       l_Return = NDIS_STATUS_RESOURCES;
; 880  :       goto cleanup;

  0022e	75 43		 jne	 SHORT $L21665

; 881  :     }
; 882  : 
; 883  :   /* Set TAP device flags */
; 884  :   p_Extension->m_TapDevice->Flags |= DO_DIRECT_IO;

  00230	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00233	83 48 30 10	 or	 DWORD PTR [rax+48], 16	; 00000010H

; 885  : 
; 886  :   //========================================================
; 887  :   // Initialize Packet and IRP queues.
; 888  :   //
; 889  :   // The packet queue is used to buffer data which has been
; 890  :   // "transmitted" by the virtual NIC, before user space
; 891  :   // has had a chance to read it.
; 892  :   //
; 893  :   // The IRP queue is used to buffer pending I/O requests
; 894  :   // from userspace, i.e. read requests on the TAP device
; 895  :   // waiting for the system to "transmit" something through
; 896  :   // the virtual NIC.
; 897  :   //
; 898  :   // Basically, packets in the packet queue are used
; 899  :   // to satisfy IRP requests in the IRP queue.
; 900  :   //
; 901  :   // QueueLock is used to lock the packet queue used
; 902  :   // for the TAP-Win32 NIC -> User Space packet flow direction.
; 903  :   //
; 904  :   // All accesses to packet or IRP queues should be
; 905  :   // bracketed by the QueueLock spinlock,
; 906  :   // in order to be SMP-safe.
; 907  :   //========================================================
; 908  : 
; 909  :   NdisAllocateSpinLock (&p_Extension->m_QueueLock);

  00237	49 89 5c 24 28	 mov	 QWORD PTR [r12+40], rbx

; 910  :   p_Extension->m_AllocatedSpinlocks = TRUE;

  0023c	41 c6 44 24 38
	01		 mov	 BYTE PTR [r12+56], 1

; 911  : 
; 912  :   p_Extension->m_PacketQueue = QueueInit (PACKET_QUEUE_SIZE);

  00242	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00247	e8 00 00 00 00	 call	 QueueInit
  0024c	49 89 04 24	 mov	 QWORD PTR [r12], rax

; 913  :   p_Extension->m_IrpQueue = QueueInit (IRP_QUEUE_SIZE);

  00250	b9 10 00 00 00	 mov	 ecx, 16			; 00000010H
  00255	e8 00 00 00 00	 call	 QueueInit
  0025a	49 89 44 24 08	 mov	 QWORD PTR [r12+8], rax

; 914  : 
; 915  :   if (!p_Extension->m_PacketQueue
; 916  :       || !p_Extension->m_IrpQueue)

  0025f	49 83 3c 24 00	 cmp	 QWORD PTR [r12], 0
  00264	74 0d		 je	 SHORT $L21665
  00266	48 85 c0	 test	 rax, rax
  00269	74 08		 je	 SHORT $L21665

; 920  :       goto cleanup;
; 921  :     }
; 922  : 
; 923  :   //========================
; 924  :   // Finalize initialization
; 925  :   //========================
; 926  : 
; 927  :   p_Extension->m_TapIsRunning = TRUE;

  0026b	41 c6 44 24 78
	01		 mov	 BYTE PTR [r12+120], 1
  00271	eb 05		 jmp	 SHORT $L23515
$L21665:

; 917  :     {
; 918  :       DEBUGP (("[%s] couldn't alloc TAP queues\n", p_Name));
; 919  :       l_Return = NDIS_STATUS_RESOURCES;

  00273	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH
$L23515:

; 928  : 
; 929  :   DEBUGP (("[%s] successfully created TAP device [%s]\n", p_Name,
; 930  : 	    p_Extension->m_TapName));
; 931  : 
; 932  :  cleanup:
; 933  :   if (l_FreeTapUnicode)
; 934  :     RtlFreeUnicodeString (&l_TapUnicode);

  00278	48 8d 4c 24 70	 lea	 rcx, QWORD PTR l_TapUnicode$[rsp]
  0027d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeUnicodeString
$L21668:

; 935  :   if (l_LinkString.Buffer)

  00283	48 8b 44 24 58	 mov	 rax, QWORD PTR l_LinkString$[rsp+8]
  00288	48 85 c0	 test	 rax, rax
  0028b	74 0b		 je	 SHORT $L21669

; 936  :     MemFree (l_LinkString.Buffer, NAME_BUFFER_SIZE);

  0028d	41 8b d7	 mov	 edx, r15d
  00290	48 8b c8	 mov	 rcx, rax
  00293	e8 00 00 00 00	 call	 MemFree
$L21669:

; 937  :   if (l_Dispatch)

  00298	4d 85 ed	 test	 r13, r13
  0029b	74 0d		 je	 SHORT $L21670

; 938  :     MemFree (l_Dispatch, SIZEOF_DISPATCH);

  0029d	ba e0 00 00 00	 mov	 edx, 224		; 000000e0H
  002a2	49 8b cd	 mov	 rcx, r13
  002a5	e8 00 00 00 00	 call	 MemFree
$L21670:

; 939  : 
; 940  :   if (l_Return != NDIS_STATUS_SUCCESS)

  002aa	85 db		 test	 ebx, ebx
  002ac	74 08		 je	 SHORT $L23516

; 941  :     TapDeviceFreeResources (p_Extension);

  002ae	49 8b cc	 mov	 rcx, r12
  002b1	e8 00 00 00 00	 call	 TapDeviceFreeResources
$L23516:

; 942  : 
; 943  :   return l_Return;

  002b6	8b c3		 mov	 eax, ebx

; 944  : }

  002b8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  002bf	41 5f		 pop	 r15
  002c1	41 5e		 pop	 r14
  002c3	41 5d		 pop	 r13
  002c5	41 5c		 pop	 r12
  002c7	5f		 pop	 rdi
  002c8	5e		 pop	 rsi
  002c9	5d		 pop	 rbp
  002ca	5b		 pop	 rbx
  002cb	c3		 ret	 0
CreateTapDevice ENDP
_TEXT	ENDS
PUBLIC	AdapterCreate
EXTRN	__imp_NdisMSetAttributesEx:NEAR
EXTRN	__imp_NdisMRegisterAdapterShutdownHandler:NEAR
EXTRN	__imp_NdisOpenConfiguration:NEAR
EXTRN	__imp_RtlUnicodeStringToAnsiString:NEAR
EXTRN	__imp_NdisReadConfiguration:NEAR
EXTRN	__imp_NdisCloseConfiguration:NEAR
;	COMDAT AdapterCreate
; File c:\winddk\3790\inc\ddk\wnet\ntddk.h
AdapterCreate	SEGMENT
$SG21483 DB	'M', 00H, 'i', 00H, 'n', 00H, 'i', 00H, 'p', 00H, 'o', 00H
	DB	'r', 00H, 't', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H, 00H
	DB	00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21495 DB	'N', 00H, 'd', 00H, 'i', 00H, 's', 00H, 'V', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21513 DB	'M', 00H, 'T', 00H, 'U', 00H, 00H, 00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21523 DB	'M', 00H, 'e', 00H, 'd', 00H, 'i', 00H, 'a', 00H, 'S', 00H
	DB	't', 00H, 'a', 00H, 't', 00H, 'u', 00H, 's', 00H, 00H, 00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21531 DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'w', 00H, 'N', 00H
	DB	'o', 00H, 'n', 00H, 'A', 00H, 'd', 00H, 'm', 00H, 'i', 00H, 'n'
	DB	00H, 00H, 00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21539 DB	'M', 00H, 'A', 00H, 'C', 00H, 00H, 00H
AdapterCreate	ENDS
;	COMDAT AdapterCreate
AdapterCreate	SEGMENT
$SG21558 DB	'c:\development\leafnets\engineering\software\client\wind'
	DB	'ows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.'
	DB	'c', 00H
AdapterCreate	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AdapterCreate DD 080f01H
	DD	0f00bd20fH
	DD	0d007e009H
	DD	07003c005H
	DD	030016002H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AdapterCreate DD @imagerel(AdapterCreate#)
	DD	@imagerel(AdapterCreate#+1128)
	DD	@imagerel($unwind$AdapterCreate#)
; Function compile flags: /Ogty
; File c:\development\leafnets\engineering\software\client\windows\p2p\code\exsrc\tap-win32\openvpn-2.0.9\tap-win32\tapdrvr.c
pdata	ENDS
;	COMDAT AdapterCreate
_TEXT	SEGMENT
status$21475 = 48
parm$21477 = 56
configHandle$21476 = 64
mac_string$21540 = 72
key$21481 = 72
key$21537 = 88
key$21529 = 88
key$21521 = 88
key$21511 = 88
key$21493 = 88
p_ErrorStatus$ = 176
p_MediaIndex$ = 184
p_Media$ = 192
p_MediaCount$ = 200
p_AdapterHandle$ = 208
p_ConfigurationHandle$ = 216
AdapterCreate PROC NEAR					; COMDAT

; 286  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 55		 push	 r13
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 287  :   TapAdapterPointer l_Adapter = NULL;
; 288  : 
; 289  :   NDIS_MEDIUM l_PreferredMedium = NdisMedium802_3; // Ethernet
; 290  :   BOOLEAN l_MacFromRegistry = FALSE;

  0000f	45 32 ed	 xor	 r13b, r13b

; 291  :   UINT l_Index;
; 292  :   NDIS_STATUS status;
; 293  : 
; 294  : #if ENABLE_NONADMIN
; 295  :   BOOLEAN enable_non_admin = FALSE;

  00012	45 32 e4	 xor	 r12b, r12b

; 296  : #endif
; 297  : 
; 298  :   //====================================
; 299  :   // Make sure adapter type is supported
; 300  :   //====================================
; 301  : 
; 302  :   for (l_Index = 0;
; 303  :        l_Index < p_MediaCount && p_Media[l_Index] != l_PreferredMedium;
; 304  :        ++l_Index);

  00015	45 33 f6	 xor	 r14d, r14d
  00018	41 8b ce	 mov	 ecx, r14d
  0001b	45 85 c9	 test	 r9d, r9d
  0001e	76 11		 jbe	 SHORT $L21465
$L21463:
  00020	8b c1		 mov	 eax, ecx
  00022	41 83 3c 80 00	 cmp	 DWORD PTR [r8+rax*4], 0
  00027	74 08		 je	 SHORT $L21465
  00029	83 c1 01	 add	 ecx, 1
  0002c	41 3b c9	 cmp	 ecx, r9d
  0002f	72 ef		 jb	 SHORT $L21463
$L21465:

; 305  : 
; 306  :   if (l_Index == p_MediaCount)

  00031	41 3b c9	 cmp	 ecx, r9d
  00034	75 15		 jne	 SHORT $L21466

; 307  :     {
; 308  :       DEBUGP (("[TAP] Unsupported adapter type [wanted: %d]\n",
; 309  : 	       l_PreferredMedium));
; 310  :       return NDIS_STATUS_UNSUPPORTED_MEDIA;

  00036	b8 19 00 01 c0	 mov	 eax, -1073676263	; c0010019H

; 572  : }

  0003b	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0003f	41 5f		 pop	 r15
  00041	41 5e		 pop	 r14
  00043	41 5d		 pop	 r13
  00045	41 5c		 pop	 r12
  00047	5f		 pop	 rdi
  00048	5e		 pop	 rsi
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$L21466:

; 311  :     }
; 312  : 
; 313  :   *p_MediaIndex = l_Index;

  0004b	89 0a		 mov	 DWORD PTR [rdx], ecx

; 314  : 
; 315  :   //=========================================
; 316  :   // Allocate memory for TapAdapter structure
; 317  :   //=========================================
; 318  : 
; 319  :   l_Adapter = MemAlloc (sizeof (TapAdapter), TRUE);

  0004d	b2 01		 mov	 dl, 1
  0004f	b9 f8 02 00 00	 mov	 ecx, 760		; 000002f8H
  00054	e8 00 00 00 00	 call	 MemAlloc
  00059	48 8b d8	 mov	 rbx, rax

; 320  : 
; 321  :   if (l_Adapter == NULL)

  0005c	48 85 db	 test	 rbx, rbx

; 322  :     {
; 323  :       DEBUGP (("[TAP] Couldn't allocate adapter memory\n"));
; 324  :       return NDIS_STATUS_RESOURCES;

  0005f	0f 84 d6 03 00
	00		 je	 $L23562

; 325  :     }
; 326  : 
; 327  :   //==========================================
; 328  :   // Inform the NDIS library about significant
; 329  :   // features of our virtual NIC.
; 330  :   //==========================================
; 331  : 
; 332  :   NdisMSetAttributesEx
; 333  :     (p_AdapterHandle,
; 334  :      (NDIS_HANDLE) l_Adapter,
; 335  :      16,
; 336  :      NDIS_ATTRIBUTE_DESERIALIZE
; 337  :      | NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
; 338  :      | NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT
; 339  :      | NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND,
; 340  :      NdisInterfaceInternal);

  00065	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  0006a	41 b9 63 00 00
	00		 mov	 r9d, 99			; 00000063H
  00070	41 b8 10 00 00
	00		 mov	 r8d, 16			; 00000010H
  00076	48 8b d3	 mov	 rdx, rbx
  00079	48 8b b4 24 d0
	00 00 00	 mov	 rsi, QWORD PTR p_AdapterHandle$[rsp]
  00081	48 8b ce	 mov	 rcx, rsi
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMSetAttributesEx

; 341  : 
; 342  :   //=====================================
; 343  :   // Initialize simple Adapter parameters
; 344  :   //=====================================
; 345  : 
; 346  :   l_Adapter->m_Lookahead = DEFAULT_PACKET_LOOKAHEAD;

  0008a	c7 43 3c ea 05
	00 00		 mov	 DWORD PTR [rbx+60], 1514 ; 000005eaH

; 347  :   l_Adapter->m_Medium = l_PreferredMedium;

  00091	44 89 73 38	 mov	 DWORD PTR [rbx+56], r14d

; 348  :   l_Adapter->m_DeviceState = '?';

  00095	c6 43 46 3f	 mov	 BYTE PTR [rbx+70], 63	; 0000003fH

; 349  :   l_Adapter->m_MiniportAdapterHandle = p_AdapterHandle;

  00099	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 350  : 
; 351  :   //==================================
; 352  :   // Allocate spinlock for controlling
; 353  :   // access to multicast address list.
; 354  :   //==================================
; 355  :   NdisAllocateSpinLock (&l_Adapter->m_MCLock);

  0009d	4c 89 b3 a0 01
	00 00		 mov	 QWORD PTR [rbx+416], r14

; 356  :   l_Adapter->m_MCLockAllocated = TRUE;

  000a4	c6 83 b0 01 00
	00 01		 mov	 BYTE PTR [rbx+432], 1

; 357  : 
; 358  :   //====================================================
; 359  :   // Register a shutdown handler which will be called
; 360  :   // on system restart/shutdown to halt our virtual NIC.
; 361  :   //====================================================
; 362  : 
; 363  :   NdisMRegisterAdapterShutdownHandler (p_AdapterHandle, l_Adapter,
; 364  : 				       AdapterHalt);

  000ab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:AdapterHalt
  000b2	48 8b d3	 mov	 rdx, rbx
  000b5	48 8b ce	 mov	 rcx, rsi
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMRegisterAdapterShutdownHandler

; 365  :   l_Adapter->m_RegisteredAdapterShutdownHandler = TRUE;

  000be	c6 83 9d 01 00
	00 01		 mov	 BYTE PTR [rbx+413], 1

; 366  : 
; 367  :   //============================================
; 368  :   // Get parameters from registry which were set
; 369  :   // in the adapter advanced properties dialog.
; 370  :   //============================================
; 371  :   {
; 372  :     NDIS_STATUS status;
; 373  :     NDIS_HANDLE configHandle;
; 374  :     NDIS_CONFIGURATION_PARAMETER *parm;
; 375  : 
; 376  :     // set defaults in case our registry query fails
; 377  :     l_Adapter->m_MTU = ETHERNET_MTU;

  000c5	c7 43 40 dc 05
	00 00		 mov	 DWORD PTR [rbx+64], 1500 ; 000005dcH

; 378  :     l_Adapter->m_MediaStateAlwaysConnected = FALSE;

  000cc	c6 43 44 00	 mov	 BYTE PTR [rbx+68], 0

; 379  :     l_Adapter->m_MediaState = FALSE;

  000d0	c6 43 45 00	 mov	 BYTE PTR [rbx+69], 0

; 380  : 
; 381  :     NdisOpenConfiguration (&status, &configHandle, p_ConfigurationHandle);

  000d4	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR p_ConfigurationHandle$[rsp]
  000dc	48 8d 54 24 40	 lea	 rdx, QWORD PTR configHandle$21476[rsp]
  000e1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisOpenConfiguration

; 382  :     if (status != NDIS_STATUS_SUCCESS)

  000ec	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  000f1	74 1c		 je	 SHORT $L21480

; 383  :       {
; 384  : 	  DEBUGP (("[TAP] Couldn't open adapter registry\n"));
; 385  : 	  AdapterFreeResources (l_Adapter);

  000f3	48 8b cb	 mov	 rcx, rbx
  000f6	e8 00 00 00 00	 call	 AdapterFreeResources

; 386  : 	  return status;

  000fb	8b 44 24 30	 mov	 eax, DWORD PTR status$21475[rsp]

; 572  : }

  000ff	48 83 c4 70	 add	 rsp, 112		; 00000070H
  00103	41 5f		 pop	 r15
  00105	41 5e		 pop	 r14
  00107	41 5d		 pop	 r13
  00109	41 5c		 pop	 r12
  0010b	5f		 pop	 rdi
  0010c	5e		 pop	 rsi
  0010d	5b		 pop	 rbx
  0010e	c3		 ret	 0
$L21480:

; 387  :       }
; 388  : 
; 389  :     //====================================
; 390  :     // Allocate and construct adapter name
; 391  :     //====================================
; 392  :     {
; 393  :       NDIS_STRING key = NDIS_STRING_CONST("MiniportName");

  0010f	66 c7 44 24 48
	18 00		 mov	 WORD PTR key$21481[rsp], 24 ; 00000018H
  00116	66 c7 44 24 4a
	1a 00		 mov	 WORD PTR key$21481[rsp+2], 26 ; 0000001aH
  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21483
  00124	48 89 44 24 50	 mov	 QWORD PTR key$21481[rsp+8], rax

; 394  :       NdisReadConfiguration (&status, &parm, configHandle, &key, NdisParameterString);

  00129	41 bf 02 00 00
	00		 mov	 r15d, 2
  0012f	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00134	4c 8d 4c 24 48	 lea	 r9, QWORD PTR key$21481[rsp]
  00139	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  0013e	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  00143	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 395  :       if (status == NDIS_STATUS_SUCCESS)

  0014e	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH
  00153	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  00158	75 4f		 jne	 SHORT $L21486

; 396  : 	{
; 397  : 	  if (parm->ParameterType == NdisParameterString)

  0015a	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  0015f	44 39 38	 cmp	 DWORD PTR [rax], r15d
  00162	0f 85 a3 00 00
	00		 jne	 $L23543

; 398  : 	    {
; 399  : 	      DEBUGP (("[TAP] NdisReadConfiguration (MiniportName=%s)\n", parm->ParameterData.StringData.Buffer));
; 400  : 
; 401  : 	      if (RtlUnicodeStringToAnsiString (
; 402  : 			&l_Adapter->m_NameAnsi,
; 403  : 			&parm->ParameterData.StringData,
; 404  : 			TRUE) != STATUS_SUCCESS)

  00168	48 8d 50 08	 lea	 rdx, QWORD PTR [rax+8]
$L23561:
  0016c	41 b0 01	 mov	 r8b, 1
  0016f	48 8b cb	 mov	 rcx, rbx
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlUnicodeStringToAnsiString
  00178	85 c0		 test	 eax, eax
  0017a	0f 84 80 00 00
	00		 je	 $L21502

; 405  : 		{
; 406  : 		  DEBUGP (("[TAP] RtlUnicodeStringToAnsiString MiniportName failed\n"));
; 407  : 		  status = NDIS_STATUS_RESOURCES;

  00180	89 7c 24 30	 mov	 DWORD PTR status$21475[rsp], edi
$L21508:

; 436  :       {
; 437  : 	NdisCloseConfiguration (configHandle);

  00184	48 8b 4c 24 40	 mov	 rcx, QWORD PTR configHandle$21476[rsp]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisCloseConfiguration

; 438  : 	AdapterFreeResources (l_Adapter);

  0018f	48 8b cb	 mov	 rcx, rbx
  00192	e8 00 00 00 00	 call	 AdapterFreeResources
$L23559:

; 439  : 	return NDIS_STATUS_RESOURCES;

  00197	8b c7		 mov	 eax, edi

; 572  : }

  00199	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0019d	41 5f		 pop	 r15
  0019f	41 5e		 pop	 r14
  001a1	41 5d		 pop	 r13
  001a3	41 5c		 pop	 r12
  001a5	5f		 pop	 rdi
  001a6	5e		 pop	 rsi
  001a7	5b		 pop	 rbx
  001a8	c3		 ret	 0
$L21486:

; 408  : 		}
; 409  : 	    }
; 410  : 	} else {
; 411  : 	  /* "MiniportName" is available only XP and above.  Not on Windows 2000. */
; 412  : 	  NDIS_STRING key = NDIS_STRING_CONST("NdisVersion");

  001a9	66 c7 44 24 58
	16 00		 mov	 WORD PTR key$21493[rsp], 22 ; 00000016H
  001b0	66 c7 44 24 5a
	18 00		 mov	 WORD PTR key$21493[rsp+2], 24 ; 00000018H
  001b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21495
  001be	48 89 44 24 60	 mov	 QWORD PTR key$21493[rsp+8], rax

; 413  : 	  NdisReadConfiguration (&status, &parm, configHandle, &key, NdisParameterInteger);

  001c3	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  001c8	4c 8d 4c 24 58	 lea	 r9, QWORD PTR key$21493[rsp]
  001cd	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  001d2	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  001d7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 414  : 	  if (status == NDIS_STATUS_SUCCESS)

  001e2	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  001e7	75 9b		 jne	 SHORT $L21508

; 415  : 	    {
; 416  : 	      if (parm->ParameterData.IntegerData == 0x50000)

  001e9	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  001ee	81 78 08 00 00
	05 00		 cmp	 DWORD PTR [rax+8], 327680 ; 00050000H
  001f5	75 14		 jne	 SHORT $L23543

; 417  : 		{
; 418  : 		  /* Fallback for Windows 2000 with NDIS version 5.00.00
; 419  : 		     Don't use this on Vista, 'NDIS_MINIPORT_BLOCK' was changed! */
; 420  : 		  DEBUGP (("[TAP] NdisReadConfiguration NdisVersion (Int=%X)\n", parm->ParameterData.IntegerData));
; 421  : 		  if (RtlUnicodeStringToAnsiString (
; 422  : 			&l_Adapter->m_NameAnsi,
; 423  : 			&((PNDIS_MINIPORT_BLOCK) p_AdapterHandle)->MiniportName,
; 424  : 			TRUE) != STATUS_SUCCESS)

  001f7	48 8d 56 20	 lea	 rdx, QWORD PTR [rsi+32]

; 425  : 		    {
; 426  : 		      DEBUGP (("[TAP] RtlUnicodeStringToAnsiString MiniportName (W2K) failed\n"));
; 427  : 		      status = NDIS_STATUS_RESOURCES;
; 428  : 		    }
; 429  : 		}
; 430  : 	    }
; 431  : 	}
; 432  :     }
; 433  : 
; 434  :     /* Can't continue without name (see macro 'NAME') */
; 435  :     if (status != NDIS_STATUS_SUCCESS || !l_Adapter->m_NameAnsi.Buffer)

  001fb	e9 6c ff ff ff	 jmp	 $L23561
$L21502:
  00200	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  00205	0f 85 79 ff ff
	ff		 jne	 $L21508
$L23543:
  0020b	48 83 7b 08 00	 cmp	 QWORD PTR [rbx+8], 0
  00210	0f 84 6e ff ff
	ff		 je	 $L21508

; 440  :       }
; 441  : 
; 442  : 	/* Read MTU setting from registry */
; 443  : 	{
; 444  : 	  NDIS_STRING key = NDIS_STRING_CONST("MTU");

  00216	66 c7 44 24 58
	06 00		 mov	 WORD PTR key$21511[rsp], 6
  0021d	66 c7 44 24 5a
	08 00		 mov	 WORD PTR key$21511[rsp+2], 8
  00224	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21513
  0022b	48 89 44 24 60	 mov	 QWORD PTR key$21511[rsp+8], rax

; 445  : 	  NdisReadConfiguration (&status, &parm, configHandle,
; 446  : 				 &key, NdisParameterInteger);

  00230	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00235	4c 8d 4c 24 58	 lea	 r9, QWORD PTR key$21511[rsp]
  0023a	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  0023f	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  00244	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 447  : 	  if (status == NDIS_STATUS_SUCCESS)

  0024f	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  00254	75 24		 jne	 SHORT $L21517

; 448  : 	    {
; 449  : 	      if (parm->ParameterType == NdisParameterInteger)

  00256	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  0025b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0025e	75 1a		 jne	 SHORT $L21517

; 450  : 		{
; 451  : 		  int mtu = parm->ParameterData.IntegerData;

  00260	8b 40 08	 mov	 eax, DWORD PTR [rax+8]

; 452  : 		  if (mtu < MINIMUM_MTU)

  00263	b9 40 02 00 00	 mov	 ecx, 576		; 00000240H
  00268	3b c1		 cmp	 eax, ecx

; 453  : 		    mtu = MINIMUM_MTU;
; 454  : 		  if (mtu > MAXIMUM_MTU)

  0026a	7c 09		 jl	 SHORT $L23560
  0026c	b9 00 00 01 00	 mov	 ecx, 65536		; 00010000H
  00271	3b c1		 cmp	 eax, ecx
  00273	7e 02		 jle	 SHORT $L21520
$L23560:

; 455  : 		    mtu = MAXIMUM_MTU;

  00275	8b c1		 mov	 eax, ecx
$L21520:

; 456  : 		  l_Adapter->m_MTU = mtu;

  00277	89 43 40	 mov	 DWORD PTR [rbx+64], eax
$L21517:

; 457  : 		}
; 458  : 	    }
; 459  : 	}
; 460  : 
; 461  : 	/* Read Media Status setting from registry */
; 462  : 	{
; 463  : 	  NDIS_STRING key = NDIS_STRING_CONST("MediaStatus");

  0027a	66 c7 44 24 58
	16 00		 mov	 WORD PTR key$21521[rsp], 22 ; 00000016H
  00281	66 c7 44 24 5a
	18 00		 mov	 WORD PTR key$21521[rsp+2], 24 ; 00000018H
  00288	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21523
  0028f	48 89 44 24 60	 mov	 QWORD PTR key$21521[rsp+8], rax

; 464  : 	  NdisReadConfiguration (&status, &parm, configHandle,
; 465  : 				 &key, NdisParameterInteger);

  00294	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00299	4c 8d 4c 24 58	 lea	 r9, QWORD PTR key$21521[rsp]
  0029e	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  002a3	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  002a8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 466  : 	  if (status == NDIS_STATUS_SUCCESS)

  002b3	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  002b8	75 18		 jne	 SHORT $L21528

; 467  : 	    {
; 468  : 	      if (parm->ParameterType == NdisParameterInteger)

  002ba	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  002bf	83 38 00	 cmp	 DWORD PTR [rax], 0
  002c2	75 0e		 jne	 SHORT $L21528

; 469  : 		{
; 470  : 		  if (parm->ParameterData.IntegerData)

  002c4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002c8	74 08		 je	 SHORT $L21528

; 471  : 		    {
; 472  : 		      l_Adapter->m_MediaStateAlwaysConnected = TRUE;

  002ca	c6 43 44 01	 mov	 BYTE PTR [rbx+68], 1

; 473  : 		      l_Adapter->m_MediaState = TRUE;

  002ce	c6 43 45 01	 mov	 BYTE PTR [rbx+69], 1
$L21528:

; 474  : 		    }
; 475  : 		}
; 476  : 	    }
; 477  : 	}
; 478  : 
; 479  : #if ENABLE_NONADMIN
; 480  : 	/* Read AllowNonAdmin setting from registry */
; 481  : 	{
; 482  : 	  NDIS_STRING key = NDIS_STRING_CONST("AllowNonAdmin");

  002d2	66 c7 44 24 58
	1a 00		 mov	 WORD PTR key$21529[rsp], 26 ; 0000001aH
  002d9	66 c7 44 24 5a
	1c 00		 mov	 WORD PTR key$21529[rsp+2], 28 ; 0000001cH
  002e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21531
  002e7	48 89 44 24 60	 mov	 QWORD PTR key$21529[rsp+8], rax

; 483  : 	  NdisReadConfiguration (&status, &parm, configHandle,
; 484  : 				 &key, NdisParameterInteger);

  002ec	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  002f1	4c 8d 4c 24 58	 lea	 r9, QWORD PTR key$21529[rsp]
  002f6	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  002fb	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  00300	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 485  : 	  if (status == NDIS_STATUS_SUCCESS)

  0030b	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  00310	75 13		 jne	 SHORT $L21536

; 486  : 	    {
; 487  : 	      if (parm->ParameterType == NdisParameterInteger)

  00312	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  00317	83 38 00	 cmp	 DWORD PTR [rax], 0
  0031a	75 09		 jne	 SHORT $L21536

; 488  : 		{
; 489  : 		  if (parm->ParameterData.IntegerData)

  0031c	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00320	74 03		 je	 SHORT $L21536

; 490  : 		    {
; 491  : 			enable_non_admin = TRUE;

  00322	41 b4 01	 mov	 r12b, 1
$L21536:

; 492  : 		    }
; 493  : 		}
; 494  : 	    }
; 495  : 	}
; 496  : #endif
; 497  : 
; 498  : 	/* Read optional MAC setting from registry */
; 499  : 	{
; 500  : 	  NDIS_STRING key = NDIS_STRING_CONST("MAC");

  00325	66 c7 44 24 58
	06 00		 mov	 WORD PTR key$21537[rsp], 6
  0032c	66 c7 44 24 5a
	08 00		 mov	 WORD PTR key$21537[rsp+2], 8
  00333	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21539
  0033a	48 89 44 24 60	 mov	 QWORD PTR key$21537[rsp+8], rax

; 501  : 	  ANSI_STRING mac_string;
; 502  : 	  NdisReadConfiguration (&status, &parm, configHandle,
; 503  : 				 &key, NdisParameterString);

  0033f	44 89 7c 24 20	 mov	 DWORD PTR [rsp+32], r15d
  00344	4c 8d 4c 24 58	 lea	 r9, QWORD PTR key$21537[rsp]
  00349	4c 8b 44 24 40	 mov	 r8, QWORD PTR configHandle$21476[rsp]
  0034e	48 8d 54 24 38	 lea	 rdx, QWORD PTR parm$21477[rsp]
  00353	48 8d 4c 24 30	 lea	 rcx, QWORD PTR status$21475[rsp]
  00358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisReadConfiguration

; 504  : 	  if (status == NDIS_STATUS_SUCCESS)

  0035e	83 7c 24 30 00	 cmp	 DWORD PTR status$21475[rsp], 0
  00363	75 3d		 jne	 SHORT $L21546

; 505  : 	    {
; 506  : 	      if (parm->ParameterType == NdisParameterString)

  00365	48 8b 44 24 38	 mov	 rax, QWORD PTR parm$21477[rsp]
  0036a	83 38 02	 cmp	 DWORD PTR [rax], 2
  0036d	75 33		 jne	 SHORT $L21546

; 507  : 		{
; 508  : 		  if (RtlUnicodeStringToAnsiString (&mac_string, &parm->ParameterData.StringData, TRUE) == STATUS_SUCCESS)

  0036f	48 8d 50 08	 lea	 rdx, QWORD PTR [rax+8]
  00373	41 b0 01	 mov	 r8b, 1
  00376	48 8d 4c 24 48	 lea	 rcx, QWORD PTR mac_string$21540[rsp]
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlUnicodeStringToAnsiString
  00381	85 c0		 test	 eax, eax
  00383	75 1d		 jne	 SHORT $L21546

; 509  : 		    {
; 510  : 		      l_MacFromRegistry = ParseMAC (l_Adapter->m_MAC, mac_string.Buffer);

  00385	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  00389	48 8b 54 24 50	 mov	 rdx, QWORD PTR mac_string$21540[rsp+8]
  0038e	e8 00 00 00 00	 call	 ParseMAC
  00393	44 0f b6 e8	 movzx	 r13d, al

; 511  : 		      RtlFreeAnsiString (&mac_string);

  00397	48 8d 4c 24 48	 lea	 rcx, QWORD PTR mac_string$21540[rsp]
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlFreeAnsiString
$L21546:

; 512  : 		    }
; 513  : 		}
; 514  : 	    }
; 515  : 	}
; 516  : 
; 517  : 	NdisCloseConfiguration (configHandle);

  003a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR configHandle$21476[rsp]
  003a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisCloseConfiguration

; 518  : 
; 519  :     DEBUGP (("[%s] MTU=%d\n", NAME (l_Adapter), l_Adapter->m_MTU));
; 520  :   }
; 521  : 
; 522  :   //==================================
; 523  :   // Store and update MAC address info
; 524  :   //==================================
; 525  : 
; 526  :   if (!l_MacFromRegistry)

  003ad	45 84 ed	 test	 r13b, r13b
  003b0	75 0d		 jne	 SHORT $L21547

; 527  :     GenerateRandomMac (l_Adapter->m_MAC, NAME (l_Adapter));

  003b2	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  003b6	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  003ba	e8 00 00 00 00	 call	 GenerateRandomMac
$L21547:

; 528  : 
; 529  :   DEBUGP (("[%s] Using MAC %x:%x:%x:%x:%x:%x\n",
; 530  : 	    NAME (l_Adapter),
; 531  : 	    l_Adapter->m_MAC[0], l_Adapter->m_MAC[1], l_Adapter->m_MAC[2],
; 532  : 	    l_Adapter->m_MAC[3], l_Adapter->m_MAC[4], l_Adapter->m_MAC[5]));
; 533  : 
; 534  :   //==================
; 535  :   // Set broadcast MAC
; 536  :   //==================
; 537  :   {
; 538  :     int i;
; 539  :     for (i = 0; i < sizeof (MACADDR); ++i)
; 540  :       l_Adapter->m_MAC_Broadcast[i] = 0xFF;

  003bf	c6 43 70 ff	 mov	 BYTE PTR [rbx+112], 255	; 000000ffH
  003c3	c6 43 71 ff	 mov	 BYTE PTR [rbx+113], 255	; 000000ffH
  003c7	c6 43 72 ff	 mov	 BYTE PTR [rbx+114], 255	; 000000ffH
  003cb	c6 43 73 ff	 mov	 BYTE PTR [rbx+115], 255	; 000000ffH
  003cf	c6 43 74 ff	 mov	 BYTE PTR [rbx+116], 255	; 000000ffH
  003d3	c6 43 75 ff	 mov	 BYTE PTR [rbx+117], 255	; 000000ffH

; 541  :   }
; 542  : 
; 543  :   //====================================
; 544  :   // Initialize TAP device
; 545  :   //====================================
; 546  :   {
; 547  :     NDIS_STATUS tap_status;
; 548  :     tap_status = CreateTapDevice (&l_Adapter->m_Extension, NAME (l_Adapter));

  003d7	48 8d bb 78 02
	00 00		 lea	 rdi, QWORD PTR [rbx+632]
  003de	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
  003e2	48 8b cf	 mov	 rcx, rdi
  003e5	e8 00 00 00 00	 call	 CreateTapDevice
  003ea	8b f0		 mov	 esi, eax

; 550  :       {
; 551  : 	AdapterFreeResources (l_Adapter);

  003ec	48 8b cb	 mov	 rcx, rbx

; 549  :     if (tap_status != NDIS_STATUS_SUCCESS)

  003ef	85 f6		 test	 esi, esi
  003f1	74 17		 je	 SHORT $L21556

; 550  :       {
; 551  : 	AdapterFreeResources (l_Adapter);

  003f3	e8 00 00 00 00	 call	 AdapterFreeResources

; 552  : 	return tap_status;

  003f8	8b c6		 mov	 eax, esi

; 572  : }

  003fa	48 83 c4 70	 add	 rsp, 112		; 00000070H
  003fe	41 5f		 pop	 r15
  00400	41 5e		 pop	 r14
  00402	41 5d		 pop	 r13
  00404	41 5c		 pop	 r12
  00406	5f		 pop	 rdi
  00407	5e		 pop	 rsi
  00408	5b		 pop	 rbx
  00409	c3		 ret	 0
$L21556:

; 553  :       }
; 554  :   }
; 555  : 
; 556  :   if (!AddAdapterToInstanceList (l_Adapter))

  0040a	e8 00 00 00 00	 call	 AddAdapterToInstanceList
  0040f	84 c0		 test	 al, al
  00411	75 32		 jne	 SHORT $L21557

; 557  :     {
; 558  :       NOTE_ERROR ();

  00413	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG21558
  0041a	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_LastErrorFilename, rax
  00421	c7 05 00 00 00
	00 2e 02 00 00	 mov	 DWORD PTR g_LastErrorLineNumber, 558 ; 0000022eH

; 559  :       TapDeviceFreeResources (&l_Adapter->m_Extension);

  0042b	48 8b cf	 mov	 rcx, rdi
  0042e	e8 00 00 00 00	 call	 TapDeviceFreeResources

; 560  :       AdapterFreeResources (l_Adapter);

  00433	48 8b cb	 mov	 rcx, rbx
  00436	e8 00 00 00 00	 call	 AdapterFreeResources
$L23562:

; 561  :       return NDIS_STATUS_RESOURCES;

  0043b	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH
  00440	e9 52 fd ff ff	 jmp	 $L23559
$L21557:

; 562  :     }
; 563  : 
; 564  :   l_Adapter->m_InterfaceIsRunning = TRUE;

  00445	c6 43 16 01	 mov	 BYTE PTR [rbx+22], 1

; 565  : 
; 566  : #if ENABLE_NONADMIN
; 567  :   if (enable_non_admin)

  00449	45 84 e4	 test	 r12b, r12b
  0044c	74 08		 je	 SHORT $L21561

; 568  :     AllowNonAdmin (&l_Adapter->m_Extension);

  0044e	48 8b cf	 mov	 rcx, rdi
  00451	e8 00 00 00 00	 call	 AllowNonAdmin
$L21561:

; 569  : #endif
; 570  : 
; 571  :   return NDIS_STATUS_SUCCESS;

  00456	33 c0		 xor	 eax, eax

; 572  : }

  00458	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0045c	41 5f		 pop	 r15
  0045e	41 5e		 pop	 r14
  00460	41 5d		 pop	 r13
  00462	41 5c		 pop	 r12
  00464	5f		 pop	 rdi
  00465	5e		 pop	 rsi
  00466	5b		 pop	 rbx
  00467	c3		 ret	 0
AdapterCreate ENDP
_TEXT	ENDS
PUBLIC	DriverEntry
EXTRN	__imp_NdisMRegisterMiniport:NEAR
EXTRN	__imp_NdisInitializeWrapper:NEAR
EXTRN	__imp_NdisTerminateWrapper:NEAR
EXTRN	__imp_NdisMRegisterUnloadHandler:NEAR
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 050901H
	DD	0c0054209H
	DD	060027003H
	DD	03001H
xdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD @imagerel(DriverEntry#)
	DD	@imagerel(DriverEntry#+295)
	DD	@imagerel($unwind$DriverEntry#)
; Function compile flags: /Ogty
pdata	ENDS
;	COMDAT DriverEntry
INIT	SEGMENT
p_DriverObject$ = 80
p_RegistryPath$ = 88
DriverEntry PROC NEAR					; COMDAT

; 146  : {

  00000	53		 push	 rbx
  00001	56		 push	 rsi
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00009	48 8b f1	 mov	 rsi, rcx

; 147  :   NDIS_STATUS l_Status = NDIS_STATUS_FAILURE;

  0000c	bb 01 00 00 c0	 mov	 ebx, -1073741823	; c0000001H

; 148  :   NDIS_MINIPORT_CHARACTERISTICS *l_Properties = NULL;
; 149  : 
; 150  :   //========================================================
; 151  :   // Notify NDIS that a new miniport driver is initializing.
; 152  :   //========================================================
; 153  : 
; 154  :   NdisMInitializeWrapper (&g_NdisWrapperHandle,
; 155  : 			  p_DriverObject,
; 156  : 			  p_RegistryPath, NULL);

  00011	45 33 c9	 xor	 r9d, r9d
  00014	4c 8b c2	 mov	 r8, rdx
  00017	48 8b d6	 mov	 rdx, rsi
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:g_NdisWrapperHandle
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisInitializeWrapper

; 157  : 
; 158  :   //======================
; 159  :   // Global initialization
; 160  :   //======================
; 161  : 
; 162  : #if DBG
; 163  :   MyDebugInit (10000); // Allocate debugging text space
; 164  : #endif
; 165  : 
; 166  :   if (!InitInstanceList ())

  00027	e8 00 00 00 00	 call	 InitInstanceList
  0002c	84 c0		 test	 al, al
  0002e	0f 84 df 00 00
	00		 je	 $L21438

; 167  :     {
; 168  :       DEBUGP (("[TAP] Allocation failed for adapter instance list\n"));
; 169  :       goto cleanup;
; 170  :     }
; 171  : 
; 172  :   //=======================================
; 173  :   // Set and register miniport entry points
; 174  :   //=======================================
; 175  : 
; 176  :   l_Properties = MemAlloc (sizeof (NDIS_MINIPORT_CHARACTERISTICS), TRUE);

  00034	b2 01		 mov	 dl, 1
  00036	41 bc b8 00 00
	00		 mov	 r12d, 184		; 000000b8H
  0003c	41 8b cc	 mov	 ecx, r12d
  0003f	e8 00 00 00 00	 call	 MemAlloc
  00044	48 8b f8	 mov	 rdi, rax

; 177  : 
; 178  :   if (l_Properties == NULL)

  00047	48 85 ff	 test	 rdi, rdi
  0004a	0f 84 c3 00 00
	00		 je	 $L21438

; 179  :     {
; 180  :       DEBUGP (("[TAP] Allocation failed for miniport entry points\n"));
; 181  :       goto cleanup;
; 182  :     }
; 183  : 
; 184  :   l_Properties->MajorNdisVersion = TAP_NDIS_MAJOR_VERSION;

  00050	c6 07 05	 mov	 BYTE PTR [rdi], 5

; 185  :   l_Properties->MinorNdisVersion = TAP_NDIS_MINOR_VERSION;

  00053	c6 47 01 00	 mov	 BYTE PTR [rdi+1], 0

; 186  :   l_Properties->InitializeHandler = AdapterCreate;

  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterCreate
  0005e	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax

; 187  :   l_Properties->HaltHandler = AdapterHalt;

  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterHalt
  00069	48 89 47 20	 mov	 QWORD PTR [rdi+32], rax

; 188  :   l_Properties->ResetHandler = AdapterReset;               /* DISPATCH_LEVEL */

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterReset
  00074	48 89 47 50	 mov	 QWORD PTR [rdi+80], rax

; 189  :   l_Properties->TransferDataHandler = AdapterReceive;      /* DISPATCH_LEVEL */

  00078	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterReceive
  0007f	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax

; 190  :   l_Properties->SendHandler = AdapterTransmit;             /* DISPATCH_LEVEL */

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterTransmit
  0008a	48 89 47 58	 mov	 QWORD PTR [rdi+88], rax

; 191  :   l_Properties->QueryInformationHandler = AdapterQuery;    /* DISPATCH_LEVEL */

  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterQuery
  00095	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax

; 192  :   l_Properties->SetInformationHandler = AdapterModify;     /* DISPATCH_LEVEL */

  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AdapterModify
  000a0	48 89 47 60	 mov	 QWORD PTR [rdi+96], rax

; 193  : 
; 194  :   switch (l_Status =
; 195  : 	  NdisMRegisterMiniport (g_NdisWrapperHandle, l_Properties,
; 196  : 				 sizeof (NDIS_MINIPORT_CHARACTERISTICS)))

  000a4	45 8b c4	 mov	 r8d, r12d
  000a7	48 8b d7	 mov	 rdx, rdi
  000aa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_NdisWrapperHandle
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMRegisterMiniport
  000b7	8b d8		 mov	 ebx, eax
  000b9	81 fb 9a 00 00
	c0		 cmp	 ebx, -1073741670	; c000009aH
  000bf	74 14		 je	 SHORT $L21428
  000c1	81 fb 04 00 01
	c0		 cmp	 ebx, -1073676284	; c0010004H
  000c7	74 0c		 je	 SHORT $L21428
  000c9	81 fb 05 00 01
	c0		 cmp	 ebx, -1073676283	; c0010005H
  000cf	74 04		 je	 SHORT $L21428
  000d1	85 db		 test	 ebx, ebx
  000d3	74 0f		 je	 SHORT $cleanup$21408
$L21428:

; 197  :     {
; 198  :     case NDIS_STATUS_SUCCESS:
; 199  :       {
; 200  : 	DEBUGP (("[TAP] version [%d.%d] %s %s registered miniport successfully\n",
; 201  : 		 TAP_DRIVER_MAJOR_VERSION,
; 202  : 		 TAP_DRIVER_MINOR_VERSION,
; 203  : 		 __DATE__,
; 204  : 		 __TIME__));
; 205  : 	DEBUGP (("Registry Path: '%S'\n", p_RegistryPath->Buffer));
; 206  : 	break;
; 207  :       }
; 208  : 
; 209  :     case NDIS_STATUS_BAD_CHARACTERISTICS:
; 210  :       {
; 211  : 	DEBUGP (("[TAP] Miniport characteristics were badly defined\n"));
; 212  : 	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
; 213  : 	break;
; 214  :       }
; 215  : 
; 216  :     case NDIS_STATUS_BAD_VERSION:
; 217  :       {
; 218  : 	DEBUGP
; 219  : 	  (("[TAP] NDIS Version is wrong for the given characteristics\n"));
; 220  : 	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
; 221  : 	break;
; 222  :       }
; 223  : 
; 224  :     case NDIS_STATUS_RESOURCES:
; 225  :       {
; 226  : 	DEBUGP (("[TAP] Insufficient resources\n"));
; 227  : 	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_NdisWrapperHandle
  000dc	33 d2		 xor	 edx, edx
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisTerminateWrapper
$cleanup$21408:

; 228  : 	break;
; 229  :       }
; 230  : 
; 231  :     default:
; 232  :     case NDIS_STATUS_FAILURE:
; 233  :       {
; 234  : 	DEBUGP (("[TAP] Unknown fatal registration error\n"));
; 235  : 	NdisTerminateWrapper (g_NdisWrapperHandle, NULL);
; 236  : 	break;
; 237  :       }
; 238  :     }
; 239  : 
; 240  :  cleanup:
; 241  :   if (l_Properties)
; 242  :     MemFree (l_Properties, sizeof (NDIS_MINIPORT_CHARACTERISTICS));

  000e4	41 8b d4	 mov	 edx, r12d
  000e7	48 8b cf	 mov	 rcx, rdi
  000ea	e8 00 00 00 00	 call	 MemFree

; 243  : 
; 244  :   if (l_Status == NDIS_STATUS_SUCCESS)

  000ef	85 db		 test	 ebx, ebx
  000f1	75 20		 jne	 SHORT $L21438

; 245  :     NdisMRegisterUnloadHandler (g_NdisWrapperHandle, TapDriverUnload);

  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:TapDriverUnload
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_NdisWrapperHandle
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_NdisMRegisterUnloadHandler

; 248  : 
; 249  :   return l_Status;

  00107	8b c3		 mov	 eax, ebx

; 250  : }

  00109	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010d	41 5c		 pop	 r12
  0010f	5f		 pop	 rdi
  00110	5e		 pop	 rsi
  00111	5b		 pop	 rbx
  00112	c3		 ret	 0
$L21438:

; 246  :   else
; 247  :     TapDriverUnload (p_DriverObject);

  00113	48 8b ce	 mov	 rcx, rsi
  00116	e8 00 00 00 00	 call	 TapDriverUnload

; 248  : 
; 249  :   return l_Status;

  0011b	8b c3		 mov	 eax, ebx

; 250  : }

  0011d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00121	41 5c		 pop	 r12
  00123	5f		 pop	 rdi
  00124	5e		 pop	 rsi
  00125	5b		 pop	 rbx
  00126	c3		 ret	 0
DriverEntry ENDP
INIT	ENDS
END
