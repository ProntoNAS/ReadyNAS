/* dconf-schema.c generated by valac 0.25.3, the Vala compiler
 * generated from dconf-schema.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <libxml/tree.h>
#include <libxml/parser.h>
#include <gio/gio.h>
#include <gobject/gvaluecollector.h>


#define TYPE_SCHEMA_KEY (schema_key_get_type ())
#define SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_KEY, SchemaKey))
#define SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_KEY, SchemaKeyClass))
#define IS_SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_KEY))
#define IS_SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_KEY))
#define SCHEMA_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_KEY, SchemaKeyClass))

typedef struct _SchemaKey SchemaKey;
typedef struct _SchemaKeyClass SchemaKeyClass;
typedef struct _SchemaKeyPrivate SchemaKeyPrivate;

#define TYPE_SCHEMA (schema_get_type ())
#define SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA, Schema))
#define SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA, SchemaClass))
#define IS_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA))
#define IS_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA))
#define SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA, SchemaClass))

typedef struct _Schema Schema;
typedef struct _SchemaClass SchemaClass;

#define TYPE_SCHEMA_VALUE_RANGE (schema_value_range_get_type ())
#define SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange))
#define SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))
#define IS_SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE_RANGE))
#define IS_SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE_RANGE))
#define SCHEMA_VALUE_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))

typedef struct _SchemaValueRange SchemaValueRange;
typedef struct _SchemaValueRangeClass SchemaValueRangeClass;

#define TYPE_SCHEMA_CHOICE (schema_choice_get_type ())
#define SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_CHOICE, SchemaChoice))
#define SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))
#define IS_SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_CHOICE))
#define IS_SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_CHOICE))
#define SCHEMA_CHOICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))

typedef struct _SchemaChoice SchemaChoice;
typedef struct _SchemaChoiceClass SchemaChoiceClass;
#define _schema_unref0(var) ((var == NULL) ? NULL : (var = (schema_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
#define _schema_value_range_unref0(var) ((var == NULL) ? NULL : (var = (schema_value_range_unref (var), NULL)))
#define __g_list_free__schema_choice_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__schema_choice_unref0_ (var), NULL)))
#define _g_variant_type_free0(var) ((var == NULL) ? NULL : (var = (g_variant_type_free (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecSchemaKey ParamSpecSchemaKey;

#define TYPE_SCHEMA_VALUE (schema_value_get_type ())
#define SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE, SchemaValue))
#define SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE, SchemaValueClass))
#define IS_SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE))
#define IS_SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE))
#define SCHEMA_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE, SchemaValueClass))

typedef struct _SchemaValue SchemaValue;
typedef struct _SchemaValueClass SchemaValueClass;
typedef struct _SchemaValuePrivate SchemaValuePrivate;
typedef struct _SchemaChoicePrivate SchemaChoicePrivate;
typedef struct _ParamSpecSchemaChoice ParamSpecSchemaChoice;
typedef struct _SchemaValueRangePrivate SchemaValueRangePrivate;
typedef struct _ParamSpecSchemaValueRange ParamSpecSchemaValueRange;

#define TYPE_SCHEMA_ENUM (schema_enum_get_type ())
#define SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_ENUM, SchemaEnum))
#define SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_ENUM, SchemaEnumClass))
#define IS_SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_ENUM))
#define IS_SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_ENUM))
#define SCHEMA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_ENUM, SchemaEnumClass))

typedef struct _SchemaEnum SchemaEnum;
typedef struct _SchemaEnumClass SchemaEnumClass;
typedef struct _SchemaEnumPrivate SchemaEnumPrivate;

#define TYPE_SCHEMA_LIST (schema_list_get_type ())
#define SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_LIST, SchemaList))
#define SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_LIST, SchemaListClass))
#define IS_SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_LIST))
#define IS_SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_LIST))
#define SCHEMA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_LIST, SchemaListClass))

typedef struct _SchemaList SchemaList;
typedef struct _SchemaListClass SchemaListClass;
#define _schema_list_unref0(var) ((var == NULL) ? NULL : (var = (schema_list_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _ParamSpecSchemaEnum ParamSpecSchemaEnum;

#define TYPE_SCHEMA_FLAGS (schema_flags_get_type ())
#define SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_FLAGS, SchemaFlags))
#define SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))
#define IS_SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_FLAGS))
#define IS_SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_FLAGS))
#define SCHEMA_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))

typedef struct _SchemaFlags SchemaFlags;
typedef struct _SchemaFlagsClass SchemaFlagsClass;
typedef struct _SchemaFlagsPrivate SchemaFlagsPrivate;
typedef struct _ParamSpecSchemaFlags ParamSpecSchemaFlags;
typedef struct _SchemaPrivate SchemaPrivate;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define _schema_key_unref0(var) ((var == NULL) ? NULL : (var = (schema_key_unref (var), NULL)))
typedef struct _ParamSpecSchema ParamSpecSchema;
typedef struct _SchemaListPrivate SchemaListPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
#define _schema_enum_unref0(var) ((var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL)))
#define _schema_flags_unref0(var) ((var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL)))
#define _g_key_file_free0(var) ((var == NULL) ? NULL : (var = (g_key_file_free (var), NULL)))
typedef struct _ParamSpecSchemaList ParamSpecSchemaList;

struct _SchemaKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaKeyPrivate * priv;
	Schema* schema;
	gchar* name;
	gchar* type;
	GVariant* default_value;
	SchemaValueRange* range;
	SchemaValueRange* type_range;
	GList* choices;
	gchar* enum_name;
	gchar* summary;
	gchar* description;
	gchar* gettext_domain;
};

struct _SchemaKeyClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaKey *self);
};

struct _ParamSpecSchemaKey {
	GParamSpec parent_instance;
};

struct _SchemaValue {
	GObject parent_instance;
	SchemaValuePrivate * priv;
	guint index;
	gchar* nick;
	gint value;
};

struct _SchemaValueClass {
	GObjectClass parent_class;
};

struct _SchemaChoice {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaChoicePrivate * priv;
	gchar* name;
	GVariant* value;
};

struct _SchemaChoiceClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaChoice *self);
};

struct _ParamSpecSchemaChoice {
	GParamSpec parent_instance;
};

struct _SchemaValueRange {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaValueRangePrivate * priv;
	GVariant* min;
	GVariant* max;
};

struct _SchemaValueRangeClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaValueRange *self);
};

struct _ParamSpecSchemaValueRange {
	GParamSpec parent_instance;
};

struct _SchemaEnum {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaEnumPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaEnumClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaEnum *self);
};

struct _ParamSpecSchemaEnum {
	GParamSpec parent_instance;
};

struct _SchemaFlags {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaFlagsPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaFlagsClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaFlags *self);
};

struct _ParamSpecSchemaFlags {
	GParamSpec parent_instance;
};

struct _Schema {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaPrivate * priv;
	SchemaList* list;
	gchar* id;
	gchar* path;
	GHashTable* keys;
};

struct _SchemaClass {
	GTypeClass parent_class;
	void (*finalize) (Schema *self);
};

struct _ParamSpecSchema {
	GParamSpec parent_instance;
};

struct _SchemaList {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaListPrivate * priv;
	GHashTable* schemas;
	GHashTable* keys;
	GHashTable* enums;
	GHashTable* flags;
};

struct _SchemaListClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaList *self);
};

struct _ParamSpecSchemaList {
	GParamSpec parent_instance;
};


static gpointer schema_key_parent_class = NULL;
static gpointer schema_value_parent_class = NULL;
static gpointer schema_choice_parent_class = NULL;
static gpointer schema_value_range_parent_class = NULL;
static gpointer schema_enum_parent_class = NULL;
static gpointer schema_flags_parent_class = NULL;
static gpointer schema_parent_class = NULL;
static gpointer schema_list_parent_class = NULL;

gpointer schema_key_ref (gpointer instance);
void schema_key_unref (gpointer instance);
GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_key (GValue* value, gpointer v_object);
void value_take_schema_key (GValue* value, gpointer v_object);
gpointer value_get_schema_key (const GValue* value);
GType schema_key_get_type (void) G_GNUC_CONST;
gpointer schema_ref (gpointer instance);
void schema_unref (gpointer instance);
GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema (GValue* value, gpointer v_object);
void value_take_schema (GValue* value, gpointer v_object);
gpointer value_get_schema (const GValue* value);
GType schema_get_type (void) G_GNUC_CONST;
gpointer schema_value_range_ref (gpointer instance);
void schema_value_range_unref (gpointer instance);
GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_value_range (GValue* value, gpointer v_object);
void value_take_schema_value_range (GValue* value, gpointer v_object);
gpointer value_get_schema_value_range (const GValue* value);
GType schema_value_range_get_type (void) G_GNUC_CONST;
gpointer schema_choice_ref (gpointer instance);
void schema_choice_unref (gpointer instance);
GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_choice (GValue* value, gpointer v_object);
void value_take_schema_choice (GValue* value, gpointer v_object);
gpointer value_get_schema_choice (const GValue* value);
GType schema_choice_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_KEY_DUMMY_PROPERTY
};
static void _schema_choice_unref0_ (gpointer var);
static void _g_list_free__schema_choice_unref0_ (GList* self);
SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain);
SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node);
SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node);
SchemaChoice* schema_choice_new (const gchar* name, GVariant* value);
SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value);
SchemaKey* schema_key_new (void);
SchemaKey* schema_key_construct (GType object_type);
static void schema_key_finalize (SchemaKey* obj);
GType schema_value_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_VALUE_DUMMY_PROPERTY
};
SchemaValue* schema_value_new (guint index, const gchar* nick, gint value);
SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value);
static void schema_value_finalize (GObject* obj);
enum  {
	SCHEMA_CHOICE_DUMMY_PROPERTY
};
static void schema_choice_finalize (SchemaChoice* obj);
enum  {
	SCHEMA_VALUE_RANGE_DUMMY_PROPERTY
};
SchemaValueRange* schema_value_range_new (void);
SchemaValueRange* schema_value_range_construct (GType object_type);
static void schema_value_range_finalize (SchemaValueRange* obj);
gpointer schema_enum_ref (gpointer instance);
void schema_enum_unref (gpointer instance);
GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_enum (GValue* value, gpointer v_object);
void value_take_schema_enum (GValue* value, gpointer v_object);
gpointer value_get_schema_enum (const GValue* value);
GType schema_enum_get_type (void) G_GNUC_CONST;
gpointer schema_list_ref (gpointer instance);
void schema_list_unref (gpointer instance);
GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_list (GValue* value, gpointer v_object);
void value_take_schema_list (GValue* value, gpointer v_object);
gpointer value_get_schema_list (const GValue* value);
GType schema_list_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_ENUM_DUMMY_PROPERTY
};
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaEnum* schema_enum_new (void);
SchemaEnum* schema_enum_construct (GType object_type);
static void schema_enum_finalize (SchemaEnum* obj);
gpointer schema_flags_ref (gpointer instance);
void schema_flags_unref (gpointer instance);
GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_flags (GValue* value, gpointer v_object);
void value_take_schema_flags (GValue* value, gpointer v_object);
gpointer value_get_schema_flags (const GValue* value);
GType schema_flags_get_type (void) G_GNUC_CONST;
enum  {
	SCHEMA_FLAGS_DUMMY_PROPERTY
};
SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node);
SchemaFlags* schema_flags_new (void);
SchemaFlags* schema_flags_construct (GType object_type);
static void schema_flags_finalize (SchemaFlags* obj);
enum  {
	SCHEMA_DUMMY_PROPERTY
};
static void _g_free0_ (gpointer var);
static void _schema_key_unref0_ (gpointer var);
Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain);
Schema* schema_new (void);
Schema* schema_construct (GType object_type);
static void schema_finalize (Schema* obj);
enum  {
	SCHEMA_LIST_DUMMY_PROPERTY
};
static void _schema_unref0_ (gpointer var);
static void _schema_enum_unref0_ (gpointer var);
static void _schema_flags_unref0_ (gpointer var);
void schema_list_parse_file (SchemaList* self, const gchar* path);
void schema_list_parse_override (SchemaList* self, const gchar* path);
void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error);
SchemaList* schema_list_new (void);
SchemaList* schema_list_construct (GType object_type);
static void schema_list_finalize (SchemaList* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _schema_choice_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_choice_unref (var), NULL));
}


static void _g_list_free__schema_choice_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _schema_choice_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_ref0 (gpointer self) {
	return self ? schema_ref (self) : NULL;
}


SchemaKey* schema_key_construct_from_xml (GType object_type, xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	SchemaKey* self = NULL;
	Schema* _tmp0_ = NULL;
	Schema* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (schema != NULL, NULL);
	self = (SchemaKey*) g_type_create_instance (object_type);
	_tmp0_ = schema;
	_tmp1_ = _schema_ref0 (_tmp0_);
	_schema_unref0 (self->schema);
	self->schema = _tmp1_;
	_tmp2_ = gettext_domain;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->gettext_domain);
	self->gettext_domain = _tmp3_;
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp4_ = NULL;
		xmlAttr* _tmp5_ = NULL;
		_tmp4_ = node;
		_tmp5_ = _tmp4_->properties;
		prop = _tmp5_;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp9_ = NULL;
				xmlAttr* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				if (!_tmp6_) {
					xmlAttr* _tmp7_ = NULL;
					xmlAttr* _tmp8_ = NULL;
					_tmp7_ = prop;
					_tmp8_ = _tmp7_->next;
					prop = _tmp8_;
				}
				_tmp6_ = FALSE;
				_tmp9_ = prop;
				if (!(_tmp9_ != NULL)) {
					break;
				}
				_tmp10_ = prop;
				_tmp11_ = _tmp10_->name;
				if (g_strcmp0 (_tmp11_, "name") == 0) {
					xmlAttr* _tmp12_ = NULL;
					xmlNode* _tmp13_ = NULL;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					_tmp12_ = prop;
					_tmp13_ = _tmp12_->children;
					_tmp14_ = _tmp13_->content;
					_tmp15_ = g_strdup (_tmp14_);
					_g_free0 (self->name);
					self->name = _tmp15_;
				} else {
					xmlAttr* _tmp16_ = NULL;
					const gchar* _tmp17_ = NULL;
					_tmp16_ = prop;
					_tmp17_ = _tmp16_->name;
					if (g_strcmp0 (_tmp17_, "type") == 0) {
						xmlAttr* _tmp18_ = NULL;
						xmlNode* _tmp19_ = NULL;
						const gchar* _tmp20_ = NULL;
						gchar* _tmp21_ = NULL;
						_tmp18_ = prop;
						_tmp19_ = _tmp18_->children;
						_tmp20_ = _tmp19_->content;
						_tmp21_ = g_strdup (_tmp20_);
						_g_free0 (self->type);
						self->type = _tmp21_;
					} else {
						xmlAttr* _tmp22_ = NULL;
						const gchar* _tmp23_ = NULL;
						_tmp22_ = prop;
						_tmp23_ = _tmp22_->name;
						if (g_strcmp0 (_tmp23_, "enum") == 0) {
							gchar* _tmp24_ = NULL;
							xmlAttr* _tmp25_ = NULL;
							xmlNode* _tmp26_ = NULL;
							const gchar* _tmp27_ = NULL;
							gchar* _tmp28_ = NULL;
							_tmp24_ = g_strdup ("s");
							_g_free0 (self->type);
							self->type = _tmp24_;
							_tmp25_ = prop;
							_tmp26_ = _tmp25_->children;
							_tmp27_ = _tmp26_->content;
							_tmp28_ = g_strdup (_tmp27_);
							_g_free0 (self->enum_name);
							self->enum_name = _tmp28_;
						} else {
							xmlAttr* _tmp29_ = NULL;
							const gchar* _tmp30_ = NULL;
							_tmp29_ = prop;
							_tmp30_ = _tmp29_->name;
							if (g_strcmp0 (_tmp30_, "flags") == 0) {
								gchar* _tmp31_ = NULL;
								_tmp31_ = g_strdup ("as");
								_g_free0 (self->type);
								self->type = _tmp31_;
							} else {
								xmlAttr* _tmp32_ = NULL;
								const gchar* _tmp33_ = NULL;
								_tmp32_ = prop;
								_tmp33_ = _tmp32_->name;
								g_warning ("dconf-schema.vala:35: Unknown property on <key>, %s", _tmp33_);
							}
						}
					}
				}
			}
		}
	}
	{
		xmlNode* child = NULL;
		xmlNode* _tmp34_ = NULL;
		xmlNode* _tmp35_ = NULL;
		_tmp34_ = node;
		_tmp35_ = _tmp34_->children;
		child = _tmp35_;
		{
			gboolean _tmp36_ = FALSE;
			_tmp36_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp39_ = NULL;
				xmlNode* _tmp40_ = NULL;
				const gchar* _tmp41_ = NULL;
				if (!_tmp36_) {
					xmlNode* _tmp37_ = NULL;
					xmlNode* _tmp38_ = NULL;
					_tmp37_ = child;
					_tmp38_ = _tmp37_->next;
					child = _tmp38_;
				}
				_tmp36_ = FALSE;
				_tmp39_ = child;
				if (!(_tmp39_ != NULL)) {
					break;
				}
				_tmp40_ = child;
				_tmp41_ = _tmp40_->name;
				if (g_strcmp0 (_tmp41_, "default") == 0) {
					{
						GVariant* _tmp42_ = NULL;
						const gchar* _tmp43_ = NULL;
						GVariantType* _tmp44_ = NULL;
						GVariantType* _tmp45_ = NULL;
						xmlNode* _tmp46_ = NULL;
						gchar* _tmp47_ = NULL;
						gchar* _tmp48_ = NULL;
						GVariant* _tmp49_ = NULL;
						GVariant* _tmp50_ = NULL;
						GVariant* _tmp51_ = NULL;
						_tmp43_ = self->type;
						_tmp44_ = g_variant_type_new (_tmp43_);
						_tmp45_ = _tmp44_;
						_tmp46_ = child;
						_tmp47_ = (gchar*) xmlNodeGetContent (_tmp46_);
						_tmp48_ = _tmp47_;
						_tmp49_ = g_variant_parse (_tmp45_, _tmp48_, NULL, NULL, &_inner_error_);
						_tmp50_ = _tmp49_;
						_g_free0 (_tmp48_);
						_g_variant_type_free0 (_tmp45_);
						_tmp42_ = _tmp50_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch5_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_tmp51_ = _tmp42_;
						_tmp42_ = NULL;
						_g_variant_unref0 (self->default_value);
						self->default_value = _tmp51_;
						_g_variant_unref0 (_tmp42_);
					}
					goto __finally5;
					__catch5_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally5:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlNode* _tmp52_ = NULL;
					const gchar* _tmp53_ = NULL;
					_tmp52_ = child;
					_tmp53_ = _tmp52_->name;
					if (g_strcmp0 (_tmp53_, "summary") == 0) {
						xmlNode* _tmp54_ = NULL;
						gchar* _tmp55_ = NULL;
						_tmp54_ = child;
						_tmp55_ = (gchar*) xmlNodeGetContent (_tmp54_);
						_g_free0 (self->summary);
						self->summary = _tmp55_;
					} else {
						xmlNode* _tmp56_ = NULL;
						const gchar* _tmp57_ = NULL;
						_tmp56_ = child;
						_tmp57_ = _tmp56_->name;
						if (g_strcmp0 (_tmp57_, "description") == 0) {
							xmlNode* _tmp58_ = NULL;
							gchar* _tmp59_ = NULL;
							_tmp58_ = child;
							_tmp59_ = (gchar*) xmlNodeGetContent (_tmp58_);
							_g_free0 (self->description);
							self->description = _tmp59_;
						} else {
							xmlNode* _tmp60_ = NULL;
							const gchar* _tmp61_ = NULL;
							_tmp60_ = child;
							_tmp61_ = _tmp60_->name;
							if (g_strcmp0 (_tmp61_, "range") == 0) {
								const gchar* _tmp62_ = NULL;
								xmlNode* _tmp63_ = NULL;
								SchemaValueRange* _tmp64_ = NULL;
								_tmp62_ = self->type;
								_tmp63_ = child;
								_tmp64_ = schema_value_range_new_from_xml (_tmp62_, _tmp63_);
								_schema_value_range_unref0 (self->range);
								self->range = _tmp64_;
							} else {
								xmlNode* _tmp65_ = NULL;
								const gchar* _tmp66_ = NULL;
								_tmp65_ = child;
								_tmp66_ = _tmp65_->name;
								if (g_strcmp0 (_tmp66_, "choices") == 0) {
									{
										xmlNode* n = NULL;
										xmlNode* _tmp67_ = NULL;
										xmlNode* _tmp68_ = NULL;
										_tmp67_ = child;
										_tmp68_ = _tmp67_->children;
										n = _tmp68_;
										{
											gboolean _tmp69_ = FALSE;
											_tmp69_ = TRUE;
											while (TRUE) {
												xmlNode* _tmp72_ = NULL;
												xmlNode* _tmp73_ = NULL;
												xmlElementType _tmp74_ = 0;
												xmlNode* _tmp75_ = NULL;
												const gchar* _tmp76_ = NULL;
												gchar* value = NULL;
												const gchar* _tmp93_ = NULL;
												GVariant* v = NULL;
												const gchar* _tmp94_ = NULL;
												GVariant* _tmp95_ = NULL;
												const gchar* _tmp96_ = NULL;
												GVariant* _tmp97_ = NULL;
												SchemaChoice* _tmp98_ = NULL;
												if (!_tmp69_) {
													xmlNode* _tmp70_ = NULL;
													xmlNode* _tmp71_ = NULL;
													_tmp70_ = n;
													_tmp71_ = _tmp70_->next;
													n = _tmp71_;
												}
												_tmp69_ = FALSE;
												_tmp72_ = n;
												if (!(_tmp72_ != NULL)) {
													break;
												}
												_tmp73_ = n;
												_tmp74_ = _tmp73_->type;
												if (_tmp74_ != XML_ELEMENT_NODE) {
													continue;
												}
												_tmp75_ = n;
												_tmp76_ = _tmp75_->name;
												if (g_strcmp0 (_tmp76_, "choice") != 0) {
													xmlNode* _tmp77_ = NULL;
													const gchar* _tmp78_ = NULL;
													_tmp77_ = n;
													_tmp78_ = _tmp77_->name;
													g_warning ("dconf-schema.vala:68: Unknown child tag in <choices>, <%s>", _tmp78_);
													continue;
												}
												value = NULL;
												{
													xmlAttr* prop = NULL;
													xmlNode* _tmp79_ = NULL;
													xmlAttr* _tmp80_ = NULL;
													_tmp79_ = n;
													_tmp80_ = _tmp79_->properties;
													prop = _tmp80_;
													{
														gboolean _tmp81_ = FALSE;
														_tmp81_ = TRUE;
														while (TRUE) {
															xmlAttr* _tmp84_ = NULL;
															xmlAttr* _tmp85_ = NULL;
															const gchar* _tmp86_ = NULL;
															if (!_tmp81_) {
																xmlAttr* _tmp82_ = NULL;
																xmlAttr* _tmp83_ = NULL;
																_tmp82_ = prop;
																_tmp83_ = _tmp82_->next;
																prop = _tmp83_;
															}
															_tmp81_ = FALSE;
															_tmp84_ = prop;
															if (!(_tmp84_ != NULL)) {
																break;
															}
															_tmp85_ = prop;
															_tmp86_ = _tmp85_->name;
															if (g_strcmp0 (_tmp86_, "value") == 0) {
																xmlAttr* _tmp87_ = NULL;
																xmlNode* _tmp88_ = NULL;
																const gchar* _tmp89_ = NULL;
																gchar* _tmp90_ = NULL;
																_tmp87_ = prop;
																_tmp88_ = _tmp87_->children;
																_tmp89_ = _tmp88_->content;
																_tmp90_ = g_strdup (_tmp89_);
																_g_free0 (value);
																value = _tmp90_;
															} else {
																xmlAttr* _tmp91_ = NULL;
																const gchar* _tmp92_ = NULL;
																_tmp91_ = prop;
																_tmp92_ = _tmp91_->name;
																g_warning ("dconf-schema.vala:78: Unknown property on <choice>, %s", _tmp92_);
															}
														}
													}
												}
												_tmp93_ = value;
												if (_tmp93_ == NULL) {
													g_warning ("dconf-schema.vala:83: Ignoring <choice> with no value");
													_g_free0 (value);
													continue;
												}
												_tmp94_ = value;
												_tmp95_ = g_variant_new_string (_tmp94_);
												g_variant_ref_sink (_tmp95_);
												v = _tmp95_;
												_tmp96_ = value;
												_tmp97_ = v;
												_tmp98_ = schema_choice_new (_tmp96_, _tmp97_);
												self->choices = g_list_append (self->choices, _tmp98_);
												_g_variant_unref0 (v);
												_g_free0 (value);
											}
										}
									}
								} else {
									xmlNode* _tmp99_ = NULL;
									const gchar* _tmp100_ = NULL;
									_tmp99_ = child;
									_tmp100_ = _tmp99_->name;
									if (g_strcmp0 (_tmp100_, "aliases") == 0) {
										{
											xmlNode* n = NULL;
											xmlNode* _tmp101_ = NULL;
											xmlNode* _tmp102_ = NULL;
											_tmp101_ = child;
											_tmp102_ = _tmp101_->children;
											n = _tmp102_;
											{
												gboolean _tmp103_ = FALSE;
												_tmp103_ = TRUE;
												while (TRUE) {
													xmlNode* _tmp106_ = NULL;
													xmlNode* _tmp107_ = NULL;
													xmlElementType _tmp108_ = 0;
													xmlNode* _tmp109_ = NULL;
													const gchar* _tmp110_ = NULL;
													gchar* value = NULL;
													gchar* target = NULL;
													const gchar* _tmp133_ = NULL;
													const gchar* _tmp134_ = NULL;
													GVariant* v = NULL;
													const gchar* _tmp135_ = NULL;
													GVariant* _tmp136_ = NULL;
													const gchar* _tmp137_ = NULL;
													GVariant* _tmp138_ = NULL;
													SchemaChoice* _tmp139_ = NULL;
													if (!_tmp103_) {
														xmlNode* _tmp104_ = NULL;
														xmlNode* _tmp105_ = NULL;
														_tmp104_ = n;
														_tmp105_ = _tmp104_->next;
														n = _tmp105_;
													}
													_tmp103_ = FALSE;
													_tmp106_ = n;
													if (!(_tmp106_ != NULL)) {
														break;
													}
													_tmp107_ = n;
													_tmp108_ = _tmp107_->type;
													if (_tmp108_ != XML_ELEMENT_NODE) {
														continue;
													}
													_tmp109_ = n;
													_tmp110_ = _tmp109_->name;
													if (g_strcmp0 (_tmp110_, "alias") != 0) {
														xmlNode* _tmp111_ = NULL;
														const gchar* _tmp112_ = NULL;
														_tmp111_ = n;
														_tmp112_ = _tmp111_->name;
														g_warning ("dconf-schema.vala:99: Unknown child tag in <aliases>, <%s>", _tmp112_);
														continue;
													}
													value = NULL;
													target = NULL;
													{
														xmlAttr* prop = NULL;
														xmlNode* _tmp113_ = NULL;
														xmlAttr* _tmp114_ = NULL;
														_tmp113_ = n;
														_tmp114_ = _tmp113_->properties;
														prop = _tmp114_;
														{
															gboolean _tmp115_ = FALSE;
															_tmp115_ = TRUE;
															while (TRUE) {
																xmlAttr* _tmp118_ = NULL;
																xmlAttr* _tmp119_ = NULL;
																const gchar* _tmp120_ = NULL;
																if (!_tmp115_) {
																	xmlAttr* _tmp116_ = NULL;
																	xmlAttr* _tmp117_ = NULL;
																	_tmp116_ = prop;
																	_tmp117_ = _tmp116_->next;
																	prop = _tmp117_;
																}
																_tmp115_ = FALSE;
																_tmp118_ = prop;
																if (!(_tmp118_ != NULL)) {
																	break;
																}
																_tmp119_ = prop;
																_tmp120_ = _tmp119_->name;
																if (g_strcmp0 (_tmp120_, "value") == 0) {
																	xmlAttr* _tmp121_ = NULL;
																	xmlNode* _tmp122_ = NULL;
																	const gchar* _tmp123_ = NULL;
																	gchar* _tmp124_ = NULL;
																	_tmp121_ = prop;
																	_tmp122_ = _tmp121_->children;
																	_tmp123_ = _tmp122_->content;
																	_tmp124_ = g_strdup (_tmp123_);
																	_g_free0 (value);
																	value = _tmp124_;
																} else {
																	xmlAttr* _tmp125_ = NULL;
																	const gchar* _tmp126_ = NULL;
																	_tmp125_ = prop;
																	_tmp126_ = _tmp125_->name;
																	if (g_strcmp0 (_tmp126_, "target") == 0) {
																		xmlAttr* _tmp127_ = NULL;
																		xmlNode* _tmp128_ = NULL;
																		const gchar* _tmp129_ = NULL;
																		gchar* _tmp130_ = NULL;
																		_tmp127_ = prop;
																		_tmp128_ = _tmp127_->children;
																		_tmp129_ = _tmp128_->content;
																		_tmp130_ = g_strdup (_tmp129_);
																		_g_free0 (target);
																		target = _tmp130_;
																	} else {
																		xmlAttr* _tmp131_ = NULL;
																		const gchar* _tmp132_ = NULL;
																		_tmp131_ = prop;
																		_tmp132_ = _tmp131_->name;
																		g_warning ("dconf-schema.vala:111: Unknown property on <alias>, %s", _tmp132_);
																	}
																}
															}
														}
													}
													_tmp133_ = value;
													if (_tmp133_ == NULL) {
														g_warning ("dconf-schema.vala:116: Ignoring <alias> with no value");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp134_ = target;
													if (_tmp134_ == NULL) {
														g_warning ("dconf-schema.vala:121: Ignoring <alias> with no target");
														_g_free0 (target);
														_g_free0 (value);
														continue;
													}
													_tmp135_ = target;
													_tmp136_ = g_variant_new_string (_tmp135_);
													g_variant_ref_sink (_tmp136_);
													v = _tmp136_;
													_tmp137_ = value;
													_tmp138_ = v;
													_tmp139_ = schema_choice_new (_tmp137_, _tmp138_);
													self->choices = g_list_append (self->choices, _tmp139_);
													_g_variant_unref0 (v);
													_g_free0 (target);
													_g_free0 (value);
												}
											}
										}
									} else {
										gboolean _tmp140_ = FALSE;
										xmlNode* _tmp141_ = NULL;
										xmlElementType _tmp142_ = 0;
										_tmp141_ = child;
										_tmp142_ = _tmp141_->type;
										if (_tmp142_ != XML_TEXT_NODE) {
											xmlNode* _tmp143_ = NULL;
											xmlElementType _tmp144_ = 0;
											_tmp143_ = child;
											_tmp144_ = _tmp143_->type;
											_tmp140_ = _tmp144_ != XML_COMMENT_NODE;
										} else {
											_tmp140_ = FALSE;
										}
										if (_tmp140_) {
											xmlNode* _tmp145_ = NULL;
											const gchar* _tmp146_ = NULL;
											_tmp145_ = child;
											_tmp146_ = _tmp145_->name;
											g_warning ("dconf-schema.vala:130: Unknown child tag in <key>, <%s>", _tmp146_);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return self;
}


SchemaKey* schema_key_new_from_xml (xmlNode* node, Schema* schema, const gchar* gettext_domain) {
	return schema_key_construct_from_xml (TYPE_SCHEMA_KEY, node, schema, gettext_domain);
}


SchemaKey* schema_key_construct (GType object_type) {
	SchemaKey* self = NULL;
	self = (SchemaKey*) g_type_create_instance (object_type);
	return self;
}


SchemaKey* schema_key_new (void) {
	return schema_key_construct (TYPE_SCHEMA_KEY);
}


static void value_schema_key_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_key_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_key_unref (value->data[0].v_pointer);
	}
}


static void value_schema_key_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_key_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_key_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_key_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaKey* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_key_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_key_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaKey** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_key_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaKey* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_KEY), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_key (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_key_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


void value_take_schema_key (GValue* value, gpointer v_object) {
	SchemaKey* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_KEY));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_KEY));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_key_unref (old);
	}
}


static void schema_key_class_init (SchemaKeyClass * klass) {
	schema_key_parent_class = g_type_class_peek_parent (klass);
	((SchemaKeyClass *) klass)->finalize = schema_key_finalize;
}


static void schema_key_instance_init (SchemaKey * self) {
	self->ref_count = 1;
}


static void schema_key_finalize (SchemaKey* obj) {
	SchemaKey * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_KEY, SchemaKey);
	g_signal_handlers_destroy (self);
	_schema_unref0 (self->schema);
	_g_free0 (self->name);
	_g_free0 (self->type);
	_g_variant_unref0 (self->default_value);
	_schema_value_range_unref0 (self->range);
	_schema_value_range_unref0 (self->type_range);
	__g_list_free__schema_choice_unref0_0 (self->choices);
	_g_free0 (self->enum_name);
	_g_free0 (self->summary);
	_g_free0 (self->description);
	_g_free0 (self->gettext_domain);
}


GType schema_key_get_type (void) {
	static volatile gsize schema_key_type_id__volatile = 0;
	if (g_once_init_enter (&schema_key_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_key_init, value_schema_key_free_value, value_schema_key_copy_value, value_schema_key_peek_pointer, "p", value_schema_key_collect_value, "p", value_schema_key_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaKeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_key_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaKey), 0, (GInstanceInitFunc) schema_key_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_key_type_id;
		schema_key_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaKey", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_key_type_id__volatile, schema_key_type_id);
	}
	return schema_key_type_id__volatile;
}


gpointer schema_key_ref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_key_unref (gpointer instance) {
	SchemaKey* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_KEY_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValue* schema_value_construct (GType object_type, guint index, const gchar* nick, gint value) {
	SchemaValue * self = NULL;
	guint _tmp0_ = 0U;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	g_return_val_if_fail (nick != NULL, NULL);
	self = (SchemaValue*) g_object_new (object_type, NULL);
	_tmp0_ = index;
	self->index = _tmp0_;
	_tmp1_ = nick;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->nick);
	self->nick = _tmp2_;
	_tmp3_ = value;
	self->value = _tmp3_;
	return self;
}


SchemaValue* schema_value_new (guint index, const gchar* nick, gint value) {
	return schema_value_construct (TYPE_SCHEMA_VALUE, index, nick, value);
}


static void schema_value_class_init (SchemaValueClass * klass) {
	schema_value_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = schema_value_finalize;
}


static void schema_value_instance_init (SchemaValue * self) {
}


static void schema_value_finalize (GObject* obj) {
	SchemaValue * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE, SchemaValue);
	_g_free0 (self->nick);
	G_OBJECT_CLASS (schema_value_parent_class)->finalize (obj);
}


GType schema_value_get_type (void) {
	static volatile gsize schema_value_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValue), 0, (GInstanceInitFunc) schema_value_instance_init, NULL };
		GType schema_value_type_id;
		schema_value_type_id = g_type_register_static (G_TYPE_OBJECT, "SchemaValue", &g_define_type_info, 0);
		g_once_init_leave (&schema_value_type_id__volatile, schema_value_type_id);
	}
	return schema_value_type_id__volatile;
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


SchemaChoice* schema_choice_construct (GType object_type, const gchar* name, GVariant* value) {
	SchemaChoice* self = NULL;
	const gchar* _tmp0_ = NULL;
	gchar* _tmp1_ = NULL;
	GVariant* _tmp2_ = NULL;
	GVariant* _tmp3_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (value != NULL, NULL);
	self = (SchemaChoice*) g_type_create_instance (object_type);
	_tmp0_ = name;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->name);
	self->name = _tmp1_;
	_tmp2_ = value;
	_tmp3_ = _g_variant_ref0 (_tmp2_);
	_g_variant_unref0 (self->value);
	self->value = _tmp3_;
	return self;
}


SchemaChoice* schema_choice_new (const gchar* name, GVariant* value) {
	return schema_choice_construct (TYPE_SCHEMA_CHOICE, name, value);
}


static void value_schema_choice_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_choice_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_choice_unref (value->data[0].v_pointer);
	}
}


static void value_schema_choice_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_choice_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_choice_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_choice_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaChoice* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_choice_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_choice_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaChoice** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_choice_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaChoice* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_CHOICE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_choice (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_choice_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


void value_take_schema_choice (GValue* value, gpointer v_object) {
	SchemaChoice* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_CHOICE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_CHOICE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_choice_unref (old);
	}
}


static void schema_choice_class_init (SchemaChoiceClass * klass) {
	schema_choice_parent_class = g_type_class_peek_parent (klass);
	((SchemaChoiceClass *) klass)->finalize = schema_choice_finalize;
}


static void schema_choice_instance_init (SchemaChoice * self) {
	self->ref_count = 1;
}


static void schema_choice_finalize (SchemaChoice* obj) {
	SchemaChoice * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_CHOICE, SchemaChoice);
	g_signal_handlers_destroy (self);
	_g_free0 (self->name);
	_g_variant_unref0 (self->value);
}


GType schema_choice_get_type (void) {
	static volatile gsize schema_choice_type_id__volatile = 0;
	if (g_once_init_enter (&schema_choice_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_choice_init, value_schema_choice_free_value, value_schema_choice_copy_value, value_schema_choice_peek_pointer, "p", value_schema_choice_collect_value, "p", value_schema_choice_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaChoiceClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_choice_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaChoice), 0, (GInstanceInitFunc) schema_choice_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_choice_type_id;
		schema_choice_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaChoice", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_choice_type_id__volatile, schema_choice_type_id);
	}
	return schema_choice_type_id__volatile;
}


gpointer schema_choice_ref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_choice_unref (gpointer instance) {
	SchemaChoice* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_CHOICE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaValueRange* schema_value_range_construct_from_xml (GType object_type, const gchar* type, xmlNode* node) {
	SchemaValueRange* self = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (type != NULL, NULL);
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp0_ = NULL;
		xmlAttr* _tmp1_ = NULL;
		_tmp0_ = node;
		_tmp1_ = _tmp0_->properties;
		prop = _tmp1_;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp5_ = NULL;
				xmlAttr* _tmp6_ = NULL;
				const gchar* _tmp7_ = NULL;
				if (!_tmp2_) {
					xmlAttr* _tmp3_ = NULL;
					xmlAttr* _tmp4_ = NULL;
					_tmp3_ = prop;
					_tmp4_ = _tmp3_->next;
					prop = _tmp4_;
				}
				_tmp2_ = FALSE;
				_tmp5_ = prop;
				if (!(_tmp5_ != NULL)) {
					break;
				}
				_tmp6_ = prop;
				_tmp7_ = _tmp6_->name;
				if (g_strcmp0 (_tmp7_, "min") == 0) {
					{
						GVariant* _tmp8_ = NULL;
						const gchar* _tmp9_ = NULL;
						GVariantType* _tmp10_ = NULL;
						GVariantType* _tmp11_ = NULL;
						xmlAttr* _tmp12_ = NULL;
						xmlNode* _tmp13_ = NULL;
						const gchar* _tmp14_ = NULL;
						GVariant* _tmp15_ = NULL;
						GVariant* _tmp16_ = NULL;
						GVariant* _tmp17_ = NULL;
						_tmp9_ = type;
						_tmp10_ = g_variant_type_new (_tmp9_);
						_tmp11_ = _tmp10_;
						_tmp12_ = prop;
						_tmp13_ = _tmp12_->children;
						_tmp14_ = _tmp13_->content;
						_tmp15_ = g_variant_parse (_tmp11_, _tmp14_, NULL, NULL, &_inner_error_);
						_tmp16_ = _tmp15_;
						_g_variant_type_free0 (_tmp11_);
						_tmp8_ = _tmp16_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
								goto __catch6_g_variant_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
						_tmp17_ = _tmp8_;
						_tmp8_ = NULL;
						_g_variant_unref0 (self->min);
						self->min = _tmp17_;
						_g_variant_unref0 (_tmp8_);
					}
					goto __finally6;
					__catch6_g_variant_parse_error:
					{
						GError* e = NULL;
						e = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (e);
					}
					__finally6:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				} else {
					xmlAttr* _tmp18_ = NULL;
					const gchar* _tmp19_ = NULL;
					_tmp18_ = prop;
					_tmp19_ = _tmp18_->name;
					if (g_strcmp0 (_tmp19_, "max") == 0) {
						{
							GVariant* _tmp20_ = NULL;
							const gchar* _tmp21_ = NULL;
							GVariantType* _tmp22_ = NULL;
							GVariantType* _tmp23_ = NULL;
							xmlAttr* _tmp24_ = NULL;
							xmlNode* _tmp25_ = NULL;
							const gchar* _tmp26_ = NULL;
							GVariant* _tmp27_ = NULL;
							GVariant* _tmp28_ = NULL;
							GVariant* _tmp29_ = NULL;
							_tmp21_ = type;
							_tmp22_ = g_variant_type_new (_tmp21_);
							_tmp23_ = _tmp22_;
							_tmp24_ = prop;
							_tmp25_ = _tmp24_->children;
							_tmp26_ = _tmp25_->content;
							_tmp27_ = g_variant_parse (_tmp23_, _tmp26_, NULL, NULL, &_inner_error_);
							_tmp28_ = _tmp27_;
							_g_variant_type_free0 (_tmp23_);
							_tmp20_ = _tmp28_;
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
									goto __catch7_g_variant_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
							_tmp29_ = _tmp20_;
							_tmp20_ = NULL;
							_g_variant_unref0 (self->max);
							self->max = _tmp29_;
							_g_variant_unref0 (_tmp20_);
						}
						goto __finally7;
						__catch7_g_variant_parse_error:
						{
							GError* e = NULL;
							e = _inner_error_;
							_inner_error_ = NULL;
							_g_error_free0 (e);
						}
						__finally7:
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					} else {
						xmlAttr* _tmp30_ = NULL;
						const gchar* _tmp31_ = NULL;
						_tmp30_ = prop;
						_tmp31_ = _tmp30_->name;
						g_warning ("dconf-schema.vala:196: Unknown property in <range>, %s", _tmp31_);
					}
				}
			}
		}
	}
	return self;
}


SchemaValueRange* schema_value_range_new_from_xml (const gchar* type, xmlNode* node) {
	return schema_value_range_construct_from_xml (TYPE_SCHEMA_VALUE_RANGE, type, node);
}


SchemaValueRange* schema_value_range_construct (GType object_type) {
	SchemaValueRange* self = NULL;
	self = (SchemaValueRange*) g_type_create_instance (object_type);
	return self;
}


SchemaValueRange* schema_value_range_new (void) {
	return schema_value_range_construct (TYPE_SCHEMA_VALUE_RANGE);
}


static void value_schema_value_range_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_value_range_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_value_range_unref (value->data[0].v_pointer);
	}
}


static void value_schema_value_range_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_value_range_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_value_range_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_value_range_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaValueRange* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_value_range_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_value_range_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaValueRange** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_value_range_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaValueRange* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_VALUE_RANGE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_value_range (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_value_range_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


void value_take_schema_value_range (GValue* value, gpointer v_object) {
	SchemaValueRange* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_VALUE_RANGE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_VALUE_RANGE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_value_range_unref (old);
	}
}


static void schema_value_range_class_init (SchemaValueRangeClass * klass) {
	schema_value_range_parent_class = g_type_class_peek_parent (klass);
	((SchemaValueRangeClass *) klass)->finalize = schema_value_range_finalize;
}


static void schema_value_range_instance_init (SchemaValueRange * self) {
	self->ref_count = 1;
}


static void schema_value_range_finalize (SchemaValueRange* obj) {
	SchemaValueRange * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange);
	g_signal_handlers_destroy (self);
	_g_variant_unref0 (self->min);
	_g_variant_unref0 (self->max);
}


GType schema_value_range_get_type (void) {
	static volatile gsize schema_value_range_type_id__volatile = 0;
	if (g_once_init_enter (&schema_value_range_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_value_range_init, value_schema_value_range_free_value, value_schema_value_range_copy_value, value_schema_value_range_peek_pointer, "p", value_schema_value_range_collect_value, "p", value_schema_value_range_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaValueRangeClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_value_range_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaValueRange), 0, (GInstanceInitFunc) schema_value_range_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_value_range_type_id;
		schema_value_range_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaValueRange", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_value_range_type_id__volatile, schema_value_range_type_id);
	}
	return schema_value_range_type_id__volatile;
}


gpointer schema_value_range_ref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_value_range_unref (gpointer instance) {
	SchemaValueRange* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_VALUE_RANGE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


static gpointer _schema_list_ref0 (gpointer self) {
	return self ? schema_list_ref (self) : NULL;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


SchemaEnum* schema_enum_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaEnum* self = NULL;
	SchemaList* _tmp0_ = NULL;
	SchemaList* _tmp1_ = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaEnum*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp2_ = NULL;
		xmlAttr* _tmp3_ = NULL;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp7_ = NULL;
				xmlAttr* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				if (!_tmp4_) {
					xmlAttr* _tmp5_ = NULL;
					xmlAttr* _tmp6_ = NULL;
					_tmp5_ = prop;
					_tmp6_ = _tmp5_->next;
					prop = _tmp6_;
				}
				_tmp4_ = FALSE;
				_tmp7_ = prop;
				if (!(_tmp7_ != NULL)) {
					break;
				}
				_tmp8_ = prop;
				_tmp9_ = _tmp8_->name;
				if (g_strcmp0 (_tmp9_, "id") == 0) {
					xmlAttr* _tmp10_ = NULL;
					xmlNode* _tmp11_ = NULL;
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					_tmp10_ = prop;
					_tmp11_ = _tmp10_->children;
					_tmp12_ = _tmp11_->content;
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (self->id);
					self->id = _tmp13_;
				} else {
					xmlAttr* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					_tmp14_ = prop;
					_tmp15_ = _tmp14_->name;
					g_warning ("dconf-schema.vala:219: Unknown property in <enum>, %s", _tmp15_);
				}
			}
		}
	}
	{
		xmlNode* child = NULL;
		xmlNode* _tmp16_ = NULL;
		xmlNode* _tmp17_ = NULL;
		_tmp16_ = node;
		_tmp17_ = _tmp16_->children;
		child = _tmp17_;
		{
			gboolean _tmp18_ = FALSE;
			_tmp18_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp21_ = NULL;
				xmlNode* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				if (!_tmp18_) {
					xmlNode* _tmp19_ = NULL;
					xmlNode* _tmp20_ = NULL;
					_tmp19_ = child;
					_tmp20_ = _tmp19_->next;
					child = _tmp20_;
				}
				_tmp18_ = FALSE;
				_tmp21_ = child;
				if (!(_tmp21_ != NULL)) {
					break;
				}
				_tmp22_ = child;
				_tmp23_ = _tmp22_->name;
				if (g_strcmp0 (_tmp23_, "value") == 0) {
					gchar* nick = NULL;
					gint value = 0;
					SchemaValue* schema_value = NULL;
					GList* _tmp44_ = NULL;
					guint _tmp45_ = 0U;
					const gchar* _tmp46_ = NULL;
					gint _tmp47_ = 0;
					SchemaValue* _tmp48_ = NULL;
					SchemaValue* _tmp49_ = NULL;
					SchemaValue* _tmp50_ = NULL;
					nick = NULL;
					value = -1;
					{
						xmlAttr* prop = NULL;
						xmlNode* _tmp24_ = NULL;
						xmlAttr* _tmp25_ = NULL;
						_tmp24_ = child;
						_tmp25_ = _tmp24_->properties;
						prop = _tmp25_;
						{
							gboolean _tmp26_ = FALSE;
							_tmp26_ = TRUE;
							while (TRUE) {
								xmlAttr* _tmp29_ = NULL;
								xmlAttr* _tmp30_ = NULL;
								const gchar* _tmp31_ = NULL;
								if (!_tmp26_) {
									xmlAttr* _tmp27_ = NULL;
									xmlAttr* _tmp28_ = NULL;
									_tmp27_ = prop;
									_tmp28_ = _tmp27_->next;
									prop = _tmp28_;
								}
								_tmp26_ = FALSE;
								_tmp29_ = prop;
								if (!(_tmp29_ != NULL)) {
									break;
								}
								_tmp30_ = prop;
								_tmp31_ = _tmp30_->name;
								if (g_strcmp0 (_tmp31_, "value") == 0) {
									xmlAttr* _tmp32_ = NULL;
									xmlNode* _tmp33_ = NULL;
									const gchar* _tmp34_ = NULL;
									gint _tmp35_ = 0;
									_tmp32_ = prop;
									_tmp33_ = _tmp32_->children;
									_tmp34_ = _tmp33_->content;
									_tmp35_ = atoi (_tmp34_);
									value = _tmp35_;
								} else {
									xmlAttr* _tmp36_ = NULL;
									const gchar* _tmp37_ = NULL;
									_tmp36_ = prop;
									_tmp37_ = _tmp36_->name;
									if (g_strcmp0 (_tmp37_, "nick") == 0) {
										xmlAttr* _tmp38_ = NULL;
										xmlNode* _tmp39_ = NULL;
										const gchar* _tmp40_ = NULL;
										gchar* _tmp41_ = NULL;
										_tmp38_ = prop;
										_tmp39_ = _tmp38_->children;
										_tmp40_ = _tmp39_->content;
										_tmp41_ = g_strdup (_tmp40_);
										_g_free0 (nick);
										nick = _tmp41_;
									} else {
										xmlAttr* _tmp42_ = NULL;
										const gchar* _tmp43_ = NULL;
										_tmp42_ = prop;
										_tmp43_ = _tmp42_->name;
										g_warning ("dconf-schema.vala:239: Unknown property in enum <value>, %s", _tmp43_);
									}
								}
							}
						}
					}
					_tmp44_ = self->values;
					_tmp45_ = g_list_length (_tmp44_);
					_tmp46_ = nick;
					_tmp47_ = value;
					_tmp48_ = schema_value_new (_tmp45_, _tmp46_, _tmp47_);
					schema_value = _tmp48_;
					_tmp49_ = schema_value;
					_tmp50_ = _g_object_ref0 (_tmp49_);
					self->values = g_list_append (self->values, _tmp50_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp51_ = FALSE;
					xmlNode* _tmp52_ = NULL;
					xmlElementType _tmp53_ = 0;
					_tmp52_ = child;
					_tmp53_ = _tmp52_->type;
					if (_tmp53_ != XML_TEXT_NODE) {
						xmlNode* _tmp54_ = NULL;
						xmlElementType _tmp55_ = 0;
						_tmp54_ = child;
						_tmp55_ = _tmp54_->type;
						_tmp51_ = _tmp55_ != XML_COMMENT_NODE;
					} else {
						_tmp51_ = FALSE;
					}
					if (_tmp51_) {
						xmlNode* _tmp56_ = NULL;
						const gchar* _tmp57_ = NULL;
						_tmp56_ = child;
						_tmp57_ = _tmp56_->name;
						g_warning ("dconf-schema.vala:249: Unknown tag in <enum>, <%s>", _tmp57_);
					}
				}
			}
		}
	}
	return self;
}


SchemaEnum* schema_enum_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_enum_construct_from_xml (TYPE_SCHEMA_ENUM, list, node);
}


SchemaEnum* schema_enum_construct (GType object_type) {
	SchemaEnum* self = NULL;
	self = (SchemaEnum*) g_type_create_instance (object_type);
	return self;
}


SchemaEnum* schema_enum_new (void) {
	return schema_enum_construct (TYPE_SCHEMA_ENUM);
}


static void value_schema_enum_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_enum_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_enum_unref (value->data[0].v_pointer);
	}
}


static void value_schema_enum_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_enum_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_enum_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_enum_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaEnum* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_enum_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_enum_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaEnum** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_enum_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaEnum* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_ENUM), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_enum (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_enum_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


void value_take_schema_enum (GValue* value, gpointer v_object) {
	SchemaEnum* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_ENUM));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_ENUM));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_enum_unref (old);
	}
}


static void schema_enum_class_init (SchemaEnumClass * klass) {
	schema_enum_parent_class = g_type_class_peek_parent (klass);
	((SchemaEnumClass *) klass)->finalize = schema_enum_finalize;
}


static void schema_enum_instance_init (SchemaEnum * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_enum_finalize (SchemaEnum* obj) {
	SchemaEnum * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_ENUM, SchemaEnum);
	g_signal_handlers_destroy (self);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_enum_get_type (void) {
	static volatile gsize schema_enum_type_id__volatile = 0;
	if (g_once_init_enter (&schema_enum_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_enum_init, value_schema_enum_free_value, value_schema_enum_copy_value, value_schema_enum_peek_pointer, "p", value_schema_enum_collect_value, "p", value_schema_enum_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaEnumClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_enum_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaEnum), 0, (GInstanceInitFunc) schema_enum_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_enum_type_id;
		schema_enum_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaEnum", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_enum_type_id__volatile, schema_enum_type_id);
	}
	return schema_enum_type_id__volatile;
}


gpointer schema_enum_ref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_enum_unref (gpointer instance) {
	SchemaEnum* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_ENUM_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


SchemaFlags* schema_flags_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node) {
	SchemaFlags* self = NULL;
	SchemaList* _tmp0_ = NULL;
	SchemaList* _tmp1_ = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (SchemaFlags*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp2_ = NULL;
		xmlAttr* _tmp3_ = NULL;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp7_ = NULL;
				xmlAttr* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				if (!_tmp4_) {
					xmlAttr* _tmp5_ = NULL;
					xmlAttr* _tmp6_ = NULL;
					_tmp5_ = prop;
					_tmp6_ = _tmp5_->next;
					prop = _tmp6_;
				}
				_tmp4_ = FALSE;
				_tmp7_ = prop;
				if (!(_tmp7_ != NULL)) {
					break;
				}
				_tmp8_ = prop;
				_tmp9_ = _tmp8_->name;
				if (g_strcmp0 (_tmp9_, "id") == 0) {
					xmlAttr* _tmp10_ = NULL;
					xmlNode* _tmp11_ = NULL;
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					_tmp10_ = prop;
					_tmp11_ = _tmp10_->children;
					_tmp12_ = _tmp11_->content;
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (self->id);
					self->id = _tmp13_;
				} else {
					xmlAttr* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					_tmp14_ = prop;
					_tmp15_ = _tmp14_->name;
					g_warning ("dconf-schema.vala:272: Unknown property in <flags>, %s", _tmp15_);
				}
			}
		}
	}
	{
		xmlNode* child = NULL;
		xmlNode* _tmp16_ = NULL;
		xmlNode* _tmp17_ = NULL;
		_tmp16_ = node;
		_tmp17_ = _tmp16_->children;
		child = _tmp17_;
		{
			gboolean _tmp18_ = FALSE;
			_tmp18_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp21_ = NULL;
				xmlNode* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				if (!_tmp18_) {
					xmlNode* _tmp19_ = NULL;
					xmlNode* _tmp20_ = NULL;
					_tmp19_ = child;
					_tmp20_ = _tmp19_->next;
					child = _tmp20_;
				}
				_tmp18_ = FALSE;
				_tmp21_ = child;
				if (!(_tmp21_ != NULL)) {
					break;
				}
				_tmp22_ = child;
				_tmp23_ = _tmp22_->name;
				if (g_strcmp0 (_tmp23_, "value") == 0) {
					gchar* nick = NULL;
					gint value = 0;
					SchemaValue* schema_value = NULL;
					GList* _tmp44_ = NULL;
					guint _tmp45_ = 0U;
					const gchar* _tmp46_ = NULL;
					gint _tmp47_ = 0;
					SchemaValue* _tmp48_ = NULL;
					SchemaValue* _tmp49_ = NULL;
					SchemaValue* _tmp50_ = NULL;
					nick = NULL;
					value = -1;
					{
						xmlAttr* prop = NULL;
						xmlNode* _tmp24_ = NULL;
						xmlAttr* _tmp25_ = NULL;
						_tmp24_ = child;
						_tmp25_ = _tmp24_->properties;
						prop = _tmp25_;
						{
							gboolean _tmp26_ = FALSE;
							_tmp26_ = TRUE;
							while (TRUE) {
								xmlAttr* _tmp29_ = NULL;
								xmlAttr* _tmp30_ = NULL;
								const gchar* _tmp31_ = NULL;
								if (!_tmp26_) {
									xmlAttr* _tmp27_ = NULL;
									xmlAttr* _tmp28_ = NULL;
									_tmp27_ = prop;
									_tmp28_ = _tmp27_->next;
									prop = _tmp28_;
								}
								_tmp26_ = FALSE;
								_tmp29_ = prop;
								if (!(_tmp29_ != NULL)) {
									break;
								}
								_tmp30_ = prop;
								_tmp31_ = _tmp30_->name;
								if (g_strcmp0 (_tmp31_, "value") == 0) {
									xmlAttr* _tmp32_ = NULL;
									xmlNode* _tmp33_ = NULL;
									const gchar* _tmp34_ = NULL;
									gint _tmp35_ = 0;
									_tmp32_ = prop;
									_tmp33_ = _tmp32_->children;
									_tmp34_ = _tmp33_->content;
									_tmp35_ = atoi (_tmp34_);
									value = _tmp35_;
								} else {
									xmlAttr* _tmp36_ = NULL;
									const gchar* _tmp37_ = NULL;
									_tmp36_ = prop;
									_tmp37_ = _tmp36_->name;
									if (g_strcmp0 (_tmp37_, "nick") == 0) {
										xmlAttr* _tmp38_ = NULL;
										xmlNode* _tmp39_ = NULL;
										const gchar* _tmp40_ = NULL;
										gchar* _tmp41_ = NULL;
										_tmp38_ = prop;
										_tmp39_ = _tmp38_->children;
										_tmp40_ = _tmp39_->content;
										_tmp41_ = g_strdup (_tmp40_);
										_g_free0 (nick);
										nick = _tmp41_;
									} else {
										xmlAttr* _tmp42_ = NULL;
										const gchar* _tmp43_ = NULL;
										_tmp42_ = prop;
										_tmp43_ = _tmp42_->name;
										g_warning ("dconf-schema.vala:292: Unknown property in flags <value>, %s", _tmp43_);
									}
								}
							}
						}
					}
					_tmp44_ = self->values;
					_tmp45_ = g_list_length (_tmp44_);
					_tmp46_ = nick;
					_tmp47_ = value;
					_tmp48_ = schema_value_new (_tmp45_, _tmp46_, _tmp47_);
					schema_value = _tmp48_;
					_tmp49_ = schema_value;
					_tmp50_ = _g_object_ref0 (_tmp49_);
					self->values = g_list_append (self->values, _tmp50_);
					_g_object_unref0 (schema_value);
					_g_free0 (nick);
				} else {
					gboolean _tmp51_ = FALSE;
					xmlNode* _tmp52_ = NULL;
					xmlElementType _tmp53_ = 0;
					_tmp52_ = child;
					_tmp53_ = _tmp52_->type;
					if (_tmp53_ != XML_TEXT_NODE) {
						xmlNode* _tmp54_ = NULL;
						xmlElementType _tmp55_ = 0;
						_tmp54_ = child;
						_tmp55_ = _tmp54_->type;
						_tmp51_ = _tmp55_ != XML_COMMENT_NODE;
					} else {
						_tmp51_ = FALSE;
					}
					if (_tmp51_) {
						xmlNode* _tmp56_ = NULL;
						const gchar* _tmp57_ = NULL;
						_tmp56_ = child;
						_tmp57_ = _tmp56_->name;
						g_warning ("dconf-schema.vala:302: Unknown tag in <flags>, <%s>", _tmp57_);
					}
				}
			}
		}
	}
	return self;
}


SchemaFlags* schema_flags_new_from_xml (SchemaList* list, xmlNode* node) {
	return schema_flags_construct_from_xml (TYPE_SCHEMA_FLAGS, list, node);
}


SchemaFlags* schema_flags_construct (GType object_type) {
	SchemaFlags* self = NULL;
	self = (SchemaFlags*) g_type_create_instance (object_type);
	return self;
}


SchemaFlags* schema_flags_new (void) {
	return schema_flags_construct (TYPE_SCHEMA_FLAGS);
}


static void value_schema_flags_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_flags_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_flags_unref (value->data[0].v_pointer);
	}
}


static void value_schema_flags_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_flags_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_flags_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_flags_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaFlags* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_flags_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_flags_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaFlags** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_flags_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaFlags* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_FLAGS), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_flags (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_flags_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


void value_take_schema_flags (GValue* value, gpointer v_object) {
	SchemaFlags* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_FLAGS));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_FLAGS));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_flags_unref (old);
	}
}


static void schema_flags_class_init (SchemaFlagsClass * klass) {
	schema_flags_parent_class = g_type_class_peek_parent (klass);
	((SchemaFlagsClass *) klass)->finalize = schema_flags_finalize;
}


static void schema_flags_instance_init (SchemaFlags * self) {
	self->values = NULL;
	self->ref_count = 1;
}


static void schema_flags_finalize (SchemaFlags* obj) {
	SchemaFlags * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_FLAGS, SchemaFlags);
	g_signal_handlers_destroy (self);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	__g_list_free__g_object_unref0_0 (self->values);
}


GType schema_flags_get_type (void) {
	static volatile gsize schema_flags_type_id__volatile = 0;
	if (g_once_init_enter (&schema_flags_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_flags_init, value_schema_flags_free_value, value_schema_flags_copy_value, value_schema_flags_peek_pointer, "p", value_schema_flags_collect_value, "p", value_schema_flags_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaFlagsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_flags_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaFlags), 0, (GInstanceInitFunc) schema_flags_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_flags_type_id;
		schema_flags_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaFlags", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_flags_type_id__volatile, schema_flags_type_id);
	}
	return schema_flags_type_id__volatile;
}


gpointer schema_flags_ref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_flags_unref (gpointer instance) {
	SchemaFlags* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_FLAGS_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _schema_key_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_key_unref (var), NULL));
}


static gpointer _schema_key_ref0 (gpointer self) {
	return self ? schema_key_ref (self) : NULL;
}


Schema* schema_construct_from_xml (GType object_type, SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	Schema* self = NULL;
	SchemaList* _tmp0_ = NULL;
	SchemaList* _tmp1_ = NULL;
	g_return_val_if_fail (list != NULL, NULL);
	self = (Schema*) g_type_create_instance (object_type);
	_tmp0_ = list;
	_tmp1_ = _schema_list_ref0 (_tmp0_);
	_schema_list_unref0 (self->list);
	self->list = _tmp1_;
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp2_ = NULL;
		xmlAttr* _tmp3_ = NULL;
		_tmp2_ = node;
		_tmp3_ = _tmp2_->properties;
		prop = _tmp3_;
		{
			gboolean _tmp4_ = FALSE;
			_tmp4_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp7_ = NULL;
				xmlAttr* _tmp8_ = NULL;
				const gchar* _tmp9_ = NULL;
				if (!_tmp4_) {
					xmlAttr* _tmp5_ = NULL;
					xmlAttr* _tmp6_ = NULL;
					_tmp5_ = prop;
					_tmp6_ = _tmp5_->next;
					prop = _tmp6_;
				}
				_tmp4_ = FALSE;
				_tmp7_ = prop;
				if (!(_tmp7_ != NULL)) {
					break;
				}
				_tmp8_ = prop;
				_tmp9_ = _tmp8_->name;
				if (g_strcmp0 (_tmp9_, "id") == 0) {
					xmlAttr* _tmp10_ = NULL;
					xmlNode* _tmp11_ = NULL;
					const gchar* _tmp12_ = NULL;
					gchar* _tmp13_ = NULL;
					_tmp10_ = prop;
					_tmp11_ = _tmp10_->children;
					_tmp12_ = _tmp11_->content;
					_tmp13_ = g_strdup (_tmp12_);
					_g_free0 (self->id);
					self->id = _tmp13_;
				} else {
					xmlAttr* _tmp14_ = NULL;
					const gchar* _tmp15_ = NULL;
					_tmp14_ = prop;
					_tmp15_ = _tmp14_->name;
					if (g_strcmp0 (_tmp15_, "path") == 0) {
						xmlAttr* _tmp16_ = NULL;
						xmlNode* _tmp17_ = NULL;
						const gchar* _tmp18_ = NULL;
						gchar* _tmp19_ = NULL;
						_tmp16_ = prop;
						_tmp17_ = _tmp16_->children;
						_tmp18_ = _tmp17_->content;
						_tmp19_ = g_strdup (_tmp18_);
						_g_free0 (self->path);
						self->path = _tmp19_;
					} else {
						xmlAttr* _tmp20_ = NULL;
						const gchar* _tmp21_ = NULL;
						_tmp20_ = prop;
						_tmp21_ = _tmp20_->name;
						if (g_strcmp0 (_tmp21_, "gettext-domain") == 0) {
							xmlAttr* _tmp22_ = NULL;
							xmlNode* _tmp23_ = NULL;
							const gchar* _tmp24_ = NULL;
							_tmp22_ = prop;
							_tmp23_ = _tmp22_->children;
							_tmp24_ = _tmp23_->content;
							gettext_domain = _tmp24_;
						} else {
							xmlAttr* _tmp25_ = NULL;
							const gchar* _tmp26_ = NULL;
							_tmp25_ = prop;
							_tmp26_ = _tmp25_->name;
							g_warning ("dconf-schema.vala:330: Unknown property on <schema>, %s", _tmp26_);
						}
					}
				}
			}
		}
	}
	{
		xmlNode* child = NULL;
		xmlNode* _tmp27_ = NULL;
		xmlNode* _tmp28_ = NULL;
		_tmp27_ = node;
		_tmp28_ = _tmp27_->children;
		child = _tmp28_;
		{
			gboolean _tmp29_ = FALSE;
			_tmp29_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp32_ = NULL;
				xmlNode* _tmp33_ = NULL;
				const gchar* _tmp34_ = NULL;
				SchemaKey* key = NULL;
				xmlNode* _tmp35_ = NULL;
				const gchar* _tmp36_ = NULL;
				SchemaKey* _tmp37_ = NULL;
				GHashTable* _tmp38_ = NULL;
				SchemaKey* _tmp39_ = NULL;
				const gchar* _tmp40_ = NULL;
				gchar* _tmp41_ = NULL;
				SchemaKey* _tmp42_ = NULL;
				SchemaKey* _tmp43_ = NULL;
				if (!_tmp29_) {
					xmlNode* _tmp30_ = NULL;
					xmlNode* _tmp31_ = NULL;
					_tmp30_ = child;
					_tmp31_ = _tmp30_->next;
					child = _tmp31_;
				}
				_tmp29_ = FALSE;
				_tmp32_ = child;
				if (!(_tmp32_ != NULL)) {
					break;
				}
				_tmp33_ = child;
				_tmp34_ = _tmp33_->name;
				if (g_strcmp0 (_tmp34_, "key") != 0) {
					continue;
				}
				_tmp35_ = child;
				_tmp36_ = gettext_domain;
				_tmp37_ = schema_key_new_from_xml (_tmp35_, self, _tmp36_);
				key = _tmp37_;
				_tmp38_ = self->keys;
				_tmp39_ = key;
				_tmp40_ = _tmp39_->name;
				_tmp41_ = g_strdup (_tmp40_);
				_tmp42_ = key;
				_tmp43_ = _schema_key_ref0 (_tmp42_);
				g_hash_table_insert (_tmp38_, _tmp41_, _tmp43_);
				_schema_key_unref0 (key);
			}
		}
	}
	return self;
}


Schema* schema_new_from_xml (SchemaList* list, xmlNode* node, const gchar* gettext_domain) {
	return schema_construct_from_xml (TYPE_SCHEMA, list, node, gettext_domain);
}


Schema* schema_construct (GType object_type) {
	Schema* self = NULL;
	self = (Schema*) g_type_create_instance (object_type);
	return self;
}


Schema* schema_new (void) {
	return schema_construct (TYPE_SCHEMA);
}


static void value_schema_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_unref (value->data[0].v_pointer);
	}
}


static void value_schema_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		Schema* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	Schema** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchema* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


void value_take_schema (GValue* value, gpointer v_object) {
	Schema* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_unref (old);
	}
}


static void schema_class_init (SchemaClass * klass) {
	schema_parent_class = g_type_class_peek_parent (klass);
	((SchemaClass *) klass)->finalize = schema_finalize;
}


static void schema_instance_init (Schema * self) {
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp2_;
	self->ref_count = 1;
}


static void schema_finalize (Schema* obj) {
	Schema * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA, Schema);
	g_signal_handlers_destroy (self);
	_schema_list_unref0 (self->list);
	_g_free0 (self->id);
	_g_free0 (self->path);
	_g_hash_table_unref0 (self->keys);
}


GType schema_get_type (void) {
	static volatile gsize schema_type_id__volatile = 0;
	if (g_once_init_enter (&schema_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_init, value_schema_free_value, value_schema_copy_value, value_schema_peek_pointer, "p", value_schema_collect_value, "p", value_schema_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Schema), 0, (GInstanceInitFunc) schema_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_type_id;
		schema_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Schema", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_type_id__volatile, schema_type_id);
	}
	return schema_type_id__volatile;
}


gpointer schema_ref (gpointer instance) {
	Schema* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_unref (gpointer instance) {
	Schema* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _schema_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_unref (var), NULL));
}


static void _schema_enum_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL));
}


static void _schema_flags_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (schema_flags_unref (var), NULL));
}


static gpointer _schema_enum_ref0 (gpointer self) {
	return self ? schema_enum_ref (self) : NULL;
}


static gpointer _schema_flags_ref0 (gpointer self) {
	return self ? schema_flags_ref (self) : NULL;
}


void schema_list_parse_file (SchemaList* self, const gchar* path) {
	xmlDoc* doc = NULL;
	const gchar* _tmp0_ = NULL;
	xmlDoc* _tmp1_ = NULL;
	xmlDoc* _tmp2_ = NULL;
	xmlNode* root = NULL;
	xmlDoc* _tmp3_ = NULL;
	xmlNode* _tmp4_ = NULL;
	xmlNode* _tmp5_ = NULL;
	xmlNode* _tmp6_ = NULL;
	const gchar* _tmp7_ = NULL;
	gchar* gettext_domain = NULL;
	xmlDoc* _tmp78_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = xmlParseFile (_tmp0_);
	doc = _tmp1_;
	_tmp2_ = doc;
	if (_tmp2_ == NULL) {
		return;
	}
	_tmp3_ = doc;
	_tmp4_ = xmlDocGetRootElement (_tmp3_);
	root = _tmp4_;
	_tmp5_ = root;
	if (_tmp5_ == NULL) {
		return;
	}
	_tmp6_ = root;
	_tmp7_ = _tmp6_->name;
	if (g_strcmp0 (_tmp7_, "schemalist") != 0) {
		return;
	}
	gettext_domain = NULL;
	{
		xmlAttr* prop = NULL;
		xmlNode* _tmp8_ = NULL;
		xmlAttr* _tmp9_ = NULL;
		_tmp8_ = root;
		_tmp9_ = _tmp8_->properties;
		prop = _tmp9_;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				xmlAttr* _tmp13_ = NULL;
				xmlAttr* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				if (!_tmp10_) {
					xmlAttr* _tmp11_ = NULL;
					xmlAttr* _tmp12_ = NULL;
					_tmp11_ = prop;
					_tmp12_ = _tmp11_->next;
					prop = _tmp12_;
				}
				_tmp10_ = FALSE;
				_tmp13_ = prop;
				if (!(_tmp13_ != NULL)) {
					break;
				}
				_tmp14_ = prop;
				_tmp15_ = _tmp14_->name;
				if (g_strcmp0 (_tmp15_, "gettext-domain") == 0) {
					xmlAttr* _tmp16_ = NULL;
					xmlNode* _tmp17_ = NULL;
					const gchar* _tmp18_ = NULL;
					gchar* _tmp19_ = NULL;
					_tmp16_ = prop;
					_tmp17_ = _tmp16_->children;
					_tmp18_ = _tmp17_->content;
					_tmp19_ = g_strdup (_tmp18_);
					_g_free0 (gettext_domain);
					gettext_domain = _tmp19_;
				}
			}
		}
	}
	{
		xmlNode* node = NULL;
		xmlNode* _tmp20_ = NULL;
		xmlNode* _tmp21_ = NULL;
		_tmp20_ = root;
		_tmp21_ = _tmp20_->children;
		node = _tmp21_;
		{
			gboolean _tmp22_ = FALSE;
			_tmp22_ = TRUE;
			while (TRUE) {
				xmlNode* _tmp25_ = NULL;
				xmlNode* _tmp26_ = NULL;
				const gchar* _tmp27_ = NULL;
				if (!_tmp22_) {
					xmlNode* _tmp23_ = NULL;
					xmlNode* _tmp24_ = NULL;
					_tmp23_ = node;
					_tmp24_ = _tmp23_->next;
					node = _tmp24_;
				}
				_tmp22_ = FALSE;
				_tmp25_ = node;
				if (!(_tmp25_ != NULL)) {
					break;
				}
				_tmp26_ = node;
				_tmp27_ = _tmp26_->name;
				if (g_strcmp0 (_tmp27_, "schema") == 0) {
					Schema* schema = NULL;
					xmlNode* _tmp28_ = NULL;
					const gchar* _tmp29_ = NULL;
					Schema* _tmp30_ = NULL;
					Schema* _tmp31_ = NULL;
					const gchar* _tmp32_ = NULL;
					Schema* _tmp33_ = NULL;
					GHashTable* _tmp34_ = NULL;
					GList* _tmp35_ = NULL;
					GHashTable* _tmp46_ = NULL;
					Schema* _tmp47_ = NULL;
					const gchar* _tmp48_ = NULL;
					gchar* _tmp49_ = NULL;
					Schema* _tmp50_ = NULL;
					Schema* _tmp51_ = NULL;
					_tmp28_ = node;
					_tmp29_ = gettext_domain;
					_tmp30_ = schema_new_from_xml (self, _tmp28_, _tmp29_);
					schema = _tmp30_;
					_tmp31_ = schema;
					_tmp32_ = _tmp31_->path;
					if (_tmp32_ == NULL) {
						_schema_unref0 (schema);
						continue;
					}
					_tmp33_ = schema;
					_tmp34_ = _tmp33_->keys;
					_tmp35_ = g_hash_table_get_values (_tmp34_);
					{
						GList* key_collection = NULL;
						GList* key_it = NULL;
						key_collection = _tmp35_;
						for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
							SchemaKey* key = NULL;
							key = (SchemaKey*) key_it->data;
							{
								gchar* full_name = NULL;
								Schema* _tmp36_ = NULL;
								const gchar* _tmp37_ = NULL;
								SchemaKey* _tmp38_ = NULL;
								const gchar* _tmp39_ = NULL;
								gchar* _tmp40_ = NULL;
								GHashTable* _tmp41_ = NULL;
								const gchar* _tmp42_ = NULL;
								gchar* _tmp43_ = NULL;
								SchemaKey* _tmp44_ = NULL;
								SchemaKey* _tmp45_ = NULL;
								_tmp36_ = schema;
								_tmp37_ = _tmp36_->path;
								_tmp38_ = key;
								_tmp39_ = _tmp38_->name;
								_tmp40_ = g_strconcat (_tmp37_, _tmp39_, NULL);
								full_name = _tmp40_;
								_tmp41_ = self->keys;
								_tmp42_ = full_name;
								_tmp43_ = g_strdup (_tmp42_);
								_tmp44_ = key;
								_tmp45_ = _schema_key_ref0 (_tmp44_);
								g_hash_table_insert (_tmp41_, _tmp43_, _tmp45_);
								_g_free0 (full_name);
							}
						}
						_g_list_free0 (key_collection);
					}
					_tmp46_ = self->schemas;
					_tmp47_ = schema;
					_tmp48_ = _tmp47_->id;
					_tmp49_ = g_strdup (_tmp48_);
					_tmp50_ = schema;
					_tmp51_ = _schema_ref0 (_tmp50_);
					g_hash_table_insert (_tmp46_, _tmp49_, _tmp51_);
					_schema_unref0 (schema);
				} else {
					xmlNode* _tmp52_ = NULL;
					const gchar* _tmp53_ = NULL;
					_tmp52_ = node;
					_tmp53_ = _tmp52_->name;
					if (g_strcmp0 (_tmp53_, "enum") == 0) {
						SchemaEnum* _enum_ = NULL;
						xmlNode* _tmp54_ = NULL;
						SchemaEnum* _tmp55_ = NULL;
						GHashTable* _tmp56_ = NULL;
						SchemaEnum* _tmp57_ = NULL;
						const gchar* _tmp58_ = NULL;
						gchar* _tmp59_ = NULL;
						SchemaEnum* _tmp60_ = NULL;
						SchemaEnum* _tmp61_ = NULL;
						_tmp54_ = node;
						_tmp55_ = schema_enum_new_from_xml (self, _tmp54_);
						_enum_ = _tmp55_;
						_tmp56_ = self->enums;
						_tmp57_ = _enum_;
						_tmp58_ = _tmp57_->id;
						_tmp59_ = g_strdup (_tmp58_);
						_tmp60_ = _enum_;
						_tmp61_ = _schema_enum_ref0 (_tmp60_);
						g_hash_table_insert (_tmp56_, _tmp59_, _tmp61_);
						_schema_enum_unref0 (_enum_);
					} else {
						xmlNode* _tmp62_ = NULL;
						const gchar* _tmp63_ = NULL;
						_tmp62_ = node;
						_tmp63_ = _tmp62_->name;
						if (g_strcmp0 (_tmp63_, "flags") == 0) {
							SchemaFlags* f = NULL;
							xmlNode* _tmp64_ = NULL;
							SchemaFlags* _tmp65_ = NULL;
							GHashTable* _tmp66_ = NULL;
							SchemaFlags* _tmp67_ = NULL;
							const gchar* _tmp68_ = NULL;
							gchar* _tmp69_ = NULL;
							SchemaFlags* _tmp70_ = NULL;
							SchemaFlags* _tmp71_ = NULL;
							_tmp64_ = node;
							_tmp65_ = schema_flags_new_from_xml (self, _tmp64_);
							f = _tmp65_;
							_tmp66_ = self->flags;
							_tmp67_ = f;
							_tmp68_ = _tmp67_->id;
							_tmp69_ = g_strdup (_tmp68_);
							_tmp70_ = f;
							_tmp71_ = _schema_flags_ref0 (_tmp70_);
							g_hash_table_insert (_tmp66_, _tmp69_, _tmp71_);
							_schema_flags_unref0 (f);
						} else {
							xmlNode* _tmp72_ = NULL;
							xmlElementType _tmp73_ = 0;
							_tmp72_ = node;
							_tmp73_ = _tmp72_->type;
							if (_tmp73_ == XML_COMMENT_NODE) {
							} else {
								xmlNode* _tmp74_ = NULL;
								xmlElementType _tmp75_ = 0;
								_tmp74_ = node;
								_tmp75_ = _tmp74_->type;
								if (_tmp75_ != XML_TEXT_NODE) {
									xmlNode* _tmp76_ = NULL;
									const gchar* _tmp77_ = NULL;
									_tmp76_ = node;
									_tmp77_ = _tmp76_->name;
									g_warning ("dconf-schema.vala:404: Unknown tag <%s>", _tmp77_);
								}
							}
						}
					}
				}
			}
		}
	}
	_tmp78_ = doc;
	xmlFreeDoc (_tmp78_);
	_g_free0 (gettext_domain);
}


void schema_list_parse_override (SchemaList* self, const gchar* path) {
	GKeyFile* keyfile = NULL;
	GKeyFile* _tmp0_ = NULL;
	GKeyFile* _tmp6_ = NULL;
	gsize _tmp7_;
	gchar** _tmp8_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = g_key_file_new ();
	keyfile = _tmp0_;
	{
		GKeyFile* _tmp1_ = NULL;
		const gchar* _tmp2_ = NULL;
		_tmp1_ = keyfile;
		_tmp2_ = path;
		g_key_file_load_from_file (_tmp1_, _tmp2_, G_KEY_FILE_NONE, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch8_g_error;
		}
	}
	goto __finally8;
	__catch8_g_error:
	{
		GError* e = NULL;
		const gchar* _tmp3_ = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp3_ = path;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_warning ("dconf-schema.vala:419: Failed to load override file %s: %s", _tmp3_, _tmp5_);
		_g_error_free0 (e);
		_g_key_file_free0 (keyfile);
		return;
	}
	__finally8:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		_g_key_file_free0 (keyfile);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_tmp6_ = keyfile;
	_tmp8_ = g_key_file_get_groups (_tmp6_, &_tmp7_);
	{
		gchar** group_collection = NULL;
		gint group_collection_length1 = 0;
		gint _group_collection_size_ = 0;
		gint group_it = 0;
		group_collection = _tmp8_;
		group_collection_length1 = _tmp7_;
		for (group_it = 0; group_it < _tmp7_; group_it = group_it + 1) {
			gchar* _tmp9_ = NULL;
			gchar* group = NULL;
			_tmp9_ = g_strdup (group_collection[group_it]);
			group = _tmp9_;
			{
				Schema* schema = NULL;
				GHashTable* _tmp10_ = NULL;
				const gchar* _tmp11_ = NULL;
				gconstpointer _tmp12_ = NULL;
				Schema* _tmp13_ = NULL;
				Schema* _tmp14_ = NULL;
				gchar** keys = NULL;
				gint keys_length1 = 0;
				gint _keys_size_ = 0;
				gchar** _tmp21_ = NULL;
				gint _tmp21__length1 = 0;
				_tmp10_ = self->schemas;
				_tmp11_ = group;
				_tmp12_ = g_hash_table_lookup (_tmp10_, _tmp11_);
				_tmp13_ = _schema_ref0 ((Schema*) _tmp12_);
				schema = _tmp13_;
				_tmp14_ = schema;
				if (_tmp14_ == NULL) {
					_schema_unref0 (schema);
					_g_free0 (group);
					continue;
				}
				{
					gchar** _tmp15_ = NULL;
					GKeyFile* _tmp16_ = NULL;
					const gchar* _tmp17_ = NULL;
					gsize _tmp18_;
					gchar** _tmp19_ = NULL;
					gint _tmp15__length1 = 0;
					gint __tmp15__size_ = 0;
					gchar** _tmp20_ = NULL;
					gint _tmp20__length1 = 0;
					_tmp16_ = keyfile;
					_tmp17_ = group;
					_tmp19_ = g_key_file_get_keys (_tmp16_, _tmp17_, &_tmp18_, &_inner_error_);
					_tmp15_ = _tmp19_;
					_tmp15__length1 = _tmp18_;
					__tmp15__size_ = _tmp15__length1;
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						goto __catch9_g_error;
					}
					_tmp20_ = _tmp15_;
					_tmp20__length1 = _tmp15__length1;
					_tmp15_ = NULL;
					_tmp15__length1 = 0;
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					keys = _tmp20_;
					keys_length1 = _tmp20__length1;
					_keys_size_ = keys_length1;
					_tmp15_ = (_vala_array_free (_tmp15_, _tmp15__length1, (GDestroyNotify) g_free), NULL);
				}
				goto __finally9;
				__catch9_g_error:
				{
					GError* e = NULL;
					e = _inner_error_;
					_inner_error_ = NULL;
					_g_error_free0 (e);
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					_schema_unref0 (schema);
					_g_free0 (group);
					continue;
				}
				__finally9:
				if (G_UNLIKELY (_inner_error_ != NULL)) {
					keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
					_schema_unref0 (schema);
					_g_free0 (group);
					group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
					_g_key_file_free0 (keyfile);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				_tmp21_ = keys;
				_tmp21__length1 = keys_length1;
				{
					gchar** key_name_collection = NULL;
					gint key_name_collection_length1 = 0;
					gint _key_name_collection_size_ = 0;
					gint key_name_it = 0;
					key_name_collection = _tmp21_;
					key_name_collection_length1 = _tmp21__length1;
					for (key_name_it = 0; key_name_it < _tmp21__length1; key_name_it = key_name_it + 1) {
						gchar* _tmp22_ = NULL;
						gchar* key_name = NULL;
						_tmp22_ = g_strdup (key_name_collection[key_name_it]);
						key_name = _tmp22_;
						{
							gchar* value = NULL;
							SchemaKey* key = NULL;
							Schema* _tmp29_ = NULL;
							GHashTable* _tmp30_ = NULL;
							const gchar* _tmp31_ = NULL;
							gconstpointer _tmp32_ = NULL;
							SchemaKey* _tmp33_ = NULL;
							SchemaKey* _tmp34_ = NULL;
							GVariant* default_value = NULL;
							SchemaKey* _tmp44_ = NULL;
							GVariant* _tmp45_ = NULL;
							GVariant* _tmp46_ = NULL;
							{
								gchar* _tmp23_ = NULL;
								GKeyFile* _tmp24_ = NULL;
								const gchar* _tmp25_ = NULL;
								const gchar* _tmp26_ = NULL;
								gchar* _tmp27_ = NULL;
								gchar* _tmp28_ = NULL;
								_tmp24_ = keyfile;
								_tmp25_ = group;
								_tmp26_ = key_name;
								_tmp27_ = g_key_file_get_value (_tmp24_, _tmp25_, _tmp26_, &_inner_error_);
								_tmp23_ = _tmp27_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									goto __catch10_g_error;
								}
								_tmp28_ = _tmp23_;
								_tmp23_ = NULL;
								_g_free0 (value);
								value = _tmp28_;
								_g_free0 (_tmp23_);
							}
							goto __finally10;
							__catch10_g_error:
							{
								GError* e = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_g_error_free0 (e);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							__finally10:
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								_g_free0 (value);
								_g_free0 (key_name);
								keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
								_schema_unref0 (schema);
								_g_free0 (group);
								group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
								_g_key_file_free0 (keyfile);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp29_ = schema;
							_tmp30_ = _tmp29_->keys;
							_tmp31_ = key_name;
							_tmp32_ = g_hash_table_lookup (_tmp30_, _tmp31_);
							_tmp33_ = _schema_key_ref0 ((SchemaKey*) _tmp32_);
							key = _tmp33_;
							_tmp34_ = key;
							if (_tmp34_ == NULL) {
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							{
								GVariant* _tmp35_ = NULL;
								SchemaKey* _tmp36_ = NULL;
								const gchar* _tmp37_ = NULL;
								GVariantType* _tmp38_ = NULL;
								GVariantType* _tmp39_ = NULL;
								const gchar* _tmp40_ = NULL;
								GVariant* _tmp41_ = NULL;
								GVariant* _tmp42_ = NULL;
								GVariant* _tmp43_ = NULL;
								_tmp36_ = key;
								_tmp37_ = _tmp36_->type;
								_tmp38_ = g_variant_type_new (_tmp37_);
								_tmp39_ = _tmp38_;
								_tmp40_ = value;
								_tmp41_ = g_variant_parse (_tmp39_, _tmp40_, NULL, NULL, &_inner_error_);
								_tmp42_ = _tmp41_;
								_g_variant_type_free0 (_tmp39_);
								_tmp35_ = _tmp42_;
								if (G_UNLIKELY (_inner_error_ != NULL)) {
									if (_inner_error_->domain == G_VARIANT_PARSE_ERROR) {
										goto __catch11_g_variant_parse_error;
									}
									_g_variant_unref0 (default_value);
									_schema_key_unref0 (key);
									_g_free0 (value);
									_g_free0 (key_name);
									keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
									_schema_unref0 (schema);
									_g_free0 (group);
									group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
									_g_key_file_free0 (keyfile);
									g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return;
								}
								_tmp43_ = _tmp35_;
								_tmp35_ = NULL;
								_g_variant_unref0 (default_value);
								default_value = _tmp43_;
								_g_variant_unref0 (_tmp35_);
							}
							goto __finally11;
							__catch11_g_variant_parse_error:
							{
								GError* e = NULL;
								e = _inner_error_;
								_inner_error_ = NULL;
								_g_error_free0 (e);
								_g_variant_unref0 (default_value);
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								continue;
							}
							__finally11:
							if (G_UNLIKELY (_inner_error_ != NULL)) {
								_g_variant_unref0 (default_value);
								_schema_key_unref0 (key);
								_g_free0 (value);
								_g_free0 (key_name);
								keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
								_schema_unref0 (schema);
								_g_free0 (group);
								group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
								_g_key_file_free0 (keyfile);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
							_tmp44_ = key;
							_tmp45_ = default_value;
							_tmp46_ = _g_variant_ref0 (_tmp45_);
							_g_variant_unref0 (_tmp44_->default_value);
							_tmp44_->default_value = _tmp46_;
							_g_variant_unref0 (default_value);
							_schema_key_unref0 (key);
							_g_free0 (value);
							_g_free0 (key_name);
						}
					}
				}
				keys = (_vala_array_free (keys, keys_length1, (GDestroyNotify) g_free), NULL);
				_schema_unref0 (schema);
				_g_free0 (group);
			}
		}
		group_collection = (_vala_array_free (group_collection, group_collection_length1, (GDestroyNotify) g_free), NULL);
	}
	_g_key_file_free0 (keyfile);
}


void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error) {
	GFile* directory = NULL;
	const gchar* _tmp0_ = NULL;
	GFile* _tmp1_ = NULL;
	GFileEnumerator* i = NULL;
	GFile* _tmp2_ = NULL;
	GFileEnumerator* _tmp3_ = NULL;
	GFileEnumerator* _tmp19_ = NULL;
	GFile* _tmp20_ = NULL;
	GFileEnumerator* _tmp21_ = NULL;
	GFileEnumerator* _tmp22_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (dir != NULL);
	_tmp0_ = dir;
	_tmp1_ = g_file_new_for_path (_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = g_file_enumerate_children (_tmp2_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	i = _tmp3_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (directory);
		return;
	}
	while (TRUE) {
		GFileInfo* info = NULL;
		GFileEnumerator* _tmp4_ = NULL;
		GFileInfo* _tmp5_ = NULL;
		GFileInfo* _tmp6_ = NULL;
		gchar* name = NULL;
		GFileInfo* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gboolean _tmp10_ = FALSE;
		const gchar* _tmp11_ = NULL;
		gboolean _tmp12_ = FALSE;
		_tmp4_ = i;
		_tmp5_ = g_file_enumerator_next_file (_tmp4_, NULL, &_inner_error_);
		info = _tmp5_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (i);
			_g_object_unref0 (directory);
			return;
		}
		_tmp6_ = info;
		if (_tmp6_ == NULL) {
			_g_object_unref0 (info);
			break;
		}
		_tmp7_ = info;
		_tmp8_ = g_file_info_get_name (_tmp7_);
		_tmp9_ = g_strdup (_tmp8_);
		name = _tmp9_;
		_tmp11_ = name;
		_tmp12_ = g_str_has_suffix (_tmp11_, ".gschema.xml");
		if (_tmp12_) {
			_tmp10_ = TRUE;
		} else {
			const gchar* _tmp13_ = NULL;
			gboolean _tmp14_ = FALSE;
			_tmp13_ = name;
			_tmp14_ = g_str_has_suffix (_tmp13_, ".enums.xml");
			_tmp10_ = _tmp14_;
		}
		if (_tmp10_) {
			const gchar* _tmp15_ = NULL;
			const gchar* _tmp16_ = NULL;
			gchar* _tmp17_ = NULL;
			gchar* _tmp18_ = NULL;
			_tmp15_ = dir;
			_tmp16_ = name;
			_tmp17_ = g_build_filename (_tmp15_, _tmp16_, NULL, NULL);
			_tmp18_ = _tmp17_;
			schema_list_parse_file (self, _tmp18_);
			_g_free0 (_tmp18_);
		}
		_g_free0 (name);
		_g_object_unref0 (info);
	}
	_tmp20_ = directory;
	_tmp21_ = g_file_enumerate_children (_tmp20_, G_FILE_ATTRIBUTE_STANDARD_NAME, 0, NULL, &_inner_error_);
	_tmp19_ = _tmp21_;
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_propagate_error (error, _inner_error_);
		_g_object_unref0 (i);
		_g_object_unref0 (directory);
		return;
	}
	_tmp22_ = _tmp19_;
	_tmp19_ = NULL;
	_g_object_unref0 (i);
	i = _tmp22_;
	while (TRUE) {
		GFileInfo* info = NULL;
		GFileEnumerator* _tmp23_ = NULL;
		GFileInfo* _tmp24_ = NULL;
		GFileInfo* _tmp25_ = NULL;
		gchar* name = NULL;
		GFileInfo* _tmp26_ = NULL;
		const gchar* _tmp27_ = NULL;
		gchar* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		gboolean _tmp30_ = FALSE;
		_tmp23_ = i;
		_tmp24_ = g_file_enumerator_next_file (_tmp23_, NULL, &_inner_error_);
		info = _tmp24_;
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			g_propagate_error (error, _inner_error_);
			_g_object_unref0 (_tmp19_);
			_g_object_unref0 (i);
			_g_object_unref0 (directory);
			return;
		}
		_tmp25_ = info;
		if (_tmp25_ == NULL) {
			_g_object_unref0 (info);
			break;
		}
		_tmp26_ = info;
		_tmp27_ = g_file_info_get_name (_tmp26_);
		_tmp28_ = g_strdup (_tmp27_);
		name = _tmp28_;
		_tmp29_ = name;
		_tmp30_ = g_str_has_suffix (_tmp29_, ".override");
		if (_tmp30_) {
			const gchar* _tmp31_ = NULL;
			const gchar* _tmp32_ = NULL;
			gchar* _tmp33_ = NULL;
			gchar* _tmp34_ = NULL;
			_tmp31_ = dir;
			_tmp32_ = name;
			_tmp33_ = g_build_filename (_tmp31_, _tmp32_, NULL, NULL);
			_tmp34_ = _tmp33_;
			schema_list_parse_override (self, _tmp34_);
			_g_free0 (_tmp34_);
		}
		_g_free0 (name);
		_g_object_unref0 (info);
	}
	_g_object_unref0 (_tmp19_);
	_g_object_unref0 (i);
	_g_object_unref0 (directory);
}


SchemaList* schema_list_construct (GType object_type) {
	SchemaList* self = NULL;
	self = (SchemaList*) g_type_create_instance (object_type);
	return self;
}


SchemaList* schema_list_new (void) {
	return schema_list_construct (TYPE_SCHEMA_LIST);
}


static void value_schema_list_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void value_schema_list_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		schema_list_unref (value->data[0].v_pointer);
	}
}


static void value_schema_list_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = schema_list_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer value_schema_list_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* value_schema_list_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		SchemaList* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = schema_list_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* value_schema_list_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	SchemaList** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = schema_list_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ParamSpecSchemaList* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_SCHEMA_LIST), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer value_get_schema_list (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST), NULL);
	return value->data[0].v_pointer;
}


void value_set_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		schema_list_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


void value_take_schema_list (GValue* value, gpointer v_object) {
	SchemaList* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_SCHEMA_LIST));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_SCHEMA_LIST));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		schema_list_unref (old);
	}
}


static void schema_list_class_init (SchemaListClass * klass) {
	schema_list_parent_class = g_type_class_peek_parent (klass);
	((SchemaListClass *) klass)->finalize = schema_list_finalize;
}


static void schema_list_instance_init (SchemaList * self) {
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	GHashFunc _tmp3_ = NULL;
	GEqualFunc _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	GHashFunc _tmp6_ = NULL;
	GEqualFunc _tmp7_ = NULL;
	GHashTable* _tmp8_ = NULL;
	GHashFunc _tmp9_ = NULL;
	GEqualFunc _tmp10_ = NULL;
	GHashTable* _tmp11_ = NULL;
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _schema_unref0_);
	self->schemas = _tmp2_;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _schema_key_unref0_);
	self->keys = _tmp5_;
	_tmp6_ = g_str_hash;
	_tmp7_ = g_str_equal;
	_tmp8_ = g_hash_table_new_full (_tmp6_, _tmp7_, _g_free0_, _schema_enum_unref0_);
	self->enums = _tmp8_;
	_tmp9_ = g_str_hash;
	_tmp10_ = g_str_equal;
	_tmp11_ = g_hash_table_new_full (_tmp9_, _tmp10_, _g_free0_, _schema_flags_unref0_);
	self->flags = _tmp11_;
	self->ref_count = 1;
}


static void schema_list_finalize (SchemaList* obj) {
	SchemaList * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SCHEMA_LIST, SchemaList);
	g_signal_handlers_destroy (self);
	_g_hash_table_unref0 (self->schemas);
	_g_hash_table_unref0 (self->keys);
	_g_hash_table_unref0 (self->enums);
	_g_hash_table_unref0 (self->flags);
}


GType schema_list_get_type (void) {
	static volatile gsize schema_list_type_id__volatile = 0;
	if (g_once_init_enter (&schema_list_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { value_schema_list_init, value_schema_list_free_value, value_schema_list_copy_value, value_schema_list_peek_pointer, "p", value_schema_list_collect_value, "p", value_schema_list_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (SchemaListClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) schema_list_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SchemaList), 0, (GInstanceInitFunc) schema_list_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType schema_list_type_id;
		schema_list_type_id = g_type_register_fundamental (g_type_fundamental_next (), "SchemaList", &g_define_type_info, &g_define_type_fundamental_info, 0);
		g_once_init_leave (&schema_list_type_id__volatile, schema_list_type_id);
	}
	return schema_list_type_id__volatile;
}


gpointer schema_list_ref (gpointer instance) {
	SchemaList* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void schema_list_unref (gpointer instance) {
	SchemaList* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		SCHEMA_LIST_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



