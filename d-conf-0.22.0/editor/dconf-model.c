/* dconf-model.c generated by valac 0.25.3, the Vala compiler
 * generated from dconf-model.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <float.h>
#include <math.h>
#include <gtk/gtk.h>
#include <dconf.h>
#include <pango/pango.h>
#include <gio/gio.h>


#define TYPE_KEY (key_get_type ())
#define KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY, Key))
#define KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY, KeyClass))
#define IS_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY))
#define IS_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY))
#define KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY, KeyClass))

typedef struct _Key Key;
typedef struct _KeyClass KeyClass;
typedef struct _KeyPrivate KeyPrivate;

#define TYPE_DIRECTORY (directory_get_type ())
#define DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DIRECTORY, Directory))
#define DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DIRECTORY, DirectoryClass))
#define IS_DIRECTORY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DIRECTORY))
#define IS_DIRECTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DIRECTORY))
#define DIRECTORY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DIRECTORY, DirectoryClass))

typedef struct _Directory Directory;
typedef struct _DirectoryClass DirectoryClass;

#define TYPE_SCHEMA_KEY (schema_key_get_type ())
#define SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_KEY, SchemaKey))
#define SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_KEY, SchemaKeyClass))
#define IS_SCHEMA_KEY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_KEY))
#define IS_SCHEMA_KEY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_KEY))
#define SCHEMA_KEY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_KEY, SchemaKeyClass))

typedef struct _SchemaKey SchemaKey;
typedef struct _SchemaKeyClass SchemaKeyClass;

#define TYPE_SETTINGS_MODEL (settings_model_get_type ())
#define SETTINGS_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SETTINGS_MODEL, SettingsModel))
#define SETTINGS_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SETTINGS_MODEL, SettingsModelClass))
#define IS_SETTINGS_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SETTINGS_MODEL))
#define IS_SETTINGS_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SETTINGS_MODEL))
#define SETTINGS_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SETTINGS_MODEL, SettingsModelClass))

typedef struct _SettingsModel SettingsModel;
typedef struct _SettingsModelClass SettingsModelClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _schema_key_unref0(var) ((var == NULL) ? NULL : (var = (schema_key_unref (var), NULL)))
#define _g_variant_unref0(var) ((var == NULL) ? NULL : (var = (g_variant_unref (var), NULL)))
typedef struct _SettingsModelPrivate SettingsModelPrivate;

#define TYPE_SCHEMA_LIST (schema_list_get_type ())
#define SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_LIST, SchemaList))
#define SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_LIST, SchemaListClass))
#define IS_SCHEMA_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_LIST))
#define IS_SCHEMA_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_LIST))
#define SCHEMA_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_LIST, SchemaListClass))

typedef struct _SchemaList SchemaList;
typedef struct _SchemaListClass SchemaListClass;
typedef struct _SchemaListPrivate SchemaListPrivate;

#define TYPE_SCHEMA (schema_get_type ())
#define SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA, Schema))
#define SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA, SchemaClass))
#define IS_SCHEMA(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA))
#define IS_SCHEMA_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA))
#define SCHEMA_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA, SchemaClass))

typedef struct _Schema Schema;
typedef struct _SchemaClass SchemaClass;

#define TYPE_SCHEMA_ENUM (schema_enum_get_type ())
#define SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_ENUM, SchemaEnum))
#define SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_ENUM, SchemaEnumClass))
#define IS_SCHEMA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_ENUM))
#define IS_SCHEMA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_ENUM))
#define SCHEMA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_ENUM, SchemaEnumClass))

typedef struct _SchemaEnum SchemaEnum;
typedef struct _SchemaEnumClass SchemaEnumClass;

#define TYPE_SCHEMA_FLAGS (schema_flags_get_type ())
#define SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_FLAGS, SchemaFlags))
#define SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))
#define IS_SCHEMA_FLAGS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_FLAGS))
#define IS_SCHEMA_FLAGS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_FLAGS))
#define SCHEMA_FLAGS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_FLAGS, SchemaFlagsClass))

typedef struct _SchemaFlags SchemaFlags;
typedef struct _SchemaFlagsClass SchemaFlagsClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _SchemaKeyPrivate SchemaKeyPrivate;

#define TYPE_SCHEMA_VALUE_RANGE (schema_value_range_get_type ())
#define SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRange))
#define SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))
#define IS_SCHEMA_VALUE_RANGE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE_RANGE))
#define IS_SCHEMA_VALUE_RANGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE_RANGE))
#define SCHEMA_VALUE_RANGE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE_RANGE, SchemaValueRangeClass))

typedef struct _SchemaValueRange SchemaValueRange;
typedef struct _SchemaValueRangeClass SchemaValueRangeClass;

#define TYPE_SCHEMA_CHOICE (schema_choice_get_type ())
#define SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_CHOICE, SchemaChoice))
#define SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))
#define IS_SCHEMA_CHOICE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_CHOICE))
#define IS_SCHEMA_CHOICE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_CHOICE))
#define SCHEMA_CHOICE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_CHOICE, SchemaChoiceClass))

typedef struct _SchemaChoice SchemaChoice;
typedef struct _SchemaChoiceClass SchemaChoiceClass;
typedef struct _DirectoryPrivate DirectoryPrivate;

#define TYPE_KEY_MODEL (key_model_get_type ())
#define KEY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_KEY_MODEL, KeyModel))
#define KEY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_KEY_MODEL, KeyModelClass))
#define IS_KEY_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_KEY_MODEL))
#define IS_KEY_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_KEY_MODEL))
#define KEY_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_KEY_MODEL, KeyModelClass))

typedef struct _KeyModel KeyModel;
typedef struct _KeyModelClass KeyModelClass;
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _SchemaPrivate SchemaPrivate;
#define _g_list_free0(var) ((var == NULL) ? NULL : (var = (g_list_free (var), NULL)))
typedef struct _KeyModelPrivate KeyModelPrivate;
#define _gtk_tree_path_free0(var) ((var == NULL) ? NULL : (var = (gtk_tree_path_free (var), NULL)))

#define TYPE_ENUM_MODEL (enum_model_get_type ())
#define ENUM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ENUM_MODEL, EnumModel))
#define ENUM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ENUM_MODEL, EnumModelClass))
#define IS_ENUM_MODEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ENUM_MODEL))
#define IS_ENUM_MODEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ENUM_MODEL))
#define ENUM_MODEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ENUM_MODEL, EnumModelClass))

typedef struct _EnumModel EnumModel;
typedef struct _EnumModelClass EnumModelClass;
typedef struct _EnumModelPrivate EnumModelPrivate;
#define _schema_enum_unref0(var) ((var == NULL) ? NULL : (var = (schema_enum_unref (var), NULL)))

#define TYPE_SCHEMA_VALUE (schema_value_get_type ())
#define SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_SCHEMA_VALUE, SchemaValue))
#define SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_SCHEMA_VALUE, SchemaValueClass))
#define IS_SCHEMA_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_SCHEMA_VALUE))
#define IS_SCHEMA_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_SCHEMA_VALUE))
#define SCHEMA_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_SCHEMA_VALUE, SchemaValueClass))

typedef struct _SchemaValue SchemaValue;
typedef struct _SchemaValueClass SchemaValueClass;
typedef struct _SchemaValuePrivate SchemaValuePrivate;
typedef struct _SchemaEnumPrivate SchemaEnumPrivate;
#define _schema_list_unref0(var) ((var == NULL) ? NULL : (var = (schema_list_unref (var), NULL)))

struct _Key {
	GObject parent_instance;
	KeyPrivate * priv;
	Directory* parent;
	gchar* name;
	gchar* full_name;
	SchemaKey* schema;
};

struct _KeyClass {
	GObjectClass parent_class;
};

struct _KeyPrivate {
	SettingsModel* model;
	GVariant* _value;
};

struct _SettingsModel {
	GObject parent_instance;
	SettingsModelPrivate * priv;
	SchemaList* schemas;
	DConfClient* client;
};

struct _SettingsModelClass {
	GObjectClass parent_class;
};

struct _SchemaList {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaListPrivate * priv;
	GHashTable* schemas;
	GHashTable* keys;
	GHashTable* enums;
	GHashTable* flags;
};

struct _SchemaListClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaList *self);
};

struct _SchemaKey {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaKeyPrivate * priv;
	Schema* schema;
	gchar* name;
	gchar* type;
	GVariant* default_value;
	SchemaValueRange* range;
	SchemaValueRange* type_range;
	GList* choices;
	gchar* enum_name;
	gchar* summary;
	gchar* description;
	gchar* gettext_domain;
};

struct _SchemaKeyClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaKey *self);
};

struct _Directory {
	GObject parent_instance;
	DirectoryPrivate * priv;
	gchar* name;
	gchar* full_name;
	Directory* parent;
	GHashTable* _child_map;
	GList* _children;
	GHashTable* _key_map;
};

struct _DirectoryClass {
	GObjectClass parent_class;
};

struct _DirectoryPrivate {
	SettingsModel* model;
	KeyModel* _key_model;
	GList* _keys;
	gboolean have_children;
};

struct _Schema {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaPrivate * priv;
	SchemaList* list;
	gchar* id;
	gchar* path;
	GHashTable* keys;
};

struct _SchemaClass {
	GTypeClass parent_class;
	void (*finalize) (Schema *self);
};

struct _KeyModel {
	GObject parent_instance;
	KeyModelPrivate * priv;
};

struct _KeyModelClass {
	GObjectClass parent_class;
};

struct _KeyModelPrivate {
	Directory* directory;
};

struct _EnumModel {
	GObject parent_instance;
	EnumModelPrivate * priv;
};

struct _EnumModelClass {
	GObjectClass parent_class;
};

struct _EnumModelPrivate {
	SchemaEnum* schema_enum;
};

struct _SchemaValue {
	GObject parent_instance;
	SchemaValuePrivate * priv;
	guint index;
	gchar* nick;
	gint value;
};

struct _SchemaValueClass {
	GObjectClass parent_class;
};

struct _SchemaEnum {
	GTypeInstance parent_instance;
	volatile int ref_count;
	SchemaEnumPrivate * priv;
	SchemaList* list;
	gchar* id;
	GList* values;
};

struct _SchemaEnumClass {
	GTypeClass parent_class;
	void (*finalize) (SchemaEnum *self);
};

struct _SettingsModelPrivate {
	Directory* root;
};


static gpointer key_parent_class = NULL;
static gpointer directory_parent_class = NULL;
static gpointer key_model_parent_class = NULL;
static GtkTreeModelIface* key_model_gtk_tree_model_parent_iface = NULL;
static gpointer enum_model_parent_class = NULL;
static GtkTreeModelIface* enum_model_gtk_tree_model_parent_iface = NULL;
static gpointer settings_model_parent_class = NULL;
static GtkTreeModelIface* settings_model_gtk_tree_model_parent_iface = NULL;

GType key_get_type (void) G_GNUC_CONST;
GType directory_get_type (void) G_GNUC_CONST;
gpointer schema_key_ref (gpointer instance);
void schema_key_unref (gpointer instance);
GParamSpec* param_spec_schema_key (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_key (GValue* value, gpointer v_object);
void value_take_schema_key (GValue* value, gpointer v_object);
gpointer value_get_schema_key (const GValue* value);
GType schema_key_get_type (void) G_GNUC_CONST;
GType settings_model_get_type (void) G_GNUC_CONST;
#define KEY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY, KeyPrivate))
enum  {
	KEY_DUMMY_PROPERTY,
	KEY_HAS_SCHEMA,
	KEY_INDEX,
	KEY_TYPE_STRING,
	KEY_VALUE,
	KEY_IS_DEFAULT
};
GVariant* key_get_min (Key* self);
GVariant* key_get_value (Key* self);
GVariant* key_get_max (Key* self);
static void key_item_changed (Key* self, const gchar* key);
Key* key_new (SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name);
Key* key_construct (GType object_type, SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name);
gpointer schema_list_ref (gpointer instance);
void schema_list_unref (gpointer instance);
GParamSpec* param_spec_schema_list (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_list (GValue* value, gpointer v_object);
void value_take_schema_list (GValue* value, gpointer v_object);
gpointer value_get_schema_list (const GValue* value);
GType schema_list_get_type (void) G_GNUC_CONST;
gpointer schema_ref (gpointer instance);
void schema_unref (gpointer instance);
GParamSpec* param_spec_schema (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema (GValue* value, gpointer v_object);
void value_take_schema (GValue* value, gpointer v_object);
gpointer value_get_schema (const GValue* value);
GType schema_get_type (void) G_GNUC_CONST;
gpointer schema_enum_ref (gpointer instance);
void schema_enum_unref (gpointer instance);
GParamSpec* param_spec_schema_enum (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_enum (GValue* value, gpointer v_object);
void value_take_schema_enum (GValue* value, gpointer v_object);
gpointer value_get_schema_enum (const GValue* value);
GType schema_enum_get_type (void) G_GNUC_CONST;
gpointer schema_flags_ref (gpointer instance);
void schema_flags_unref (gpointer instance);
GParamSpec* param_spec_schema_flags (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_flags (GValue* value, gpointer v_object);
void value_take_schema_flags (GValue* value, gpointer v_object);
gpointer value_get_schema_flags (const GValue* value);
GType schema_flags_get_type (void) G_GNUC_CONST;
static void _key_item_changed_settings_model_item_changed (SettingsModel* _sender, const gchar* key, gpointer self);
void key_set_to_default (Key* self);
gboolean key_get_has_schema (Key* self);
static void key_update_value (Key* self);
gint key_get_index (Key* self);
GList* directory_get_keys (Directory* self);
const gchar* key_get_type_string (Key* self);
gpointer schema_value_range_ref (gpointer instance);
void schema_value_range_unref (gpointer instance);
GParamSpec* param_spec_schema_value_range (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_value_range (GValue* value, gpointer v_object);
void value_take_schema_value_range (GValue* value, gpointer v_object);
gpointer value_get_schema_value_range (const GValue* value);
GType schema_value_range_get_type (void) G_GNUC_CONST;
gpointer schema_choice_ref (gpointer instance);
void schema_choice_unref (gpointer instance);
GParamSpec* param_spec_schema_choice (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void value_set_schema_choice (GValue* value, gpointer v_object);
void value_take_schema_choice (GValue* value, gpointer v_object);
gpointer value_get_schema_choice (const GValue* value);
GType schema_choice_get_type (void) G_GNUC_CONST;
static void key_set_type_string (Key* self, const gchar* value);
void key_set_value (Key* self, GVariant* value);
gboolean key_get_is_default (Key* self);
static void key_finalize (GObject* obj);
static void _vala_key_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_key_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
GType key_model_get_type (void) G_GNUC_CONST;
#define DIRECTORY_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_DIRECTORY, DirectoryPrivate))
enum  {
	DIRECTORY_DUMMY_PROPERTY,
	DIRECTORY_KEY_MODEL,
	DIRECTORY_INDEX,
	DIRECTORY_CHILDREN,
	DIRECTORY_KEYS
};
static void _g_free0_ (gpointer var);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
Directory* directory_new (SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name);
Directory* directory_construct (GType object_type, SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name);
Directory* directory_get_child (Directory* self, const gchar* name);
static gint directory_compare_directories (Directory* a, Directory* b);
static gint _directory_compare_directories_gcompare_func (gconstpointer a, gconstpointer b);
Key* directory_get_key (Directory* self, const gchar* name);
gint directory_compare_keys (Key* a, Key* b);
static gint _directory_compare_keys_gcompare_func (gconstpointer a, gconstpointer b);
void directory_load_schema (Directory* self, Schema* schema, const gchar* path);
static void directory_update_children (Directory* self);
KeyModel* directory_get_key_model (Directory* self);
KeyModel* key_model_new (Directory* directory);
KeyModel* key_model_construct (GType object_type, Directory* directory);
static void directory_set_key_model (Directory* self, KeyModel* value);
gint directory_get_index (Directory* self);
GList* directory_get_children (Directory* self);
static void directory_set_children (Directory* self, GList* value);
static void directory_set_keys (Directory* self, GList* value);
static void directory_finalize (GObject* obj);
static void _vala_directory_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_directory_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);
#define KEY_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_KEY_MODEL, KeyModelPrivate))
enum  {
	KEY_MODEL_DUMMY_PROPERTY
};
static void key_model_key_changed_cb (KeyModel* self, Key* key);
static void _key_model_key_changed_cb_key_value_changed (Key* _sender, gpointer self);
Key* key_model_get_key (KeyModel* self, GtkTreeIter* iter);
static GtkTreeModelFlags key_model_real_get_flags (GtkTreeModel* base);
static gint key_model_real_get_n_columns (GtkTreeModel* base);
static GType key_model_real_get_column_type (GtkTreeModel* base, gint index);
static void key_model_set_iter (KeyModel* self, GtkTreeIter* iter, Key* key);
static gboolean key_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path);
static GtkTreePath* key_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter);
static void key_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value);
static gboolean key_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean key_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent);
static gboolean key_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter);
static gint key_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean key_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n);
static gboolean key_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child);
static void key_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void key_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void key_model_finalize (GObject* obj);
GType enum_model_get_type (void) G_GNUC_CONST;
#define ENUM_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_ENUM_MODEL, EnumModelPrivate))
enum  {
	ENUM_MODEL_DUMMY_PROPERTY
};
EnumModel* enum_model_new (SchemaEnum* schema_enum);
EnumModel* enum_model_construct (GType object_type, SchemaEnum* schema_enum);
static GtkTreeModelFlags enum_model_real_get_flags (GtkTreeModel* base);
static gint enum_model_real_get_n_columns (GtkTreeModel* base);
static GType enum_model_real_get_column_type (GtkTreeModel* base, gint index);
GType schema_value_get_type (void) G_GNUC_CONST;
static void enum_model_set_iter (EnumModel* self, GtkTreeIter* iter, SchemaValue* value);
SchemaValue* enum_model_get_enum_value (EnumModel* self, GtkTreeIter* iter);
static gboolean enum_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path);
static GtkTreePath* enum_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter);
static void enum_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value);
static gboolean enum_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean enum_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent);
static gboolean enum_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter);
static gint enum_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean enum_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n);
static gboolean enum_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child);
static void enum_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void enum_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void enum_model_finalize (GObject* obj);
#define SETTINGS_MODEL_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_SETTINGS_MODEL, SettingsModelPrivate))
enum  {
	SETTINGS_MODEL_DUMMY_PROPERTY
};
static void settings_model_watch_func (SettingsModel* self, DConfClient* client, const gchar* path, gchar** items, int items_length1, const gchar* tag);
SettingsModel* settings_model_new (void);
SettingsModel* settings_model_construct (GType object_type);
static void _settings_model_watch_func_dconf_client_changed (DConfClient* _sender, const gchar* prefix, gchar** changes, const gchar* tag, gpointer self);
SchemaList* schema_list_new (void);
SchemaList* schema_list_construct (GType object_type);
static gchar** _vala_array_dup1 (gchar** self, int length);
void schema_list_load_directory (SchemaList* self, const gchar* dir, GError** error);
static GtkTreeModelFlags settings_model_real_get_flags (GtkTreeModel* base);
static gint settings_model_real_get_n_columns (GtkTreeModel* base);
static GType settings_model_real_get_column_type (GtkTreeModel* base, gint index);
static void settings_model_set_iter (SettingsModel* self, GtkTreeIter* iter, Directory* directory);
Directory* settings_model_get_directory (SettingsModel* self, GtkTreeIter* iter);
static gboolean settings_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path);
static GtkTreePath* settings_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter);
static void settings_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value);
static gboolean settings_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean settings_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent);
static gboolean settings_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter);
static gint settings_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter);
static gboolean settings_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n);
static gboolean settings_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child);
static void settings_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void settings_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter);
static void settings_model_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GVariant* key_get_min (Key* self) {
	GVariant* result = NULL;
	GVariant* _tmp0_ = NULL;
	GVariant* _tmp1_ = NULL;
	GVariantClass _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = key_get_value (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_classify (_tmp1_);
	switch (_tmp2_) {
		case G_VARIANT_CLASS_BYTE:
		{
			GVariant* _tmp3_ = NULL;
			_tmp3_ = g_variant_new_byte ((guchar) 0);
			g_variant_ref_sink (_tmp3_);
			result = _tmp3_;
			return result;
		}
		case G_VARIANT_CLASS_INT16:
		{
			GVariant* _tmp4_ = NULL;
			_tmp4_ = g_variant_new_int16 (G_MININT16);
			g_variant_ref_sink (_tmp4_);
			result = _tmp4_;
			return result;
		}
		case G_VARIANT_CLASS_UINT16:
		{
			GVariant* _tmp5_ = NULL;
			_tmp5_ = g_variant_new_uint16 (0U);
			g_variant_ref_sink (_tmp5_);
			result = _tmp5_;
			return result;
		}
		case G_VARIANT_CLASS_INT32:
		{
			GVariant* _tmp6_ = NULL;
			_tmp6_ = g_variant_new_int32 (G_MININT32);
			g_variant_ref_sink (_tmp6_);
			result = _tmp6_;
			return result;
		}
		case G_VARIANT_CLASS_UINT32:
		{
			GVariant* _tmp7_ = NULL;
			_tmp7_ = g_variant_new_uint32 (0U);
			g_variant_ref_sink (_tmp7_);
			result = _tmp7_;
			return result;
		}
		case G_VARIANT_CLASS_INT64:
		{
			GVariant* _tmp8_ = NULL;
			_tmp8_ = g_variant_new_int64 (G_MININT64);
			g_variant_ref_sink (_tmp8_);
			result = _tmp8_;
			return result;
		}
		case G_VARIANT_CLASS_UINT64:
		{
			GVariant* _tmp9_ = NULL;
			_tmp9_ = g_variant_new_uint64 (0ULL);
			g_variant_ref_sink (_tmp9_);
			result = _tmp9_;
			return result;
		}
		case G_VARIANT_CLASS_DOUBLE:
		{
			GVariant* _tmp10_ = NULL;
			_tmp10_ = g_variant_new_double (DBL_MIN);
			g_variant_ref_sink (_tmp10_);
			result = _tmp10_;
			return result;
		}
		default:
		{
			result = NULL;
			return result;
		}
	}
}


GVariant* key_get_max (Key* self) {
	GVariant* result = NULL;
	GVariant* _tmp0_ = NULL;
	GVariant* _tmp1_ = NULL;
	GVariantClass _tmp2_ = 0;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = key_get_value (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_variant_classify (_tmp1_);
	switch (_tmp2_) {
		case G_VARIANT_CLASS_BYTE:
		{
			GVariant* _tmp3_ = NULL;
			_tmp3_ = g_variant_new_byte ((guchar) 255);
			g_variant_ref_sink (_tmp3_);
			result = _tmp3_;
			return result;
		}
		case G_VARIANT_CLASS_INT16:
		{
			GVariant* _tmp4_ = NULL;
			_tmp4_ = g_variant_new_int16 (G_MAXINT16);
			g_variant_ref_sink (_tmp4_);
			result = _tmp4_;
			return result;
		}
		case G_VARIANT_CLASS_UINT16:
		{
			GVariant* _tmp5_ = NULL;
			_tmp5_ = g_variant_new_uint16 (G_MAXUINT16);
			g_variant_ref_sink (_tmp5_);
			result = _tmp5_;
			return result;
		}
		case G_VARIANT_CLASS_INT32:
		{
			GVariant* _tmp6_ = NULL;
			_tmp6_ = g_variant_new_int32 (G_MAXINT32);
			g_variant_ref_sink (_tmp6_);
			result = _tmp6_;
			return result;
		}
		case G_VARIANT_CLASS_UINT32:
		{
			GVariant* _tmp7_ = NULL;
			_tmp7_ = g_variant_new_uint32 (G_MAXUINT32);
			g_variant_ref_sink (_tmp7_);
			result = _tmp7_;
			return result;
		}
		case G_VARIANT_CLASS_INT64:
		{
			GVariant* _tmp8_ = NULL;
			_tmp8_ = g_variant_new_int64 (G_MAXINT64);
			g_variant_ref_sink (_tmp8_);
			result = _tmp8_;
			return result;
		}
		case G_VARIANT_CLASS_UINT64:
		{
			GVariant* _tmp9_ = NULL;
			_tmp9_ = g_variant_new_uint64 (G_MAXUINT64);
			g_variant_ref_sink (_tmp9_);
			result = _tmp9_;
			return result;
		}
		case G_VARIANT_CLASS_DOUBLE:
		{
			GVariant* _tmp10_ = NULL;
			_tmp10_ = g_variant_new_double (DBL_MAX);
			g_variant_ref_sink (_tmp10_);
			result = _tmp10_;
			return result;
		}
		default:
		{
			result = NULL;
			return result;
		}
	}
}


static void key_item_changed (Key* self, const gchar* key) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	const gchar* _tmp2_ = NULL;
	gboolean _tmp3_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp2_ = key;
	_tmp3_ = g_str_has_suffix (_tmp2_, "/");
	if (_tmp3_) {
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		gboolean _tmp6_ = FALSE;
		_tmp4_ = self->full_name;
		_tmp5_ = key;
		_tmp6_ = g_str_has_prefix (_tmp4_, _tmp5_);
		_tmp1_ = _tmp6_;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		_tmp7_ = key;
		_tmp8_ = self->full_name;
		_tmp0_ = g_strcmp0 (_tmp7_, _tmp8_) == 0;
	}
	if (_tmp0_) {
		g_signal_emit_by_name (self, "value-changed");
	}
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static gpointer _schema_key_ref0 (gpointer self) {
	return self ? schema_key_ref (self) : NULL;
}


static void _key_item_changed_settings_model_item_changed (SettingsModel* _sender, const gchar* key, gpointer self) {
	key_item_changed ((Key*) self, key);
}


Key* key_construct (GType object_type, SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name) {
	Key * self = NULL;
	SettingsModel* _tmp0_ = NULL;
	SettingsModel* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	Directory* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	SettingsModel* _tmp8_ = NULL;
	SchemaList* _tmp9_ = NULL;
	GHashTable* _tmp10_ = NULL;
	const gchar* _tmp11_ = NULL;
	gconstpointer _tmp12_ = NULL;
	SchemaKey* _tmp13_ = NULL;
	SettingsModel* _tmp14_ = NULL;
	g_return_val_if_fail (model != NULL, NULL);
	g_return_val_if_fail (parent != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (full_name != NULL, NULL);
	self = (Key*) g_object_new (object_type, NULL);
	_tmp0_ = model;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->model);
	self->priv->model = _tmp1_;
	_tmp2_ = parent;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->parent);
	self->parent = _tmp3_;
	_tmp4_ = name;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->name);
	self->name = _tmp5_;
	_tmp6_ = full_name;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->full_name);
	self->full_name = _tmp7_;
	_tmp8_ = model;
	_tmp9_ = _tmp8_->schemas;
	_tmp10_ = _tmp9_->keys;
	_tmp11_ = full_name;
	_tmp12_ = g_hash_table_lookup (_tmp10_, _tmp11_);
	_tmp13_ = _schema_key_ref0 ((SchemaKey*) _tmp12_);
	_schema_key_unref0 (self->schema);
	self->schema = _tmp13_;
	_tmp14_ = model;
	g_signal_connect_object (_tmp14_, "item-changed", (GCallback) _key_item_changed_settings_model_item_changed, self, 0);
	return self;
}


Key* key_new (SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name) {
	return key_construct (TYPE_KEY, model, parent, name, full_name);
}


void key_set_to_default (Key* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = key_get_has_schema (self);
	_tmp1_ = _tmp0_;
	if (!_tmp1_) {
		return;
	}
	_g_variant_unref0 (self->priv->_value);
	self->priv->_value = NULL;
	{
		SettingsModel* _tmp2_ = NULL;
		DConfClient* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		_tmp2_ = self->priv->model;
		_tmp3_ = _tmp2_->client;
		_tmp4_ = self->full_name;
		dconf_client_write_sync (_tmp3_, _tmp4_, NULL, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch2_g_error;
		}
	}
	goto __finally2;
	__catch2_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally2:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_signal_emit_by_name (self, "value-changed");
}


static void key_update_value (Key* self) {
	SettingsModel* _tmp0_ = NULL;
	DConfClient* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GVariant* _tmp3_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->model;
	_tmp1_ = _tmp0_->client;
	_tmp2_ = self->full_name;
	_tmp3_ = dconf_client_read (_tmp1_, _tmp2_);
	_g_variant_unref0 (self->priv->_value);
	self->priv->_value = _tmp3_;
}


gboolean key_get_has_schema (Key* self) {
	gboolean result;
	SchemaKey* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->schema;
	result = _tmp0_ != NULL;
	return result;
}


gint key_get_index (Key* self) {
	gint result;
	Directory* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->parent;
	_tmp1_ = directory_get_keys (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_list_index (_tmp2_, self);
	result = _tmp3_;
	return result;
}


const gchar* key_get_type_string (Key* self) {
	const gchar* result;
	GVariant* _tmp0_ = NULL;
	GVariant* _tmp1_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = key_get_value (self);
	_tmp1_ = _tmp0_;
	if (_tmp1_ != NULL) {
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		GVariant* _tmp4_ = NULL;
		GVariant* _tmp5_ = NULL;
		const GVariantType* _tmp6_ = NULL;
		gboolean _tmp7_ = FALSE;
		_tmp4_ = key_get_value (self);
		_tmp5_ = _tmp4_;
		_tmp6_ = G_VARIANT_TYPE_STRING;
		_tmp7_ = g_variant_is_of_type (_tmp5_, _tmp6_);
		if (_tmp7_) {
			gboolean _tmp8_ = FALSE;
			gboolean _tmp9_ = FALSE;
			_tmp8_ = key_get_has_schema (self);
			_tmp9_ = _tmp8_;
			_tmp3_ = _tmp9_;
		} else {
			_tmp3_ = FALSE;
		}
		if (_tmp3_) {
			SchemaKey* _tmp10_ = NULL;
			const gchar* _tmp11_ = NULL;
			_tmp10_ = self->schema;
			_tmp11_ = _tmp10_->enum_name;
			_tmp2_ = _tmp11_ != NULL;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			result = "<enum>";
			return result;
		} else {
			GVariant* _tmp12_ = NULL;
			GVariant* _tmp13_ = NULL;
			const gchar* _tmp14_ = NULL;
			_tmp12_ = key_get_value (self);
			_tmp13_ = _tmp12_;
			_tmp14_ = g_variant_get_type_string (_tmp13_);
			result = _tmp14_;
			return result;
		}
	} else {
		SchemaKey* _tmp15_ = NULL;
		const gchar* _tmp16_ = NULL;
		_tmp15_ = self->schema;
		_tmp16_ = _tmp15_->type;
		result = _tmp16_;
		return result;
	}
}


static void key_set_type_string (Key* self, const gchar* value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "type-string");
}


GVariant* key_get_value (Key* self) {
	GVariant* result;
	GVariant* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	key_update_value (self);
	_tmp0_ = self->priv->_value;
	if (_tmp0_ != NULL) {
		GVariant* _tmp1_ = NULL;
		_tmp1_ = self->priv->_value;
		result = _tmp1_;
		return result;
	} else {
		SchemaKey* _tmp2_ = NULL;
		GVariant* _tmp3_ = NULL;
		_tmp2_ = self->schema;
		_tmp3_ = _tmp2_->default_value;
		result = _tmp3_;
		return result;
	}
}


static gpointer _g_variant_ref0 (gpointer self) {
	return self ? g_variant_ref (self) : NULL;
}


void key_set_value (Key* self, GVariant* value) {
	GVariant* _tmp0_ = NULL;
	GVariant* _tmp1_ = NULL;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	_tmp1_ = _g_variant_ref0 (_tmp0_);
	_g_variant_unref0 (self->priv->_value);
	self->priv->_value = _tmp1_;
	{
		SettingsModel* _tmp2_ = NULL;
		DConfClient* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		GVariant* _tmp5_ = NULL;
		_tmp2_ = self->priv->model;
		_tmp3_ = _tmp2_->client;
		_tmp4_ = self->full_name;
		_tmp5_ = value;
		dconf_client_write_sync (_tmp3_, _tmp4_, _tmp5_, NULL, NULL, &_inner_error_);
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			goto __catch3_g_error;
		}
	}
	goto __finally3;
	__catch3_g_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_g_error_free0 (e);
	}
	__finally3:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_signal_emit_by_name (self, "value-changed");
	g_object_notify ((GObject *) self, "value");
}


gboolean key_get_is_default (Key* self) {
	gboolean result;
	GVariant* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	key_update_value (self);
	_tmp0_ = self->priv->_value;
	result = _tmp0_ == NULL;
	return result;
}


static void key_class_init (KeyClass * klass) {
	key_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_key_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_key_set_property;
	G_OBJECT_CLASS (klass)->finalize = key_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_HAS_SCHEMA, g_param_spec_boolean ("has-schema", "has-schema", "has-schema", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_INDEX, g_param_spec_int ("index", "index", "index", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_TYPE_STRING, g_param_spec_string ("type-string", "type-string", "type-string", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_VALUE, g_param_spec_variant ("value", "value", "value", G_VARIANT_TYPE_ANY, NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), KEY_IS_DEFAULT, g_param_spec_boolean ("is-default", "is-default", "is-default", FALSE, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_signal_new ("value_changed", TYPE_KEY, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}


static void key_instance_init (Key * self) {
	self->priv = KEY_GET_PRIVATE (self);
}


static void key_finalize (GObject* obj) {
	Key * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY, Key);
	_g_object_unref0 (self->priv->model);
	_g_object_unref0 (self->parent);
	_g_free0 (self->name);
	_g_free0 (self->full_name);
	_schema_key_unref0 (self->schema);
	_g_variant_unref0 (self->priv->_value);
	G_OBJECT_CLASS (key_parent_class)->finalize (obj);
}


GType key_get_type (void) {
	static volatile gsize key_type_id__volatile = 0;
	if (g_once_init_enter (&key_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Key), 0, (GInstanceInitFunc) key_instance_init, NULL };
		GType key_type_id;
		key_type_id = g_type_register_static (G_TYPE_OBJECT, "Key", &g_define_type_info, 0);
		g_once_init_leave (&key_type_id__volatile, key_type_id);
	}
	return key_type_id__volatile;
}


static void _vala_key_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Key * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY, Key);
	switch (property_id) {
		case KEY_HAS_SCHEMA:
		g_value_set_boolean (value, key_get_has_schema (self));
		break;
		case KEY_INDEX:
		g_value_set_int (value, key_get_index (self));
		break;
		case KEY_TYPE_STRING:
		g_value_set_string (value, key_get_type_string (self));
		break;
		case KEY_VALUE:
		g_value_set_variant (value, key_get_value (self));
		break;
		case KEY_IS_DEFAULT:
		g_value_set_boolean (value, key_get_is_default (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_key_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Key * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_KEY, Key);
	switch (property_id) {
		case KEY_TYPE_STRING:
		key_set_type_string (self, g_value_get_string (value));
		break;
		case KEY_VALUE:
		key_set_value (self, g_value_get_variant (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


Directory* directory_construct (GType object_type, SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name) {
	Directory * self = NULL;
	SettingsModel* _tmp0_ = NULL;
	SettingsModel* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	Directory* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	const gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	g_return_val_if_fail (model != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (full_name != NULL, NULL);
	self = (Directory*) g_object_new (object_type, NULL);
	_tmp0_ = model;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->model);
	self->priv->model = _tmp1_;
	_tmp2_ = parent;
	_tmp3_ = _g_object_ref0 (_tmp2_);
	_g_object_unref0 (self->parent);
	self->parent = _tmp3_;
	_tmp4_ = name;
	_tmp5_ = g_strdup (_tmp4_);
	_g_free0 (self->name);
	self->name = _tmp5_;
	_tmp6_ = full_name;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->full_name);
	self->full_name = _tmp7_;
	return self;
}


Directory* directory_new (SettingsModel* model, Directory* parent, const gchar* name, const gchar* full_name) {
	return directory_construct (TYPE_DIRECTORY, model, parent, name, full_name);
}


static gint _directory_compare_directories_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = directory_compare_directories ((Directory*) a, (Directory*) b);
	return result;
}


Directory* directory_get_child (Directory* self, const gchar* name) {
	Directory* result = NULL;
	Directory* directory = NULL;
	GHashTable* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	Directory* _tmp3_ = NULL;
	Directory* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->_child_map;
	_tmp1_ = name;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _g_object_ref0 ((Directory*) _tmp2_);
	directory = _tmp3_;
	_tmp4_ = directory;
	if (_tmp4_ == NULL) {
		SettingsModel* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		gchar* _tmp11_ = NULL;
		gchar* _tmp12_ = NULL;
		Directory* _tmp13_ = NULL;
		Directory* _tmp14_ = NULL;
		Directory* _tmp15_ = NULL;
		GHashTable* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		gchar* _tmp18_ = NULL;
		Directory* _tmp19_ = NULL;
		Directory* _tmp20_ = NULL;
		_tmp5_ = self->priv->model;
		_tmp6_ = name;
		_tmp7_ = self->full_name;
		_tmp8_ = name;
		_tmp9_ = g_strconcat (_tmp7_, _tmp8_, NULL);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_strconcat (_tmp10_, "/", NULL);
		_tmp12_ = _tmp11_;
		_tmp13_ = directory_new (_tmp5_, self, _tmp6_, _tmp12_);
		_g_object_unref0 (directory);
		directory = _tmp13_;
		_g_free0 (_tmp12_);
		_g_free0 (_tmp10_);
		_tmp14_ = directory;
		_tmp15_ = _g_object_ref0 (_tmp14_);
		self->_children = g_list_insert_sorted (self->_children, _tmp15_, _directory_compare_directories_gcompare_func);
		_tmp16_ = self->_child_map;
		_tmp17_ = name;
		_tmp18_ = g_strdup (_tmp17_);
		_tmp19_ = directory;
		_tmp20_ = _g_object_ref0 (_tmp19_);
		g_hash_table_insert (_tmp16_, _tmp18_, _tmp20_);
	}
	result = directory;
	return result;
}


static gint directory_compare_directories (Directory* a, Directory* b) {
	gint result = 0;
	GCompareFunc _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	Directory* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = _tmp1_->name;
	_tmp3_ = b;
	_tmp4_ = _tmp3_->name;
	_tmp5_ = _tmp0_ (_tmp2_, _tmp4_);
	result = _tmp5_;
	return result;
}


static gint _directory_compare_keys_gcompare_func (gconstpointer a, gconstpointer b) {
	gint result;
	result = directory_compare_keys ((Key*) a, (Key*) b);
	return result;
}


Key* directory_get_key (Directory* self, const gchar* name) {
	Key* result = NULL;
	Key* key = NULL;
	GHashTable* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gconstpointer _tmp2_ = NULL;
	Key* _tmp3_ = NULL;
	Key* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->_key_map;
	_tmp1_ = name;
	_tmp2_ = g_hash_table_lookup (_tmp0_, _tmp1_);
	_tmp3_ = _g_object_ref0 ((Key*) _tmp2_);
	key = _tmp3_;
	_tmp4_ = key;
	if (_tmp4_ == NULL) {
		SettingsModel* _tmp5_ = NULL;
		const gchar* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		const gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		gchar* _tmp10_ = NULL;
		Key* _tmp11_ = NULL;
		Key* _tmp12_ = NULL;
		Key* _tmp13_ = NULL;
		GHashTable* _tmp14_ = NULL;
		const gchar* _tmp15_ = NULL;
		gchar* _tmp16_ = NULL;
		Key* _tmp17_ = NULL;
		Key* _tmp18_ = NULL;
		_tmp5_ = self->priv->model;
		_tmp6_ = name;
		_tmp7_ = self->full_name;
		_tmp8_ = name;
		_tmp9_ = g_strconcat (_tmp7_, _tmp8_, NULL);
		_tmp10_ = _tmp9_;
		_tmp11_ = key_new (_tmp5_, self, _tmp6_, _tmp10_);
		_g_object_unref0 (key);
		key = _tmp11_;
		_g_free0 (_tmp10_);
		_tmp12_ = key;
		_tmp13_ = _g_object_ref0 (_tmp12_);
		self->priv->_keys = g_list_insert_sorted (self->priv->_keys, _tmp13_, _directory_compare_keys_gcompare_func);
		_tmp14_ = self->_key_map;
		_tmp15_ = name;
		_tmp16_ = g_strdup (_tmp15_);
		_tmp17_ = key;
		_tmp18_ = _g_object_ref0 (_tmp17_);
		g_hash_table_insert (_tmp14_, _tmp16_, _tmp18_);
	}
	result = key;
	return result;
}


gint directory_compare_keys (Key* a, Key* b) {
	gint result = 0;
	GCompareFunc _tmp0_ = NULL;
	Key* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	Key* _tmp3_ = NULL;
	const gchar* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	g_return_val_if_fail (a != NULL, 0);
	g_return_val_if_fail (b != NULL, 0);
	_tmp0_ = g_strcmp0;
	_tmp1_ = a;
	_tmp2_ = _tmp1_->name;
	_tmp3_ = b;
	_tmp4_ = _tmp3_->name;
	_tmp5_ = _tmp0_ (_tmp2_, _tmp4_);
	result = _tmp5_;
	return result;
}


void directory_load_schema (Directory* self, Schema* schema, const gchar* path) {
	const gchar* _tmp0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (schema != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	if (g_strcmp0 (_tmp0_, "") == 0) {
		Schema* _tmp1_ = NULL;
		GHashTable* _tmp2_ = NULL;
		GList* _tmp3_ = NULL;
		_tmp1_ = schema;
		_tmp2_ = _tmp1_->keys;
		_tmp3_ = g_hash_table_get_values (_tmp2_);
		{
			GList* schema_key_collection = NULL;
			GList* schema_key_it = NULL;
			schema_key_collection = _tmp3_;
			for (schema_key_it = schema_key_collection; schema_key_it != NULL; schema_key_it = schema_key_it->next) {
				SchemaKey* schema_key = NULL;
				schema_key = (SchemaKey*) schema_key_it->data;
				{
					SchemaKey* _tmp4_ = NULL;
					const gchar* _tmp5_ = NULL;
					Key* _tmp6_ = NULL;
					Key* _tmp7_ = NULL;
					_tmp4_ = schema_key;
					_tmp5_ = _tmp4_->name;
					_tmp6_ = directory_get_key (self, _tmp5_);
					_tmp7_ = _tmp6_;
					_g_object_unref0 (_tmp7_);
				}
			}
			_g_list_free0 (schema_key_collection);
		}
	} else {
		gchar** tokens = NULL;
		const gchar* _tmp8_ = NULL;
		gchar** _tmp9_ = NULL;
		gchar** _tmp10_ = NULL;
		gint tokens_length1 = 0;
		gint _tokens_size_ = 0;
		gchar* name = NULL;
		gchar** _tmp11_ = NULL;
		gint _tmp11__length1 = 0;
		const gchar* _tmp12_ = NULL;
		gchar* _tmp13_ = NULL;
		Directory* directory = NULL;
		const gchar* _tmp14_ = NULL;
		Directory* _tmp15_ = NULL;
		Directory* _tmp16_ = NULL;
		Schema* _tmp17_ = NULL;
		gchar** _tmp18_ = NULL;
		gint _tmp18__length1 = 0;
		const gchar* _tmp19_ = NULL;
		_tmp8_ = path;
		_tmp10_ = _tmp9_ = g_strsplit (_tmp8_, "/", 2);
		tokens = _tmp10_;
		tokens_length1 = _vala_array_length (_tmp9_);
		_tokens_size_ = tokens_length1;
		_tmp11_ = tokens;
		_tmp11__length1 = tokens_length1;
		_tmp12_ = _tmp11_[0];
		_tmp13_ = g_strdup (_tmp12_);
		name = _tmp13_;
		_tmp14_ = name;
		_tmp15_ = directory_get_child (self, _tmp14_);
		directory = _tmp15_;
		_tmp16_ = directory;
		_tmp17_ = schema;
		_tmp18_ = tokens;
		_tmp18__length1 = tokens_length1;
		_tmp19_ = _tmp18_[1];
		directory_load_schema (_tmp16_, _tmp17_, _tmp19_);
		_g_object_unref0 (directory);
		_g_free0 (name);
		tokens = (_vala_array_free (tokens, tokens_length1, (GDestroyNotify) g_free), NULL);
	}
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	glong string_length = 0L;
	gint _tmp0_ = 0;
	gint _tmp1_ = 0;
	glong _tmp2_ = 0L;
	glong _tmp5_ = 0L;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_ = 0L;
	gboolean _tmp12_ = FALSE;
	glong _tmp13_ = 0L;
	glong _tmp16_ = 0L;
	glong _tmp17_ = 0L;
	glong _tmp18_ = 0L;
	glong _tmp19_ = 0L;
	glong _tmp20_ = 0L;
	gchar* _tmp21_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_ = 0L;
		glong _tmp4_ = 0L;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_ = 0L;
		glong _tmp7_ = 0L;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_ = 0L;
		glong _tmp11_ = 0L;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	g_return_val_if_fail (_tmp8_, NULL);
	_tmp13_ = end;
	if (_tmp13_ >= ((glong) 0)) {
		glong _tmp14_ = 0L;
		glong _tmp15_ = 0L;
		_tmp14_ = end;
		_tmp15_ = string_length;
		_tmp12_ = _tmp14_ <= _tmp15_;
	} else {
		_tmp12_ = FALSE;
	}
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp16_ = start;
	_tmp17_ = end;
	g_return_val_if_fail (_tmp16_ <= _tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	_tmp20_ = start;
	_tmp21_ = g_strndup (((gchar*) self) + _tmp18_, (gsize) (_tmp19_ - _tmp20_));
	result = _tmp21_;
	return result;
}


static void directory_update_children (Directory* self) {
	gboolean _tmp0_ = FALSE;
	gchar** items = NULL;
	SettingsModel* _tmp1_ = NULL;
	DConfClient* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gchar** _tmp5_ = NULL;
	gint items_length1 = 0;
	gint _items_size_ = 0;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->have_children;
	if (_tmp0_) {
		return;
	}
	self->priv->have_children = TRUE;
	_tmp1_ = self->priv->model;
	_tmp2_ = _tmp1_->client;
	_tmp3_ = self->full_name;
	_tmp5_ = dconf_client_list (_tmp2_, _tmp3_, &_tmp4_);
	items = _tmp5_;
	items_length1 = _tmp4_;
	_items_size_ = items_length1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				gint _tmp8_ = 0;
				gchar** _tmp9_ = NULL;
				gint _tmp9__length1 = 0;
				gchar* item_name = NULL;
				const gchar* _tmp10_ = NULL;
				gchar** _tmp11_ = NULL;
				gint _tmp11__length1 = 0;
				gint _tmp12_ = 0;
				const gchar* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				const gchar* _tmp15_ = NULL;
				gboolean _tmp16_ = FALSE;
				if (!_tmp6_) {
					gint _tmp7_ = 0;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp8_ = i;
				_tmp9_ = items;
				_tmp9__length1 = items_length1;
				if (!(_tmp8_ < _tmp9__length1)) {
					break;
				}
				_tmp10_ = self->full_name;
				_tmp11_ = items;
				_tmp11__length1 = items_length1;
				_tmp12_ = i;
				_tmp13_ = _tmp11_[_tmp12_];
				_tmp14_ = g_strconcat (_tmp10_, _tmp13_, NULL);
				item_name = _tmp14_;
				_tmp15_ = item_name;
				_tmp16_ = dconf_is_dir (_tmp15_, NULL);
				if (_tmp16_) {
					gchar* dir_name = NULL;
					gchar** _tmp17_ = NULL;
					gint _tmp17__length1 = 0;
					gint _tmp18_ = 0;
					const gchar* _tmp19_ = NULL;
					gchar* _tmp20_ = NULL;
					const gchar* _tmp21_ = NULL;
					Directory* _tmp22_ = NULL;
					Directory* _tmp23_ = NULL;
					_tmp17_ = items;
					_tmp17__length1 = items_length1;
					_tmp18_ = i;
					_tmp19_ = _tmp17_[_tmp18_];
					_tmp20_ = string_slice (_tmp19_, (glong) 0, (glong) (-1));
					dir_name = _tmp20_;
					_tmp21_ = dir_name;
					_tmp22_ = directory_get_child (self, _tmp21_);
					_tmp23_ = _tmp22_;
					_g_object_unref0 (_tmp23_);
					_g_free0 (dir_name);
				} else {
					gchar** _tmp24_ = NULL;
					gint _tmp24__length1 = 0;
					gint _tmp25_ = 0;
					const gchar* _tmp26_ = NULL;
					Key* _tmp27_ = NULL;
					Key* _tmp28_ = NULL;
					_tmp24_ = items;
					_tmp24__length1 = items_length1;
					_tmp25_ = i;
					_tmp26_ = _tmp24_[_tmp25_];
					_tmp27_ = directory_get_key (self, _tmp26_);
					_tmp28_ = _tmp27_;
					_g_object_unref0 (_tmp28_);
				}
				_g_free0 (item_name);
			}
		}
	}
	items = (_vala_array_free (items, items_length1, (GDestroyNotify) g_free), NULL);
}


KeyModel* directory_get_key_model (Directory* self) {
	KeyModel* result;
	KeyModel* _tmp0_ = NULL;
	KeyModel* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	directory_update_children (self);
	_tmp0_ = self->priv->_key_model;
	if (_tmp0_ == NULL) {
		KeyModel* _tmp1_ = NULL;
		_tmp1_ = key_model_new (self);
		_g_object_unref0 (self->priv->_key_model);
		self->priv->_key_model = _tmp1_;
	}
	_tmp2_ = self->priv->_key_model;
	result = _tmp2_;
	return result;
}


static void directory_set_key_model (Directory* self, KeyModel* value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "key-model");
}


gint directory_get_index (Directory* self) {
	gint result;
	Directory* _tmp0_ = NULL;
	GList* _tmp1_ = NULL;
	GList* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->parent;
	_tmp1_ = directory_get_children (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_list_index (_tmp2_, self);
	result = _tmp3_;
	return result;
}


GList* directory_get_children (Directory* self) {
	GList* result;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	directory_update_children (self);
	_tmp0_ = self->_children;
	result = _tmp0_;
	return result;
}


static void directory_set_children (Directory* self, GList* value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "children");
}


GList* directory_get_keys (Directory* self) {
	GList* result;
	GList* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	directory_update_children (self);
	_tmp0_ = self->priv->_keys;
	result = _tmp0_;
	return result;
}


static void directory_set_keys (Directory* self, GList* value) {
	g_return_if_fail (self != NULL);
	g_object_notify ((GObject *) self, "keys");
}


static void directory_class_init (DirectoryClass * klass) {
	directory_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (DirectoryPrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_directory_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_directory_set_property;
	G_OBJECT_CLASS (klass)->finalize = directory_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), DIRECTORY_KEY_MODEL, g_param_spec_object ("key-model", "key-model", "key-model", TYPE_KEY_MODEL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DIRECTORY_INDEX, g_param_spec_int ("index", "index", "index", G_MININT, G_MAXINT, 0, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DIRECTORY_CHILDREN, g_param_spec_pointer ("children", "children", "children", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
	g_object_class_install_property (G_OBJECT_CLASS (klass), DIRECTORY_KEYS, g_param_spec_pointer ("keys", "keys", "keys", G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE));
}


static void directory_instance_init (Directory * self) {
	GHashFunc _tmp0_ = NULL;
	GEqualFunc _tmp1_ = NULL;
	GHashTable* _tmp2_ = NULL;
	GHashFunc _tmp3_ = NULL;
	GEqualFunc _tmp4_ = NULL;
	GHashTable* _tmp5_ = NULL;
	self->priv = DIRECTORY_GET_PRIVATE (self);
	_tmp0_ = g_str_hash;
	_tmp1_ = g_str_equal;
	_tmp2_ = g_hash_table_new_full (_tmp0_, _tmp1_, _g_free0_, _g_object_unref0_);
	self->_child_map = _tmp2_;
	self->_children = NULL;
	_tmp3_ = g_str_hash;
	_tmp4_ = g_str_equal;
	_tmp5_ = g_hash_table_new_full (_tmp3_, _tmp4_, _g_free0_, _g_object_unref0_);
	self->_key_map = _tmp5_;
	self->priv->_keys = NULL;
}


static void directory_finalize (GObject* obj) {
	Directory * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DIRECTORY, Directory);
	_g_object_unref0 (self->priv->model);
	_g_free0 (self->name);
	_g_free0 (self->full_name);
	_g_object_unref0 (self->parent);
	_g_object_unref0 (self->priv->_key_model);
	_g_hash_table_unref0 (self->_child_map);
	__g_list_free__g_object_unref0_0 (self->_children);
	_g_hash_table_unref0 (self->_key_map);
	__g_list_free__g_object_unref0_0 (self->priv->_keys);
	G_OBJECT_CLASS (directory_parent_class)->finalize (obj);
}


GType directory_get_type (void) {
	static volatile gsize directory_type_id__volatile = 0;
	if (g_once_init_enter (&directory_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (DirectoryClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) directory_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Directory), 0, (GInstanceInitFunc) directory_instance_init, NULL };
		GType directory_type_id;
		directory_type_id = g_type_register_static (G_TYPE_OBJECT, "Directory", &g_define_type_info, 0);
		g_once_init_leave (&directory_type_id__volatile, directory_type_id);
	}
	return directory_type_id__volatile;
}


static void _vala_directory_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	Directory * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DIRECTORY, Directory);
	switch (property_id) {
		case DIRECTORY_KEY_MODEL:
		g_value_set_object (value, directory_get_key_model (self));
		break;
		case DIRECTORY_INDEX:
		g_value_set_int (value, directory_get_index (self));
		break;
		case DIRECTORY_CHILDREN:
		g_value_set_pointer (value, directory_get_children (self));
		break;
		case DIRECTORY_KEYS:
		g_value_set_pointer (value, directory_get_keys (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_directory_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	Directory * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (object, TYPE_DIRECTORY, Directory);
	switch (property_id) {
		case DIRECTORY_KEY_MODEL:
		directory_set_key_model (self, g_value_get_object (value));
		break;
		case DIRECTORY_CHILDREN:
		directory_set_children (self, g_value_get_pointer (value));
		break;
		case DIRECTORY_KEYS:
		directory_set_keys (self, g_value_get_pointer (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _key_model_key_changed_cb_key_value_changed (Key* _sender, gpointer self) {
	key_model_key_changed_cb ((KeyModel*) self, _sender);
}


KeyModel* key_model_construct (GType object_type, Directory* directory) {
	KeyModel * self = NULL;
	Directory* _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	g_return_val_if_fail (directory != NULL, NULL);
	self = (KeyModel*) g_object_new (object_type, NULL);
	_tmp0_ = directory;
	_tmp1_ = _g_object_ref0 (_tmp0_);
	_g_object_unref0 (self->priv->directory);
	self->priv->directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = directory_get_keys (_tmp2_);
	_tmp4_ = _tmp3_;
	{
		GList* key_collection = NULL;
		GList* key_it = NULL;
		key_collection = _tmp4_;
		for (key_it = key_collection; key_it != NULL; key_it = key_it->next) {
			Key* _tmp5_ = NULL;
			Key* key = NULL;
			_tmp5_ = _g_object_ref0 ((Key*) key_it->data);
			key = _tmp5_;
			{
				Key* _tmp6_ = NULL;
				_tmp6_ = key;
				g_signal_connect_object (_tmp6_, "value-changed", (GCallback) _key_model_key_changed_cb_key_value_changed, self, 0);
				_g_object_unref0 (key);
			}
		}
	}
	return self;
}


KeyModel* key_model_new (Directory* directory) {
	return key_model_construct (TYPE_KEY_MODEL, directory);
}


static void key_model_key_changed_cb (KeyModel* self, Key* key) {
	GtkTreeIter iter = {0};
	GtkTreeIter _tmp0_ = {0};
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (self != NULL);
	g_return_if_fail (key != NULL);
	_tmp1_ = gtk_tree_model_get_iter_first ((GtkTreeModel*) self, &_tmp0_);
	iter = _tmp0_;
	if (!_tmp1_) {
		return;
	}
	{
		gboolean _tmp2_ = FALSE;
		_tmp2_ = TRUE;
		while (TRUE) {
			GtkTreeIter _tmp4_ = {0};
			Key* _tmp5_ = NULL;
			Key* _tmp6_ = NULL;
			Key* _tmp7_ = NULL;
			gboolean _tmp8_ = FALSE;
			if (!_tmp2_) {
				gboolean _tmp3_ = FALSE;
				_tmp3_ = gtk_tree_model_iter_next ((GtkTreeModel*) self, &iter);
				if (!_tmp3_) {
					break;
				}
			}
			_tmp2_ = FALSE;
			_tmp4_ = iter;
			_tmp5_ = key_model_get_key (self, &_tmp4_);
			_tmp6_ = _tmp5_;
			_tmp7_ = key;
			_tmp8_ = _tmp6_ == _tmp7_;
			_g_object_unref0 (_tmp6_);
			if (_tmp8_) {
				GtkTreeIter _tmp9_ = {0};
				GtkTreePath* _tmp10_ = NULL;
				GtkTreePath* _tmp11_ = NULL;
				GtkTreeIter _tmp12_ = {0};
				_tmp9_ = iter;
				_tmp10_ = gtk_tree_model_get_path ((GtkTreeModel*) self, &_tmp9_);
				_tmp11_ = _tmp10_;
				_tmp12_ = iter;
				gtk_tree_model_row_changed ((GtkTreeModel*) self, _tmp11_, &_tmp12_);
				_gtk_tree_path_free0 (_tmp11_);
				return;
			}
		}
	}
}


static GtkTreeModelFlags key_model_real_get_flags (GtkTreeModel* base) {
	KeyModel * self;
	GtkTreeModelFlags result = 0;
	self = (KeyModel*) base;
	result = GTK_TREE_MODEL_LIST_ONLY;
	return result;
}


static gint key_model_real_get_n_columns (GtkTreeModel* base) {
	KeyModel * self;
	gint result = 0;
	self = (KeyModel*) base;
	result = 3;
	return result;
}


static GType key_model_real_get_column_type (GtkTreeModel* base, gint index) {
	KeyModel * self;
	GType result = 0UL;
	gint _tmp0_ = 0;
	self = (KeyModel*) base;
	_tmp0_ = index;
	if (_tmp0_ == 0) {
		result = TYPE_KEY;
		return result;
	} else {
		result = G_TYPE_STRING;
		return result;
	}
}


static void key_model_set_iter (KeyModel* self, GtkTreeIter* iter, Key* key) {
	Key* _tmp0_ = NULL;
	Key* _tmp1_ = NULL;
	Key* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (key != NULL);
	(*iter).stamp = 0;
	_tmp0_ = key;
	(*iter).user_data = _tmp0_;
	_tmp1_ = key;
	(*iter).user_data2 = _tmp1_;
	_tmp2_ = key;
	(*iter).user_data3 = _tmp2_;
}


Key* key_model_get_key (KeyModel* self, GtkTreeIter* iter) {
	Key* result = NULL;
	GtkTreeIter _tmp0_ = {0};
	void* _tmp1_ = NULL;
	Key* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = *iter;
	_tmp1_ = _tmp0_.user_data;
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, TYPE_KEY, Key));
	result = _tmp2_;
	return result;
}


static gboolean key_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path) {
	KeyModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreePath* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GtkTreePath* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GtkTreeIter _tmp6_ = {0};
	gboolean _tmp7_ = FALSE;
	self = (KeyModel*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = path;
	_tmp1_ = gtk_tree_path_get_depth (_tmp0_);
	if (_tmp1_ != 1) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp2_ = path;
	_tmp4_ = gtk_tree_path_get_indices_with_depth (_tmp2_, &_tmp3_);
	_tmp5_ = _tmp4_[0];
	_tmp7_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp6_, NULL, _tmp5_);
	_vala_iter = _tmp6_;
	result = _tmp7_;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static GtkTreePath* key_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	GtkTreePath* result = NULL;
	GtkTreePath* path = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	Key* _tmp2_ = NULL;
	Key* _tmp3_ = NULL;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	self = (KeyModel*) base;
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = gtk_tree_path_new ();
	path = _tmp0_;
	_tmp1_ = *iter;
	_tmp2_ = key_model_get_key (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = key_get_index (_tmp3_);
	_tmp5_ = _tmp4_;
	gtk_tree_path_append_index (path, _tmp5_);
	_g_object_unref0 (_tmp3_);
	result = path;
	return result;
}


static void key_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value) {
	KeyModel * self;
	GValue _vala_value = {0};
	Key* key = NULL;
	GtkTreeIter _tmp0_ = {0};
	Key* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	self = (KeyModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = key_model_get_key (self, &_tmp0_);
	key = _tmp1_;
	_tmp2_ = column;
	if (_tmp2_ == 0) {
		Key* _tmp3_ = NULL;
		GValue _tmp4_ = {0};
		_tmp3_ = key;
		g_value_init (&_tmp4_, TYPE_KEY);
		g_value_set_object (&_tmp4_, _tmp3_);
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
		_vala_value = _tmp4_;
	} else {
		gint _tmp5_ = 0;
		_tmp5_ = column;
		if (_tmp5_ == 1) {
			Key* _tmp6_ = NULL;
			const gchar* _tmp7_ = NULL;
			GValue _tmp8_ = {0};
			_tmp6_ = key;
			_tmp7_ = _tmp6_->name;
			g_value_init (&_tmp8_, G_TYPE_STRING);
			g_value_set_string (&_tmp8_, _tmp7_);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp8_;
		} else {
			gint _tmp9_ = 0;
			_tmp9_ = column;
			if (_tmp9_ == 2) {
				Key* _tmp10_ = NULL;
				GVariant* _tmp11_ = NULL;
				GVariant* _tmp12_ = NULL;
				_tmp10_ = key;
				_tmp11_ = key_get_value (_tmp10_);
				_tmp12_ = _tmp11_;
				if (_tmp12_ != NULL) {
					Key* _tmp13_ = NULL;
					GVariant* _tmp14_ = NULL;
					GVariant* _tmp15_ = NULL;
					gchar* _tmp16_ = NULL;
					GValue _tmp17_ = {0};
					_tmp13_ = key;
					_tmp14_ = key_get_value (_tmp13_);
					_tmp15_ = _tmp14_;
					_tmp16_ = g_variant_print (_tmp15_, FALSE);
					g_value_init (&_tmp17_, G_TYPE_STRING);
					g_value_take_string (&_tmp17_, _tmp16_);
					G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
					_vala_value = _tmp17_;
				} else {
					GValue _tmp18_ = {0};
					g_value_init (&_tmp18_, G_TYPE_STRING);
					g_value_set_string (&_tmp18_, "");
					G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
					_vala_value = _tmp18_;
				}
			} else {
				gint _tmp19_ = 0;
				_tmp19_ = column;
				if (_tmp19_ == 4) {
					Key* _tmp20_ = NULL;
					gboolean _tmp21_ = FALSE;
					gboolean _tmp22_ = FALSE;
					_tmp20_ = key;
					_tmp21_ = key_get_is_default (_tmp20_);
					_tmp22_ = _tmp21_;
					if (_tmp22_) {
						GValue _tmp23_ = {0};
						g_value_init (&_tmp23_, pango_weight_get_type ());
						g_value_set_enum (&_tmp23_, PANGO_WEIGHT_NORMAL);
						G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
						_vala_value = _tmp23_;
					} else {
						GValue _tmp24_ = {0};
						g_value_init (&_tmp24_, pango_weight_get_type ());
						g_value_set_enum (&_tmp24_, PANGO_WEIGHT_BOLD);
						G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
						_vala_value = _tmp24_;
					}
				} else {
					GValue _tmp25_ = {0};
					g_value_init (&_tmp25_, G_TYPE_INT);
					g_value_set_int (&_tmp25_, 0);
					G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
					_vala_value = _tmp25_;
				}
			}
		}
	}
	_g_object_unref0 (key);
	if (value) {
		*value = _vala_value;
	} else {
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	}
}


static gboolean key_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	gboolean result = FALSE;
	gint index = 0;
	GtkTreeIter _tmp0_ = {0};
	Key* _tmp1_ = NULL;
	Key* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	gint _tmp5_ = 0;
	gint _tmp6_ = 0;
	Directory* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	GList* _tmp9_ = NULL;
	guint _tmp10_ = 0U;
	Directory* _tmp11_ = NULL;
	GList* _tmp12_ = NULL;
	GList* _tmp13_ = NULL;
	gint _tmp14_ = 0;
	gconstpointer _tmp15_ = NULL;
	self = (KeyModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = *iter;
	_tmp1_ = key_model_get_key (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = key_get_index (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = _tmp4_;
	_g_object_unref0 (_tmp2_);
	index = _tmp5_;
	_tmp6_ = index;
	_tmp7_ = self->priv->directory;
	_tmp8_ = directory_get_keys (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = g_list_length (_tmp9_);
	if (((guint) _tmp6_) >= (_tmp10_ - 1)) {
		result = FALSE;
		return result;
	}
	_tmp11_ = self->priv->directory;
	_tmp12_ = directory_get_keys (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = index;
	_tmp15_ = g_list_nth_data (_tmp13_, (guint) (_tmp14_ + 1));
	key_model_set_iter (self, iter, (Key*) _tmp15_);
	result = TRUE;
	return result;
}


static gboolean key_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent) {
	KeyModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkTreeIter* _tmp1_ = NULL;
	Directory* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	gconstpointer _tmp9_ = NULL;
	self = (KeyModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp1_ = parent;
	if (_tmp1_ != NULL) {
		_tmp0_ = TRUE;
	} else {
		Directory* _tmp2_ = NULL;
		GList* _tmp3_ = NULL;
		GList* _tmp4_ = NULL;
		guint _tmp5_ = 0U;
		_tmp2_ = self->priv->directory;
		_tmp3_ = directory_get_keys (_tmp2_);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_list_length (_tmp4_);
		_tmp0_ = _tmp5_ == ((guint) 0);
	}
	if (_tmp0_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp6_ = self->priv->directory;
	_tmp7_ = directory_get_keys (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_list_nth_data (_tmp8_, (guint) 0);
	key_model_set_iter (self, &_vala_iter, (Key*) _tmp9_);
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean key_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	gboolean result = FALSE;
	self = (KeyModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	result = FALSE;
	return result;
}


static gint key_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	gint result = 0;
	GtkTreeIter* _tmp0_ = NULL;
	self = (KeyModel*) base;
	_tmp0_ = iter;
	if (_tmp0_ == NULL) {
		Directory* _tmp1_ = NULL;
		GList* _tmp2_ = NULL;
		GList* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		_tmp1_ = self->priv->directory;
		_tmp2_ = directory_get_keys (_tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = g_list_length (_tmp3_);
		result = (gint) _tmp4_;
		return result;
	} else {
		result = 0;
		return result;
	}
}


static gboolean key_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n) {
	KeyModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreeIter* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	Directory* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	Directory* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	gconstpointer _tmp10_ = NULL;
	self = (KeyModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = parent;
	if (_tmp0_ != NULL) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp1_ = n;
	_tmp2_ = self->priv->directory;
	_tmp3_ = directory_get_keys (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_list_length (_tmp4_);
	if (((guint) _tmp1_) >= _tmp5_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp6_ = self->priv->directory;
	_tmp7_ = directory_get_keys (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = n;
	_tmp10_ = g_list_nth_data (_tmp8_, (guint) _tmp9_);
	key_model_set_iter (self, &_vala_iter, (Key*) _tmp10_);
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean key_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child) {
	KeyModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	self = (KeyModel*) base;
	g_return_val_if_fail (child != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	result = FALSE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static void key_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	GtkTreeIter _tmp0_ = {0};
	Key* _tmp1_ = NULL;
	Key* _tmp2_ = NULL;
	self = (KeyModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = key_model_get_key (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_ref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void key_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	KeyModel * self;
	GtkTreeIter _tmp0_ = {0};
	Key* _tmp1_ = NULL;
	Key* _tmp2_ = NULL;
	self = (KeyModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = key_model_get_key (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_unref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void key_model_class_init (KeyModelClass * klass) {
	key_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (KeyModelPrivate));
	G_OBJECT_CLASS (klass)->finalize = key_model_finalize;
}


static void key_model_gtk_tree_model_interface_init (GtkTreeModelIface * iface) {
	key_model_gtk_tree_model_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_flags = (GtkTreeModelFlags (*)(GtkTreeModel*)) key_model_real_get_flags;
	iface->get_n_columns = (gint (*)(GtkTreeModel*)) key_model_real_get_n_columns;
	iface->get_column_type = (GType (*)(GtkTreeModel*, gint)) key_model_real_get_column_type;
	iface->get_iter = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreePath*)) key_model_real_get_iter;
	iface->get_path = (GtkTreePath* (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_get_path;
	iface->get_value = (void (*)(GtkTreeModel*, GtkTreeIter*, gint, GValue*)) key_model_real_get_value;
	iface->iter_next = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_iter_next;
	iface->iter_children = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) key_model_real_iter_children;
	iface->iter_has_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_iter_has_child;
	iface->iter_n_children = (gint (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_iter_n_children;
	iface->iter_nth_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gint)) key_model_real_iter_nth_child;
	iface->iter_parent = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) key_model_real_iter_parent;
	iface->ref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_ref_node;
	iface->unref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) key_model_real_unref_node;
}


static void key_model_instance_init (KeyModel * self) {
	self->priv = KEY_MODEL_GET_PRIVATE (self);
}


static void key_model_finalize (GObject* obj) {
	KeyModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_KEY_MODEL, KeyModel);
	_g_object_unref0 (self->priv->directory);
	G_OBJECT_CLASS (key_model_parent_class)->finalize (obj);
}


GType key_model_get_type (void) {
	static volatile gsize key_model_type_id__volatile = 0;
	if (g_once_init_enter (&key_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (KeyModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) key_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (KeyModel), 0, (GInstanceInitFunc) key_model_instance_init, NULL };
		static const GInterfaceInfo gtk_tree_model_info = { (GInterfaceInitFunc) key_model_gtk_tree_model_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType key_model_type_id;
		key_model_type_id = g_type_register_static (G_TYPE_OBJECT, "KeyModel", &g_define_type_info, 0);
		g_type_add_interface_static (key_model_type_id, GTK_TYPE_TREE_MODEL, &gtk_tree_model_info);
		g_once_init_leave (&key_model_type_id__volatile, key_model_type_id);
	}
	return key_model_type_id__volatile;
}


static gpointer _schema_enum_ref0 (gpointer self) {
	return self ? schema_enum_ref (self) : NULL;
}


EnumModel* enum_model_construct (GType object_type, SchemaEnum* schema_enum) {
	EnumModel * self = NULL;
	SchemaEnum* _tmp0_ = NULL;
	SchemaEnum* _tmp1_ = NULL;
	g_return_val_if_fail (schema_enum != NULL, NULL);
	self = (EnumModel*) g_object_new (object_type, NULL);
	_tmp0_ = schema_enum;
	_tmp1_ = _schema_enum_ref0 (_tmp0_);
	_schema_enum_unref0 (self->priv->schema_enum);
	self->priv->schema_enum = _tmp1_;
	return self;
}


EnumModel* enum_model_new (SchemaEnum* schema_enum) {
	return enum_model_construct (TYPE_ENUM_MODEL, schema_enum);
}


static GtkTreeModelFlags enum_model_real_get_flags (GtkTreeModel* base) {
	EnumModel * self;
	GtkTreeModelFlags result = 0;
	self = (EnumModel*) base;
	result = GTK_TREE_MODEL_LIST_ONLY;
	return result;
}


static gint enum_model_real_get_n_columns (GtkTreeModel* base) {
	EnumModel * self;
	gint result = 0;
	self = (EnumModel*) base;
	result = 2;
	return result;
}


static GType enum_model_real_get_column_type (GtkTreeModel* base, gint index) {
	EnumModel * self;
	GType result = 0UL;
	gint _tmp0_ = 0;
	self = (EnumModel*) base;
	_tmp0_ = index;
	if (_tmp0_ == 0) {
		result = G_TYPE_STRING;
		return result;
	} else {
		result = G_TYPE_INT;
		return result;
	}
}


static void enum_model_set_iter (EnumModel* self, GtkTreeIter* iter, SchemaValue* value) {
	SchemaValue* _tmp0_ = NULL;
	SchemaValue* _tmp1_ = NULL;
	SchemaValue* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (value != NULL);
	(*iter).stamp = 0;
	_tmp0_ = value;
	(*iter).user_data = _tmp0_;
	_tmp1_ = value;
	(*iter).user_data2 = _tmp1_;
	_tmp2_ = value;
	(*iter).user_data3 = _tmp2_;
}


SchemaValue* enum_model_get_enum_value (EnumModel* self, GtkTreeIter* iter) {
	SchemaValue* result = NULL;
	GtkTreeIter _tmp0_ = {0};
	void* _tmp1_ = NULL;
	SchemaValue* _tmp2_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = *iter;
	_tmp1_ = _tmp0_.user_data;
	_tmp2_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp1_, TYPE_SCHEMA_VALUE, SchemaValue));
	result = _tmp2_;
	return result;
}


static gboolean enum_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path) {
	EnumModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreePath* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GtkTreePath* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	GtkTreeIter _tmp6_ = {0};
	gboolean _tmp7_ = FALSE;
	self = (EnumModel*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = path;
	_tmp1_ = gtk_tree_path_get_depth (_tmp0_);
	if (_tmp1_ != 1) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp2_ = path;
	_tmp4_ = gtk_tree_path_get_indices_with_depth (_tmp2_, &_tmp3_);
	_tmp5_ = _tmp4_[0];
	_tmp7_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp6_, NULL, _tmp5_);
	_vala_iter = _tmp6_;
	result = _tmp7_;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static GtkTreePath* enum_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	GtkTreePath* result = NULL;
	GtkTreePath* path = NULL;
	GtkTreePath* _tmp0_ = NULL;
	GtkTreeIter _tmp1_ = {0};
	SchemaValue* _tmp2_ = NULL;
	SchemaValue* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	self = (EnumModel*) base;
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = gtk_tree_path_new ();
	path = _tmp0_;
	_tmp1_ = *iter;
	_tmp2_ = enum_model_get_enum_value (self, &_tmp1_);
	_tmp3_ = _tmp2_;
	_tmp4_ = _tmp3_->index;
	gtk_tree_path_append_index (path, (gint) _tmp4_);
	_g_object_unref0 (_tmp3_);
	result = path;
	return result;
}


static void enum_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value) {
	EnumModel * self;
	GValue _vala_value = {0};
	gint _tmp0_ = 0;
	self = (EnumModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = column;
	if (_tmp0_ == 0) {
		GtkTreeIter _tmp1_ = {0};
		SchemaValue* _tmp2_ = NULL;
		SchemaValue* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		GValue _tmp5_ = {0};
		_tmp1_ = *iter;
		_tmp2_ = enum_model_get_enum_value (self, &_tmp1_);
		_tmp3_ = _tmp2_;
		_tmp4_ = _tmp3_->nick;
		g_value_init (&_tmp5_, G_TYPE_STRING);
		g_value_set_string (&_tmp5_, _tmp4_);
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
		_vala_value = _tmp5_;
		_g_object_unref0 (_tmp3_);
	} else {
		gint _tmp6_ = 0;
		_tmp6_ = column;
		if (_tmp6_ == 1) {
			GtkTreeIter _tmp7_ = {0};
			SchemaValue* _tmp8_ = NULL;
			SchemaValue* _tmp9_ = NULL;
			gint _tmp10_ = 0;
			GValue _tmp11_ = {0};
			_tmp7_ = *iter;
			_tmp8_ = enum_model_get_enum_value (self, &_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = _tmp9_->value;
			g_value_init (&_tmp11_, G_TYPE_INT);
			g_value_set_int (&_tmp11_, _tmp10_);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp11_;
			_g_object_unref0 (_tmp9_);
		} else {
			GValue _tmp12_ = {0};
			g_value_init (&_tmp12_, G_TYPE_INT);
			g_value_set_int (&_tmp12_, 0);
			G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
			_vala_value = _tmp12_;
		}
	}
	if (value) {
		*value = _vala_value;
	} else {
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	}
}


static gboolean enum_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	gboolean result = FALSE;
	guint index = 0U;
	GtkTreeIter _tmp0_ = {0};
	SchemaValue* _tmp1_ = NULL;
	SchemaValue* _tmp2_ = NULL;
	guint _tmp3_ = 0U;
	guint _tmp4_ = 0U;
	guint _tmp5_ = 0U;
	SchemaEnum* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	guint _tmp8_ = 0U;
	SchemaEnum* _tmp9_ = NULL;
	GList* _tmp10_ = NULL;
	guint _tmp11_ = 0U;
	gconstpointer _tmp12_ = NULL;
	self = (EnumModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = *iter;
	_tmp1_ = enum_model_get_enum_value (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = _tmp2_->index;
	_tmp4_ = _tmp3_;
	_g_object_unref0 (_tmp2_);
	index = _tmp4_;
	_tmp5_ = index;
	_tmp6_ = self->priv->schema_enum;
	_tmp7_ = _tmp6_->values;
	_tmp8_ = g_list_length (_tmp7_);
	if (_tmp5_ >= (_tmp8_ - 1)) {
		result = FALSE;
		return result;
	}
	_tmp9_ = self->priv->schema_enum;
	_tmp10_ = _tmp9_->values;
	_tmp11_ = index;
	_tmp12_ = g_list_nth_data (_tmp10_, _tmp11_ + 1);
	enum_model_set_iter (self, iter, (SchemaValue*) _tmp12_);
	result = TRUE;
	return result;
}


static gboolean enum_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent) {
	EnumModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	GtkTreeIter* _tmp1_ = NULL;
	SchemaEnum* _tmp5_ = NULL;
	GList* _tmp6_ = NULL;
	gconstpointer _tmp7_ = NULL;
	self = (EnumModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp1_ = parent;
	if (_tmp1_ != NULL) {
		_tmp0_ = TRUE;
	} else {
		SchemaEnum* _tmp2_ = NULL;
		GList* _tmp3_ = NULL;
		guint _tmp4_ = 0U;
		_tmp2_ = self->priv->schema_enum;
		_tmp3_ = _tmp2_->values;
		_tmp4_ = g_list_length (_tmp3_);
		_tmp0_ = _tmp4_ == ((guint) 0);
	}
	if (_tmp0_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp5_ = self->priv->schema_enum;
	_tmp6_ = _tmp5_->values;
	_tmp7_ = g_list_nth_data (_tmp6_, (guint) 0);
	enum_model_set_iter (self, &_vala_iter, (SchemaValue*) _tmp7_);
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean enum_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	gboolean result = FALSE;
	self = (EnumModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	result = FALSE;
	return result;
}


static gint enum_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	gint result = 0;
	GtkTreeIter* _tmp0_ = NULL;
	self = (EnumModel*) base;
	_tmp0_ = iter;
	if (_tmp0_ == NULL) {
		SchemaEnum* _tmp1_ = NULL;
		GList* _tmp2_ = NULL;
		guint _tmp3_ = 0U;
		_tmp1_ = self->priv->schema_enum;
		_tmp2_ = _tmp1_->values;
		_tmp3_ = g_list_length (_tmp2_);
		result = (gint) _tmp3_;
		return result;
	} else {
		result = 0;
		return result;
	}
}


static gboolean enum_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n) {
	EnumModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreeIter* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	SchemaEnum* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	guint _tmp4_ = 0U;
	SchemaEnum* _tmp5_ = NULL;
	GList* _tmp6_ = NULL;
	gint _tmp7_ = 0;
	gconstpointer _tmp8_ = NULL;
	self = (EnumModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = parent;
	if (_tmp0_ != NULL) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp1_ = n;
	_tmp2_ = self->priv->schema_enum;
	_tmp3_ = _tmp2_->values;
	_tmp4_ = g_list_length (_tmp3_);
	if (((guint) _tmp1_) >= _tmp4_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp5_ = self->priv->schema_enum;
	_tmp6_ = _tmp5_->values;
	_tmp7_ = n;
	_tmp8_ = g_list_nth_data (_tmp6_, (guint) _tmp7_);
	enum_model_set_iter (self, &_vala_iter, (SchemaValue*) _tmp8_);
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean enum_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child) {
	EnumModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	self = (EnumModel*) base;
	g_return_val_if_fail (child != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	result = FALSE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static void enum_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	GtkTreeIter _tmp0_ = {0};
	SchemaValue* _tmp1_ = NULL;
	SchemaValue* _tmp2_ = NULL;
	self = (EnumModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = enum_model_get_enum_value (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_ref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void enum_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	EnumModel * self;
	GtkTreeIter _tmp0_ = {0};
	SchemaValue* _tmp1_ = NULL;
	SchemaValue* _tmp2_ = NULL;
	self = (EnumModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = enum_model_get_enum_value (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_unref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void enum_model_class_init (EnumModelClass * klass) {
	enum_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (EnumModelPrivate));
	G_OBJECT_CLASS (klass)->finalize = enum_model_finalize;
}


static void enum_model_gtk_tree_model_interface_init (GtkTreeModelIface * iface) {
	enum_model_gtk_tree_model_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_flags = (GtkTreeModelFlags (*)(GtkTreeModel*)) enum_model_real_get_flags;
	iface->get_n_columns = (gint (*)(GtkTreeModel*)) enum_model_real_get_n_columns;
	iface->get_column_type = (GType (*)(GtkTreeModel*, gint)) enum_model_real_get_column_type;
	iface->get_iter = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreePath*)) enum_model_real_get_iter;
	iface->get_path = (GtkTreePath* (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_get_path;
	iface->get_value = (void (*)(GtkTreeModel*, GtkTreeIter*, gint, GValue*)) enum_model_real_get_value;
	iface->iter_next = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_iter_next;
	iface->iter_children = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) enum_model_real_iter_children;
	iface->iter_has_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_iter_has_child;
	iface->iter_n_children = (gint (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_iter_n_children;
	iface->iter_nth_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gint)) enum_model_real_iter_nth_child;
	iface->iter_parent = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) enum_model_real_iter_parent;
	iface->ref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_ref_node;
	iface->unref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) enum_model_real_unref_node;
}


static void enum_model_instance_init (EnumModel * self) {
	self->priv = ENUM_MODEL_GET_PRIVATE (self);
}


static void enum_model_finalize (GObject* obj) {
	EnumModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ENUM_MODEL, EnumModel);
	_schema_enum_unref0 (self->priv->schema_enum);
	G_OBJECT_CLASS (enum_model_parent_class)->finalize (obj);
}


GType enum_model_get_type (void) {
	static volatile gsize enum_model_type_id__volatile = 0;
	if (g_once_init_enter (&enum_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (EnumModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) enum_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (EnumModel), 0, (GInstanceInitFunc) enum_model_instance_init, NULL };
		static const GInterfaceInfo gtk_tree_model_info = { (GInterfaceInitFunc) enum_model_gtk_tree_model_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType enum_model_type_id;
		enum_model_type_id = g_type_register_static (G_TYPE_OBJECT, "EnumModel", &g_define_type_info, 0);
		g_type_add_interface_static (enum_model_type_id, GTK_TYPE_TREE_MODEL, &gtk_tree_model_info);
		g_once_init_leave (&enum_model_type_id__volatile, enum_model_type_id);
	}
	return enum_model_type_id__volatile;
}


static void settings_model_watch_func (SettingsModel* self, DConfClient* client, const gchar* path, gchar** items, int items_length1, const gchar* tag) {
	gchar** _tmp0_ = NULL;
	gint _tmp0__length1 = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (client != NULL);
	g_return_if_fail (path != NULL);
	_tmp0_ = items;
	_tmp0__length1 = items_length1;
	{
		gchar** item_collection = NULL;
		gint item_collection_length1 = 0;
		gint _item_collection_size_ = 0;
		gint item_it = 0;
		item_collection = _tmp0_;
		item_collection_length1 = _tmp0__length1;
		for (item_it = 0; item_it < _tmp0__length1; item_it = item_it + 1) {
			gchar* _tmp1_ = NULL;
			gchar* item = NULL;
			_tmp1_ = g_strdup (item_collection[item_it]);
			item = _tmp1_;
			{
				const gchar* _tmp2_ = NULL;
				const gchar* _tmp3_ = NULL;
				gchar* _tmp4_ = NULL;
				gchar* _tmp5_ = NULL;
				_tmp2_ = path;
				_tmp3_ = item;
				_tmp4_ = g_strconcat (_tmp2_, _tmp3_, NULL);
				_tmp5_ = _tmp4_;
				g_signal_emit_by_name (self, "item-changed", _tmp5_);
				_g_free0 (_tmp5_);
				_g_free0 (item);
			}
		}
	}
}


static void _settings_model_watch_func_dconf_client_changed (DConfClient* _sender, const gchar* prefix, gchar** changes, const gchar* tag, gpointer self) {
	settings_model_watch_func ((SettingsModel*) self, _sender, prefix, changes, _vala_array_length (changes), tag);
}


static gchar** _vala_array_dup1 (gchar** self, int length) {
	gchar** result;
	int i;
	result = g_new0 (gchar*, length + 1);
	for (i = 0; i < length; i++) {
		gchar* _tmp0_ = NULL;
		_tmp0_ = g_strdup (self[i]);
		result[i] = _tmp0_;
	}
	return result;
}


SettingsModel* settings_model_construct (GType object_type) {
	SettingsModel * self = NULL;
	DConfClient* _tmp0_ = NULL;
	DConfClient* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	DConfClient* _tmp3_ = NULL;
	SchemaList* _tmp4_ = NULL;
	SchemaList* _tmp30_ = NULL;
	GHashTable* _tmp31_ = NULL;
	GList* _tmp32_ = NULL;
	GError * _inner_error_ = NULL;
	self = (SettingsModel*) g_object_new (object_type, NULL);
	_tmp0_ = dconf_client_new ();
	_g_object_unref0 (self->client);
	self->client = _tmp0_;
	_tmp1_ = self->client;
	g_signal_connect_object (_tmp1_, "changed", (GCallback) _settings_model_watch_func_dconf_client_changed, self, 0);
	_tmp2_ = directory_new (self, NULL, "/", "/");
	_g_object_unref0 (self->priv->root);
	self->priv->root = _tmp2_;
	_tmp3_ = self->client;
	dconf_client_watch_sync (_tmp3_, "/");
	_tmp4_ = schema_list_new ();
	_schema_list_unref0 (self->schemas);
	self->schemas = _tmp4_;
	{
		gchar** dirs = NULL;
		gchar** _tmp5_ = NULL;
		gchar** _tmp6_ = NULL;
		gchar** _tmp7_ = NULL;
		gint _tmp7__length1 = 0;
		gint dirs_length1 = 0;
		gint _dirs_size_ = 0;
		gchar* dir = NULL;
		const gchar* _tmp23_ = NULL;
		gchar* _tmp24_ = NULL;
		const gchar* _tmp25_ = NULL;
		_tmp6_ = _tmp5_ = g_get_system_data_dirs ();
		_tmp7_ = (_tmp6_ != NULL) ? _vala_array_dup1 (_tmp6_, _vala_array_length (_tmp5_)) : ((gpointer) _tmp6_);
		_tmp7__length1 = _vala_array_length (_tmp5_);
		dirs = _tmp7_;
		dirs_length1 = _tmp7__length1;
		_dirs_size_ = dirs_length1;
		{
			gint i = 0;
			gchar** _tmp8_ = NULL;
			gint _tmp8__length1 = 0;
			_tmp8_ = dirs;
			_tmp8__length1 = dirs_length1;
			i = _tmp8__length1 - 1;
			{
				gboolean _tmp9_ = FALSE;
				_tmp9_ = TRUE;
				while (TRUE) {
					gint _tmp11_ = 0;
					gchar* path = NULL;
					gchar** _tmp12_ = NULL;
					gint _tmp12__length1 = 0;
					gint _tmp13_ = 0;
					const gchar* _tmp14_ = NULL;
					gchar* _tmp15_ = NULL;
					const gchar* _tmp16_ = NULL;
					GFile* _tmp17_ = NULL;
					GFile* _tmp18_ = NULL;
					gboolean _tmp19_ = FALSE;
					gboolean _tmp20_ = FALSE;
					if (!_tmp9_) {
						gint _tmp10_ = 0;
						_tmp10_ = i;
						i = _tmp10_ - 1;
					}
					_tmp9_ = FALSE;
					_tmp11_ = i;
					if (!(_tmp11_ >= 0)) {
						break;
					}
					_tmp12_ = dirs;
					_tmp12__length1 = dirs_length1;
					_tmp13_ = i;
					_tmp14_ = _tmp12_[_tmp13_];
					_tmp15_ = g_build_filename (_tmp14_, "glib-2.0", "schemas", NULL);
					path = _tmp15_;
					_tmp16_ = path;
					_tmp17_ = g_file_new_for_path (_tmp16_);
					_tmp18_ = _tmp17_;
					_tmp19_ = g_file_query_exists (_tmp18_, NULL);
					_tmp20_ = _tmp19_;
					_g_object_unref0 (_tmp18_);
					if (_tmp20_) {
						SchemaList* _tmp21_ = NULL;
						const gchar* _tmp22_ = NULL;
						_tmp21_ = self->schemas;
						_tmp22_ = path;
						schema_list_load_directory (_tmp21_, _tmp22_, &_inner_error_);
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							_g_free0 (path);
							dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
							goto __catch4_g_error;
						}
					}
					_g_free0 (path);
				}
			}
		}
		_tmp23_ = g_getenv ("GSETTINGS_SCHEMA_DIR");
		_tmp24_ = g_strdup (_tmp23_);
		dir = _tmp24_;
		_tmp25_ = dir;
		if (_tmp25_ != NULL) {
			SchemaList* _tmp26_ = NULL;
			const gchar* _tmp27_ = NULL;
			_tmp26_ = self->schemas;
			_tmp27_ = dir;
			schema_list_load_directory (_tmp26_, _tmp27_, &_inner_error_);
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				_g_free0 (dir);
				dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
				goto __catch4_g_error;
			}
		}
		_g_free0 (dir);
		dirs = (_vala_array_free (dirs, dirs_length1, (GDestroyNotify) g_free), NULL);
	}
	goto __finally4;
	__catch4_g_error:
	{
		GError* e = NULL;
		GError* _tmp28_ = NULL;
		const gchar* _tmp29_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp28_ = e;
		_tmp29_ = _tmp28_->message;
		g_warning ("dconf-model.vala:622: Failed to parse schemas: %s", _tmp29_);
		_g_error_free0 (e);
	}
	__finally4:
	if (G_UNLIKELY (_inner_error_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp30_ = self->schemas;
	_tmp31_ = _tmp30_->schemas;
	_tmp32_ = g_hash_table_get_values (_tmp31_);
	{
		GList* schema_collection = NULL;
		GList* schema_it = NULL;
		schema_collection = _tmp32_;
		for (schema_it = schema_collection; schema_it != NULL; schema_it = schema_it->next) {
			Schema* schema = NULL;
			schema = (Schema*) schema_it->data;
			{
				Directory* _tmp33_ = NULL;
				Schema* _tmp34_ = NULL;
				Schema* _tmp35_ = NULL;
				const gchar* _tmp36_ = NULL;
				Schema* _tmp37_ = NULL;
				const gchar* _tmp38_ = NULL;
				gint _tmp39_ = 0;
				gint _tmp40_ = 0;
				gchar* _tmp41_ = NULL;
				gchar* _tmp42_ = NULL;
				_tmp33_ = self->priv->root;
				_tmp34_ = schema;
				_tmp35_ = schema;
				_tmp36_ = _tmp35_->path;
				_tmp37_ = schema;
				_tmp38_ = _tmp37_->path;
				_tmp39_ = strlen (_tmp38_);
				_tmp40_ = _tmp39_;
				_tmp41_ = string_slice (_tmp36_, (glong) 1, (glong) _tmp40_);
				_tmp42_ = _tmp41_;
				directory_load_schema (_tmp33_, _tmp34_, _tmp42_);
				_g_free0 (_tmp42_);
			}
		}
		_g_list_free0 (schema_collection);
	}
	return self;
}


SettingsModel* settings_model_new (void) {
	return settings_model_construct (TYPE_SETTINGS_MODEL);
}


static GtkTreeModelFlags settings_model_real_get_flags (GtkTreeModel* base) {
	SettingsModel * self;
	GtkTreeModelFlags result = 0;
	self = (SettingsModel*) base;
	result = 0;
	return result;
}


static gint settings_model_real_get_n_columns (GtkTreeModel* base) {
	SettingsModel * self;
	gint result = 0;
	self = (SettingsModel*) base;
	result = 2;
	return result;
}


static GType settings_model_real_get_column_type (GtkTreeModel* base, gint index) {
	SettingsModel * self;
	GType result = 0UL;
	gint _tmp0_ = 0;
	self = (SettingsModel*) base;
	_tmp0_ = index;
	if (_tmp0_ == 0) {
		result = TYPE_DIRECTORY;
		return result;
	} else {
		result = G_TYPE_STRING;
		return result;
	}
}


static void settings_model_set_iter (SettingsModel* self, GtkTreeIter* iter, Directory* directory) {
	Directory* _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iter != NULL);
	g_return_if_fail (directory != NULL);
	(*iter).stamp = 0;
	_tmp0_ = directory;
	(*iter).user_data = _tmp0_;
	_tmp1_ = directory;
	(*iter).user_data2 = _tmp1_;
	_tmp2_ = directory;
	(*iter).user_data3 = _tmp2_;
}


Directory* settings_model_get_directory (SettingsModel* self, GtkTreeIter* iter) {
	Directory* result = NULL;
	GtkTreeIter* _tmp0_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = iter;
	if (_tmp0_ == NULL) {
		Directory* _tmp1_ = NULL;
		Directory* _tmp2_ = NULL;
		_tmp1_ = self->priv->root;
		_tmp2_ = _g_object_ref0 (_tmp1_);
		result = _tmp2_;
		return result;
	} else {
		GtkTreeIter* _tmp3_ = NULL;
		void* _tmp4_ = NULL;
		Directory* _tmp5_ = NULL;
		_tmp3_ = iter;
		_tmp4_ = (*_tmp3_).user_data;
		_tmp5_ = _g_object_ref0 (G_TYPE_CHECK_INSTANCE_CAST (_tmp4_, TYPE_DIRECTORY, Directory));
		result = _tmp5_;
		return result;
	}
}


static gboolean settings_model_real_get_iter (GtkTreeModel* base, GtkTreeIter* iter, GtkTreePath* path) {
	SettingsModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	GtkTreePath* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	gint* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	GtkTreeIter _tmp4_ = {0};
	gboolean _tmp5_ = FALSE;
	self = (SettingsModel*) base;
	g_return_val_if_fail (path != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = path;
	_tmp2_ = gtk_tree_path_get_indices_with_depth (_tmp0_, &_tmp1_);
	_tmp3_ = _tmp2_[0];
	_tmp5_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp4_, NULL, _tmp3_);
	_vala_iter = _tmp4_;
	if (!_tmp5_) {
		result = FALSE;
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	{
		gint i = 0;
		i = 1;
		{
			gboolean _tmp6_ = FALSE;
			_tmp6_ = TRUE;
			while (TRUE) {
				gint _tmp8_ = 0;
				GtkTreePath* _tmp9_ = NULL;
				gint _tmp10_ = 0;
				GtkTreeIter parent = {0};
				GtkTreeIter _tmp11_ = {0};
				GtkTreeIter _tmp12_ = {0};
				GtkTreePath* _tmp13_ = NULL;
				gint _tmp14_ = 0;
				gint* _tmp15_ = NULL;
				gint _tmp16_ = 0;
				gint _tmp17_ = 0;
				GtkTreeIter _tmp18_ = {0};
				gboolean _tmp19_ = FALSE;
				if (!_tmp6_) {
					gint _tmp7_ = 0;
					_tmp7_ = i;
					i = _tmp7_ + 1;
				}
				_tmp6_ = FALSE;
				_tmp8_ = i;
				_tmp9_ = path;
				_tmp10_ = gtk_tree_path_get_depth (_tmp9_);
				if (!(_tmp8_ < _tmp10_)) {
					break;
				}
				_tmp11_ = _vala_iter;
				parent = _tmp11_;
				_tmp12_ = parent;
				_tmp13_ = path;
				_tmp15_ = gtk_tree_path_get_indices_with_depth (_tmp13_, &_tmp14_);
				_tmp16_ = i;
				_tmp17_ = _tmp15_[_tmp16_];
				_tmp19_ = gtk_tree_model_iter_nth_child ((GtkTreeModel*) self, &_tmp18_, &_tmp12_, _tmp17_);
				_vala_iter = _tmp18_;
				if (!_tmp19_) {
					result = FALSE;
					if (iter) {
						*iter = _vala_iter;
					}
					return result;
				}
			}
		}
	}
	result = TRUE;
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static GtkTreePath* settings_model_real_get_path (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	GtkTreePath* result = NULL;
	GtkTreePath* path = NULL;
	GtkTreePath* _tmp0_ = NULL;
	self = (SettingsModel*) base;
	g_return_val_if_fail (iter != NULL, NULL);
	_tmp0_ = gtk_tree_path_new ();
	path = _tmp0_;
	{
		Directory* d = NULL;
		GtkTreeIter _tmp1_ = {0};
		Directory* _tmp2_ = NULL;
		_tmp1_ = *iter;
		_tmp2_ = settings_model_get_directory (self, &_tmp1_);
		d = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				Directory* _tmp7_ = NULL;
				Directory* _tmp8_ = NULL;
				GtkTreePath* _tmp9_ = NULL;
				Directory* _tmp10_ = NULL;
				gint _tmp11_ = 0;
				gint _tmp12_ = 0;
				if (!_tmp3_) {
					Directory* _tmp4_ = NULL;
					Directory* _tmp5_ = NULL;
					Directory* _tmp6_ = NULL;
					_tmp4_ = d;
					_tmp5_ = _tmp4_->parent;
					_tmp6_ = _g_object_ref0 (_tmp5_);
					_g_object_unref0 (d);
					d = _tmp6_;
				}
				_tmp3_ = FALSE;
				_tmp7_ = d;
				_tmp8_ = self->priv->root;
				if (!(_tmp7_ != _tmp8_)) {
					break;
				}
				_tmp9_ = path;
				_tmp10_ = d;
				_tmp11_ = directory_get_index (_tmp10_);
				_tmp12_ = _tmp11_;
				gtk_tree_path_prepend_index (_tmp9_, (gint) _tmp12_);
			}
		}
		_g_object_unref0 (d);
	}
	result = path;
	return result;
}


static void settings_model_real_get_value (GtkTreeModel* base, GtkTreeIter* iter, gint column, GValue* value) {
	SettingsModel * self;
	GValue _vala_value = {0};
	gint _tmp0_ = 0;
	self = (SettingsModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = column;
	if (_tmp0_ == 0) {
		GtkTreeIter _tmp1_ = {0};
		Directory* _tmp2_ = NULL;
		GValue _tmp3_ = {0};
		_tmp1_ = *iter;
		_tmp2_ = settings_model_get_directory (self, &_tmp1_);
		g_value_init (&_tmp3_, TYPE_DIRECTORY);
		g_value_take_object (&_tmp3_, _tmp2_);
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
		_vala_value = _tmp3_;
	} else {
		GtkTreeIter _tmp4_ = {0};
		Directory* _tmp5_ = NULL;
		Directory* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		GValue _tmp8_ = {0};
		_tmp4_ = *iter;
		_tmp5_ = settings_model_get_directory (self, &_tmp4_);
		_tmp6_ = _tmp5_;
		_tmp7_ = _tmp6_->name;
		g_value_init (&_tmp8_, G_TYPE_STRING);
		g_value_set_string (&_tmp8_, _tmp7_);
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
		_vala_value = _tmp8_;
		_g_object_unref0 (_tmp6_);
	}
	if (value) {
		*value = _vala_value;
	} else {
		G_IS_VALUE (&_vala_value) ? (g_value_unset (&_vala_value), NULL) : NULL;
	}
}


static gboolean settings_model_real_iter_next (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	gboolean result = FALSE;
	Directory* directory = NULL;
	GtkTreeIter _tmp0_ = {0};
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	Directory* _tmp5_ = NULL;
	Directory* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	guint _tmp9_ = 0U;
	Directory* _tmp10_ = NULL;
	Directory* _tmp11_ = NULL;
	GList* _tmp12_ = NULL;
	GList* _tmp13_ = NULL;
	Directory* _tmp14_ = NULL;
	gint _tmp15_ = 0;
	gint _tmp16_ = 0;
	gconstpointer _tmp17_ = NULL;
	self = (SettingsModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = *iter;
	_tmp1_ = settings_model_get_directory (self, &_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = directory_get_index (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = directory;
	_tmp6_ = _tmp5_->parent;
	_tmp7_ = directory_get_children (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_list_length (_tmp8_);
	if (((guint) _tmp4_) >= (_tmp9_ - 1)) {
		result = FALSE;
		_g_object_unref0 (directory);
		return result;
	}
	_tmp10_ = directory;
	_tmp11_ = _tmp10_->parent;
	_tmp12_ = directory_get_children (_tmp11_);
	_tmp13_ = _tmp12_;
	_tmp14_ = directory;
	_tmp15_ = directory_get_index (_tmp14_);
	_tmp16_ = _tmp15_;
	_tmp17_ = g_list_nth_data (_tmp13_, (guint) (_tmp16_ + 1));
	settings_model_set_iter (self, iter, (Directory*) _tmp17_);
	result = TRUE;
	_g_object_unref0 (directory);
	return result;
}


static gboolean settings_model_real_iter_children (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent) {
	SettingsModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	Directory* directory = NULL;
	GtkTreeIter* _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	Directory* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	gconstpointer _tmp9_ = NULL;
	self = (SettingsModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = parent;
	_tmp1_ = settings_model_get_directory (self, _tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = directory_get_children (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_list_length (_tmp4_);
	if (_tmp5_ == ((guint) 0)) {
		result = FALSE;
		_g_object_unref0 (directory);
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp6_ = directory;
	_tmp7_ = directory_get_children (_tmp6_);
	_tmp8_ = _tmp7_;
	_tmp9_ = g_list_nth_data (_tmp8_, (guint) 0);
	settings_model_set_iter (self, &_vala_iter, (Directory*) _tmp9_);
	result = TRUE;
	_g_object_unref0 (directory);
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean settings_model_real_iter_has_child (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	gboolean result = FALSE;
	GtkTreeIter _tmp0_ = {0};
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	gboolean _tmp6_ = FALSE;
	self = (SettingsModel*) base;
	g_return_val_if_fail (iter != NULL, FALSE);
	_tmp0_ = *iter;
	_tmp1_ = settings_model_get_directory (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = directory_get_children (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_list_length (_tmp4_);
	_tmp6_ = _tmp5_ > ((guint) 0);
	_g_object_unref0 (_tmp2_);
	result = _tmp6_;
	return result;
}


static gint settings_model_real_iter_n_children (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	gint result = 0;
	GtkTreeIter* _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	GList* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	guint _tmp5_ = 0U;
	gint _tmp6_ = 0;
	self = (SettingsModel*) base;
	_tmp0_ = iter;
	_tmp1_ = settings_model_get_directory (self, _tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = directory_get_children (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp5_ = g_list_length (_tmp4_);
	_tmp6_ = (gint) _tmp5_;
	_g_object_unref0 (_tmp2_);
	result = _tmp6_;
	return result;
}


static gboolean settings_model_real_iter_nth_child (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* parent, gint n) {
	SettingsModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	Directory* directory = NULL;
	GtkTreeIter* _tmp0_ = NULL;
	Directory* _tmp1_ = NULL;
	gint _tmp2_ = 0;
	Directory* _tmp3_ = NULL;
	GList* _tmp4_ = NULL;
	GList* _tmp5_ = NULL;
	guint _tmp6_ = 0U;
	Directory* _tmp7_ = NULL;
	GList* _tmp8_ = NULL;
	GList* _tmp9_ = NULL;
	gint _tmp10_ = 0;
	gconstpointer _tmp11_ = NULL;
	self = (SettingsModel*) base;
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = parent;
	_tmp1_ = settings_model_get_directory (self, _tmp0_);
	directory = _tmp1_;
	_tmp2_ = n;
	_tmp3_ = directory;
	_tmp4_ = directory_get_children (_tmp3_);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_list_length (_tmp5_);
	if (((guint) _tmp2_) >= _tmp6_) {
		result = FALSE;
		_g_object_unref0 (directory);
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp7_ = directory;
	_tmp8_ = directory_get_children (_tmp7_);
	_tmp9_ = _tmp8_;
	_tmp10_ = n;
	_tmp11_ = g_list_nth_data (_tmp9_, (guint) _tmp10_);
	settings_model_set_iter (self, &_vala_iter, (Directory*) _tmp11_);
	result = TRUE;
	_g_object_unref0 (directory);
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static gboolean settings_model_real_iter_parent (GtkTreeModel* base, GtkTreeIter* iter, GtkTreeIter* child) {
	SettingsModel * self;
	GtkTreeIter _vala_iter = {0};
	gboolean result = FALSE;
	Directory* directory = NULL;
	GtkTreeIter _tmp0_ = {0};
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	Directory* _tmp3_ = NULL;
	Directory* _tmp4_ = NULL;
	Directory* _tmp5_ = NULL;
	Directory* _tmp6_ = NULL;
	self = (SettingsModel*) base;
	g_return_val_if_fail (child != NULL, FALSE);
	memset (&_vala_iter, 0, sizeof (GtkTreeIter));
	_tmp0_ = *child;
	_tmp1_ = settings_model_get_directory (self, &_tmp0_);
	directory = _tmp1_;
	_tmp2_ = directory;
	_tmp3_ = _tmp2_->parent;
	_tmp4_ = self->priv->root;
	if (_tmp3_ == _tmp4_) {
		result = FALSE;
		_g_object_unref0 (directory);
		if (iter) {
			*iter = _vala_iter;
		}
		return result;
	}
	_tmp5_ = directory;
	_tmp6_ = _tmp5_->parent;
	settings_model_set_iter (self, &_vala_iter, _tmp6_);
	result = TRUE;
	_g_object_unref0 (directory);
	if (iter) {
		*iter = _vala_iter;
	}
	return result;
}


static void settings_model_real_ref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	GtkTreeIter _tmp0_ = {0};
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	self = (SettingsModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = settings_model_get_directory (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_ref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void settings_model_real_unref_node (GtkTreeModel* base, GtkTreeIter* iter) {
	SettingsModel * self;
	GtkTreeIter _tmp0_ = {0};
	Directory* _tmp1_ = NULL;
	Directory* _tmp2_ = NULL;
	self = (SettingsModel*) base;
	g_return_if_fail (iter != NULL);
	_tmp0_ = *iter;
	_tmp1_ = settings_model_get_directory (self, &_tmp0_);
	_tmp2_ = _tmp1_;
	g_object_unref ((GObject*) _tmp2_);
	_g_object_unref0 (_tmp2_);
}


static void settings_model_class_init (SettingsModelClass * klass) {
	settings_model_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (SettingsModelPrivate));
	G_OBJECT_CLASS (klass)->finalize = settings_model_finalize;
	g_signal_new ("item_changed", TYPE_SETTINGS_MODEL, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__STRING, G_TYPE_NONE, 1, G_TYPE_STRING);
}


static void settings_model_gtk_tree_model_interface_init (GtkTreeModelIface * iface) {
	settings_model_gtk_tree_model_parent_iface = g_type_interface_peek_parent (iface);
	iface->get_flags = (GtkTreeModelFlags (*)(GtkTreeModel*)) settings_model_real_get_flags;
	iface->get_n_columns = (gint (*)(GtkTreeModel*)) settings_model_real_get_n_columns;
	iface->get_column_type = (GType (*)(GtkTreeModel*, gint)) settings_model_real_get_column_type;
	iface->get_iter = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreePath*)) settings_model_real_get_iter;
	iface->get_path = (GtkTreePath* (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_get_path;
	iface->get_value = (void (*)(GtkTreeModel*, GtkTreeIter*, gint, GValue*)) settings_model_real_get_value;
	iface->iter_next = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_iter_next;
	iface->iter_children = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) settings_model_real_iter_children;
	iface->iter_has_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_iter_has_child;
	iface->iter_n_children = (gint (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_iter_n_children;
	iface->iter_nth_child = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gint)) settings_model_real_iter_nth_child;
	iface->iter_parent = (gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*)) settings_model_real_iter_parent;
	iface->ref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_ref_node;
	iface->unref_node = (void (*)(GtkTreeModel*, GtkTreeIter*)) settings_model_real_unref_node;
}


static void settings_model_instance_init (SettingsModel * self) {
	self->priv = SETTINGS_MODEL_GET_PRIVATE (self);
}


static void settings_model_finalize (GObject* obj) {
	SettingsModel * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_SETTINGS_MODEL, SettingsModel);
	_schema_list_unref0 (self->schemas);
	_g_object_unref0 (self->client);
	_g_object_unref0 (self->priv->root);
	G_OBJECT_CLASS (settings_model_parent_class)->finalize (obj);
}


GType settings_model_get_type (void) {
	static volatile gsize settings_model_type_id__volatile = 0;
	if (g_once_init_enter (&settings_model_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (SettingsModelClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) settings_model_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (SettingsModel), 0, (GInstanceInitFunc) settings_model_instance_init, NULL };
		static const GInterfaceInfo gtk_tree_model_info = { (GInterfaceInitFunc) settings_model_gtk_tree_model_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType settings_model_type_id;
		settings_model_type_id = g_type_register_static (G_TYPE_OBJECT, "SettingsModel", &g_define_type_info, 0);
		g_type_add_interface_static (settings_model_type_id, GTK_TYPE_TREE_MODEL, &gtk_tree_model_info);
		g_once_init_leave (&settings_model_type_id__volatile, settings_model_type_id);
	}
	return settings_model_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}



