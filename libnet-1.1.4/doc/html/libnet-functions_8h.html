<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>libnet: libnet-functions.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>libnet-functions.h File Reference</h1>libnet exported function prototypes <a href="#_details">More...</a>
<p>

<p>
<a href="libnet-functions_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#6a879b30d3e1864fd9bad33e195223b5">libnet_init</a> (int injection_type, char *device, char *err_buf)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#591804711cffa92582703a5aedbd9b25">libnet_destroy</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b84889f7fe57a1801cf03eceac47463e">libnet_clear_packet</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#886dc359d6add4b0608e8611af7e1b35">libnet_stats</a> (libnet_t *l, struct libnet_stats *ls)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b9b137f454b3da05d4ac5fe388c1f2b8">libnet_getfd</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#1e68365ece2c976a75bc50e91df40ea0">libnet_getdevice</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#8b784c9899c429dd0f4790a71bdf55a2">libnet_getpbuf</a> (libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#095de516e5b119d6e72fff4286157386">libnet_getpbuf_size</a> (libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#a04f828cf6b7ade20204ec0e3dcbc778">libnet_getpacket_size</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#69470998be995ec8c5e11ecbb19137f5">libnet_seed_prand</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#453d816dc8adffaefc040a1bf5bd9b5f">libnet_get_prand</a> (int mod)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d36144707ce7994c12ef9d87dc9a2edf">libnet_toggle_checksum</a> (libnet_t *l, libnet_ptag_t ptag, int mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#65cea3a63aac7a17f681ab15fcfd2947">libnet_addr2name4</a> (u_int32_t in, u_int8_t use_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#5042e4e9d37d9c1ab566b8d3b97e21a2">libnet_name2addr4</a> (libnet_t *l, char *host_name, u_int8_t use_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct libnet_in6_addr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#6f3677b524c46fad4d185be9a3142099">libnet_name2addr6</a> (libnet_t *l, char *host_name, u_int8_t use_name)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#221ab1d86e36a0b1411eebdbea0cd012">libnet_addr2name6_r</a> (struct libnet_in6_addr addr, u_int8_t use_name, char *host_name, int host_name_len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#aee8e5f54482bf3c9b7c5b101fa8f41f">libnet_plist_chain_new</a> (libnet_t *l, libnet_plist_t **plist, char *token_list)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#05ced873eacf4a000e4ce3a3ab635108">libnet_plist_chain_next_pair</a> (libnet_plist_t *plist, u_int16_t *bport, u_int16_t *eport)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#39e332daa771627372a01867818b4301">libnet_plist_chain_dump</a> (libnet_plist_t *plist)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b854695d1306f9af440145fc6767d953">libnet_plist_chain_dump_string</a> (libnet_plist_t *plist)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b5cb1d70164207a7c279a909576058be">libnet_plist_chain_free</a> (libnet_plist_t *plist)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#60a223766dc718c544ec500b0829d39e">libnet_build_802_1q</a> (u_int8_t *dst, u_int8_t *src, u_int16_t tpi, u_int8_t priority, u_int8_t cfi, u_int16_t vlan_id, u_int16_t len_proto, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#2e2ba82d84c8af087e53c60cb2cf0f16">libnet_build_802_1x</a> (u_int8_t eap_ver, u_int8_t eap_type, u_int16_t length, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#df241a95102fc267d0a20a1a73f0c5f1">libnet_build_802_2</a> (u_int8_t dsap, u_int8_t ssap, u_int8_t control, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#997b6c996b95fbcb09f87a0caf12ffa0">libnet_build_802_2snap</a> (u_int8_t dsap, u_int8_t ssap, u_int8_t control, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#55367f2634cf6409bbda8bbf5b834877">libnet_build_802_3</a> (u_int8_t *dst, u_int8_t *src, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b8a60ba5d3c669a1439ace4f91ee52e0">libnet_build_ethernet</a> (u_int8_t *dst, u_int8_t *src, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0ab98b1c67ac61b39b646ecfd93d58e3">libnet_autobuild_ethernet</a> (u_int8_t *dst, u_int16_t type, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#2fb726d9841fa180bd79ab0a6362f533">libnet_build_fddi</a> (u_int8_t fc, u_int8_t *dst, u_int8_t *src, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#2a0f9f03a1c43253638ecb07dfc2bb62">libnet_autobuild_fddi</a> (u_int8_t fc, u_int8_t *dst, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#65c81208185c68937ef97c0203d3d924">libnet_build_arp</a> (u_int16_t hrd, u_int16_t pro, u_int8_t hln, u_int8_t pln, u_int16_t op, u_int8_t *sha, u_int8_t *spa, u_int8_t *tha, u_int8_t *tpa, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#c2ac4909b3657c4ac34c80dbc9f91abe">libnet_autobuild_arp</a> (u_int16_t op, u_int8_t *sha, u_int8_t *spa, u_int8_t *tha, u_int8_t *tpa, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#24b1a32adad116ddc743482a229af490">libnet_build_tcp</a> (u_int16_t sp, u_int16_t dp, u_int32_t seq, u_int32_t ack, u_int8_t control, u_int16_t win, u_int16_t sum, u_int16_t urg, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#316a2d08bdd3199b6b30fa446b48df51">libnet_build_tcp_options</a> (u_int8_t *options, u_int32_t options_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#6d3f91d01237eef2f82ffd322ecbc792">libnet_build_udp</a> (u_int16_t sp, u_int16_t dp, u_int16_t len, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e16743df24525d5ab9b4c1ef13e87423">libnet_build_cdp</a> (u_int8_t version, u_int8_t ttl, u_int16_t sum, u_int16_t type, u_int16_t len, u_int8_t *value, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b80f86d2cbf32126fe5952cc77d7c512">libnet_build_icmpv4_echo</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#58605cfff0090e3cbf26abd5b7194c16">libnet_build_icmpv4_mask</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, u_int32_t mask, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d8e682f057f00dc53fe82960d7893b3f">libnet_build_icmpv4_unreach</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#973112121198b7151d21ab7285f6ae34">libnet_build_icmpv4_redirect</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int32_t gateway, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#87fd21c0e964dc0e2f8866178240db39">libnet_build_icmpv4_timeexceed</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#512a61266327928df97b010bc3f821b6">libnet_build_icmpv4_timestamp</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, n_time otime, n_time rtime, n_time ttime, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d614cefecf7ffbabdf241e707c474575">libnet_build_igmp</a> (u_int8_t type, u_int8_t code, u_int16_t sum, u_int32_t ip, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4</a> (u_int16_t ip_len, u_int8_t tos, u_int16_t id, u_int16_t frag, u_int8_t ttl, u_int8_t prot, u_int16_t sum, u_int32_t src, u_int32_t dst, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#f5a9b52bc56903e3c71b3ae155ffc1df">libnet_build_ipv4_options</a> (u_int8_t *options, u_int32_t options_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#bcef75c186b4db27f13a29c38b8f40ec">libnet_autobuild_ipv4</a> (u_int16_t len, u_int8_t prot, u_int32_t dst, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#844fc0a5b0f5acf57cbe4c9f42a1125c">libnet_build_ipv6</a> (u_int8_t tc, u_int32_t fl, u_int16_t len, u_int8_t nh, u_int8_t hl, struct libnet_in6_addr src, struct libnet_in6_addr dst, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#6c65244937ef5bc8e84efa5fe54aaac9">libnet_build_ipv6_frag</a> (u_int8_t nh, u_int8_t reserved, u_int16_t frag, u_int32_t id, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#ccf52055b316417674bfcb76f85d6227">libnet_build_ipv6_routing</a> (u_int8_t nh, u_int8_t len, u_int8_t rtype, u_int8_t segments, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#a5695b5f8419b440d41bbac0aaa34564">libnet_build_ipv6_destopts</a> (u_int8_t nh, u_int8_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#db7b7870cc626d8d67f723de286034a9">libnet_build_ipv6_hbhopts</a> (u_int8_t nh, u_int8_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#f21186614be986ab83740275bb984426">libnet_autobuild_ipv6</a> (u_int16_t len, u_int8_t nh, struct libnet_in6_addr dst, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#84a2f87c5188f95a73ab04e7bb8eebf3">libnet_build_isl</a> (u_int8_t *dhost, u_int8_t type, u_int8_t user, u_int8_t *shost, u_int16_t len, u_int8_t *snap, u_int16_t vid, u_int16_t portindex, u_int16_t reserved, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#7080bea55af439f0e74031197bc0924c">libnet_build_ipsec_esp_hdr</a> (u_int32_t spi, u_int32_t seq, u_int32_t iv, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#47d4aa351486618f993ed6e2652681b1">libnet_build_ipsec_esp_ftr</a> (u_int8_t len, u_int8_t nh, int8_t *auth, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#ad130b6104956524af16fcb18fa759e9">libnet_build_ipsec_ah</a> (u_int8_t nh, u_int8_t len, u_int16_t res, u_int32_t spi, u_int32_t seq, u_int32_t auth, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#98bc91a6c39910ee6069d789d8dcd3e6">libnet_build_dnsv4</a> (u_int16_t h_len, u_int16_t id, u_int16_t flags, u_int16_t num_q, u_int16_t num_anws_rr, u_int16_t num_auth_rr, u_int16_t num_addi_rr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#c9549e65e228cdfa901fca9012f1b52f">libnet_build_rip</a> (u_int8_t cmd, u_int8_t version, u_int16_t rd, u_int16_t af, u_int16_t rt, u_int32_t addr, u_int32_t mask, u_int32_t next_hop, u_int32_t metric, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#33bdb212c766a869a55560d523deb807">libnet_build_rpc_call</a> (u_int32_t rm, u_int32_t xid, u_int32_t prog_num, u_int32_t prog_vers, u_int32_t procedure, u_int32_t cflavor, u_int32_t clength, u_int8_t *cdata, u_int32_t vflavor, u_int32_t vlength, u_int8_t *vdata, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0a3c886a4103e0a80aea25d6d326b6bf">libnet_build_stp_conf</a> (u_int16_t id, u_int8_t version, u_int8_t bpdu_type, u_int8_t flags, u_int8_t *root_id, u_int32_t root_pc, u_int8_t *bridge_id, u_int16_t port_id, u_int16_t message_age, u_int16_t max_age, u_int16_t hello_time, u_int16_t f_delay, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0d0bf94c6887aec7702cf9f4190a1e55">libnet_build_stp_tcn</a> (u_int16_t id, u_int8_t version, u_int8_t bpdu_type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#65635fcbae54edb768ed36e8ce3abca6">libnet_build_token_ring</a> (u_int8_t ac, u_int8_t fc, u_int8_t *dst, u_int8_t *src, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e2962f923beabedfe761dcd97cf41e87">libnet_autobuild_token_ring</a> (u_int8_t ac, u_int8_t fc, u_int8_t *dst, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e94f381e758de9faf26920042a2830e0">libnet_build_vrrp</a> (u_int8_t version, u_int8_t type, u_int8_t vrouter_id, u_int8_t priority, u_int8_t ip_count, u_int8_t auth_type, u_int8_t advert_int, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#2be4c11b7a37ab8ad9d46e1ebf3b53db">libnet_build_mpls</a> (u_int32_t label, u_int8_t experimental, u_int8_t bos, u_int8_t ttl, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#a18676bbed2910988a65ace745226301">libnet_build_ntp</a> (u_int8_t leap_indicator, u_int8_t version, u_int8_t mode, u_int8_t stratum, u_int8_t poll, u_int8_t precision, u_int16_t delay_int, u_int16_t delay_frac, u_int16_t dispersion_int, u_int16_t dispersion_frac, u_int32_t reference_id, u_int32_t ref_ts_int, u_int32_t ref_ts_frac, u_int32_t orig_ts_int, u_int32_t orig_ts_frac, u_int32_t rec_ts_int, u_int32_t rec_ts_frac, u_int32_t xmt_ts_int, u_int32_t xmt_ts_frac, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#40115f0c696b84e2f4f84c09e72f60dc">libnet_build_ospfv2</a> (u_int16_t len, u_int8_t type, u_int32_t rtr_id, u_int32_t area_id, u_int16_t sum, u_int16_t autype, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0f0d868bb17ff951305327becaec80e5">libnet_build_ospfv2_hello</a> (u_int32_t netmask, u_int16_t interval, u_int8_t opts, u_int8_t priority, u_int dead_int, u_int32_t des_rtr, u_int32_t bkup_rtr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#60b59bb26475cd0892299c4888454b3b">libnet_build_ospfv2_dbd</a> (u_int16_t dgram_len, u_int8_t opts, u_int8_t type, u_int seqnum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#bd981b21f34c0efcdbd7123f9c6b1ab4">libnet_build_ospfv2_lsr</a> (u_int type, u_int lsid, u_int32_t advrtr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#9460b64aba613d6e367a3a6d472ae5e6">libnet_build_ospfv2_lsu</a> (u_int num, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#8884632ef2860b3b292188fcacf54cf8">libnet_build_ospfv2_lsa</a> (u_int16_t age, u_int8_t opts, u_int8_t type, u_int lsid, u_int32_t advrtr, u_int seqnum, u_int16_t sum, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#8f27133661d6c10e3c776cfb7e24b8b6">libnet_build_ospfv2_lsa_rtr</a> (u_int16_t flags, u_int16_t num, u_int id, u_int data, u_int8_t type, u_int8_t tos, u_int16_t metric, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#ae2ddd904b99753f88073c1525e9a08f">libnet_build_ospfv2_lsa_net</a> (u_int32_t nmask, u_int rtrid, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b9d76074203ed1e92683a056b6f7b8ba">libnet_build_ospfv2_lsa_sum</a> (u_int32_t nmask, u_int metric, u_int tos, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#bcecd50e35e742531f59cce0b90b8b79">libnet_build_ospfv2_lsa_as</a> (u_int32_t nmask, u_int metric, u_int32_t fwdaddr, u_int tag, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#cb56eccdd9d924cd3a81affdbef4cf30">libnet_build_data</a> (u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#20d397bac4d614e395878f239d26d4dc">libnet_build_dhcpv4</a> (u_int8_t opcode, u_int8_t htype, u_int8_t hlen, u_int8_t hopcount, u_int32_t xid, u_int16_t secs, u_int16_t flags, u_int32_t cip, u_int32_t yip, u_int32_t sip, u_int32_t gip, u_int8_t *chaddr, u_int8_t *sname, u_int8_t *file, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#37164c33698bd0c59cd51393a1fdfae6">libnet_build_bootpv4</a> (u_int8_t opcode, u_int8_t htype, u_int8_t hlen, u_int8_t hopcount, u_int32_t xid, u_int16_t secs, u_int16_t flags, u_int32_t cip, u_int32_t yip, u_int32_t sip, u_int32_t gip, u_int8_t *chaddr, u_int8_t *sname, u_int8_t *file, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0af792a7e4bc49bd252b062cd4f35af5">libnet_getgre_length</a> (u_int16_t fv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#fff121ac7bc157e3df0eb1bd624263c1">libnet_build_gre</a> (u_int16_t fv, u_int16_t type, u_int16_t sum, u_int16_t offset, u_int32_t key, u_int32_t seq, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e8c54127e49779805cedf46506f564d4">libnet_build_egre</a> (u_int16_t fv, u_int16_t type, u_int16_t sum, u_int16_t offset, u_int32_t key, u_int32_t seq, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#7cca16e4e1b5ca96a1b0a35a2b766710">libnet_build_gre_sre</a> (u_int16_t af, u_int8_t offset, u_int8_t length, u_int8_t *routing, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#578594ad820ae9d82fe3f9ea470f0b27">libnet_build_gre_last_sre</a> (libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#5d7fd09f44af695b543beaff7abd2c1c">libnet_build_bgp4_header</a> (u_int8_t marker[LIBNET_BGP4_MARKER_SIZE], u_int16_t len, u_int8_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#9f5e3e137a1290437eb54ead063821f8">libnet_build_bgp4_open</a> (u_int8_t version, u_int16_t src_as, u_int16_t hold_time, u_int32_t bgp_id, u_int8_t opt_len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#213d5a264ea39a17fc0fc9edb3aac30c">libnet_build_bgp4_update</a> (u_int16_t unfeasible_rt_len, u_int8_t *withdrawn_rt, u_int16_t total_path_attr_len, u_int8_t *path_attributes, u_int16_t info_len, u_int8_t *reachability_info, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#1ba1e13d1fc8cc089ddd7931a6890d2b">libnet_build_bgp4_notification</a> (u_int8_t err_code, u_int8_t err_subcode, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d20d81e5ce0cd581ff374242fb30a089">libnet_build_sebek</a> (u_int32_t magic, u_int16_t version, u_int16_t type, u_int32_t counter, u_int32_t time_sec, u_int32_t time_usec, u_int32_t pid, u_int32_t uid, u_int32_t fd, u_int8_t cmd[SEBEK_CMD_LENGTH], u_int32_t length, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#69bf76db8b62ec812cb734965c31eb46">libnet_build_hsrp</a> (u_int8_t version, u_int8_t opcode, u_int8_t state, u_int8_t hello_time, u_int8_t hold_time, u_int8_t priority, u_int8_t group, u_int8_t reserved, u_int8_t authdata[HSRP_AUTHDATA_LENGTH], u_int32_t virtual_ip, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#71bc438f807ab7e84d424533e81e1693">libnet_build_link</a> (u_int8_t *dst, u_int8_t *src, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#3e21b6aaf8a1c690b6dca96c410083ee">libnet_autobuild_link</a> (u_int8_t *dst, u_int8_t *oui, u_int16_t type, libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#53375552efe95906e152152fc170cc0d">libnet_write</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e5143c0ab5dc9e9fa817d865eac428b0">libnet_get_ipaddr4</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct libnet_in6_addr&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#3d7de8968c2087df7a22140d7993e267">libnet_get_ipaddr6</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct <br>
libnet_ether_addr *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#6531e479687de8d195bd1605422735ca">libnet_get_hwaddr</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int8_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#66bfbb546b4a9fd49d446870b3b30bb0">libnet_hex_aton</a> (const char *s, int *len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#5264b060183d307688780bf862fae37c">libnet_version</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#9040018e0c1b2c795066941c0ebfc015">libnet_adv_cull_packet</a> (libnet_t *l, u_int8_t **packet, u_int32_t *packet_s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#e804d72696e8e050bd0893b1869b3126">libnet_adv_cull_header</a> (libnet_t *l, libnet_ptag_t ptag, u_int8_t **header, u_int32_t *header_s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#f70276132971083dba940f40b1487434">libnet_adv_write_link</a> (libnet_t *l, u_int8_t *packet, u_int32_t packet_s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#fa26941a0155d45914003642c6976ff4">libnet_adv_write_raw_ipv4</a> (libnet_t *l, u_int8_t *packet, u_int32_t packet_s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#b73eb15623b02971e5a45d8bf82fb9e2">libnet_adv_free_packet</a> (libnet_t *l, u_int8_t *packet)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#20887ffe940f1d2c5bcae79a188176c6">libnet_cq_add</a> (libnet_t *l, char *label)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#29f60504a0fe9b7bf6f5a962063118bb">libnet_cq_remove</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#4e972664a0d839eab039f8fb2379987a">libnet_cq_remove_by_label</a> (char *label)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#bb1341d217de4d9c39ec484951e518b0">libnet_cq_getlabel</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#0cd216f0e5563ee06043a8ebfa16fe57">libnet_cq_find_by_label</a> (char *label)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#565d99e292980d5033bef2d186596217">libnet_cq_destroy</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#7e98a045ac6e29ca421507d9a200b5aa">libnet_cq_head</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#ab1eb1e3ae64cde579a5a6035d5406c8">libnet_cq_last</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">libnet_t *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d312f3182e3e5367db87fc6bab32604d">libnet_cq_next</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#d2d4679155425c02822559bcb0caa275">libnet_cq_size</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#4846c3ce22db19195b235ad11d7c60ce">libnet_cq_end_loop</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#3aa6623246e13310dc6f9f9834e7313b">libnet_diag_dump_context</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#9825c6c69efd6ef24545d59177a333e6">libnet_diag_dump_pblock</a> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#053bcb30c956b858db88b9a551e9360b">libnet_diag_dump_pblock_type</a> (u_int8_t type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="libnet-functions_8h.html#862af1289e6eb7a930e18bf1f3008cd4">libnet_diag_dump_hex</a> (u_int8_t *packet, u_int32_t len, int swap, FILE *stream)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c6291524f1b552189f7b9e4846b281b7"></a><!-- doxytag: member="libnet-functions.h::libnet_write_raw_ipv4" ref="c6291524f1b552189f7b9e4846b281b7" args="(libnet_t *l, u_int8_t *packet, u_int32_t size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_write_raw_ipv4</b> (libnet_t *l, u_int8_t *packet, u_int32_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="87029099f6020c294b3cf068fc93aa83"></a><!-- doxytag: member="libnet-functions.h::libnet_write_raw_ipv6" ref="87029099f6020c294b3cf068fc93aa83" args="(libnet_t *l, u_int8_t *packet, u_int32_t size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_write_raw_ipv6</b> (libnet_t *l, u_int8_t *packet, u_int32_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a57648d63d646ac12a11664bd2299f46"></a><!-- doxytag: member="libnet-functions.h::libnet_write_link" ref="a57648d63d646ac12a11664bd2299f46" args="(libnet_t *l, u_int8_t *packet, u_int32_t size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_write_link</b> (libnet_t *l, u_int8_t *packet, u_int32_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9c939bfce1e95e6c4000543e4747bd25"></a><!-- doxytag: member="libnet-functions.h::libnet_open_raw4" ref="9c939bfce1e95e6c4000543e4747bd25" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_open_raw4</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="637b6c3d06ba0c7bb81641f95d9b9817"></a><!-- doxytag: member="libnet-functions.h::libnet_close_raw4" ref="637b6c3d06ba0c7bb81641f95d9b9817" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_close_raw4</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cfa541f84cd8b66fbfe88684920621dc"></a><!-- doxytag: member="libnet-functions.h::libnet_open_raw6" ref="cfa541f84cd8b66fbfe88684920621dc" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_open_raw6</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c26f71561c5a3069cb17681d02de15d2"></a><!-- doxytag: member="libnet-functions.h::libnet_close_raw6" ref="c26f71561c5a3069cb17681d02de15d2" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_close_raw6</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="848cce024af46ad0b283ae962379ee5c"></a><!-- doxytag: member="libnet-functions.h::libnet_select_device" ref="848cce024af46ad0b283ae962379ee5c" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_select_device</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d924dd4bcaaa9d9f1638232d69ab1b3c"></a><!-- doxytag: member="libnet-functions.h::libnet_open_link" ref="d924dd4bcaaa9d9f1638232d69ab1b3c" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_open_link</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="14ba6b1f8e79d6c1e8d0d398aa2300a4"></a><!-- doxytag: member="libnet-functions.h::libnet_close_link" ref="14ba6b1f8e79d6c1e8d0d398aa2300a4" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_close_link</b> (libnet_t *l)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6b12d8cbea884d95f2412d575e621111"></a><!-- doxytag: member="libnet-functions.h::libnet_do_checksum" ref="6b12d8cbea884d95f2412d575e621111" args="(libnet_t *l, u_int8_t *packet, int protocol, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_do_checksum</b> (libnet_t *l, u_int8_t *packet, int protocol, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b81e3002181cf2e8a51a671309b3d6d5"></a><!-- doxytag: member="libnet-functions.h::libnet_compute_crc" ref="b81e3002181cf2e8a51a671309b3d6d5" args="(u_int8_t *buf, u_int32_t len)" -->
u_int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_compute_crc</b> (u_int8_t *buf, u_int32_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad68626b3bc0b50f65483b4619e5da8f"></a><!-- doxytag: member="libnet-functions.h::libnet_ip_check" ref="ad68626b3bc0b50f65483b4619e5da8f" args="(u_int16_t *addr, int len)" -->
u_int16_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_ip_check</b> (u_int16_t *addr, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2502a9891ac25d3c402cced8c5f0eedf"></a><!-- doxytag: member="libnet-functions.h::libnet_in_cksum" ref="2502a9891ac25d3c402cced8c5f0eedf" args="(u_int16_t *addr, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_in_cksum</b> (u_int16_t *addr, int len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="054e1550e1d623fba97c726ec64859e3"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_probe" ref="054e1550e1d623fba97c726ec64859e3" args="(libnet_t *l, libnet_ptag_t ptag, u_int32_t n, u_int8_t type)" -->
libnet_pblock_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_probe</b> (libnet_t *l, libnet_ptag_t ptag, u_int32_t n, u_int8_t type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9d1e73c3c484d6d551a969adbbab930f"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_new" ref="9d1e73c3c484d6d551a969adbbab930f" args="(libnet_t *l, u_int32_t size)" -->
libnet_pblock_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_new</b> (libnet_t *l, u_int32_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d74cffce51462163ec68af50573148a8"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_swap" ref="d74cffce51462163ec68af50573148a8" args="(libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_swap</b> (libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0d9f18e13741c16a7b98fa5d8652995d"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_insert_before" ref="0d9f18e13741c16a7b98fa5d8652995d" args="(libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_insert_before</b> (libnet_t *l, libnet_ptag_t ptag1, libnet_ptag_t ptag2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6cfc6d31463e8067908ea5dac698de8"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_delete" ref="f6cfc6d31463e8067908ea5dac698de8" args="(libnet_t *l, libnet_pblock_t *p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_delete</b> (libnet_t *l, libnet_pblock_t *p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7fcaeb7aff418b7bff40c215c14aea00"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_update" ref="7fcaeb7aff418b7bff40c215c14aea00" args="(libnet_t *l, libnet_pblock_t *p, u_int32_t h, u_int8_t type)" -->
libnet_ptag_t&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_update</b> (libnet_t *l, libnet_pblock_t *p, u_int32_t h, u_int8_t type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8e66057916f11f48370be045ec95298"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_record_ip_offset" ref="b8e66057916f11f48370be045ec95298" args="(libnet_t *l, libnet_pblock_t *p)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_record_ip_offset</b> (libnet_t *l, libnet_pblock_t *p)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6bcc33ff1096bb349c8ffb70953acded"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_find" ref="6bcc33ff1096bb349c8ffb70953acded" args="(libnet_t *l, libnet_ptag_t ptag)" -->
libnet_pblock_t *&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_find</b> (libnet_t *l, libnet_ptag_t ptag)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74401cb87d63f054d17c902b1f93f000"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_append" ref="74401cb87d63f054d17c902b1f93f000" args="(libnet_t *l, libnet_pblock_t *p, u_int8_t *buf, u_int32_t len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_append</b> (libnet_t *l, libnet_pblock_t *p, u_int8_t *buf, u_int32_t len)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6f13ca22a18895085a1d338f2a302b4"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_setflags" ref="a6f13ca22a18895085a1d338f2a302b4" args="(libnet_pblock_t *p, u_int8_t flags)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_setflags</b> (libnet_pblock_t *p, u_int8_t flags)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90dfb2aae96e704a6960427737a749de"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_p2p" ref="90dfb2aae96e704a6960427737a749de" args="(u_int8_t type)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_p2p</b> (u_int8_t type)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="663b7e70c92a388ceac0c1bb16441182"></a><!-- doxytag: member="libnet-functions.h::libnet_pblock_coalesce" ref="663b7e70c92a388ceac0c1bb16441182" args="(libnet_t *l, u_int8_t **packet, u_int32_t *size)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_pblock_coalesce</b> (libnet_t *l, u_int8_t **packet, u_int32_t *size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d71dbbd506317e90548aa4600b5d62c4"></a><!-- doxytag: member="libnet-functions.h::libnet_check_iface" ref="d71dbbd506317e90548aa4600b5d62c4" args="(libnet_t *l)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>libnet_check_iface</b> (libnet_t *l)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1dc04717e621f421d7edc848183f8549"></a><!-- doxytag: member="libnet-functions.h::in6addr_error" ref="1dc04717e621f421d7edc848183f8549" args="" -->
struct libnet_in6_addr&nbsp;</td><td class="memItemRight" valign="bottom"><b>in6addr_error</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
libnet exported function prototypes 
<p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="65cea3a63aac7a17f681ab15fcfd2947"></a><!-- doxytag: member="libnet-functions.h::libnet_addr2name4" ref="65cea3a63aac7a17f681ab15fcfd2947" args="(u_int32_t in, u_int8_t use_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* libnet_addr2name4           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>use_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a network byte ordered IPv4 address and returns a pointer to either a canonical DNS name (if it has one) or a string of dotted decimals. This may incur a DNS lookup if the hostname and mode is set to LIBNET_RESOLVE. If mode is set to LIBNET_DONT_RESOLVE, no DNS lookup will be performed and the function will return a pointer to a dotted decimal string. The function cannot fail -- if no canonical name exists, it will fall back on returning a dotted decimal string. This function is non-reentrant. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in</em>&nbsp;</td><td>network byte ordered IPv4 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_name</em>&nbsp;</td><td>LIBNET_RESOLVE or LIBNET_DONT_RESOLVE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to presentation format string </dd></dl>

</div>
</div><p>
<a class="anchor" name="221ab1d86e36a0b1411eebdbea0cd012"></a><!-- doxytag: member="libnet-functions.h::libnet_addr2name6_r" ref="221ab1d86e36a0b1411eebdbea0cd012" args="(struct libnet_in6_addr addr, u_int8_t use_name, char *host_name, int host_name_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_addr2name6_r           </td>
          <td>(</td>
          <td class="paramtype">struct libnet_in6_addr&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>use_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>host_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>host_name_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Should document this baby right here. 
</div>
</div><p>
<a class="anchor" name="e804d72696e8e050bd0893b1869b3126"></a><!-- doxytag: member="libnet-functions.h::libnet_adv_cull_header" ref="e804d72696e8e050bd0893b1869b3126" args="(libnet_t *l, libnet_ptag_t ptag, u_int8_t **header, u_int32_t *header_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_adv_cull_header           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t **&nbsp;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t *&nbsp;</td>
          <td class="paramname"> <em>header_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Advanced Interface] Pulls the header from the specified ptag from the given libnet context. This function is part of the advanced interface and is only available when libnet is initialized in advanced mode. If the function fails <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> can tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>the ptag referencing the header to pull </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header</em>&nbsp;</td><td>will contain the header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>header_s</em>&nbsp;</td><td>will contain the header size </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="9040018e0c1b2c795066941c0ebfc015"></a><!-- doxytag: member="libnet-functions.h::libnet_adv_cull_packet" ref="9040018e0c1b2c795066941c0ebfc015" args="(libnet_t *l, u_int8_t **packet, u_int32_t *packet_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_adv_cull_packet           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t **&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t *&nbsp;</td>
          <td class="paramname"> <em>packet_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Advanced Interface] Yanks a prebuilt, wire-ready packet from the given libnet context. If libnet was configured to do so (which it is by default) the packet will have all checksums written in. This function is part of the advanced interface and is only available when libnet is initialized in advanced mode. It is important to note that the function performs an implicit malloc() and a corresponding call to <a class="el" href="libnet-functions_8h.html#b73eb15623b02971e5a45d8bf82fb9e2">libnet_adv_free_packet()</a> should be made to free the memory packet occupies. If the function fails <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> can tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>will contain the wire-ready packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet_s</em>&nbsp;</td><td>will contain the packet size </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="b73eb15623b02971e5a45d8bf82fb9e2"></a><!-- doxytag: member="libnet-functions.h::libnet_adv_free_packet" ref="b73eb15623b02971e5a45d8bf82fb9e2" args="(libnet_t *l, u_int8_t *packet)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_adv_free_packet           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>packet</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Advanced Interface] Frees the memory allocated when <a class="el" href="libnet-functions_8h.html#9040018e0c1b2c795066941c0ebfc015">libnet_adv_cull_packet()</a> is called. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>a pointer to the packet to free </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f70276132971083dba940f40b1487434"></a><!-- doxytag: member="libnet-functions.h::libnet_adv_write_link" ref="f70276132971083dba940f40b1487434" args="(libnet_t *l, u_int8_t *packet, u_int32_t packet_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_adv_write_link           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>packet_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Advanced Interface] Writes a packet the network at the link layer. This function is useful to write a packet that has been constructed by hand by the application programmer or, more commonly, to write a packet that has been returned by a call to <a class="el" href="libnet-functions_8h.html#9040018e0c1b2c795066941c0ebfc015">libnet_adv_cull_packet()</a>. This function is part of the advanced interface and is only available when libnet is initialized in advanced mode. If the function fails <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> can tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>a pointer to the packet to inject </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet_s</em>&nbsp;</td><td>the size of the packet </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written, or -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="fa26941a0155d45914003642c6976ff4"></a><!-- doxytag: member="libnet-functions.h::libnet_adv_write_raw_ipv4" ref="fa26941a0155d45914003642c6976ff4" args="(libnet_t *l, u_int8_t *packet, u_int32_t packet_s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_adv_write_raw_ipv4           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>packet_s</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Advanced Interface] Writes a packet the network at the raw socket layer. This function is useful to write a packet that has been constructed by hand by the application programmer or, more commonly, to write a packet that has been returned by a call to <a class="el" href="libnet-functions_8h.html#9040018e0c1b2c795066941c0ebfc015">libnet_adv_cull_packet()</a>. This function is part of the advanced interface and is only available when libnet is initialized in advanced mode. If the function fails <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> can tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>a pointer to the packet to inject </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>packet_s</em>&nbsp;</td><td>the size of the packet </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written, or -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="c2ac4909b3657c4ac34c80dbc9f91abe"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_arp" ref="c2ac4909b3657c4ac34c80dbc9f91abe" args="(u_int16_t op, u_int8_t *sha, u_int8_t *spa, u_int8_t *tha, u_int8_t *tpa, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_arp           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>sha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>spa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>tha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>tpa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Autouilds an Address Resolution Protocol (ARP) header. Depending on the op value, the function builds one of several different types of RFC 826 or RFC 903 RARP packets. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>ARP operation type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sha</em>&nbsp;</td><td>sender's hardware address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spa</em>&nbsp;</td><td>sender's protocol address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tha</em>&nbsp;</td><td>target hardware address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpa</em>&nbsp;</td><td>targer protocol address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ab98b1c67ac61b39b646ecfd93d58e3"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_ethernet" ref="0ab98b1c67ac61b39b646ecfd93d58e3" args="(u_int8_t *dst, u_int16_t type, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_ethernet           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Autobuilds an Ethernet header. The RFC 894 Ethernet II header is almost identical to the IEEE 802.3 header, with the exception that the field immediately following the source address holds the layer 3 protocol (as opposed to frame's length). You should only use this function when libnet is initialized with the LIBNET_LINK interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="2a0f9f03a1c43253638ecb07dfc2bb62"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_fddi" ref="2a0f9f03a1c43253638ecb07dfc2bb62" args="(u_int8_t fc, u_int8_t *dst, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_fddi           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Autobuilds a Fiber Distributed Data Interface (FDDI) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fc</em>&nbsp;</td><td>class format and priority </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination fddi address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cf</em>&nbsp;</td><td>cf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>IEEE organizational code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcef75c186b4db27f13a29c38b8f40ec"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_ipv4" ref="bcef75c186b4db27f13a29c38b8f40ec" args="(u_int16_t len, u_int8_t prot, u_int32_t dst, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_ipv4           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Autobuilds a version 4 Internet Protocol (IP) header. The function is useful to build an IP header quickly when you do not need a granular level of control. The function takes the same len, prot, and dst arguments as <a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4()</a>. The function does not accept a ptag argument, but it does return a ptag. In other words, you can use it to build a new IP header but not to modify an existing one. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the IP packet including all subsequent data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prot</em>&nbsp;</td><td>upper layer protocol </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination IPv4 address (little endian) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="f21186614be986ab83740275bb984426"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_ipv6" ref="f21186614be986ab83740275bb984426" args="(u_int16_t len, u_int8_t nh, struct libnet_in6_addr dst, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_ipv6           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct libnet_in6_addr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is not yet implement and is a NOOP. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination IPv6 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="3e21b6aaf8a1c690b6dca96c410083ee"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_link" ref="3e21b6aaf8a1c690b6dca96c410083ee" args="(u_int8_t *dst, u_int8_t *oui, u_int16_t type, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_link           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Automatically builds a link layer header for an initialized l. The function determines the proper link layer header format from how l was initialized. The function current supports Ethernet and Token Ring link layers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>the destination MAC address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>Organizationally Unique Identifier (unused for Ethernet) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="e2962f923beabedfe761dcd97cf41e87"></a><!-- doxytag: member="libnet-functions.h::libnet_autobuild_token_ring" ref="e2962f923beabedfe761dcd97cf41e87" args="(u_int8_t ac, u_int8_t fc, u_int8_t *dst, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_autobuild_token_ring           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Auto-builds a token ring header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>access control </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fc</em>&nbsp;</td><td>frame control </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cf</em>&nbsp;</td><td>control field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>Organizationally Unique Identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="60a223766dc718c544ec500b0829d39e"></a><!-- doxytag: member="libnet-functions.h::libnet_build_802_1q" ref="60a223766dc718c544ec500b0829d39e" args="(u_int8_t *dst, u_int8_t *src, u_int16_t tpi, u_int8_t priority, u_int8_t cfi, u_int16_t vlan_id, u_int16_t len_proto, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_802_1q           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>tpi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cfi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>vlan_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len_proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<h2><a class="anchor" name="PBF">
Packet Builder Functions</a></h2>
The core of libnet is the platform-independent packet-building functionality. These functions enable an application programmer to build protocol headers (and data) in a simple and consistent manner without having to worry (too much) about low-level network odds and ends. Each libnet_build() function builds a piece of a packet (generally a protocol header). While it is perfectly possible to build an entire, ready-to-transmit packet with a single call to a libnet_build() function, generally more than one builder-class function call is required to construct a full packet. A complete wire-ready packet generally consists of more than one piece. Every function that builds a protocol header takes a series of arguments roughly corresponding to the header values as they appear on the wire. This process is intuitive but often makes for functions with huge prototypes and large stack frames. One important thing to note is that you must call these functions in order, corresponding to how they should appear on the wire (from the highest protocol layer on down). This building process is intuitive; it approximates what happens in an operating system kernel. In other words, to build a Network Time Protocol (NTP) packet by using the link-layer interface, the application programmer would call the libnet_build() functions in the following order: 1. <a class="el" href="libnet-functions_8h.html#a18676bbed2910988a65ace745226301">libnet_build_ntp()</a> 2. <a class="el" href="libnet-functions_8h.html#6d3f91d01237eef2f82ffd322ecbc792">libnet_build_udp()</a> 3. <a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4()</a> 4. <a class="el" href="libnet-functions_8h.html#b8a60ba5d3c669a1439ace4f91ee52e0">libnet_build_ethernet()</a> This ordering is essential for libnet 1.1.x to properly link together the packet internally (previous libnet versions did not have the requirement).<h3><a class="anchor" name="TPI">
The Payload Interface</a></h3>
The payload interface specifies an optional way to include data directly after the protocol header in question. You can use this function for a variety of purposes, including the following:<ul>
<li>Including additional or arbitrary protocol header information that is not available from a libnet interface</li><li>Including a packet payload (data segment)</li><li>Building another protocol header that is not available from a libnet interface To employ the interface, the application programmer should construct the i payload data and pass a u_int8_t * to this data and its size to the desired libnet_build() function. Libnet handles the rest.</li></ul>
<p>
It is important to note that some functions (notably the IPv6 builders) do use the payload interface to specify variable length but ostensibly non-optional data. See the individual libnet_build_ipv6*() functions for more information.<h3><a class="anchor" name="PT">
Protocol Tags and Packet Builder Return Values</a></h3>
Libnet uses the protocol tag (ptag) to identify individual pieces of a packet after being created. A new ptag results every time a libnet_build() function with an empty (0) ptag argument completes successfully. This new ptag now refers to the packet piece just created. The application programmer's responsibility is to save this value if he or she plans to modify this particular portion later on in the program. If the application programmer needs to modify some portion of that particular packet piece again, he or she calls the same libnet_build() function specifying the saved ptag argument. Libnet then searches for that packet piece and modifies it rather than creating a new one. Upon failure for any reason, libnet_build() functions return -1; <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> tells you why. Builds an IEEE 802.1q VLAN tagging header. Depending on the value of len_proto, the function wraps the 802.1q header inside either an IEEE 802.3 header or an RFC 894 Ethernet II (DIX) header (both resulting in an 18-byte frame). If len is 1500 or less, most receiving protocol stacks parse the frame as an IEEE 802.3 encapsulated frame. If len is one of the Ethernet type values, most protocol stacks parse the frame as an RFC 894 Ethernet II encapsulated frame. Note the length value is calculated without the 802.1q header of 18 bytes. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>pointer to a six byte source ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>pointer to a six byte destination ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpi</em>&nbsp;</td><td>tag protocol identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>priority </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cfi</em>&nbsp;</td><td>canonical format indicator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vlan_id</em>&nbsp;</td><td>vlan identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len_proto</em>&nbsp;</td><td>length (802.3) protocol (Ethernet II) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e2ba82d84c8af087e53c60cb2cf0f16"></a><!-- doxytag: member="libnet-functions.h::libnet_build_802_1x" ref="2e2ba82d84c8af087e53c60cb2cf0f16" args="(u_int8_t eap_ver, u_int8_t eap_type, u_int16_t length, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_802_1x           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>eap_ver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>eap_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.1x extended authentication protocol header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eap_ver</em>&nbsp;</td><td>the EAP version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eap_type</em>&nbsp;</td><td>the EAP type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>frame length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="df241a95102fc267d0a20a1a73f0c5f1"></a><!-- doxytag: member="libnet-functions.h::libnet_build_802_2" ref="df241a95102fc267d0a20a1a73f0c5f1" args="(u_int8_t dsap, u_int8_t ssap, u_int8_t control, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_802_2           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.2 LLC header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>control</em>&nbsp;</td><td>control field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="997b6c996b95fbcb09f87a0caf12ffa0"></a><!-- doxytag: member="libnet-functions.h::libnet_build_802_2snap" ref="997b6c996b95fbcb09f87a0caf12ffa0" args="(u_int8_t dsap, u_int8_t ssap, u_int8_t control, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_802_2snap           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.2 LLC SNAP header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>control</em>&nbsp;</td><td>control field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>Organizationally Unique Identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="55367f2634cf6409bbda8bbf5b834877"></a><!-- doxytag: member="libnet-functions.h::libnet_build_802_3" ref="55367f2634cf6409bbda8bbf5b834877" args="(u_int8_t *dst, u_int8_t *src, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_802_3           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.3 header. The 802.3 header is almost identical to the RFC 894 Ethernet II header, the exception being that the field immediately following the source address holds the frame's length (as opposed to the layer 3 protocol). You should only use this function when libnet is initialized with the LIBNET_LINK interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>frame length sans header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="65c81208185c68937ef97c0203d3d924"></a><!-- doxytag: member="libnet-functions.h::libnet_build_arp" ref="65c81208185c68937ef97c0203d3d924" args="(u_int16_t hrd, u_int16_t pro, u_int8_t hln, u_int8_t pln, u_int16_t op, u_int8_t *sha, u_int8_t *spa, u_int8_t *tha, u_int8_t *tpa, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_arp           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>hrd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>pro</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>pln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>sha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>spa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>tha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>tpa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Address Resolution Protocol (ARP) header. Depending on the op value, the function builds one of several different types of RFC 826 or RFC 903 RARP packets. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hrd</em>&nbsp;</td><td>hardware address format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pro</em>&nbsp;</td><td>protocol address format </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hln</em>&nbsp;</td><td>hardware address length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pln</em>&nbsp;</td><td>protocol address length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>op</em>&nbsp;</td><td>ARP operation type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sha</em>&nbsp;</td><td>sender's hardware address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spa</em>&nbsp;</td><td>sender's protocol address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tha</em>&nbsp;</td><td>target hardware address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tpa</em>&nbsp;</td><td>targer protocol address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d7fd09f44af695b543beaff7abd2c1c"></a><!-- doxytag: member="libnet-functions.h::libnet_build_bgp4_header" ref="5d7fd09f44af695b543beaff7abd2c1c" args="(u_int8_t marker[LIBNET_BGP4_MARKER_SIZE], u_int16_t len, u_int8_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_bgp4_header           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>marker</em>[LIBNET_BGP4_MARKER_SIZE], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) header. The primary function of a BGP speaking system is to exchange network reachability information with other BGP systems. This network reachability information includes information on the list of Autonomous Systems (ASs) that reachability information traverses. This information is sufficient to construct a graph of AS connectivity from which routing loops may be pruned and some policy decisions at the AS level may be enforced. This function builds the base BGP header which is used as a preamble before any other BGP header. For example, a BGP KEEPALIVE message may be built with only this function, while an error notification requires a subsequent call to libnet_build_bgp4_notification. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>marker</em>&nbsp;</td><td>a value the receiver can predict (if the message type is not BGP OPEN, or no authentication is used, these 16 bytes are normally set as all ones) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the BGP message, including the header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type code of the message (OPEN, UPDATE, NOTIFICATION or KEEPALIVE) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="1ba1e13d1fc8cc089ddd7931a6890d2b"></a><!-- doxytag: member="libnet-functions.h::libnet_build_bgp4_notification" ref="1ba1e13d1fc8cc089ddd7931a6890d2b" args="(u_int8_t err_code, u_int8_t err_subcode, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_bgp4_notification           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>err_code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>err_subcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) notification header. A NOTIFICATION message is sent when an error condition is detected. Specific error information may be passed through the payload interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>err_code</em>&nbsp;</td><td>type of notification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err_subcode</em>&nbsp;</td><td>more specific information about the reported error. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="9f5e3e137a1290437eb54ead063821f8"></a><!-- doxytag: member="libnet-functions.h::libnet_build_bgp4_open" ref="9f5e3e137a1290437eb54ead063821f8" args="(u_int8_t version, u_int16_t src_as, u_int16_t hold_time, u_int32_t bgp_id, u_int8_t opt_len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_bgp4_open           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>src_as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>hold_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>bgp_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) OPEN header. This is the first message sent by each side of a BGP connection. The optional parameters options should be constructed using the payload interface (see RFC 1771 for the options structures). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>protocol version (should be set to 4) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src_as</em>&nbsp;</td><td>Autonomous System of the sender </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hold_time</em>&nbsp;</td><td>used to compute the maximum allowed time between the receipt of KEEPALIVE, and/or UPDATE messages by the sender </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bgp_id</em>&nbsp;</td><td>BGP identifier of the sender </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opt_len</em>&nbsp;</td><td>total length of the optional parameters field in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="213d5a264ea39a17fc0fc9edb3aac30c"></a><!-- doxytag: member="libnet-functions.h::libnet_build_bgp4_update" ref="213d5a264ea39a17fc0fc9edb3aac30c" args="(u_int16_t unfeasible_rt_len, u_int8_t *withdrawn_rt, u_int16_t total_path_attr_len, u_int8_t *path_attributes, u_int16_t info_len, u_int8_t *reachability_info, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_bgp4_update           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>unfeasible_rt_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>withdrawn_rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>total_path_attr_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>path_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>info_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>reachability_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1771 Border Gateway Protocol 4 (BGP-4) update header. Update messages are used to transfer routing information between BGP peers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>unfeasible_rt_len</em>&nbsp;</td><td>indicates the length of the (next) "withdrawn routes" field in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>withdrawn_rt</em>&nbsp;</td><td>list of IP addresses prefixes for the routes that are being withdrawn; each IP address prefix is built as a 2-tuple &lt;length (1 byte), prefix (variable)&gt; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>total_path_attr_len</em>&nbsp;</td><td>indicates the length of the (next) "path attributes" field in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>path_attributes</em>&nbsp;</td><td>each attribute is a 3-tuple &lt;type (2 bytes), length, value&gt; </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>info_len</em>&nbsp;</td><td>indicates the length of the (next) "network layer reachability information" field in bytes (needed for internal memory size calculation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reachability_info</em>&nbsp;</td><td>2-tuples &lt;length (1 byte), prefix (variable)&gt;. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="37164c33698bd0c59cd51393a1fdfae6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_bootpv4" ref="37164c33698bd0c59cd51393a1fdfae6" args="(u_int8_t opcode, u_int8_t htype, u_int8_t hlen, u_int8_t hopcount, u_int32_t xid, u_int16_t secs, u_int16_t flags, u_int32_t cip, u_int32_t yip, u_int32_t sip, u_int32_t gip, u_int8_t *chaddr, u_int8_t *sname, u_int8_t *file, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_bootpv4           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>htype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hopcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>secs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>cip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>yip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>sip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>gip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>chaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>sname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opcode</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>htype</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hlen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hopcount</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xid</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>secs</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chaddr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sname</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="e16743df24525d5ab9b4c1ef13e87423"></a><!-- doxytag: member="libnet-functions.h::libnet_build_cdp" ref="e16743df24525d5ab9b4c1ef13e87423" args="(u_int8_t version, u_int8_t ttl, u_int16_t sum, u_int16_t type, u_int16_t len, u_int8_t *value, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_cdp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a Cisco Discovery Protocol (CDP) header. Cisco Systems designed CDP to aid in the network management of adjacent Cisco devices. The CDP protocol specifies data by using a type/length/value (TLV) setup. The first TLV can specified by using the functions type, length, and value arguments. To specify additional TLVs, the programmer could either use the payload interface or <a class="el" href="libnet-functions_8h.html#cb56eccdd9d924cd3a81affdbef4cf30">libnet_build_data()</a> to construct them. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>CDP version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ttl</em>&nbsp;</td><td>time to live (time information should be cached by recipient) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of data contained in value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of value arugment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>the CDP information string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="cb56eccdd9d924cd3a81affdbef4cf30"></a><!-- doxytag: member="libnet-functions.h::libnet_build_data" ref="cb56eccdd9d924cd3a81affdbef4cf30" args="(u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_data           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a generic libnet protocol header. This is useful for including an optional payload to a packet that might need to change repeatedly inside of a loop. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="20d397bac4d614e395878f239d26d4dc"></a><!-- doxytag: member="libnet-functions.h::libnet_build_dhcpv4" ref="20d397bac4d614e395878f239d26d4dc" args="(u_int8_t opcode, u_int8_t htype, u_int8_t hlen, u_int8_t hopcount, u_int32_t xid, u_int16_t secs, u_int16_t flags, u_int32_t cip, u_int32_t yip, u_int32_t sip, u_int32_t gip, u_int8_t *chaddr, u_int8_t *sname, u_int8_t *file, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_dhcpv4           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>htype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hopcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>secs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>cip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>yip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>sip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>gip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>chaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>sname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>opcode</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>htype</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hlen</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hopcount</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xid</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>secs</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gip</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chaddr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sname</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>file</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="98bc91a6c39910ee6069d789d8dcd3e6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_dnsv4" ref="98bc91a6c39910ee6069d789d8dcd3e6" args="(u_int16_t h_len, u_int16_t id, u_int16_t flags, u_int16_t num_q, u_int16_t num_anws_rr, u_int16_t num_auth_rr, u_int16_t num_addi_rr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_dnsv4           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>h_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>num_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>num_anws_rr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>num_auth_rr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>num_addi_rr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1035 version 4 DNS header. Additional DNS payload information should be specified using the payload interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>h_len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>DNS packet id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>control flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_q</em>&nbsp;</td><td>number of questions </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_anws_rr</em>&nbsp;</td><td>number of answer resource records </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_auth_rr</em>&nbsp;</td><td>number of authority resource records </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_addi_rr</em>&nbsp;</td><td>number of additional resource records </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="e8c54127e49779805cedf46506f564d4"></a><!-- doxytag: member="libnet-functions.h::libnet_build_egre" ref="e8c54127e49779805cedf46506f564d4" args="(u_int16_t fv, u_int16_t type, u_int16_t sum, u_int16_t offset, u_int32_t key, u_int32_t seq, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_egre           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any protocol. Hence, the IP part of the packet is usually referred as "delivery header". It is then followed by the GRE header and finally the encapsulated packet (IP or whatever). As GRE is very modular, the first GRE header describes the structure of the header, using bits and flag to specify which fields will be present in the header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>the 16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...), bits 8 to 12: flag, bits 13 to 15: version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>which protocol is encapsulated (PPP, IP, ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>byte offset from the start of the routing field to the first byte of the SRE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>inserted by the encapsulator to authenticate the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence number used by the receiver to sort the packets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>size of the GRE packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8a60ba5d3c669a1439ace4f91ee52e0"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ethernet" ref="b8a60ba5d3c669a1439ace4f91ee52e0" args="(u_int8_t *dst, u_int8_t *src, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ethernet           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Ethernet header. The RFC 894 Ethernet II header is almost identical to the IEEE 802.3 header, with the exception that the field immediately following the source address holds the layer 3 protocol (as opposed to frame's length). You should only use this function when libnet is initialized with the LIBNET_LINK interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source ethernet address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fb726d9841fa180bd79ab0a6362f533"></a><!-- doxytag: member="libnet-functions.h::libnet_build_fddi" ref="2fb726d9841fa180bd79ab0a6362f533" args="(u_int8_t fc, u_int8_t *dst, u_int8_t *src, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_fddi           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a Fiber Distributed Data Interface (FDDI) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fc</em>&nbsp;</td><td>class format and priority </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination fddi address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source fddi address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cf</em>&nbsp;</td><td>cf </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>3 byte IEEE organizational code </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="fff121ac7bc157e3df0eb1bd624263c1"></a><!-- doxytag: member="libnet-functions.h::libnet_build_gre" ref="fff121ac7bc157e3df0eb1bd624263c1" args="(u_int16_t fv, u_int16_t type, u_int16_t sum, u_int16_t offset, u_int32_t key, u_int32_t seq, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_gre           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>fv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generic Routing Encapsulation (GRE - RFC 1701) is used to encapsulate any protocol. Hence, the IP part of the packet is usually referred as "delivery header". It is then followed by the GRE header and finally the encapsulated packet (IP or whatever). As GRE is very modular, the first GRE header describes the structure of the header, using bits and flag to specify which fields will be present in the header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>the 16 0 to 7: which fields are included in the header (checksum, seq. number, key, ...), bits 8 to 12: flag, bits 13 to 15: version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>which protocol is encapsulated (PPP, IP, ...) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>byte offset from the start of the routing field to the first byte of the SRE </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>inserted by the encapsulator to authenticate the source </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence number used by the receiver to sort the packets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>size of the GRE packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="578594ad820ae9d82fe3f9ea470f0b27"></a><!-- doxytag: member="libnet-functions.h::libnet_build_gre_last_sre" ref="578594ad820ae9d82fe3f9ea470f0b27" args="(libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_gre_last_sre           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="7cca16e4e1b5ca96a1b0a35a2b766710"></a><!-- doxytag: member="libnet-functions.h::libnet_build_gre_sre" ref="7cca16e4e1b5ca96a1b0a35a2b766710" args="(u_int16_t af, u_int8_t offset, u_int8_t length, u_int8_t *routing, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_gre_sre           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>routing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>routing</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="69bf76db8b62ec812cb734965c31eb46"></a><!-- doxytag: member="libnet-functions.h::libnet_build_hsrp" ref="69bf76db8b62ec812cb734965c31eb46" args="(u_int8_t version, u_int8_t opcode, u_int8_t state, u_int8_t hello_time, u_int8_t hold_time, u_int8_t priority, u_int8_t group, u_int8_t reserved, u_int8_t authdata[HSRP_AUTHDATA_LENGTH], u_int32_t virtual_ip, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_hsrp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hello_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hold_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>reserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>authdata</em>[HSRP_AUTHDATA_LENGTH], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>virtual_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a HSRP header. HSRP is a Cisco propietary protocol defined in RFC 2281 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>version of the HSRP messages </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opcode</em>&nbsp;</td><td>type of message </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>current state of the router </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hello_time</em>&nbsp;</td><td>period in seconds between hello messages </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hold_time</em>&nbsp;</td><td>seconds that the current hello message is valid </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>priority for the election proccess </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>group</em>&nbsp;</td><td>standby group </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reserved</em>&nbsp;</td><td>reserved field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>authdata</em>&nbsp;</td><td>password </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>virtual_ip</em>&nbsp;</td><td>virtual ip address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="b80f86d2cbf32126fe5952cc77d7c512"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_echo" ref="b80f86d2cbf32126fe5952cc77d7c512" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_echo           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) echo request/reply header <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_ECHOREPLY or ICMP_ECHO) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>identification number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>packet sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="58605cfff0090e3cbf26abd5b7194c16"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_mask" ref="58605cfff0090e3cbf26abd5b7194c16" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, u_int32_t mask, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_mask           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) IP netmask request/reply header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_MASKREQ or ICMP_MASKREPLY) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>identification number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>packet sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>subnet mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="973112121198b7151d21ab7285f6ae34"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_redirect" ref="973112121198b7151d21ab7285f6ae34" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int32_t gateway, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_redirect           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>gateway</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Message Control Protocol (ICMP) redirect header. The IP header that caused the error message should be built by a previous call to <a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_REDIRECT) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (should be one of the four redirect codes) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gateway</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="87fd21c0e964dc0e2f8866178240db39"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_timeexceed" ref="87fd21c0e964dc0e2f8866178240db39" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_timeexceed           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) time exceeded header. The IP header that caused the error message should be built by a previous call to <a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_TIMXCEED) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (ICMP_TIMXCEED_INTRANS / ICMP_TIMXCEED_REASS) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="512a61266327928df97b010bc3f821b6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_timestamp" ref="512a61266327928df97b010bc3f821b6" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int16_t id, u_int16_t seq, n_time otime, n_time rtime, n_time ttime, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_timestamp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">n_time&nbsp;</td>
          <td class="paramname"> <em>otime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">n_time&nbsp;</td>
          <td class="paramname"> <em>rtime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">n_time&nbsp;</td>
          <td class="paramname"> <em>ttime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) timestamp request/reply header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_TSTAMP or ICMP_TSTAMPREPLY) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>identification number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>otime</em>&nbsp;</td><td>originate timestamp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rtime</em>&nbsp;</td><td>receive timestamp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ttime</em>&nbsp;</td><td>transmit timestamp </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="d8e682f057f00dc53fe82960d7893b3f"></a><!-- doxytag: member="libnet-functions.h::libnet_build_icmpv4_unreach" ref="d8e682f057f00dc53fe82960d7893b3f" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_icmpv4_unreach           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IP version 4 RFC 792 Internet Control Message Protocol (ICMP) unreachable header. The IP header that caused the error message should be built by a previous call to <a class="el" href="libnet-functions_8h.html#ace7ef7ee9dab7064eafc703bbd51c02">libnet_build_ipv4()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of ICMP packet (should be ICMP_UNREACH) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>code of ICMP packet (should be one of the 16 unreachable codes) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="d614cefecf7ffbabdf241e707c474575"></a><!-- doxytag: member="libnet-functions.h::libnet_build_igmp" ref="d614cefecf7ffbabdf241e707c474575" args="(u_int8_t type, u_int8_t code, u_int16_t sum, u_int32_t ip, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_igmp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 1112 Internet Group Memebership Protocol (IGMP) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>packet type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>code</em>&nbsp;</td><td>packet code (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ip</em>&nbsp;</td><td>IPv4 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ad130b6104956524af16fcb18fa759e9"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipsec_ah" ref="ad130b6104956524af16fcb18fa759e9" args="(u_int8_t nh, u_int8_t len, u_int16_t res, u_int32_t spi, u_int32_t seq, u_int32_t auth, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipsec_ah           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Internet Protocol Security Authentication header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>payload length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>res</em>&nbsp;</td><td>reserved </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>security parameter index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth</em>&nbsp;</td><td>authentication data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="47d4aa351486618f993ed6e2652681b1"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipsec_esp_ftr" ref="47d4aa351486618f993ed6e2652681b1" args="(u_int8_t len, u_int8_t nh, int8_t *auth, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipsec_esp_ftr           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&nbsp;</td>
          <td class="paramname"> <em>auth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Internet Protocol Security Encapsulating Security Payload footer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>padding length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth</em>&nbsp;</td><td>authentication data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="7080bea55af439f0e74031197bc0924c"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipsec_esp_hdr" ref="7080bea55af439f0e74031197bc0924c" args="(u_int32_t spi, u_int32_t seq, u_int32_t iv, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipsec_esp_hdr           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>spi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Internet Protocol Security Encapsulating Security Payload header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>spi</em>&nbsp;</td><td>security parameter index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>ESP sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>iv</em>&nbsp;</td><td>initialization vector </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ace7ef7ee9dab7064eafc703bbd51c02"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv4" ref="ace7ef7ee9dab7064eafc703bbd51c02" args="(u_int16_t ip_len, u_int8_t tos, u_int16_t id, u_int16_t frag, u_int8_t ttl, u_int8_t prot, u_int16_t sum, u_int32_t src, u_int32_t dst, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv4           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>ip_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>frag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 4 RFC 791 Internet Protocol (IP) header.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ip_len</em>&nbsp;</td><td>total length of the IP packet including all subsequent data (subsequent data includes any IP options and IP options padding) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tos</em>&nbsp;</td><td>type of service bits </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>IP identification number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frag</em>&nbsp;</td><td>fragmentation bits and offset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ttl</em>&nbsp;</td><td>time to live in the network </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prot</em>&nbsp;</td><td>upper layer protocol </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source IPv4 address (little endian) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination IPv4 address (little endian) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="f5a9b52bc56903e3c71b3ae155ffc1df"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv4_options" ref="f5a9b52bc56903e3c71b3ae155ffc1df" args="(u_int8_t *options, u_int32_t options_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv4_options           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>options_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an version 4 Internet Protocol (IP) options header. The function expects options to be a valid IP options string of size options_s, no larger than 40 bytes (the maximum size of an options string).<p>
When building a chain, the options must be built, then the IPv4 header.<p>
When updating a chain, if the block following the options is an IPv4 header, it's total length and header length will be updated if the options block size changes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>byte string of IP options (it will be padded up to be an integral multiple of 32-bit words). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options_s</em>&nbsp;</td><td>length of options string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="844fc0a5b0f5acf57cbe4c9f42a1125c"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv6" ref="844fc0a5b0f5acf57cbe4c9f42a1125c" args="(u_int8_t tc, u_int32_t fl, u_int16_t len, u_int8_t nh, u_int8_t hl, struct libnet_in6_addr src, struct libnet_in6_addr dst, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv6           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>tc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>fl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>hl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct libnet_in6_addr&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct libnet_in6_addr&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 6 RFC 2460 Internet Protocol (IP) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tc</em>&nbsp;</td><td>traffic class </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fl</em>&nbsp;</td><td>flow label </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the IP packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hl</em>&nbsp;</td><td>hop limit </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source IPv6 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination IPv6 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5695b5f8419b440d41bbac0aaa34564"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv6_destopts" ref="a5695b5f8419b440d41bbac0aaa34564" args="(u_int8_t nh, u_int8_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv6_destopts           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 6 RFC 2460 Internet Protocol (IP) destination options header. This function is special in that it uses the payload interface to include the options data. The application programmer will build an IPv6 options byte string and pass it to the function using the payload interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the header in 8-byte octets not including the first 8 octets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>options payload </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c65244937ef5bc8e84efa5fe54aaac9"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv6_frag" ref="6c65244937ef5bc8e84efa5fe54aaac9" args="(u_int8_t nh, u_int8_t reserved, u_int16_t frag, u_int32_t id, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv6_frag           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>reserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>frag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 6 RFC 2460 Internet Protocol (IP) fragmentation header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reserved</em>&nbsp;</td><td>unused value... OR IS IT! </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>frag</em>&nbsp;</td><td>fragmentation bits (ala ipv4) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>packet identification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="db7b7870cc626d8d67f723de286034a9"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv6_hbhopts" ref="db7b7870cc626d8d67f723de286034a9" args="(u_int8_t nh, u_int8_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv6_hbhopts           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 6 RFC 2460 Internet Protocol (IP) hop by hop options header. This function is special in that it uses the payload interface to include the options data. The application programmer will build an IPv6 hop by hop options byte string and pass it to the function using the payload interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the header in 8-byte octets not including the first 8 octets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>options payload </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ccf52055b316417674bfcb76f85d6227"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ipv6_routing" ref="ccf52055b316417674bfcb76f85d6227" args="(u_int8_t nh, u_int8_t len, u_int8_t rtype, u_int8_t segments, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ipv6_routing           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>nh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>rtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a version 6 RFC 2460 Internet Protocol (IP) routing header. This function is special in that it uses the payload interface to include the "type-specific data"; that is the routing information. Most often this will be a number of 128-bit IPv6 addresses. The application programmer will build a byte string of IPv6 address and pass them to the function using the payload interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nh</em>&nbsp;</td><td>next header </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the header in 8-byte octets not including the first 8 octets </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rtype</em>&nbsp;</td><td>routing header type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segments</em>&nbsp;</td><td>number of routing segments that follow </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload of routing information </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="84a2f87c5188f95a73ab04e7bb8eebf3"></a><!-- doxytag: member="libnet-functions.h::libnet_build_isl" ref="84a2f87c5188f95a73ab04e7bb8eebf3" args="(u_int8_t *dhost, u_int8_t type, u_int8_t user, u_int8_t *shost, u_int16_t len, u_int8_t *snap, u_int16_t vid, u_int16_t portindex, u_int16_t reserved, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_isl           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dhost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>user</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>shost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>snap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>portindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>reserved</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a Cisco Inter-Switch Link (ISL) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dhost</em>&nbsp;</td><td>destination address (should be 01:00:0c:00:00) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of frame </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>user</em>&nbsp;</td><td>user defined data </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shost</em>&nbsp;</td><td>source mac address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the encapuslated packet less 18 bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>snap</em>&nbsp;</td><td>SNAP information (0xaaaa03 + vendor code) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vid</em>&nbsp;</td><td>15 bit VLAN ID, 1 bit BPDU or CDP indicator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>portindex</em>&nbsp;</td><td>port index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reserved</em>&nbsp;</td><td>used for FDDI and token ring </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="71bc438f807ab7e84d424533e81e1693"></a><!-- doxytag: member="libnet-functions.h::libnet_build_link" ref="71bc438f807ab7e84d424533e81e1693" args="(u_int8_t *dst, u_int8_t *src, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_link           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a link layer header for an initialized l. The function determines the proper link layer header format from how l was initialized. The function current supports Ethernet and Token Ring link layers. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>the destination MAC address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>the source MAC address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>Organizationally Unique Identifier (unused for Ethernet) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="2be4c11b7a37ab8ad9d46e1ebf3b53db"></a><!-- doxytag: member="libnet-functions.h::libnet_build_mpls" ref="2be4c11b7a37ab8ad9d46e1ebf3b53db" args="(u_int32_t label, u_int8_t experimental, u_int8_t bos, u_int8_t ttl, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_mpls           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>experimental</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>bos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 3032 Multi-Protocol Label Switching (MPLS) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>20-bit label value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>experimental</em>&nbsp;</td><td>3-bit reserved field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bos</em>&nbsp;</td><td>1-bit bottom of stack identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ttl</em>&nbsp;</td><td>time to live </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="a18676bbed2910988a65ace745226301"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ntp" ref="a18676bbed2910988a65ace745226301" args="(u_int8_t leap_indicator, u_int8_t version, u_int8_t mode, u_int8_t stratum, u_int8_t poll, u_int8_t precision, u_int16_t delay_int, u_int16_t delay_frac, u_int16_t dispersion_int, u_int16_t dispersion_frac, u_int32_t reference_id, u_int32_t ref_ts_int, u_int32_t ref_ts_frac, u_int32_t orig_ts_int, u_int32_t orig_ts_frac, u_int32_t rec_ts_int, u_int32_t rec_ts_frac, u_int32_t xmt_ts_int, u_int32_t xmt_ts_frac, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ntp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>leap_indicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>stratum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>poll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>precision</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>delay_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>delay_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>dispersion_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>dispersion_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>reference_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>ref_ts_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>ref_ts_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>orig_ts_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>orig_ts_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>rec_ts_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>rec_ts_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>xmt_ts_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>xmt_ts_frac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 958 Network Time Protocol (NTP) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leap_indicator</em>&nbsp;</td><td>the leap indicator </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>NTP protocol version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>NTP mode </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stratum</em>&nbsp;</td><td>stratum </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>poll</em>&nbsp;</td><td>polling interval </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>precision</em>&nbsp;</td><td>precision </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay_int</em>&nbsp;</td><td>delay interval </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>delay_frac</em>&nbsp;</td><td>delay fraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dispersion_int</em>&nbsp;</td><td>dispersion interval </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dispersion_frac</em>&nbsp;</td><td>dispersion fraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>reference_id</em>&nbsp;</td><td>reference id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ref_ts_int</em>&nbsp;</td><td>reference timestamp integer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ref_ts_frac</em>&nbsp;</td><td>reference timestamp fraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orig_ts_int</em>&nbsp;</td><td>original timestamp integer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orig_ts_frac</em>&nbsp;</td><td>original timestamp fraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rec_ts_int</em>&nbsp;</td><td>receiver timestamp integer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rec_ts_frac</em>&nbsp;</td><td>reciever timestamp fraction </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmt_ts_int</em>&nbsp;</td><td>transmit timestamp integer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xmt_ts_frac</em>&nbsp;</td><td>transmit timestamp integer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="40115f0c696b84e2f4f84c09e72f60dc"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2" ref="40115f0c696b84e2f4f84c09e72f60dc" args="(u_int16_t len, u_int8_t type, u_int32_t rtr_id, u_int32_t area_id, u_int16_t sum, u_int16_t autype, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>rtr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>area_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>autype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rtr_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area_id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>autype</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="60b59bb26475cd0892299c4888454b3b"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_dbd" ref="60b59bb26475cd0892299c4888454b3b" args="(u_int16_t dgram_len, u_int8_t opts, u_int8_t type, u_int seqnum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_dbd           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>dgram_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>seqnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dgram_len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seqnum</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="0f0d868bb17ff951305327becaec80e5"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_hello" ref="0f0d868bb17ff951305327becaec80e5" args="(u_int32_t netmask, u_int16_t interval, u_int8_t opts, u_int8_t priority, u_int dead_int, u_int32_t des_rtr, u_int32_t bkup_rtr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_hello           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>netmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>dead_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>des_rtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>bkup_rtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>netmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interval</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dead_int</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>des_rtr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bkup_rtr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="8884632ef2860b3b292188fcacf54cf8"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsa" ref="8884632ef2860b3b292188fcacf54cf8" args="(u_int16_t age, u_int8_t opts, u_int8_t type, u_int lsid, u_int32_t advrtr, u_int seqnum, u_int16_t sum, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsa           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>age</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>lsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>advrtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>seqnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>age</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>opts</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsid</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>advrtr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seqnum</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="bcecd50e35e742531f59cce0b90b8b79"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsa_as" ref="bcecd50e35e742531f59cce0b90b8b79" args="(u_int32_t nmask, u_int metric, u_int32_t fwdaddr, u_int tag, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsa_as           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>nmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>fwdaddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metric</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fwdaddr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tag</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="ae2ddd904b99753f88073c1525e9a08f"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsa_net" ref="ae2ddd904b99753f88073c1525e9a08f" args="(u_int32_t nmask, u_int rtrid, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsa_net           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>nmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>rtrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rtrid</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f27133661d6c10e3c776cfb7e24b8b6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsa_rtr" ref="8f27133661d6c10e3c776cfb7e24b8b6" args="(u_int16_t flags, u_int16_t num, u_int id, u_int data, u_int8_t type, u_int8_t tos, u_int16_t metric, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsa_rtr           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tos</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metric</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9d76074203ed1e92683a056b6f7b8ba"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsa_sum" ref="b9d76074203ed1e92683a056b6f7b8ba" args="(u_int32_t nmask, u_int metric, u_int tos, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsa_sum           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>nmask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>tos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nmask</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metric</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tos</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="bd981b21f34c0efcdbd7123f9c6b1ab4"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsr" ref="bd981b21f34c0efcdbd7123f9c6b1ab4" args="(u_int type, u_int lsid, u_int32_t advrtr, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsr           </td>
          <td>(</td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>lsid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>advrtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsid</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>advrtr</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="9460b64aba613d6e367a3a6d472ae5e6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_ospfv2_lsu" ref="9460b64aba613d6e367a3a6d472ae5e6" args="(u_int num, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_ospfv2_lsu           </td>
          <td>(</td>
          <td class="paramtype">u_int&nbsp;</td>
          <td class="paramname"> <em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>num</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="c9549e65e228cdfa901fca9012f1b52f"></a><!-- doxytag: member="libnet-functions.h::libnet_build_rip" ref="c9549e65e228cdfa901fca9012f1b52f" args="(u_int8_t cmd, u_int8_t version, u_int16_t rd, u_int16_t af, u_int16_t rt, u_int32_t addr, u_int32_t mask, u_int32_t next_hop, u_int32_t metric, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_rip           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>rd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>af</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>rt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>next_hop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a Routing Information Protocol header (RFCs 1058 and 2453). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>command </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>protocol version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rd</em>&nbsp;</td><td>version one: 0, version two: routing domain </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>af</em>&nbsp;</td><td>address family </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rt</em>&nbsp;</td><td>version one: 0, version two: route tag </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addr</em>&nbsp;</td><td>IPv4 address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mask</em>&nbsp;</td><td>version one: 0, version two: subnet mask </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>next_hop</em>&nbsp;</td><td>version one: 0, version two: next hop address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>metric</em>&nbsp;</td><td>routing metric </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="33bdb212c766a869a55560d523deb807"></a><!-- doxytag: member="libnet-functions.h::libnet_build_rpc_call" ref="33bdb212c766a869a55560d523deb807" args="(u_int32_t rm, u_int32_t xid, u_int32_t prog_num, u_int32_t prog_vers, u_int32_t procedure, u_int32_t cflavor, u_int32_t clength, u_int8_t *cdata, u_int32_t vflavor, u_int32_t vlength, u_int8_t *vdata, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_rpc_call           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>rm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>xid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>prog_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>prog_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>procedure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>cflavor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>clength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>cdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>vflavor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>vlength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>vdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an Remote Procedure Call (Version 2) Call message header as specified in RFC 1831. This builder provides the option for specifying the record marking which is required when used with streaming protocols (TCP). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rm</em>&nbsp;</td><td>record marking indicating the position in a stream, 0 otherwise </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>xid</em>&nbsp;</td><td>transaction identifier used to link calls and replies </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prog_num</em>&nbsp;</td><td>remote program specification typically between 0 - 1fffffff </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prog_vers</em>&nbsp;</td><td>remote program version specification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>procedure</em>&nbsp;</td><td>procedure to be performed by remote program </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cflavor</em>&nbsp;</td><td>authentication credential type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>clength</em>&nbsp;</td><td>credential length (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cdata</em>&nbsp;</td><td>opaque credential data (currently unused) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vflavor</em>&nbsp;</td><td>authentication verifier type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vlength</em>&nbsp;</td><td>verifier length (should be 0) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vdata</em>&nbsp;</td><td>opaque verifier data (currently unused) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="d20d81e5ce0cd581ff374242fb30a089"></a><!-- doxytag: member="libnet-functions.h::libnet_build_sebek" ref="d20d81e5ce0cd581ff374242fb30a089" args="(u_int32_t magic, u_int16_t version, u_int16_t type, u_int32_t counter, u_int32_t time_sec, u_int32_t time_usec, u_int32_t pid, u_int32_t uid, u_int32_t fd, u_int8_t cmd[SEBEK_CMD_LENGTH], u_int32_t length, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_sebek           </td>
          <td>(</td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>magic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>time_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>time_usec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>uid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cmd</em>[SEBEK_CMD_LENGTH], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a Sebek header. The Sebek protocol was designed by the Honeynet Project as a transport mechanism for post-intrusion forensic data. More information may be found here: <a href="http://www.honeynet.org/papers/sebek.pdf.">http://www.honeynet.org/papers/sebek.pdf.</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>magic</em>&nbsp;</td><td>identify packets that should be hidden </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>protocol version, currently 1 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type of record (read data is type 0, write data is type 1) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>counter</em>&nbsp;</td><td>PDU counter used to identify when packet are lost </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time_sec</em>&nbsp;</td><td>seconds since EPOCH according to the honeypot </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>time_usec</em>&nbsp;</td><td>residual microseconds </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>PID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uid</em>&nbsp;</td><td>UID </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>FD </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>12 first characters of the command </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>length in bytes of the PDU's body </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="0a3c886a4103e0a80aea25d6d326b6bf"></a><!-- doxytag: member="libnet-functions.h::libnet_build_stp_conf" ref="0a3c886a4103e0a80aea25d6d326b6bf" args="(u_int16_t id, u_int8_t version, u_int8_t bpdu_type, u_int8_t flags, u_int8_t *root_id, u_int32_t root_pc, u_int8_t *bridge_id, u_int16_t port_id, u_int16_t message_age, u_int16_t max_age, u_int16_t hello_time, u_int16_t f_delay, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_stp_conf           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>bpdu_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>root_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>root_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>bridge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>port_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>message_age</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>max_age</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>hello_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>f_delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.1d Spanning Tree Protocol (STP) configuration header. STP frames are usually encapsulated inside of an 802.2 + 802.3 frame combination. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>protocol id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>protocol version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpdu_type</em>&nbsp;</td><td>bridge protocol data unit type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_id</em>&nbsp;</td><td>root id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>root_pc</em>&nbsp;</td><td>root path cost </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bridge_id</em>&nbsp;</td><td>bridge id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>port_id</em>&nbsp;</td><td>port id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>message_age</em>&nbsp;</td><td>message age </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_age</em>&nbsp;</td><td>max age </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>hello_time</em>&nbsp;</td><td>hello time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>f_delay</em>&nbsp;</td><td>forward delay </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="0d0bf94c6887aec7702cf9f4190a1e55"></a><!-- doxytag: member="libnet-functions.h::libnet_build_stp_tcn" ref="0d0bf94c6887aec7702cf9f4190a1e55" args="(u_int16_t id, u_int8_t version, u_int8_t bpdu_type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_stp_tcn           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>bpdu_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an IEEE 802.1d Spanning Tree Protocol (STP) topology change notification header. STP frames are usually encapsulated inside of an 802.2 + 802.3 frame combination. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>id</em>&nbsp;</td><td>protocol id </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>protocol version </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bpdu_type</em>&nbsp;</td><td>bridge protocol data unit type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="24b1a32adad116ddc743482a229af490"></a><!-- doxytag: member="libnet-functions.h::libnet_build_tcp" ref="24b1a32adad116ddc743482a229af490" args="(u_int16_t sp, u_int16_t dp, u_int32_t seq, u_int32_t ack, u_int8_t control, u_int16_t win, u_int16_t sum, u_int16_t urg, u_int16_t len, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_tcp           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>ack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>control</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>win</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>urg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 793 Transmission Control Protocol (TCP) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>source port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dp</em>&nbsp;</td><td>destination port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>seq</em>&nbsp;</td><td>sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ack</em>&nbsp;</td><td>acknowledgement number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>control</em>&nbsp;</td><td>control flags </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>win</em>&nbsp;</td><td>window size </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>urg</em>&nbsp;</td><td>urgent pointer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the TCP packet (for checksum calculation) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="316a2d08bdd3199b6b30fa446b48df51"></a><!-- doxytag: member="libnet-functions.h::libnet_build_tcp_options" ref="316a2d08bdd3199b6b30fa446b48df51" args="(u_int8_t *options, u_int32_t options_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_tcp_options           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>options_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 793 Transmission Control Protocol (TCP) options header. The function expects options to be a valid TCP options string of size options_s, which is no larger than 40 bytes (the maximum size of an options string). The function checks to ensure that the packet consists of a TCP header preceded by an IPv4 header, and that the addition of the options string would not result in a packet larger than 65,535 bytes (IPMAXPACKET). The function counts up the number of 32-bit words in the options string and adjusts the TCP header length value as necessary. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>options</em>&nbsp;</td><td>byte string of TCP options </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>options_s</em>&nbsp;</td><td>length of options string </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="65635fcbae54edb768ed36e8ce3abca6"></a><!-- doxytag: member="libnet-functions.h::libnet_build_token_ring" ref="65635fcbae54edb768ed36e8ce3abca6" args="(u_int8_t ac, u_int8_t fc, u_int8_t *dst, u_int8_t *src, u_int8_t dsap, u_int8_t ssap, u_int8_t cf, u_int8_t *oui, u_int16_t type, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_token_ring           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ac</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>fc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>dsap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ssap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>cf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>oui</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds a token ring header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ac</em>&nbsp;</td><td>access control </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fc</em>&nbsp;</td><td>frame control </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>destination address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>source address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dsap</em>&nbsp;</td><td>destination service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ssap</em>&nbsp;</td><td>source service access point </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cf</em>&nbsp;</td><td>control field </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>oui</em>&nbsp;</td><td>Organizationally Unique Identifier </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>upper layer protocol type </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="6d3f91d01237eef2f82ffd322ecbc792"></a><!-- doxytag: member="libnet-functions.h::libnet_build_udp" ref="6d3f91d01237eef2f82ffd322ecbc792" args="(u_int16_t sp, u_int16_t dp, u_int16_t len, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_udp           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>dp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 768 User Datagram Protocol (UDP) header. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sp</em>&nbsp;</td><td>source port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dp</em>&nbsp;</td><td>destination port </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>total length of the UDP packet </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="e94f381e758de9faf26920042a2830e0"></a><!-- doxytag: member="libnet-functions.h::libnet_build_vrrp" ref="e94f381e758de9faf26920042a2830e0" args="(u_int8_t version, u_int8_t type, u_int8_t vrouter_id, u_int8_t priority, u_int8_t ip_count, u_int8_t auth_type, u_int8_t advert_int, u_int16_t sum, u_int8_t *payload, u_int32_t payload_s, libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_ptag_t libnet_build_vrrp           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>vrouter_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>ip_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>auth_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>advert_int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>payload_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Builds an RFC 2338 Virtual Router Redundacy Protool (VRRP) header. Use the payload interface to specify address and autthentication information. To build a "legal" packet, the destination IPv4 address should be the multicast * address 224.0.0.18, the IP TTL should be set to 255, and the IP protocol should be set to 112. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>version</em>&nbsp;</td><td>VRRP version (should be 2) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>VRRP packet type (should be 1 -- ADVERTISEMENT) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vrouter_id</em>&nbsp;</td><td>virtual router identification </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>priority</em>&nbsp;</td><td>priority (higher numbers indicate higher priority) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ip_count</em>&nbsp;</td><td>number of IPv4 addresses contained in this advertisement </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>auth_type</em>&nbsp;</td><td>type of authentication (0, 1, 2 -- see RFC) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>advert_int</em>&nbsp;</td><td>interval between advertisements </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sum</em>&nbsp;</td><td>checksum (0 for libnet to autofill) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload</em>&nbsp;</td><td>optional payload or NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>payload_s</em>&nbsp;</td><td>payload length or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>protocol tag to modify an existing header, 0 to build a new one </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>protocol tag value on success, -1 on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="b84889f7fe57a1801cf03eceac47463e"></a><!-- doxytag: member="libnet-functions.h::libnet_clear_packet" ref="b84889f7fe57a1801cf03eceac47463e" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_clear_packet           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the current packet referenced and frees all pblocks. Should be called when the programmer want to send a completely new packet of a different type using the same context. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="20887ffe940f1d2c5bcae79a188176c6"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_add" ref="20887ffe940f1d2c5bcae79a188176c6" args="(libnet_t *l, char *label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_cq_add           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>label</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Adds a new context to the libnet context queue. If no queue exists, this function will create the queue and add the specified libnet context as the first entry on the list. The functions checks to ensure niether l nor label are NULL, and that label doesn't refer to an existing context already in the queue. Additionally, l should refer to a libnet context previously initialized with a call to <a class="el" href="libnet-functions_8h.html#6a879b30d3e1864fd9bad33e195223b5">libnet_init()</a>. If the context queue in write locked, this function will fail. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>a canonical name given to recognize the new context, no longer than LIBNET_LABEL_SIZE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="565d99e292980d5033bef2d186596217"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_destroy" ref="565d99e292980d5033bef2d186596217" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_cq_destroy           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Destroys the entire context queue, calling <a class="el" href="libnet-functions_8h.html#591804711cffa92582703a5aedbd9b25">libnet_destroy()</a> on each member context. 
</div>
</div><p>
<a class="anchor" name="4846c3ce22db19195b235ad11d7c60ce"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_end_loop" ref="4846c3ce22db19195b235ad11d7c60ce" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_cq_end_loop           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] 
</div>
</div><p>
<a class="anchor" name="0cd216f0e5563ee06043a8ebfa16fe57"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_find_by_label" ref="0cd216f0e5563ee06043a8ebfa16fe57" args="(char *label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_cq_find_by_label           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>label</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Locates a libnet context from the queue, indexed by a canonical label. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>canonical label of the libnet context to retrieve </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the expected libnet context, NULL on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="bb1341d217de4d9c39ec484951e518b0"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_getlabel" ref="bb1341d217de4d9c39ec484951e518b0" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libnet_cq_getlabel           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Returns the canonical label associated with the context. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to the libnet context's label </dd></dl>

</div>
</div><p>
<a class="anchor" name="7e98a045ac6e29ca421507d9a200b5aa"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_head" ref="7e98a045ac6e29ca421507d9a200b5aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_cq_head           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Intiailizes the interator interface and set a write lock on the entire queue. This function is intended to be called just prior to interating through the entire list of contexts (with the probable intent of inject a series of packets in rapid succession). This function is often used as per the following:<p>
for (l = <a class="el" href="libnet-functions_8h.html#7e98a045ac6e29ca421507d9a200b5aa">libnet_cq_head()</a>; <a class="el" href="libnet-functions_8h.html#ab1eb1e3ae64cde579a5a6035d5406c8">libnet_cq_last()</a>; l = <a class="el" href="libnet-functions_8h.html#d312f3182e3e5367db87fc6bab32604d">libnet_cq_next()</a>) { ... }<p>
Much of the time, the application programmer will use the iterator as it is written above; as such, libnet provides a macro to do exactly that, <a class="el" href="libnet-macros_8h.html#f36eb84eee10c525720134cfadb50a3e">for_each_context_in_cq(l)</a>. Warning: do not call the iterator more than once in a single loop. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the head of the context queue </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab1eb1e3ae64cde579a5a6035d5406c8"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_last" ref="ab1eb1e3ae64cde579a5a6035d5406c8" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_cq_last           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Check whether the iterator is at the last context in the queue. <dl class="return" compact><dt><b>Returns:</b></dt><dd>1 if at the end of the context queue, 0 otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="d312f3182e3e5367db87fc6bab32604d"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_next" ref="d312f3182e3e5367db87fc6bab32604d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_cq_next           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Get next context from the context queue. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the next context from the context queue </dd></dl>

</div>
</div><p>
<a class="anchor" name="29f60504a0fe9b7bf6f5a962063118bb"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_remove" ref="29f60504a0fe9b7bf6f5a962063118bb" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_cq_remove           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Removes a specified context from the libnet context queue by specifying the libnet context pointer. Note the function will remove the specified context from the context queue and cleanup internal memory from the queue, it is up to the application programmer to free the returned libnet context with a call to <a class="el" href="libnet-functions_8h.html#591804711cffa92582703a5aedbd9b25">libnet_destroy()</a>. Also, as it is not necessary to keep the libnet context pointer when initially adding it to the context queue, most application programmers will prefer to refer to entries on the context queue by canonical name and would use <a class="el" href="libnet-functions_8h.html#4e972664a0d839eab039f8fb2379987a">libnet_cq_remove_by_label()</a>. If the context queue is write locked, this function will fail. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the pointer to the removed libnet context, NULL on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e972664a0d839eab039f8fb2379987a"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_remove_by_label" ref="4e972664a0d839eab039f8fb2379987a" args="(char *label)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_cq_remove_by_label           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>label</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Removes a specified context from the libnet context queue by specifying the canonical name. Note the function will remove the specified context from the context queue and cleanup internal memory from the queue, it is up to the application programmer to free the returned libnet context with a call to <a class="el" href="libnet-functions_8h.html#591804711cffa92582703a5aedbd9b25">libnet_destroy()</a>. If the context queue is write locked, this function will fail. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>label</em>&nbsp;</td><td>canonical name of the context to remove </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the pointer to the removed libnet context, NULL on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2d4679155425c02822559bcb0caa275"></a><!-- doxytag: member="libnet-functions.h::libnet_cq_size" ref="d2d4679155425c02822559bcb0caa275" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_cq_size           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Context Queue] Function returns the number of libnet contexts that are in the queue. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of libnet contexts currently in the queue </dd></dl>

</div>
</div><p>
<a class="anchor" name="591804711cffa92582703a5aedbd9b25"></a><!-- doxytag: member="libnet-functions.h::libnet_destroy" ref="591804711cffa92582703a5aedbd9b25" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_destroy           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shuts down the libnet session referenced by l. It closes the network interface and frees all internal memory structures associated with l. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3aa6623246e13310dc6f9f9834e7313b"></a><!-- doxytag: member="libnet-functions.h::libnet_diag_dump_context" ref="3aa6623246e13310dc6f9f9834e7313b" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_diag_dump_context           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Diagnostic] Prints the contents of the given context. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="862af1289e6eb7a930e18bf1f3008cd4"></a><!-- doxytag: member="libnet-functions.h::libnet_diag_dump_hex" ref="862af1289e6eb7a930e18bf1f3008cd4" args="(u_int8_t *packet, u_int32_t len, int swap, FILE *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_diag_dump_hex           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int32_t&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>swap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Diagnostic] Function prints the contents of the supplied buffer to the supplied stream pointer. Will swap endianness based disposition of mode variable. Useful to be used in conjunction with the advanced interface and a culled packet. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>packet</em>&nbsp;</td><td>the packet to print </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>length of the packet in bytes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>swap</em>&nbsp;</td><td>1 to swap byte order, 0 to not. Counter-intuitively, it is necessary to swap in order to see the byte order as it is on the wire (this may be a bug). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stream</em>&nbsp;</td><td>a stream pointer to print to </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9825c6c69efd6ef24545d59177a333e6"></a><!-- doxytag: member="libnet-functions.h::libnet_diag_dump_pblock" ref="9825c6c69efd6ef24545d59177a333e6" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_diag_dump_pblock           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Diagnostic] Prints the contents of every pblock. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="053bcb30c956b858db88b9a551e9360b"></a><!-- doxytag: member="libnet-functions.h::libnet_diag_dump_pblock_type" ref="053bcb30c956b858db88b9a551e9360b" args="(u_int8_t type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* libnet_diag_dump_pblock_type           </td>
          <td>(</td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>type</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[Diagnostic] Returns the canonical name of the pblock type. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>pblock type </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a string representing the pblock type type or "unknown" for an unknown value </dd></dl>

</div>
</div><p>
<a class="anchor" name="6531e479687de8d195bd1605422735ca"></a><!-- doxytag: member="libnet-functions.h::libnet_get_hwaddr" ref="6531e479687de8d195bd1605422735ca" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libnet_ether_addr* libnet_get_hwaddr           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the MAC address for the device libnet was initialized with. If libnet was initialized without a device the function will attempt to find one. If the function fails and returns NULL a call to <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> will tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the MAC address or NULL </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5143c0ab5dc9e9fa817d865eac428b0"></a><!-- doxytag: member="libnet-functions.h::libnet_get_ipaddr4" ref="e5143c0ab5dc9e9fa817d865eac428b0" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_get_ipaddr4           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the IP address for the device libnet was initialized with. If libnet was initialized without a device (in raw socket mode) the function will attempt to find one. If the function fails and returns -1 a call to libnet_geterrror() will tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a big endian IP address suitable for use in a libnet_build function or -1 </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d7de8968c2087df7a22140d7993e267"></a><!-- doxytag: member="libnet-functions.h::libnet_get_ipaddr6" ref="3d7de8968c2087df7a22140d7993e267" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libnet_in6_addr libnet_get_ipaddr6           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is not yet implemented under IPv6. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>well, nothing yet </dd></dl>

</div>
</div><p>
<a class="anchor" name="453d816dc8adffaefc040a1bf5bd9b5f"></a><!-- doxytag: member="libnet-functions.h::libnet_get_prand" ref="453d816dc8adffaefc040a1bf5bd9b5f" args="(int mod)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_get_prand           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mod</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates an unsigned psuedo-random value within the range specified by mod. LIBNET_PR2 0 - 1 LIBNET_PR8 0 - 255 LIBNET_PR16 0 - 32767 LIBNET_PRu16 0 - 65535 LIBNET_PR32 0 - 2147483647 LIBNET_PRu32 0 - 4294967295<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mod</em>&nbsp;</td><td>one the of LIBNET_PR* constants </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e68365ece2c976a75bc50e91df40ea0"></a><!-- doxytag: member="libnet-functions.h::libnet_getdevice" ref="1e68365ece2c976a75bc50e91df40ea0" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libnet_getdevice           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the canonical name of the device used for packet injection. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the canonical name of the device used for packet injection. Note it can be NULL without being an error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="36c0b24a4926a8f5d9d392836e915f2e"></a><!-- doxytag: member="libnet-functions.h::libnet_geterror" ref="36c0b24a4926a8f5d9d392836e915f2e" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* libnet_geterror           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last error set inside of the referenced libnet context. This function should be called anytime a function fails or an error condition is detected inside of libnet. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>an error string or NULL if no error has occured </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9b137f454b3da05d4ac5fe388c1f2b8"></a><!-- doxytag: member="libnet-functions.h::libnet_getfd" ref="b9b137f454b3da05d4ac5fe388c1f2b8" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_getfd           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the FILENO of the file descriptor used for packet injection. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the file number of the file descriptor used for packet injection </dd></dl>

</div>
</div><p>
<a class="anchor" name="0af792a7e4bc49bd252b062cd4f35af5"></a><!-- doxytag: member="libnet-functions.h::libnet_getgre_length" ref="0af792a7e4bc49bd252b062cd4f35af5" args="(u_int16_t fv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_getgre_length           </td>
          <td>(</td>
          <td class="paramtype">u_int16_t&nbsp;</td>
          <td class="paramname"> <em>fv</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fv</em>&nbsp;</td><td>see <a class="el" href="libnet-functions_8h.html#fff121ac7bc157e3df0eb1bd624263c1">libnet_build_gre()</a>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>size, see <a class="el" href="libnet-functions_8h.html#fff121ac7bc157e3df0eb1bd624263c1">libnet_build_gre()</a>. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a04f828cf6b7ade20204ec0e3dcbc778"></a><!-- doxytag: member="libnet-functions.h::libnet_getpacket_size" ref="a04f828cf6b7ade20204ec0e3dcbc778" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_getpacket_size           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the sum of the size of all of the pblocks inside of l (this should be the resuling packet size). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the packet in l </dd></dl>

</div>
</div><p>
<a class="anchor" name="8b784c9899c429dd0f4790a71bdf55a2"></a><!-- doxytag: member="libnet-functions.h::libnet_getpbuf" ref="8b784c9899c429dd0f4790a71bdf55a2" args="(libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int8_t* libnet_getpbuf           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the pblock buffer contents for the specified ptag; a subsequent call to <a class="el" href="libnet-functions_8h.html#095de516e5b119d6e72fff4286157386">libnet_getpbuf_size()</a> should be made to determine the size of the buffer. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>the ptag reference number </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a pointer to the pblock buffer or NULL on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="095de516e5b119d6e72fff4286157386"></a><!-- doxytag: member="libnet-functions.h::libnet_getpbuf_size" ref="095de516e5b119d6e72fff4286157386" args="(libnet_t *l, libnet_ptag_t ptag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_getpbuf_size           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the pblock buffer size for the specified ptag; a previous call to <a class="el" href="libnet-functions_8h.html#8b784c9899c429dd0f4790a71bdf55a2">libnet_getpbuf()</a> should be made to pull the actual buffer contents. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>the ptag reference number </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the size of the pblock buffer </dd></dl>

</div>
</div><p>
<a class="anchor" name="66bfbb546b4a9fd49d446870b3b30bb0"></a><!-- doxytag: member="libnet-functions.h::libnet_hex_aton" ref="66bfbb546b4a9fd49d446870b3b30bb0" args="(const char *s, int *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int8_t* libnet_hex_aton           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a colon separated hexidecimal address (from the command line) and returns a bytestring suitable for use in a libnet_build function. Note this function performs an implicit malloc and the return value should be freed after its use. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>s</em>&nbsp;</td><td>the string to be parsed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>the resulting size of the returned byte string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a byte string or NULL on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="6a879b30d3e1864fd9bad33e195223b5"></a><!-- doxytag: member="libnet-functions.h::libnet_init" ref="6a879b30d3e1864fd9bad33e195223b5" args="(int injection_type, char *device, char *err_buf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">libnet_t* libnet_init           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>injection_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>err_buf</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates the libnet environment. It initializes the library and returns a libnet context. If the injection_type is LIBNET_LINK or LIBNET_LINK_ADV, the function initializes the injection primitives for the link-layer interface enabling the application programmer to build packets starting at the data-link layer (which also provides more granular control over the IP layer). If libnet uses the link-layer and the device argument is non-NULL, the function attempts to use the specified network device for packet injection. This is either a canonical string that references the device (such as "eth0" for a 100MB Ethernet card on Linux or "fxp0" for a 100MB Ethernet card on OpenBSD) or the dots and decimals representation of the device's IP address (192.168.0.1). If device is NULL, libnet attempts to find a suitable device to use. If the injection_type is LIBNET_RAW4 or LIBNET_RAW4_ADV, the function initializes the injection primitives for the IPv4 raw socket interface. The final argument, err_buf, should be a buffer of size LIBNET_ERRBUF_SIZE and holds an error message if the function fails. This function requires root privileges to execute successfully. Upon success, the function returns a valid libnet context for use in later function calls; upon failure, the function returns NULL. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>injection_type</em>&nbsp;</td><td>packet injection type (LIBNET_LINK, LIBNET_LINK_ADV, LIBNET_RAW4, LIBNET_RAW4_ADV, LIBNET_RAW6, LIBNET_RAW6_ADV) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>device</em>&nbsp;</td><td>the interface to use (NULL and libnet will choose one) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err_buf</em>&nbsp;</td><td>will contain an error message on failure </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>libnet context ready for use or NULL on error. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5042e4e9d37d9c1ab566b8d3b97e21a2"></a><!-- doxytag: member="libnet-functions.h::libnet_name2addr4" ref="5042e4e9d37d9c1ab566b8d3b97e21a2" args="(libnet_t *l, char *host_name, u_int8_t use_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u_int32_t libnet_name2addr4           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>host_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>use_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a dotted decimal string or a canonical DNS name and returns a network byte ordered IPv4 address. This may incur a DNS lookup if mode is set to LIBNET_RESOLVE and host_name refers to a canonical DNS name. If mode is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can fail if DNS lookup fails or if mode is set to LIBNET_DONT_RESOLVE and host_name refers to a canonical DNS name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>host_name</em>&nbsp;</td><td>pointer to a string containing a presentation format host name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_name</em>&nbsp;</td><td>LIBNET_RESOLVE or LIBNET_DONT_RESOLVE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>network byte ordered IPv4 address or -1 (2^32 - 1) on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="6f3677b524c46fad4d185be9a3142099"></a><!-- doxytag: member="libnet-functions.h::libnet_name2addr6" ref="6f3677b524c46fad4d185be9a3142099" args="(libnet_t *l, char *host_name, u_int8_t use_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct libnet_in6_addr libnet_name2addr6           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>host_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int8_t&nbsp;</td>
          <td class="paramname"> <em>use_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a dotted decimal string or a canonical DNS name and returns a network byte ordered IPv6 address. This may incur a DNS lookup if mode is set to LIBNET_RESOLVE and host_name refers to a canonical DNS name. If mode is set to LIBNET_DONT_RESOLVE no DNS lookup will occur. The function can fail if DNS lookup fails or if mode is set to LIBNET_DONT_RESOLVE and host_name refers to a canonical DNS name. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>host_name</em>&nbsp;</td><td>pointer to a string containing a presentation format host name </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>use_name</em>&nbsp;</td><td>LIBNET_RESOLVE or LIBNET_DONT_RESOLVE </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>network byte ordered IPv6 address structure </dd></dl>

</div>
</div><p>
<a class="anchor" name="39e332daa771627372a01867818b4301"></a><!-- doxytag: member="libnet-functions.h::libnet_plist_chain_dump" ref="39e332daa771627372a01867818b4301" args="(libnet_plist_t *plist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_plist_chain_dump           </td>
          <td>(</td>
          <td class="paramtype">libnet_plist_t *&nbsp;</td>
          <td class="paramname"> <em>plist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs through the port list and prints the contents of the port list chain list to stdout. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plist</em>&nbsp;</td><td>previously created portlist </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="b854695d1306f9af440145fc6767d953"></a><!-- doxytag: member="libnet-functions.h::libnet_plist_chain_dump_string" ref="b854695d1306f9af440145fc6767d953" args="(libnet_plist_t *plist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* libnet_plist_chain_dump_string           </td>
          <td>(</td>
          <td class="paramtype">libnet_plist_t *&nbsp;</td>
          <td class="paramname"> <em>plist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Runs through the port list and prints the contents of the port list chain list to string. This function uses strdup and is not re-entrant. It also has a memory leak and should not really be used. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plist</em>&nbsp;</td><td>previously created portlist </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a printable string containing the port list contents on success NULL on error </dd></dl>

</div>
</div><p>
<a class="anchor" name="b5cb1d70164207a7c279a909576058be"></a><!-- doxytag: member="libnet-functions.h::libnet_plist_chain_free" ref="b5cb1d70164207a7c279a909576058be" args="(libnet_plist_t *plist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_plist_chain_free           </td>
          <td>(</td>
          <td class="paramtype">libnet_plist_t *&nbsp;</td>
          <td class="paramname"> <em>plist</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Frees all memory associated with port list chain. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plist</em>&nbsp;</td><td>previously created portlist </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="aee8e5f54482bf3c9b7c5b101fa8f41f"></a><!-- doxytag: member="libnet-functions.h::libnet_plist_chain_new" ref="aee8e5f54482bf3c9b7c5b101fa8f41f" args="(libnet_t *l, libnet_plist_t **plist, char *token_list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_plist_chain_new           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_plist_t **&nbsp;</td>
          <td class="paramname"> <em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>token_list</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a new port list. Port list chains are useful for TCP and UDP-based applications that need to send packets to a range of ports (contiguous or otherwise). The port list chain, which token_list points to, should contain a series of int8_tacters from the following list: "0123456789,-" of the general format "x - y, z", where "xyz" are port numbers between 0 and 65,535. plist points to the front of the port list chain list for use in further libnet_plist_chain() functions. Upon success, the function returns 1. Upon failure, the function returns -1 and <a class="el" href="libnet-functions_8h.html#36c0b24a4926a8f5d9d392836e915f2e">libnet_geterror()</a> can tell you why. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plist</em>&nbsp;</td><td>if successful, will refer to the portlist, if not, NULL </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>token_list</em>&nbsp;</td><td>string containing the port list primitive </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="05ced873eacf4a000e4ce3a3ab635108"></a><!-- doxytag: member="libnet-functions.h::libnet_plist_chain_next_pair" ref="05ced873eacf4a000e4ce3a3ab635108" args="(libnet_plist_t *plist, u_int16_t *bport, u_int16_t *eport)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_plist_chain_next_pair           </td>
          <td>(</td>
          <td class="paramtype">libnet_plist_t *&nbsp;</td>
          <td class="paramname"> <em>plist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t *&nbsp;</td>
          <td class="paramname"> <em>bport</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u_int16_t *&nbsp;</td>
          <td class="paramname"> <em>eport</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next port list chain pair from the port list chain plist. bport and eport contain the starting port number and ending port number, respectively. Upon success, the function returns 1 and fills in the port variables; however, if the list is empty, the function returns 0 and sets both port variables to 0. Upon failure, the function returns -1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>plist</em>&nbsp;</td><td>previously created portlist </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bport</em>&nbsp;</td><td>will contain the beginning port number or 0 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eport</em>&nbsp;</td><td>will contain the ending port number or 0 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, 0 if empty, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="69470998be995ec8c5e11ecbb19137f5"></a><!-- doxytag: member="libnet-functions.h::libnet_seed_prand" ref="69470998be995ec8c5e11ecbb19137f5" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_seed_prand           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Seeds the psuedo-random number generator. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="886dc359d6add4b0608e8611af7e1b35"></a><!-- doxytag: member="libnet-functions.h::libnet_stats" ref="886dc359d6add4b0608e8611af7e1b35" args="(libnet_t *l, struct libnet_stats *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void libnet_stats           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct libnet_stats *&nbsp;</td>
          <td class="paramname"> <em>ls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills in a libnet_stats structure with packet injection statistics (packets written, bytes written, packet sending errors). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>pointer to a libnet statistics structure </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d36144707ce7994c12ef9d87dc9a2edf"></a><!-- doxytag: member="libnet-functions.h::libnet_toggle_checksum" ref="d36144707ce7994c12ef9d87dc9a2edf" args="(libnet_t *l, libnet_ptag_t ptag, int mode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_toggle_checksum           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">libnet_ptag_t&nbsp;</td>
          <td class="paramname"> <em>ptag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>mode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If a given protocol header is built with the checksum field set to "0", by default libnet will calculate the header checksum prior to injection. If the header is set to any other value, by default libnet will not calculate the header checksum. To over-ride this behavior, use <a class="el" href="libnet-functions_8h.html#d36144707ce7994c12ef9d87dc9a2edf">libnet_toggle_checksum()</a>. Switches auto-checksumming on or off for the specified ptag. If mode is set to LIBNET_ON, libnet will mark the specificed ptag to calculate a checksum for the ptag prior to injection. This assumes that the ptag refers to a protocol that has a checksum field. If mode is set to LIBNET_OFF, libnet will clear the checksum flag and no checksum will be computed prior to injection. This assumes that the programmer will assign a value (zero or otherwise) to the checksum field. Often times this is useful if a precomputed checksum or some other predefined value is going to be used. Note that when libnet is initialized with LIBNET_RAW4, the IPv4 header checksum will always be computed by the kernel prior to injection, regardless of what the programmer sets. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ptag</em>&nbsp;</td><td>the ptag reference number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mode</em>&nbsp;</td><td>LIBNET_ON or LIBNET_OFF </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>1 on success, -1 on failure </dd></dl>

</div>
</div><p>
<a class="anchor" name="5264b060183d307688780bf862fae37c"></a><!-- doxytag: member="libnet-functions.h::libnet_version" ref="5264b060183d307688780bf862fae37c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* libnet_version           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the version of libnet. <dl class="return" compact><dt><b>Returns:</b></dt><dd>the libnet version </dd></dl>

</div>
</div><p>
<a class="anchor" name="53375552efe95906e152152fc170cc0d"></a><!-- doxytag: member="libnet-functions.h::libnet_write" ref="53375552efe95906e152152fc170cc0d" args="(libnet_t *l)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int libnet_write           </td>
          <td>(</td>
          <td class="paramtype">libnet_t *&nbsp;</td>
          <td class="paramname"> <em>l</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a prebuilt packet to the network. The function assumes that l was previously initialized (via a call to <a class="el" href="libnet-functions_8h.html#6a879b30d3e1864fd9bad33e195223b5">libnet_init()</a>) and that a previously constructed packet has been built inside this context (via one or more calls to the libnet_build* family of functions) and is ready to go. Depending on how libnet was initialized, the function will write the packet to the wire either via the raw or link layer interface. The function will also bump up the internal libnet stat counters which are retrievable via <a class="el" href="libnet-functions_8h.html#886dc359d6add4b0608e8611af7e1b35">libnet_stats()</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>l</em>&nbsp;</td><td>pointer to a libnet context </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of bytes written, -1 on error </dd></dl>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 9 16:16:39 2009 for libnet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
