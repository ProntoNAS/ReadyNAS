From a9c746088787549bb5b1ae3add7d06a1b6d93d5e Mon Sep 17 00:00:00 2001
From: "djm@openbsd.org" <djm@openbsd.org>
Date: Fri, 25 Nov 2016 23:22:04 +0000
Subject: [PATCH] upstream commit

split allocation out of sshbuf_reserve() into a separate
sshbuf_allocate() function; ok markus@

Upstream-ID: 11b8a2795afeeb1418d508a2c8095b3355577ec2

Description: sshbuf_allocate is needed to address CVE-2016-10011,
 avoiding implicit realloc inside the buffer code.

---
 sshbuf.c | 76 ++++++++++++++++++++++++++++++++------------------------
 sshbuf.h | 10 +++++++-
 2 files changed, 52 insertions(+), 34 deletions(-)

Index: openssh/sshbuf.c
===================================================================
--- openssh.orig/sshbuf.c
+++ openssh/sshbuf.c
@@ -318,16 +318,13 @@ sshbuf_check_reserve(const struct sshbuf
 }
 
 int
-sshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)
+sshbuf_allocate(struct sshbuf *buf, size_t len)
 {
 	size_t rlen, need;
 	u_char *dp;
 	int r;
 
-	if (dpp != NULL)
-		*dpp = NULL;
-
-	SSHBUF_DBG(("reserve buf = %p len = %zu", buf, len));
+	SSHBUF_DBG(("allocate buf = %p len = %zu", buf, len));
 	if ((r = sshbuf_check_reserve(buf, len)) != 0)
 		return r;
 	/*
@@ -335,7 +332,7 @@ sshbuf_reserve(struct sshbuf *buf, size_
 	 * then pack the buffer, zeroing buf->off.
 	 */
 	sshbuf_maybe_pack(buf, buf->size + len > buf->max_size);
-	SSHBUF_TELL("reserve");
+	SSHBUF_TELL("allocate");
 	if (len + buf->size > buf->alloc) {
 		/*
 		 * Prefer to alloc in SSHBUF_SIZE_INC units, but
@@ -349,22 +346,34 @@ sshbuf_reserve(struct sshbuf *buf, size_
 		SSHBUF_DBG(("adjusted rlen %zu", rlen));
 		if ((dp = realloc(buf->d, rlen)) == NULL) {
 			SSHBUF_DBG(("realloc fail"));
-			if (dpp != NULL)
-				*dpp = NULL;
 			return SSH_ERR_ALLOC_FAIL;
 		}
 		buf->alloc = rlen;
 		buf->cd = buf->d = dp;
 		if ((r = sshbuf_check_reserve(buf, len)) < 0) {
 			/* shouldn't fail */
-			if (dpp != NULL)
-				*dpp = NULL;
 			return r;
 		}
 	}
+	SSHBUF_TELL("done");
+	return 0;
+}
+
+int
+sshbuf_reserve(struct sshbuf *buf, size_t len, u_char **dpp)
+{
+	u_char *dp;
+	int r;
+
+	if (dpp != NULL)
+		*dpp = NULL;
+
+	SSHBUF_DBG(("reserve buf = %p len = %zu", buf, len));
+	if ((r = sshbuf_allocate(buf, len)) != 0)
+		return r;
+
 	dp = buf->d + buf->size;
 	buf->size += len;
-	SSHBUF_TELL("done");
 	if (dpp != NULL)
 		*dpp = dp;
 	return 0;
Index: openssh/sshbuf.h
===================================================================
--- openssh.orig/sshbuf.h
+++ openssh/sshbuf.h
@@ -139,6 +139,14 @@ u_char *sshbuf_mutable_ptr(const struct
 int	sshbuf_check_reserve(const struct sshbuf *buf, size_t len);
 
 /*
+ * Preallocates len additional bytes in buf.
+ * Useful for cases where the caller knows how many bytes will ultimately be
+ * required to avoid realloc in the buffer code.
+ * Returns 0 on success, or a negative SSH_ERR_* error code on failure.
+ */
+int	sshbuf_allocate(struct sshbuf *buf, size_t len);
+
+/*
  * Reserve len bytes in buf.
  * Returns 0 on success and a pointer to the first reserved byte via the
  * optional dpp parameter or a negative * SSH_ERR_* error code on failure.
