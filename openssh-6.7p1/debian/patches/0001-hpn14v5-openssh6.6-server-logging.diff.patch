From e4d876f815bb32248eeef31d3e7ceb1bc13e8efc Mon Sep 17 00:00:00 2001
From: Justin Maggard <justing.maggard@netgear.com>
Date: Wed, 27 Apr 2016 20:53:28 +0000
Subject: [PATCH 1/6] hpn14v5: openssh6.6-server-logging.diff

https://sourceforge.net/projects/hpnssh/files/HPN-SSH%2014.5%206.6p1/

This patch provides enhanced logging capabilities to the server process.
Information provided includes ciphers used, throughput, bytes transferred,
and the like. In order to use this patch you *must* direct syslogd to use
an additional logging socket. This socket will be located in the sshd
chroot, typically /var/empty. As such you will need to create a
/var/empty/dev directory and add '-a /var/empty/dev/log' to your syslogd
configuration.
---
 auth2.c      |  9 +++++++++
 channels.c   | 10 ++++++----
 channels.h   |  2 +-
 kex.c        | 16 ++++++++++++++++
 packet.c     | 30 ++++++++++++++++++++----------
 packet.h     |  4 ++--
 serverloop.c | 33 ++++++++++++++++++++++++++++-----
 sshd.c       |  3 +++
 8 files changed, 85 insertions(+), 22 deletions(-)

diff --git a/auth2.c b/auth2.c
index fa1a588..cae58f4 100644
--- a/auth2.c
+++ b/auth2.c
@@ -50,6 +50,7 @@
 #include "dispatch.h"
 #include "pathnames.h"
 #include "buffer.h"
+#include "canohost.h"
 
 #ifdef GSSAPI
 #include "ssh-gss.h"
@@ -74,6 +75,9 @@ extern Authmethod method_gsskeyex;
 extern Authmethod method_gssapi;
 #endif
 
+static int log_flag = 0;
+
+
 Authmethod *authmethods[] = {
 	&method_none,
 	&method_pubkey,
@@ -227,6 +231,11 @@ input_userauth_request(int type, u_int32_t seq, void *ctxt)
 	service = packet_get_cstring(NULL);
 	method = packet_get_cstring(NULL);
 	debug("userauth-request for user %s service %s method %s", user, service, method);
+	if (!log_flag) {
+		logit("SSH: Server;Ltype: Authname;Remote: %s-%d;Name: %s", 
+		      get_remote_ipaddr(), get_remote_port(), user);
+		log_flag = 1;
+	}
 	debug("attempt %d failures %d", authctxt->attempt, authctxt->failures);
 
 	if ((role = strchr(user, '/')) != NULL)
diff --git a/channels.c b/channels.c
index d67fdf4..c0ddb4c 100644
--- a/channels.c
+++ b/channels.c
@@ -2213,11 +2213,12 @@ channel_after_select(fd_set *readset, fd_set *writeset)
 
 
 /* If there is data to send to the connection, enqueue some of it now. */
-void
+int
 channel_output_poll(void)
 {
 	Channel *c;
 	u_int i, len;
+	int packet_length = 0;
 
 	for (i = 0; i < channels_alloc; i++) {
 		c = channels[i];
@@ -2265,7 +2266,7 @@ channel_output_poll(void)
 					packet_start(SSH2_MSG_CHANNEL_DATA);
 					packet_put_int(c->remote_id);
 					packet_put_string(data, dlen);
-					packet_send();
+					packet_length = packet_send();
 					c->remote_window -= dlen + 4;
 					free(data);
 				}
@@ -2295,7 +2296,7 @@ channel_output_poll(void)
 				    SSH2_MSG_CHANNEL_DATA : SSH_MSG_CHANNEL_DATA);
 				packet_put_int(c->remote_id);
 				packet_put_string(buffer_ptr(&c->input), len);
-				packet_send();
+				packet_length = packet_send();
 				buffer_consume(&c->input, len);
 				c->remote_window -= len;
 			}
@@ -2330,12 +2331,13 @@ channel_output_poll(void)
 			packet_put_int(c->remote_id);
 			packet_put_int(SSH2_EXTENDED_DATA_STDERR);
 			packet_put_string(buffer_ptr(&c->extended), len);
-			packet_send();
+			packet_length = packet_send();
 			buffer_consume(&c->extended, len);
 			c->remote_window -= len;
 			debug2("channel %d: sent ext data %d", c->self, len);
 		}
 	}
+	return (packet_length);
 }
 
 
diff --git a/channels.h b/channels.h
index a000c98..de92fd6 100644
--- a/channels.h
+++ b/channels.h
@@ -247,7 +247,7 @@ void	 channel_input_status_confirm(int, u_int32_t, void *);
 void	 channel_prepare_select(fd_set **, fd_set **, int *, u_int*,
 	     time_t*, int);
 void     channel_after_select(fd_set *, fd_set *);
-void     channel_output_poll(void);
+int      channel_output_poll(void);
 
 int      channel_not_very_much_buffered_data(void);
 void     channel_close_all(void);
diff --git a/kex.c b/kex.c
index 891852b..086bd40 100644
--- a/kex.c
+++ b/kex.c
@@ -51,6 +51,7 @@
 #include "dispatch.h"
 #include "monitor.h"
 #include "roaming.h"
+#include "canohost.h"
 #include "digest.h"
 
 #ifdef GSSAPI
@@ -480,6 +481,7 @@ kex_choose_conf(Kex *kex)
 	int nenc, nmac, ncomp;
 	u_int mode, ctos, need, dh_need, authlen;
 	int first_kex_follows, type;
+	int log_flag = 0;
 
 	my   = kex_buf2prop(&kex->my, NULL);
 	peer = kex_buf2prop(&kex->peer, &first_kex_follows);
@@ -522,6 +524,20 @@ kex_choose_conf(Kex *kex)
 		    newkeys->enc.name,
 		    authlen == 0 ? newkeys->mac.name : "<implicit>",
 		    newkeys->comp.name);
+		/* client starts withctos = 0 && log flag = 0 and no log*/
+		/* 2nd client pass ctos=1 and flag = 1 so no log*/
+		/* server starts with ctos =1 && log_flag = 0 so log */
+		/* 2nd sever pass ctos = 1 && log flag = 1 so no log*/
+		/* -cjr*/
+		if (ctos && !log_flag) {
+			logit("SSH: Server;Ltype: Kex;Remote: %s-%d;Enc: %s;MAC: %s;Comp: %s",
+			      get_remote_ipaddr(),
+			      get_remote_port(),
+			      newkeys->enc.name,
+			      newkeys->mac.name,
+			      newkeys->comp.name);
+		}
+		log_flag = 1;
 	}
 	choose_kex(kex, cprop[PROPOSAL_KEX_ALGS], sprop[PROPOSAL_KEX_ALGS]);
 	choose_hostkeyalg(kex, cprop[PROPOSAL_SERVER_HOST_KEY_ALGS],
diff --git a/packet.c b/packet.c
index 6e7b877..997504f 100644
--- a/packet.c
+++ b/packet.c
@@ -860,7 +860,7 @@ packet_enable_delayed_compress(void)
 /*
  * Finalize packet in SSH2 format (compress, mac, encrypt, enqueue)
  */
-static void
+static int
 packet_send2_wrapped(void)
 {
 	u_char type, *cp, *macbuf = NULL;
@@ -992,11 +992,14 @@ packet_send2_wrapped(void)
 		set_newkeys(MODE_OUT);
 	else if (type == SSH2_MSG_USERAUTH_SUCCESS && active_state->server_side)
 		packet_enable_delayed_compress();
+	return (len-4);
 }
 
-static void
+static int
 packet_send2(void)
 {
+
+	static int packet_length = 0;
 	struct packet *p;
 	u_char type, *cp;
 
@@ -1016,7 +1019,7 @@ packet_send2(void)
 			    sizeof(Buffer));
 			buffer_init(&active_state->outgoing_packet);
 			TAILQ_INSERT_TAIL(&active_state->outgoing, p, next);
-			return;
+			return(sizeof(Buffer));
 		}
 	}
 
@@ -1024,7 +1027,7 @@ packet_send2(void)
 	if (type == SSH2_MSG_KEXINIT)
 		active_state->rekeying = 1;
 
-	packet_send2_wrapped();
+	packet_length = packet_send2_wrapped();
 
 	/* after a NEWKEYS message we can send the complete queue */
 	if (type == SSH2_MSG_NEWKEYS) {
@@ -1038,19 +1041,22 @@ packet_send2(void)
 			    sizeof(Buffer));
 			TAILQ_REMOVE(&active_state->outgoing, p, next);
 			free(p);
-			packet_send2_wrapped();
+			packet_length += packet_send2_wrapped();
 		}
 	}
+	return(packet_length);
 }
 
-void
+int
 packet_send(void)
 {
+  int packet_len = 0;
 	if (compat20)
-		packet_send2();
+		packet_len = packet_send2();
 	else
 		packet_send1();
 	DBG(debug("packet_send done"));
+	return(packet_len);
 }
 
 /*
@@ -1732,12 +1738,15 @@ packet_disconnect(const char *fmt,...)
 
 /* Checks if there is any buffered output, and tries to write some of the output. */
 
-void
+int
 packet_write_poll(void)
 {
-	int len = buffer_len(&active_state->output);
+
+	int len = 0;
 	int cont;
 
+	len = buffer_len(&active_state->output);
+
 	if (len > 0) {
 		cont = 0;
 		len = roaming_write(active_state->connection_out,
@@ -1745,13 +1754,14 @@ packet_write_poll(void)
 		if (len == -1) {
 			if (errno == EINTR || errno == EAGAIN ||
 			    errno == EWOULDBLOCK)
-				return;
+				return(0);
 			fatal("Write failed: %.100s", strerror(errno));
 		}
 		if (len == 0 && !cont)
 			fatal("Write connection closed");
 		buffer_consume(&active_state->output, len);
 	}
+	return(len);
 }
 
 /*
diff --git a/packet.h b/packet.h
index e7b5fcb..52f94fc 100644
--- a/packet.h
+++ b/packet.h
@@ -51,7 +51,7 @@ void     packet_put_ecpoint(const EC_GROUP *, const EC_POINT *);
 void     packet_put_string(const void *buf, u_int len);
 void     packet_put_cstring(const char *str);
 void     packet_put_raw(const void *buf, u_int len);
-void     packet_send(void);
+int      packet_send(void);
 
 int      packet_read(void);
 void     packet_read_expect(int type);
@@ -85,7 +85,7 @@ int	 packet_get_ssh1_cipher(void);
 void	 packet_set_iv(int, u_char *);
 void	*packet_get_newkeys(int);
 
-void     packet_write_poll(void);
+int      packet_write_poll(void);
 void     packet_write_wait(void);
 int      packet_have_data_to_write(void);
 int      packet_not_very_much_data_to_write(void);
diff --git a/serverloop.c b/serverloop.c
index 813e5bf..319fcdf 100644
--- a/serverloop.c
+++ b/serverloop.c
@@ -94,10 +94,10 @@ static int fdin;		/* Descriptor for stdin (for writing) */
 static int fdout;		/* Descriptor for stdout (for reading);
 				   May be same number as fdin. */
 static int fderr;		/* Descriptor for stderr.  May be -1. */
-static long stdin_bytes = 0;	/* Number of bytes written to stdin. */
-static long stdout_bytes = 0;	/* Number of stdout bytes sent to client. */
-static long stderr_bytes = 0;	/* Number of stderr bytes sent to client. */
-static long fdout_bytes = 0;	/* Number of stdout bytes read from program. */
+static u_long stdin_bytes = 0;	/* Number of bytes written to stdin. */
+static u_long stdout_bytes = 0;	/* Number of stdout bytes sent to client. */
+static u_long stderr_bytes = 0;	/* Number of stderr bytes sent to client. */
+static u_long fdout_bytes = 0;	/* Number of stdout bytes read from program. */
 static int stdin_eof = 0;	/* EOF message received from client. */
 static int fdout_eof = 0;	/* EOF encountered reading from fdout. */
 static int fderr_eof = 0;	/* EOF encountered readung from fderr. */
@@ -122,6 +122,20 @@ static volatile sig_atomic_t received_sigterm = 0;
 static void server_init_dispatch(void);
 
 /*
+ * Returns current time in seconds from Jan 1, 1970 with the maximum
+ * available resolution.
+ */
+
+static double
+get_current_time(void)
+{
+	struct timeval tv;
+	gettimeofday(&tv, NULL);
+	return (double) tv.tv_sec + (double) tv.tv_usec / 1000000.0;
+}
+
+
+/*
  * we write to this pipe if a SIGCHLD is caught in order to avoid
  * the race between select() and child_terminated
  */
@@ -421,6 +435,7 @@ process_input(fd_set *readset)
 		} else {
 			/* Buffer any received data. */
 			packet_process_incoming(buf, len);
+			fdout_bytes += len;
 		}
 	}
 	if (compat20)
@@ -443,6 +458,7 @@ process_input(fd_set *readset)
 		} else {
 			buffer_append(&stdout_buffer, buf, len);
 			fdout_bytes += len;
+			debug ("FD out now: %ld", fdout_bytes);
 		}
 	}
 	/* Read and buffer any available stderr data from the program. */
@@ -510,7 +526,7 @@ process_output(fd_set *writeset)
 	}
 	/* Send any buffered packet data to the client. */
 	if (FD_ISSET(connection_out, writeset))
-		packet_write_poll();
+		stdin_bytes += packet_write_poll();
 }
 
 /*
@@ -824,11 +840,13 @@ void
 server_loop2(Authctxt *authctxt)
 {
 	fd_set *readset = NULL, *writeset = NULL;
+	double start_time, total_time;
 	int rekeying = 0, max_fd;
 	u_int nalloc = 0;
 	u_int64_t rekey_timeout_ms = 0;
 
 	debug("Entering interactive session for SSH2.");
+	start_time = get_current_time();
 
 	mysignal(SIGCHLD, sigchld_handler);
 	child_terminated = 0;
@@ -893,6 +911,11 @@ server_loop2(Authctxt *authctxt)
 
 	/* free remaining sessions, e.g. remove wtmp entries */
 	session_destroy_all(NULL);
+	total_time = get_current_time() - start_time;
+	logit("SSH: Server;LType: Throughput;Remote: %s-%d;IN: %lu;OUT: %lu;Duration: %.1f;tPut_in: %.1f;tPut_out: %.1f",
+	      get_remote_ipaddr(), get_remote_port(),
+	      stdin_bytes, fdout_bytes, total_time, stdin_bytes / total_time, 
+	      fdout_bytes / total_time);
 }
 
 static void
diff --git a/sshd.c b/sshd.c
index 23d5a64..492fda4 100644
--- a/sshd.c
+++ b/sshd.c
@@ -497,6 +497,9 @@ sshd_exchange_identification(int sock_in, int sock_out)
 	}
 	debug("Client protocol version %d.%d; client software version %.100s",
 	    remote_major, remote_minor, remote_version);
+	logit("SSH: Server;Ltype: Version;Remote: %s-%d;Protocol: %d.%d;Client: %.100s",
+	      get_remote_ipaddr(), get_remote_port(),
+	    remote_major, remote_minor, remote_version);
 
 	compat_datafellows(remote_version);
 
-- 
2.1.4

