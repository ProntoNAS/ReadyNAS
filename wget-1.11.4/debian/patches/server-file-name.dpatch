#!/bin/sh -e
## server-file-name.dpatch by Florian Weimer <fw@deneb.enyo.de>
##
## DP: Ignore server-provided file names by default
## DP: Also fixes harmless use-after-free-bug in http_atotm()

if [ $# -lt 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi

[ -f debian/patches/00patch-opts ] && . debian/patches/00patch-opts
patch_opts="${patch_opts:--f --no-backup-if-mismatch} ${2:+-d $2}"

case "$1" in
       -patch) patch $patch_opts -p1 < $0;;
       -unpatch) patch $patch_opts -p1 -R < $0;;
        *)
                echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
                exit 1;;
esac

exit 0

@DPATCH@

diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/doc/wget.texi git/doc/wget.texi
--- git~/doc/wget.texi	2010-05-16 16:26:53.000000000 +0200
+++ git/doc/wget.texi	2010-05-16 16:29:10.246411875 +0200
@@ -1372,6 +1372,17 @@
 @code{Content-Disposition} headers to describe what the name of a
 downloaded file should be.
 
+@cindex redirects
+@cindex HTTP redirects
+@cindex file name generation
+@item --use-server-file-name
+
+If this is set to on, the file name provided from the server is used.
+(The server might return a different name using HTTP redirects.)  It is
+recommended to use this option for backwards compatibility only because
+server-provided file names can be unpredictable and lead to unexpected
+results.
+
 @cindex authentication
 @item --auth-no-challenge
 
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/http.c git/src/http.c
--- git~/src/http.c	2010-05-16 16:26:53.000000000 +0200
+++ git/src/http.c	2010-05-16 16:29:10.241664589 +0200
@@ -1359,7 +1359,8 @@
    If PROXY is non-NULL, the connection will be made to the proxy
    server, and u->url will be requested.  */
 static uerr_t
-gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy)
+gethttp (struct url *u, struct http_stat *hs, int *dt, struct url *proxy,
+         struct url *original_u)
 {
   struct request *req;
 
@@ -1418,6 +1419,8 @@
 
   bool host_lookup_failed = false;
 
+  assert(original_u != 0);
+
 #ifdef HAVE_SSL
   if (u->scheme == SCHEME_HTTPS)
     {
@@ -1815,7 +1818,7 @@
         {
           /* The Content-Disposition header is missing or broken. 
            * Choose unique file name according to given URL. */
-          hs->local_file = url_file_name (u);
+          hs->local_file = url_file_name (original_u);
         }
     }
   
@@ -2325,7 +2328,7 @@
    retried, and retried, and retried, and...  */
 uerr_t
 http_loop (struct url *u, char **newloc, char **local_file, const char *referer,
-           int *dt, struct url *proxy)
+           int *dt, struct url *proxy, struct url *original_u)
 {
   int count;
   bool got_head = false;         /* used for time-stamping and filename detection */
@@ -2341,6 +2344,8 @@
 
   /* Assert that no value for *LOCAL_FILE was passed. */
   assert (local_file == NULL || *local_file == NULL);
+
+  assert(original_u != 0);
   
   /* Set LOCAL_FILE parameter. */
   if (local_file && opt.output_document)
@@ -2370,7 +2375,7 @@
     }
   else if (!opt.content_disposition)
     {
-      hstat.local_file = url_file_name (u);
+      hstat.local_file = url_file_name (original_u);
       got_name = true;
     }
 
@@ -2412,7 +2417,7 @@
    * destination file. */
   if (opt.timestamping 
       && !opt.content_disposition
-      && file_exists_p (url_file_name (u)))
+      && file_exists_p (url_file_name (original_u)))
     send_head_first = true;
   
   /* THE loop */
@@ -2489,7 +2494,7 @@
         *dt &= ~SEND_NOCACHE;
 
       /* Try fetching the document, or at least its head.  */
-      err = gethttp (u, &hstat, dt, proxy);
+      err = gethttp (u, &hstat, dt, proxy, original_u);
 
       /* Time?  */
       tms = datetime_str (time (NULL));
@@ -2914,13 +2919,24 @@
                                    Netscape cookie specification.) */
   };
   const char *oldlocale;
-  int i;
+  char savedlocale[256];
+  size_t i;
   time_t ret = (time_t) -1;
 
   /* Solaris strptime fails to recognize English month names in
      non-English locales, which we work around by temporarily setting
      locale to C before invoking strptime.  */
   oldlocale = setlocale (LC_TIME, NULL);
+  if (oldlocale)
+    {
+      size_t l = strlen (oldlocale);
+      if (l >= sizeof savedlocale)
+        savedlocale[0] = '\0';
+      else
+        memcpy (savedlocale, oldlocale, l + 1);
+    }
+  else savedlocale[0] = '\0';
+
   setlocale (LC_TIME, "C");
 
   for (i = 0; i < countof (time_formats); i++)
@@ -2940,7 +2956,8 @@
     }
 
   /* Restore the previous locale. */
-  setlocale (LC_TIME, oldlocale);
+  if (savedlocale[0])
+    setlocale (LC_TIME, savedlocale);
 
   return ret;
 }
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/http.h git/src/http.h
--- git~/src/http.h	2010-05-16 16:26:53.000000000 +0200
+++ git/src/http.h	2010-05-16 16:29:10.246411875 +0200
@@ -33,7 +33,7 @@
 struct url;
 
 uerr_t http_loop (struct url *, char **, char **, const char *, int *,
-		  struct url *);
+		  struct url *, struct url *);
 void save_cookies (void);
 void http_cleanup (void);
 time_t http_atotm (const char *);
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/init.c git/src/init.c
--- git~/src/init.c	2010-05-16 16:26:53.000000000 +0200
+++ git/src/init.c	2010-05-16 16:29:10.241664589 +0200
@@ -243,6 +243,7 @@
   { "useproxy",         &opt.use_proxy,         cmd_boolean },
   { "user",             &opt.user,              cmd_string },
   { "useragent",        NULL,                   cmd_spec_useragent },
+  { "useserverfilename", &opt.use_server_file_name, cmd_boolean },
   { "verbose",          NULL,                   cmd_spec_verbose },
   { "wait",             &opt.wait,              cmd_time },
   { "waitretry",        &opt.waitretry,         cmd_time },
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/main.c git/src/main.c
--- git~/src/main.c	2010-05-16 16:26:53.000000000 +0200
+++ git/src/main.c	2010-05-16 16:29:10.241664589 +0200
@@ -240,6 +240,7 @@
     { "timeout", 'T', OPT_VALUE, "timeout", -1 },
     { "timestamping", 'N', OPT_BOOLEAN, "timestamping", -1 },
     { "tries", 't', OPT_VALUE, "tries", -1 },
+    { "use-server-file-name", 0, OPT_BOOLEAN, "useserverfilename", -1 },
     { "user", 0, OPT_VALUE, "user", -1 },
     { "user-agent", 'U', OPT_VALUE, "useragent", -1 },
     { "verbose", 'v', OPT_BOOLEAN, "verbose", -1 },
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/options.h git/src/options.h
--- git~/src/options.h	2010-05-16 16:26:53.000000000 +0200
+++ git/src/options.h	2010-05-16 16:29:10.241664589 +0200
@@ -236,6 +236,7 @@
   bool content_disposition;	/* Honor HTTP Content-Disposition header. */
   bool auth_without_challenge;  /* Issue Basic authentication creds without
                                    waiting for a challenge. */
+  bool use_server_file_name; 	/* Use server-provided file name. */
 };
 
 extern struct options opt;
diff -urNad '--exclude=CVS' '--exclude=.svn' '--exclude=.git' '--exclude=.arch' '--exclude=.hg' '--exclude=_darcs' '--exclude=.bzr' git~/src/retr.c git/src/retr.c
--- git~/src/retr.c	2010-05-16 16:26:53.000000000 +0200
+++ git/src/retr.c	2010-05-16 16:29:10.246411875 +0200
@@ -604,7 +604,7 @@
   bool location_changed;
   int dummy;
   char *mynewloc, *proxy;
-  struct url *u, *proxy_url;
+  struct url *u, *proxy_url, *original_u;
   int up_error_code;            /* url parse error code */
   char *local_file;
   int redirection_count = 0;
@@ -625,7 +625,7 @@
   if (file)
     *file = NULL;
 
-  u = url_parse (url, &up_error_code);
+  u = original_u = url_parse (url, &up_error_code);
   if (!u)
     {
       logprintf (LOG_NOTQUIET, "%s: %s.\n", url, url_error (up_error_code));
@@ -672,7 +672,12 @@
 #endif
       || (proxy_url && proxy_url->scheme == SCHEME_HTTP))
     {
-      result = http_loop (u, &mynewloc, &local_file, refurl, dt, proxy_url);
+      /* Only use the original URL if useserverfilename has been
+         enabled.  The local file name is extracted from the original
+         URL, and redirection might lead to unexpected file names
+         unless the original URL is used. */
+      result = http_loop (u, &mynewloc, &local_file, refurl, dt, proxy_url,
+                          opt.use_server_file_name ? u : original_u);
     }
   else if (u->scheme == SCHEME_FTP)
     {
@@ -728,6 +733,8 @@
         {
           logprintf (LOG_NOTQUIET, "%s: %s.\n", escnonprint_uri (mynewloc),
                      url_error (up_error_code));
+          if (original_u != u)
+            url_free (original_u);
           url_free (u);
           xfree (url);
           xfree (mynewloc);
@@ -747,6 +754,8 @@
           logprintf (LOG_NOTQUIET, _("%d redirections exceeded.\n"),
                      opt.max_redirect);
           url_free (newloc_parsed);
+          if (original_u != u)
+            url_free (original_u);
           url_free (u);
           xfree (url);
           xfree (mynewloc);
@@ -756,7 +765,8 @@
 
       xfree (url);
       url = mynewloc;
-      url_free (u);
+      if (u != original_u)
+        url_free (u);
       u = newloc_parsed;
 
       /* If we're being redirected from POST, we don't want to POST
@@ -787,6 +797,8 @@
   else
     xfree_null (local_file);
 
+  if (original_u != u)
+    url_free (original_u);
   url_free (u);
 
   if (redirection_count)
