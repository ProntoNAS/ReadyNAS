<!-- ***** BEGIN LICENSE BLOCK *****
  Source last modified: $Id: umakefil.html,v 1.1.1.1 2006/03/29 16:45:39 hagi Exp $
  
  Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
  
  The contents of this file, and the files included with this file,
  are subject to the current version of the RealNetworks Public
  Source License (the "RPSL") available at
  http://www.helixcommunity.org/content/rpsl unless you have licensed
  the file under the current version of the RealNetworks Community
  Source License (the "RCSL") available at
  http://www.helixcommunity.org/content/rcsl, in which case the RCSL
  will apply. You may also obtain the license terms directly from
  RealNetworks.  You may not use this file except in compliance with
  the RPSL or, if you have a valid RCSL with RealNetworks applicable
  to this file, the RCSL.  Please see the applicable RPSL or RCSL for
  the rights, obligations and limitations governing use of the
  contents of the file.
  
  Alternatively, the contents of this file may be used under the
  terms of the GNU General Public License Version 2 or later (the
  "GPL") in which case the provisions of the GPL are applicable
  instead of those above. If you wish to allow use of your version of
  this file only under the terms of the GPL, and not to allow others
  to use your version of this file under the terms of either the RPSL
  or RCSL, indicate your decision by deleting the provisions above
  and replace them with the notice and other provisions required by
  the GPL. If you do not delete the provisions above, a recipient may
  use your version of this file under the terms of any one of the
  RPSL, the RCSL or the GPL.
  
  This file is part of the Helix DNA Technology. RealNetworks is the
  developer of the Original Code and owns the copyrights in the
  portions it created.
  
  This file, and the files included with this file, is distributed
  and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
  ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
  ENJOYMENT OR NON-INFRINGEMENT.
  
  Technology Compatibility Kit Test Suite(s) Location:
     http://www.helixcommunity.org/content/tck
  
  Contributor(s):
  
  ***** END LICENSE BLOCK *****
-->
<html>
<head><title>Writing Umakefil/*.pcf Files</title></head>
<body bgcolor="#ffffff">

<h1>Writing Umakefil/*.pcf Files</h1>
<hr>


<table width=100%><tr bgcolor='#88ff88'><td><center><h2>
Targets and global functions
</h2></center></tr></td></table>

<hr>
<p>
<b>UmakefileVersion(<i>major, minor</i>)</b><br>
<i>arguments: major(int), minor(int)</i><br>
<i>returns: none</i><br>

All umake files should start with a call to UmakefileVersion(),
this will tell the build system how to interpret the contents
of the umake file in a way that is backwards compatible.
When creating a new umake file, you should use the version
of the build system you are currently using. This documentation
was written for build 2.2 which means that you should use
<tt>UmakefileVersion(2,2)</tt> in order to get the build system
to behave as described here.

</p>
<hr>

<hr>
<p>
<b>MultiTargetMake(<i>umakefil1_path, umakefil2_path, ...</i>)</b><br>
<i>arguments: umakefil1_path(string)</i><br>
<i>returns: none</i><br>

See full documentation <a href="multitarget.html">here</a>.

</p>
<hr>


<p>
<b>ProgramWithResourceTarget(<i>target, rtarget, rfile, includes</i>)</b><br>
<i>arguments: target(string), rtarget(string), rfile(string), includes(string or list of strings)</i><br>
<i>returns: none</i><br>

On the Macintosh OS9, this builds a program and Windows <b>.xrs</b>
DLL.  On all other platforms, <b>ProgramWithResourceTarget</b> simply
calls <b>ProgramTarget</b> with the <i>target</i> argument.

</p>
<hr>


<p>
<b>DLLWithResourceTarget(<i>target, rtarget, rfile, includes</i>)</b><br>
<i>arguments: target(string), rtarget(string), rfile(string), includes(string or list of strings)</i><br>
<i>returns: none</i><br>

On the Macintosh OS9, this builds a DLL and Windows <b>.xrs</b> DLL.
On all other platforms, <b>DLLWithResourceTarget</b> simply calls
<b>DLLTarget</b> with the <i>target</i> argument.

</p>
<hr>


<p>
<b>ProgramTarget(<i>target</i>)</b><br>
<i>arguments: target(string)</i><br>
<i>returns: none</i><br>

Specifies a executable should be built from the <b>project</b> data,
with name name <i>target</i>.  Umake may add a platform-appropriate
extension to the output name.  There are also several other methods
of changing the output name of the executable.

</p>
<hr>


<p>
<b>LibraryTarget(<i>target</i>)</b><br>
<i>arguments: target(string)</i><br>
<i>returns: none</i><br>

Specifies a static library should be built from the <b>project</b>
data, with name name <i>target</i>.  Umake may add a
platform-appropriate extension to the output name.  There are no other
ways of changing the output name for a static library, because
<b>project.AddModuleLibraries</b> allows linking to static libraries
by adding only their module name.  Because of this, the only way for
those other modules to find the library is to assume its name was
created the standard way by umake.  Also, <i>target</i> must be the
same as the CVS module name.

</p>
<hr>


<p>
<b>DLLTarget(<i>target, [ libtarget ]</i>)</b><br>
<i>arguments: target(string), libtarget(string)</i><br>
<i>returns: none</i><br>

Specifies a dynamic library should be built from the <b>project</b>
data, with name name <i>target</i>.  Umake may add a
platform-appropriate extension to the output name, and change the name
to include versioning information.  There are also several other
methods of changing the output name of the DLL.
<p>
If the optional argument <i>libtarget</i> is specified,
the *.lib file generated by some platforms will use this
name instead of <i>target</i>.

</p>
<hr>


<p>
<b>EmptyTarget()</b><br>
<i>arguments: none</i><br>
<i>returns: none</i><br>

Creates a empty Makefile.

</p>
<hr>



<a name=GetSDKPath>
<p>
<b>GetSDKPath(<i>sdk_name</i>)</b><br>
<i>arguments: sdk_name(string)</i><br>
<i>returns: path(string)</i><br>

This function allows you to access the path to an third party library
or SDK. These paths should be defined in your
<a href="buildrc.html">buildrc</a> file, or using environment variables.
For more information on sdk:s, see <a href="bif.html#sdk">the SDK BIF tag</a>.
GetSDKPath will always return an absolute path.
</p>
</a>
<hr>

<a name=SetSDKPath>
<p>
<b>SetSDKPath(<i>sdk_name, path</i>)</b><br>
<i>arguments: sdk_name(string), path(string)</i><br>
<i>returns: none</i><br>

This function tells the build system where to find an SDK.
It is required in order for the build system to be able to
find directx and other third party libraries. These paths
can later be used in your <a href="umakefil.html">umake files</a>
and should also be declared in your <a href="bif.html">BIF</a>
files.

</p>
</a>
<hr>




<table width=100%><tr bgcolor='#88ff88'><td><center><h2>
Global Variables
</h2></center></tr></td></table>

<p><b>ALL GLOBAL VARIABLES ARE DEPRECATED.</b>  Yes, that's right.
The entire Umakefil should be written with methods of the
<b>project</b> object described below.</p>
<hr>

<p>
<b>common_defines = "define1 define2 ..."</b><br>
Specifies a space-separated list of defines to be added to the project.  This has been replaced with <b>project.AddDefines()</b>.
</p>
<hr>

<p>
<b>common_libraries = "module1 module2 ..."</b><br>
Specifies a space-separated list of static libraries built in CVS modules named module1, module2, etc., should be added to the project.  This has been replaced with <b>project.AddModuleLibraries()</b>.
</p>
<hr>

<p>
<b>common_includes = "path1 path2 ..."</b><br>
Specifies a space-separated list of include search paths to be added to the project.  This has been replaced with <b>project.AddIncludes()</b>.
</p>
<hr>

<p>
<b>common_srcs = "source1_path source2_path ..."</b><br>
Specifies a space-separated list of source files to be added to the project.  This has been replaced with <b>project.AddSources()</b>.
</p>
<hr>

<p>
<b>sub_umakes = "umake1 umake2 ..."</b><br>
<b>sub_platform_name_pcfs = "name1 name2 ..."</b><br>
<b>sub_platform_type_pcfs = "type1 type2 .."</b><br>
Specifies a space-separated list of umake files for a multi-target
module.  This entire method of writing multi-target makefiles has been
deprecated because it is fundamentally broken.
</p>
<hr>



<table width=100%><tr bgcolor='#88ff88'><td><center>
<h2>Methods of <b>project</b></h2>
</center></tr></td></table>

<hr>
<p>
<b>project.SetDLLTypePlugin()</b><br>
<b>project.SetDLLTypeCodec()</b><br>
<b>project.SetDLLTypeCommon()</b><br>
<i>arguments: none</i><br>
<i>returns: none</i><br>

Specifies the DLL being built is a G2 plug-in, codec, or
common(normal).  This is used in when building in a mode which
statically links the plug-ins into the player.

</p>
<hr>


<p>
<b>project.AddBuildOption(<i>option</i>)</b><br>
<i>arguments: option(string)</i><br>
<i>returns: none</i><br>

Sets the same type of build option as the <i>-t option</i> does on the
command line.  Results may be mixed, because a particular option may have
to be processed before the Umakefil is executed.

</p>
<hr>


<p>
<b>project.RemoveBuildOption(<i>option</i>)</b><br>
<i>arguments: option(string)</i><br>
<i>returns: none</i><br>

Removes a build option if it was previously set.   Results may be
mixed, because a particular option may have already been processed
before the Umakefil is executed.

</p>
<hr>


<p>
<b>project.BuildOption(<i>option</i>)</b><br>
<i>arguments: option(string)</i><br>
<i>returns: true/false</i><br>

Checks if a build option was set.

</p>
<hr>


<p>
<b>project.AddSources(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Adds sources to the project.  This method takes a comma-separated list
of strings.  It is best to use UNIX-style (<b>/</b> path separators)
in deep paths, because Umake can convert those paths to the
platform-specific paths automatically.

</p>
<hr>

<p>
<b>project.AddModuleSources(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Similar to AddSources, but each source is relative to the source root
rather than the current directory.

</p>
<hr>


<p>
<b>project.RemoveSources(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Removes sources already added to the project, while not blocking those
sources from being included later in the Umakefil.  The paths must
match the string they were added with exactly.

</p>
<hr>


<p>
<b>project.AddSourceObjects(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Adds pre-compiled object files to the project.  This feature is used in
the codes for hand-optimized assembly from Intel.

</p>
<hr>


<p>
<b>project.RemoveSourceObjects(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Removes pre-compiled object files from the project. 

</p>
<hr>


<p>
<b>project.AddIncludes(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Adds header file include paths to the project.

</p>
<hr>


<p>
<b>project.RemoveIncludes(<i>source1_path, source2_path, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Removes header file include paths from the project.

</p>
<hr>


<a name=AddModuleIncludes>
<p>
<b>project.AddModuleIncludes(<i>module1, module2, module3/dir...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Similar to AddIncludes, but paths should be relative to the build
root and always use "/" as path separators. So, instead of doing
<tt>project.AddIncludes("../gemctl/pub")</tt> you can do
<tt>project.AddModuleIncludes("gemctl/pub")</tt>.

</p>
</a>
<hr>


<p>
<b>project.RemoveModuleIncludes(<i>module1, module2, module3/dir...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>

Removes header file include paths from the project, syntax
is same as project.AddModuleIncludes.

</p>
<hr>


<p>
<b>project.AddDefines(<i>define1, define2, ...</i>)</b><br>
<i>arguments: variable number of defines(strings)</i><br>
<i>returns: none</i><br>

Adds C/C++ defines to the project.  A define string without a string
assignment will default to true, otherwise a value can be set by
including the assignment in the string with a <b>=</b> sign.  For
example: <b>"DEBUG=2"</b> would define the symbol <b>DEBUG</b> to be
the value <b>2</b>.

</p>
<hr>


<p>
<b>project.RemoveDefines(<i>define1, define2, ...</i>)</b><br>
<i>arguments: variable number of defines(strings)</i><br>
<i>returns: none</i><br>

Removes C/C++ defines from the project.  They must appear exactly as
they were added.

</p>
<hr>
<p>
<b>project.IsDefined(<i>define</i>)</b><br>
<i>arguments: a define(string)</i><br>
<i>returns: bool</i><br>

Returns true if <i>define</i> is defined, false otherwise.
</p>
<hr>


<p>
<b>project.AddLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddSystemLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveSystemLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddDynamicLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveDynamicLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddModuleLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
This method links against a library created by the build system.
Each argument should the name of the module containing that library.
If the module is in a subdirectory, / can be used to specify the name.
If the name of the library is not the same as the directory it is in,
you can append <i>[libname]</i> to specify the name of the library.
<blockquote>
Examples: (where "release" is sometimes replaced with "debug")<br>
<tt>project.AddModuleLibrary("pnmisc") # Link against pnmisc/release/pnmisc.lib<br>
project.AddModuleLibrary("foo/bar") # Link against foo/bar/release/bar.lib<br>
project.AddModuleLibrary("foo/bar[gazonk]") # Link against foo/bar/release/gazonk.lib<br>
</tt>
</blockquote>

When executing AddModuleLibraries, umake will also look for a file called
<i>module</i>/<i>libraryname</i>_linkhook.cf and execute it if present.
This allows the <i>module</i> to add include paths and other magic so that
the library users don't have to think about it.

<blockquote>
Examples:
<tt>project.AddModuleLibrary("pnmisc") # Execute pnmisc/pnmisc_linkhook.cf
project.AddModuleLibrary("foo/bar") # Execute foo/bar/bar_linkhook.cf
project.AddModuleLibrary("foo/bar[gazonk]") # Execute foo/bar/gazonk_linkhook.cf
</tt>
</blockquote>

</p>
<hr>


<p>
<b>project.RemoveModuleLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddLocalLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveLocalLibraries(<i>lib1_path, lib2_path, ...</i>)</b><br>
<i>arguments: variable number of libraries(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddSystemPaths(<i>path1, path2, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveSystemPaths(<i>path1, path2, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.ExportFunction(<i>func, proto [, includedir, includefile ]</i>)</b><br>
<i>arguments: func(string), proto(string</i><br>
<i>returns: none</i><br>

This function should be used in DLLs to export functions which
needs to be accessed from outside the DLL. The <i>proto</i> should
be a list of arguments accepted by this function. The <i>proto</i>
will be used to build prototypes for this function in global header
files. If the <i>includeddir</i> and <i>includefile</i> parameters
are present, the <i>includefile</i> will be added to the generated
header file, and <i>includedir</i> is the directory which contains
that include file. <i>Includefile</i> should be relative to the
source root as it will be sent to
<a href=#AddModuleIncludes>project.AddModuleIncludes</a> in the
project which use this header file.

</p>
<hr>

<p>
<b>project.AddExportedFunctions(<i>func1, func2, ...</i>)</b> - deprecated<br>
<i>arguments: variable number of functions(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveExportedFunctions(<i>func1, func2, ...</i>)</b><br>
<i>arguments: variable number of functions(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.AddCopyTargets(<i>path1, path2, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.RemoveCopyTargets(<i>path1, path2, ...</i>)</b><br>
<i>arguments: variable number of paths(strings)</i><br>
<i>returns: none</i><br>
</p>
<hr>


<p>
<b>project.SetModuleDepth(<i>depth</i>)</b><br>
<i>arguments: depth(int)</i><br>
<i>returns: none</i><br>

This function tells the build system how many directory levels
below the build root this module is. The default value is 1.

</p>
<hr>

<p>
<b>project.EnableFeature(<i>feature</i>)</b><br>
<i>arguments: feature(string)</i><br>
<i>returns: none</i><br>

This function allows you to do what
<a href=#UmakefileVersion>UmakefileVersion</a> does manually.
This is the list of features you can turn on using this function:
<dl>
<dt> submodules
<dd> This will enable multi-target umake files to cd into the
     directory where a submodule is located instead of trying
     to execute it from the current working directory.
</dl>

<dt> versioning_off
<dd> This will turn off name mangling for DLLs on most platforms.
     Normally *.ver files are used to create a versioned filename
     for DLLs, but with this feature. (Which is on by default if
     you use <tt>UmakeFileVersion(2,1)</tt> or greater)
</dl>


</p>
<hr>
<p>
<b>project.SetBuildVersion(<i>date</i>)</b> - <i>deprecated</i><br>
<i>arguments: date(int)</i><br>
<i>returns: none</i><br>

This function tells the build system to try to be compatible with the
build system on date <i>date</i>. Date should be a 8-digit number on
the form <tt>YYYYMMDD</tt>. Please note that the default is 20020101,
which means that some newer functionality will be turned off unless
you incorporate this function in your umake file.

</p>
<hr>

<p>
<b>project.SetBuild2002Version(<i>date</i>)</b> - <i>deprecated</i><br>
<i>arguments: date(int)</i><br>
<i>returns: none</i><br>

This function does the same as SetBuildVersion, but tells the
build system to try to be compatible with the build2002 repository
on the given date.
</p>
<hr>


<a name=AddDebugOutput>
<p>
<b>project.AddDebugOutput(<i>env_var, rel_path </i>)</b><br>
<i>arguments: env_var(string), rel_path(string)</i><br>
<i>returns: none</i><br>

 This function takes an environment variable and a relative
 path as arguments. If the environment variable exists, a
 link to/alias to/copy of the output will be placed in that
 directory. Example:

   <tt> project.AddDebugOutput("RP_DEBUG_BASEDIR","plugins/rv/") </tt>

 This will copy the output into $RP_DEBUG_BASEDIR/plugins/rv/
 Since the paths are often platform specific, this functions
 should normally only be used in pcf files.<br>

 <b>NOTA BENE:</b>
   The <i>rel_path</i> arguments *must* end with a slash if it
   is a directory.
</p>
</a>
<hr>

<a name=AddFileDependency>
<p>
<b>project.AddFileDepenency(<i>file, depend [, depend, depend ... ] </i>)</b><br>
<i>arguments: file(string), depend(string)</i><br>
<i>returns: none</i><br>

 This will add a dependency to the generated makefile so that
 make knows that <i>file</i> depends on <i>depend</i>.

</p>
</a>
<hr>


<a name=SetDistLocation>
<p>
<b>project.SetDistLocation( [release = <i>location</i> ], [ debug = <i>location</i> ], [ any = <i>location</i> ] )</b><br>
<i>arguments: location(string)</i><br>
<i>returns: none</i>
<p>
  This will tell umake to check in the library/dll/program generated by
  this umakefile into the location given by 'location'. The location
  is relative to the source root and must be a directory which has a
  <a href=bif.html#checkin_dependlist>&lt;checkin_dependlist&gt;</a>
  from this module.
<p/><p>
  The location should be given using one of the named parameters
  <tt>release</tt>, <tt>debug</tt> or <tt>any</tt>.
  If you use the <tt>release</tt> parameter, then the checkin will only
  be performed if this is a release build.
</p><p>
  The location can use brackets to specify the location and name of the
  library, a few examples to illustrate. For simplicity, I will assume
  that project.SetDistLocation was used in a LibraryTarget umakefile.

  <dl>
  <dt><tt>project.SetDistLocation(release="foo/bar[../gazonk]")</tt></dt>
  <dd>This will check in the library as 'gazonk'. It will be checked in
      at the top level so that the distribution will be shared by both
      debug and release builds using this dist. If this is a debug build,
      then nothing will happen.</dd>

  <dt><tt>project.SetDistLocation(debug="foo/bar[./gazonk]")</tt></dt>
  <dd>This will check in the library as 'gazonk'. It will be checked in
      into the debug directory of the foo/bar module, but only if this is a
      debug build, otherwise nothing will happen.</dd>

  <dt><tt>project.SetDistLocation(any="foo/bar[./gazonk]")</tt></dt>
  <dd>This will check in the library as 'gazonk'. It will be checked in
      into the release/debug directory depending on what kind of build
      this is.</dd>

  <dt><tt>project.SetDistLocation("foo/bar")</tt></dt>
  <dd>This will check in the library as 'foo'.
      It will search the foo/bar directory to see if the library
      already exists, and if it does check it into the same place.
      If it does not exist, it will be checked in into the
      debug/release directory as approperiate. However, no checkin
      will take place if this is a debug build.</dd>
  </dl>
</p>
</a>
<hr>


</body>
</html>
