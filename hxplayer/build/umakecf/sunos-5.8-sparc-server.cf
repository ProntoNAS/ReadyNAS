# 
# ***** BEGIN LICENSE BLOCK *****
# Source last modified: $Id: sunos-5.8-sparc-server.cf,v 1.1.1.1 2006/03/29 16:45:39 hagi Exp $
# 
# Portions Copyright (c) 1995-2004 RealNetworks, Inc. All Rights Reserved.
# 
# The contents of this file, and the files included with this file,
# are subject to the current version of the RealNetworks Public
# Source License (the "RPSL") available at
# http://www.helixcommunity.org/content/rpsl unless you have licensed
# the file under the current version of the RealNetworks Community
# Source License (the "RCSL") available at
# http://www.helixcommunity.org/content/rcsl, in which case the RCSL
# will apply. You may also obtain the license terms directly from
# RealNetworks.  You may not use this file except in compliance with
# the RPSL or, if you have a valid RCSL with RealNetworks applicable
# to this file, the RCSL.  Please see the applicable RPSL or RCSL for
# the rights, obligations and limitations governing use of the
# contents of the file.
# 
# Alternatively, the contents of this file may be used under the
# terms of the GNU General Public License Version 2 or later (the
# "GPL") in which case the provisions of the GPL are applicable
# instead of those above. If you wish to allow use of your version of
# this file only under the terms of the GPL, and not to allow others
# to use your version of this file under the terms of either the RPSL
# or RCSL, indicate your decision by deleting the provisions above
# and replace them with the notice and other provisions required by
# the GPL. If you do not delete the provisions above, a recipient may
# use your version of this file under the terms of any one of the
# RPSL, the RCSL or the GPL.
# 
# This file is part of the Helix DNA Technology. RealNetworks is the
# developer of the Original Code and owns the copyrights in the
# portions it created.
# 
# This file, and the files included with this file, is distributed
# and made available on an 'AS IS' basis, WITHOUT WARRANTY OF ANY
# KIND, EITHER EXPRESS OR IMPLIED, AND REALNETWORKS HEREBY DISCLAIMS
# ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES
# OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET
# ENJOYMENT OR NON-INFRINGEMENT.
# 
# Technology Compatibility Kit Test Suite(s) Location:
#    http://www.helixcommunity.org/content/tck
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 
"""Solaris 8 build config for the server using SunOS 5.8 (Solaris 8)
using Sun WorkShop Release 6 update 1."""

exec_config_file('sunos-5.x-sparc-native-server.cf')

## list of PCF files to run
platform.pcf_prefix_list = ['unix', 'sunos5', 'sunos-5.8']

## defines
## Turn on Threads support
## Turn on Network IO Threading
project.AddDefines(
    "_NATIVE_COMPILER",
    "_SOLARIS28",
    "_REENTRANT",
    "_UNIX_THREADS_SUPPORTED",
    "_UNIX_THREADED_NETWORK_IO",
    "_POSIX_PTHREAD_SEMANTICS")


class Solaris8LinkerSparc(Linker2):
    def link_paths(self):
        return string.join(platform.system_paths) +\
               string.join(project.system_paths)

    def link_script_path(self):
        return "%s.exp" % (project.TargetName())

    def armerge_lib_path(self):
        libname = "%s_libs.%s" % (project.target_name, platform.library_suffix)
        return os.path.join(project.output_dir, libname)
    
    def armerge_tmp_path(self):
        return os.path.join(project.object_dir, "lib")

    def write_link_script(self, path):
        ## if there are no exported functions, die here
        if len(project.exported_func) == 0:
            umake_lib.fatal("dll target without exported functions") 
        
        ## create a gcc link script
        fil = open(path, "w")
        fil.write("G2 {\n")
        fil.write("  global:\n")

        for export in project.exported_func:
            fil.write("    %s;\n" % (export))

        fil.write("  local:\n")
        fil.write("    *;\n")
        fil.write("};\n")
        fil.close()

    def LinkLIB(self, target_path, objects):
        cmd_list = []
        
        cmd = "ar cr %s %s" % (target_path, objects)
        cmd_list.append(cmd)

        cmd = "ranlib %s" % (target_path)
        cmd_list.append(cmd)

        return cmd_list

    def CleanLIB(self, target_path):
        return [target_path]

    def basecmd(self):
        if project.BuildOption('debug'):
            #-xs: debugging with gdb?
            return "CC -xnolib -xlibmil -xlibmopt -dalign -xtarget=generic -xarch=v8plusa -g -xs"
        elif project.BuildOption('profile'):
            return "CC -xnolib -xlibmil -xlibmopt -dalign -xtarget=generic -xarch=v8plusa -xO3 -pg"
        else:
            return "CC -xnolib -xlibmil -xlibmopt -dalign -xtarget=generic -xarch=v8plusa -xO3"

    def LinkDLL(self, target_path, objects, static_libs, dynamic_libs):
        cmd_list = []

        armerge_cmd = os.path.join(BUILD_ROOT, "bin", "armerge")
        tmp_path = self.armerge_tmp_path()
        libpath = self.armerge_lib_path()
        cmd = "%s -d %s %s %s" % (armerge_cmd, tmp_path, libpath, static_libs)
        cmd_list.append(cmd)

        lspath = self.link_script_path()
        self.write_link_script(lspath)
        cmd = self.basecmd() + " -G "+ \
              " -M %s -o %s %s %s %s %s -lCstd -lCrun" % (
            lspath, target_path, objects, libpath,
            self.link_paths(), dynamic_libs)
        cmd_list.append(cmd)

        cmd = "rm %s" % (libpath)
        cmd_list.append(cmd)

        return cmd_list

    def CleanDLL(self, target_path):
        list = []
        list.append(target_path)
        list.append(self.armerge_tmp_path())
        list.append(self.armerge_lib_path())
        return list

    def LinkEXE(self, target_path, objects, static_libs, dynamic_libs):
        cmd_list = []

        armerge_cmd = os.path.join(BUILD_ROOT, "bin", "armerge")
        tmp_path = self.armerge_tmp_path()
        libpath = self.armerge_lib_path()
        cmd = "%s -d %s %s %s" % (armerge_cmd, tmp_path, libpath, static_libs)
        cmd_list.append(cmd)

        if project.BuildOption('profile'):
            cmd = self.basecmd() + \
                  " -o %s %s %s %s %s -lCstd -lCrun -pg -lc" % (
                target_path, objects, libpath, self.link_paths(), dynamic_libs)
        else:
            cmd = self.basecmd() + \
                  " -o %s %s %s %s %s -lCstd -lCrun" % (
                target_path, objects, libpath, self.link_paths(), dynamic_libs)
        cmd_list.append(cmd)

        cmd = "rm %s" % (libpath)
        cmd_list.append(cmd)

        return cmd_list
    
    def CleanEXE(self, target_path):
        list = []
        list.append(target_path)
        list.append(self.armerge_tmp_path())
        list.append(self.armerge_lib_path())
        return list
    
platform.link = Solaris8LinkerSparc()
