From 2c577d4f48f85f26986b06c1450740a327b8ec92 Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard10@gmail.com>
Date: Fri, 30 Jan 2015 12:09:30 -0800
Subject: [PATCH 07/19] vfs_shadow_copy2-btrfs.patch

---
 source3/modules/vfs_shadow_copy2.c | 103 +++++++++++++++++++++++++++++++++++++
 1 file changed, 103 insertions(+)

diff --git a/source3/modules/vfs_shadow_copy2.c b/source3/modules/vfs_shadow_copy2.c
index 439df5d..783a4c6 100644
--- a/source3/modules/vfs_shadow_copy2.c
+++ b/source3/modules/vfs_shadow_copy2.c
@@ -35,6 +35,10 @@
 #include <ccan/hash/hash.h>
 #include "util_tdb.h"
 
+#define BTRFS_IOCTL_MAGIC 0x94 
+#define BTRFS_IOC_GET_ROOT_OTIME _IOR(BTRFS_IOCTL_MAGIC, 100, \
+					struct timespec)
+
 struct shadow_copy2_config {
 	char *gmt_format;
 	bool use_sscanf;
@@ -43,6 +47,7 @@ struct shadow_copy2_config {
 	bool snapdirseverywhere;
 	bool crossmountpoints;
 	bool fixinodes;
+	bool btrfs_subvol;
 	char *sort_order;
 	bool snapdir_absolute;
 	char *basedir;
@@ -177,6 +182,59 @@ static char *shadow_copy2_insert_string(TALLOC_CTX *mem_ctx,
 		DEBUG(1, (__location__ " talloc_asprintf failed\n"));
 	}
 
+	if (result && access(result, F_OK) && config->btrfs_subvol) {
+		DIR *p;
+		struct dirent *d;
+
+		TALLOC_FREE(result);
+		p = SMB_VFS_NEXT_OPENDIR(handle, config->snapdir, NULL, 0);
+		if (!p) {
+			DEBUG(2,("%s: SMB_VFS_NEXT_OPENDIR() failed for '%s'"
+				 " - %s\n", __func__, config->snapdir,
+				 strerror(errno)));
+			talloc_free(mem_ctx);
+			errno = ENOSYS;
+			return NULL;
+		}
+
+		while ((d = SMB_VFS_NEXT_READDIR(handle, p, NULL))) {
+			struct tm timestamp;
+			unsigned long int timestamp_long;
+			int fd;
+			struct timespec tv;
+
+			if (d->d_name[0] == '.' ||
+			    sscanf(d->d_name, config->gmt_format, &timestamp_long) == 1 ||
+			    strptime(d->d_name, config->gmt_format, &timestamp))
+				continue;
+
+			if (config->snapdir_absolute) {
+				result = talloc_asprintf(mem_ctx, "%s/%s",
+							 config->snapdir, d->d_name);
+			} else {
+				result = talloc_asprintf(mem_ctx, "/%s/%s",
+							 config->snapdir, d->d_name);
+			}
+
+			fd = open(result, O_RDONLY);
+			if (fd < 0) {
+				DEBUG(2,("%s: open() failed for '%s' - %s\n",
+					 __func__, result, strerror(errno)));
+				TALLOC_FREE(result);
+				return NULL;
+			}
+			if (ioctl(fd, BTRFS_IOC_GET_ROOT_OTIME, &tv) ||
+			    tv.tv_sec != snapshot) {
+				TALLOC_FREE(result);
+				result = NULL;
+			}
+			close(fd);
+			if (result)
+				break;
+		}
+		SMB_VFS_NEXT_CLOSEDIR(handle,p);
+	}
+
 	return result;
 }
 
@@ -1319,6 +1377,39 @@ static void shadow_copy2_sort_data(vfs_handle_struct *handle,
 	}
 }
 
+static bool shadow_copy2_btrfs_subvol_snapshot_to_gmt(TALLOC_CTX *mem_ctx,
+					vfs_handle_struct *handle,
+					const char *dir,
+					const char *name,
+					char *gmt, size_t gmt_len)
+{
+	bool ret = false;
+	char *path = talloc_asprintf(mem_ctx, "%s/%s", dir, name);
+	int fd;
+	struct timespec tv;
+
+	if (!path)
+		goto exit;
+	if ((fd = open(path, O_RDONLY)) < 0)
+		goto exit_free;
+	if (ioctl(fd, BTRFS_IOC_GET_ROOT_OTIME, &tv))
+		goto exit_close;
+	if (tv.tv_sec) {
+		struct tm timestamp;
+
+		gmtime_r(&tv.tv_sec, &timestamp);
+		strftime(gmt, gmt_len, GMT_FORMAT, &timestamp);
+		ret = true;
+	}
+
+exit_close:
+	close(fd);
+exit_free:
+	TALLOC_FREE(path);
+exit:
+	return ret;
+}
+
 static int shadow_copy2_get_shadow_copy_data(
 	vfs_handle_struct *handle, files_struct *fsp,
 	struct shadow_copy_data *shadow_copy2_data,
@@ -1355,6 +1446,13 @@ static int shadow_copy2_get_shadow_copy_data(
 		char snapshot[GMT_NAME_LEN+1];
 		SHADOW_COPY_LABEL *tlabels;
 
+		if (lp_parm_bool(SNUM(handle->conn), "shadow", "btrfs_subvol",
+			false) &&
+			shadow_copy2_btrfs_subvol_snapshot_to_gmt(tmp_ctx,
+				handle, snapdir, d->d_name,
+				snapshot, sizeof(snapshot)))
+			goto go;
+
 		/*
 		 * ignore names not of the right form in the snapshot
 		 * directory
@@ -1367,6 +1465,7 @@ static int shadow_copy2_get_shadow_copy_data(
 				  "ignoring %s\n", d->d_name));
 			continue;
 		}
+go:
 		DEBUG(6,("shadow_copy2_get_shadow_copy_data: %s -> %s\n",
 			 d->d_name, snapshot));
 
@@ -1834,6 +1933,10 @@ static int shadow_copy2_connect(struct vfs_handle_struct *handle,
 					 "shadow", "fixinodes",
 					 false);
 
+	config->btrfs_subvol = lp_parm_bool(SNUM(handle->conn),
+					    "shadow", "btrfs_subvol",
+					    false);
+
 	sort_order = lp_parm_const_string(SNUM(handle->conn),
 					  "shadow", "sort", "desc");
 	config->sort_order = talloc_strdup(config, sort_order);
-- 
1.9.1

