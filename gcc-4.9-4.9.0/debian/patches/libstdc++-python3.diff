# DP: Make the libstdc++-v3 pretty printer compatible with Python3.

Index: b/src/libstdc++-v3/python/libstdcxx/v6/printers.py
===================================================================
--- a/src/libstdc++-v3/python/libstdcxx/v6/printers.py
+++ b/src/libstdc++-v3/python/libstdcxx/v6/printers.py
@@ -51,7 +51,7 @@ def find_type(orig, name):
         # anything fancier here.
         field = typ.fields()[0]
         if not field.is_base_class:
-            raise ValueError, "Cannot find type %s::%s" % (str(orig), name)
+            raise ValueError("Cannot find type %s::%s" % (str(orig), name))
         typ = field.type
 
 class SharedPointerPrinter:
@@ -97,7 +97,7 @@ class StdListPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == self.head:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -144,7 +144,7 @@ class StdSlistPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -198,7 +198,7 @@ class StdVectorPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             count = self.count
             self.count = self.count + 1
             if self.bitvec:
@@ -276,20 +276,20 @@ class StdTuplePrinter:
                 # Set the actual head to the first pair.
                 self.head  = self.head.cast (nodes[0].type)
             elif len (nodes) != 0:
-                raise ValueError, "Top of tuple tree does not consist of a single node."
+                raise ValueError("Top of tuple tree does not consist of a single node.")
             self.count = 0
 
         def __iter__ (self):
             return self
 
-        def next (self):
+        def __next__ (self):
             nodes = self.head.type.fields ()
             # Check for further recursions in the inheritance tree.
             if len (nodes) == 0:
                 raise StopIteration
             # Check that this iteration has an expected structure.
             if len (nodes) != 2:
-                raise ValueError, "Cannot parse more than 2 nodes in a tuple tree."
+                raise ValueError("Cannot parse more than 2 nodes in a tuple tree.")
 
             # - Left node is the next recursion parent.
             # - Right node is the actual class contained in the tuple.
@@ -353,7 +353,7 @@ class RbtreeIterator:
     def __len__(self):
         return int (self.size)
 
-    def next(self):
+    def __next__(self):
         if self.count == self.size:
             raise StopIteration
         result = self.node
@@ -389,7 +389,7 @@ def get_value_from_Rb_tree_node(node):
             return p.dereference()
     except:
         pass
-    raise ValueError, "Unsupported implementation for %s" % str(node.type)
+    raise ValueError("Unsupported implementation for %s" % str(node.type))
 
 # This is a pretty printer for std::_Rb_tree_iterator (which is
 # std::map::iterator), and has nothing to do with the RbtreeIterator
@@ -431,9 +431,9 @@ class StdMapPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.count % 2 == 0:
-                n = self.rbiter.next()
+                n = next(self.rbiter)
                 n = n.cast(self.type).dereference()
                 n = get_value_from_Rb_tree_node(n)
                 self.pair = n
@@ -474,8 +474,8 @@ class StdSetPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
-            item = self.rbiter.next()
+        def __next__(self):
+            item = next(self.rbiter)
             item = item.cast(self.type).dereference()
             item = get_value_from_Rb_tree_node(item)
             # FIXME: this is weird ... what to do?
@@ -553,7 +553,7 @@ class StdDequePrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.p == self.last:
                 raise StopIteration
 
@@ -591,7 +591,7 @@ class StdDequePrinter:
 
         size = self.buffer_size * delta_n + delta_s + delta_e
 
-        return '%s with %d elements' % (self.typename, long (size))
+        return '%s with %d elements' % (self.typename, int (size))
 
     def children(self):
         start = self.val['_M_impl']['_M_start']
@@ -654,7 +654,7 @@ class Tr1HashtableIterator:
     def __iter__ (self):
         return self
 
-    def next (self):
+    def __next__ (self):
         if self.node == 0:
             raise StopIteration
         node = self.node.cast(self.node_type)
@@ -677,7 +677,7 @@ class StdHashtableIterator:
     def __iter__(self):
         return self
 
-    def next(self):
+    def __next__(self):
         if self.node == 0:
             raise StopIteration
         elt = self.node.cast(self.node_type).dereference()
@@ -706,10 +706,10 @@ class Tr1UnorderedSetPrinter:
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = list(map (self.format_count, itertools.count()))
         if self.typename.startswith('std::tr1'):
-            return itertools.izip (counter, Tr1HashtableIterator (self.hashtable()))
-        return itertools.izip (counter, StdHashtableIterator (self.hashtable()))
+            return list(zip (counter, Tr1HashtableIterator (self.hashtable())))
+        return list(zip (counter, StdHashtableIterator (self.hashtable())))
 
 class Tr1UnorderedMapPrinter:
     "Print a tr1::unordered_map"
@@ -741,15 +741,15 @@ class Tr1UnorderedMapPrinter:
         return '[%d]' % i
 
     def children (self):
-        counter = itertools.imap (self.format_count, itertools.count())
+        counter = list(map (self.format_count, itertools.count()))
         # Map over the hash table and flatten the result.
         if self.typename.startswith('std::tr1'):
-            data = self.flatten (itertools.imap (self.format_one, Tr1HashtableIterator (self.hashtable())))
+            data = self.flatten (list(map (self.format_one, Tr1HashtableIterator (self.hashtable()))))
             # Zip the two iterators together.
-            return itertools.izip (counter, data)
-        data = self.flatten (itertools.imap (self.format_one, StdHashtableIterator (self.hashtable())))
+            return list(zip (counter, data))
+        data = self.flatten (list(map (self.format_one, StdHashtableIterator (self.hashtable()))))
         # Zip the two iterators together.
-        return itertools.izip (counter, data)
+        return list(zip (counter, data))
         
 
     def display_hint (self):
@@ -767,7 +767,7 @@ class StdForwardListPrinter:
         def __iter__(self):
             return self
 
-        def next(self):
+        def __next__(self):
             if self.base == 0:
                 raise StopIteration
             elt = self.base.cast(self.nodetype).dereference()
@@ -827,7 +827,7 @@ class Printer(object):
         # A small sanity check.
         # FIXME
         if not self.compiled_rx.match(name + '<>'):
-            raise ValueError, 'libstdc++ programming error: "%s" does not match' % name
+            raise ValueError('libstdc++ programming error: "%s" does not match' % name)
         printer = RxPrinter(name, function)
         self.subprinters.append(printer)
         self.lookup[name] = printer
