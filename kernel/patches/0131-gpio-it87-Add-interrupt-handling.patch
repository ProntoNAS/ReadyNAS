From 85991e632f58b222f266da7947302c4e9cd20e8f Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Wed, 11 Jan 2017 16:00:18 -0800
Subject: [PATCH 131/131] gpio: it87: Add interrupt handling

---
 drivers/gpio/gpio-it87.c | 391 ++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 374 insertions(+), 17 deletions(-)

diff --git a/drivers/gpio/gpio-it87.c b/drivers/gpio/gpio-it87.c
index 1248168..0ed9ea9 100644
--- a/drivers/gpio/gpio-it87.c
+++ b/drivers/gpio/gpio-it87.c
@@ -31,6 +31,7 @@
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/gpio.h>
+#include <linux/platform_device.h>
 
 /* Chip Id numbers */
 #define NO_DEV_ID	0xffff
@@ -72,10 +73,25 @@ struct it87_gpio {
 	u8 output_base;
 	u8 simple_base;
 	u8 simple_size;
+
+	u16 chip_type;
+	u8 polarity_base;
+	u8 debounce_irq;
+	u8 debounce[2];
+	u8 ext_routing_irq;
+	u8 ext_routing[2];
+	u8 smi_status_reg2;
+
+	u8 irq_map_reg[2];
+	u8 irq_level_reg;
+
+	u8 *valid_irq_mapping;	 /* Pointer to bool map of IRQ-possible GPIOs */
+	u8 *valid_irq_level;	 /* Pointer to bool map of possible IRQs */
+	u16 irq_base;
+	struct platform_device *pdev;
 };
 
 static struct it87_gpio it87_gpio_chip = {
-	.lock = __SPIN_LOCK_UNLOCKED(it87_gpio_chip.lock),
 };
 
 static inline struct it87_gpio *to_it87_gpio(struct gpio_chip *chip)
@@ -85,6 +101,12 @@ static inline struct it87_gpio *to_it87_gpio(struct gpio_chip *chip)
 
 /* Superio chip access functions; copied from wdt_it87 */
 
+static inline void superio_select(int ldn)
+{
+	outb(LDNREG, REG);
+	outb(ldn, VAL);
+}
+
 static inline int superio_enter(void)
 {
 	/*
@@ -97,6 +119,7 @@ static inline int superio_enter(void)
 	outb(0x01, REG);
 	outb(0x55, REG);
 	outb(0x55, REG);
+	superio_select(GPIO);
 	return 0;
 }
 
@@ -107,12 +130,6 @@ static inline void superio_exit(void)
 	release_region(REG, 2);
 }
 
-static inline void superio_select(int ldn)
-{
-	outb(LDNREG, REG);
-	outb(ldn, VAL);
-}
-
 static inline int superio_inb(int reg)
 {
 	outb(reg, REG);
@@ -162,16 +179,31 @@ static inline void superio_clear_mask(int mask, int reg)
 		superio_outb(new_val, reg);
 }
 
+static void simple_or_alternative(struct it87_gpio *it87_gpio,
+					unsigned gpio_num)
+{
+	u8 mask = 1 << (gpio_num % 8);
+	u8 group = (gpio_num / 8);
+
+        /* Panel button => ALTERNATIVE, otherwise => Simple IO */
+        if ((superio_inb(it87_gpio->debounce[0]) & 0x3f) == gpio_num + 8 ||
+                (superio_inb(it87_gpio->debounce[1]) & 0x3f) == gpio_num + 8)
+                superio_clear_mask(mask, group + it87_gpio->simple_base);
+        else
+                superio_set_mask(mask, group + it87_gpio->simple_base);
+}
+
 static int it87_gpio_request(struct gpio_chip *chip, unsigned gpio_num)
 {
 	u8 mask, group;
 	int rc = 0;
 	struct it87_gpio *it87_gpio = to_it87_gpio(chip);
+	unsigned long flags;
 
 	mask = 1 << (gpio_num % 8);
 	group = (gpio_num / 8);
 
-	spin_lock(&it87_gpio->lock);
+	spin_lock_irqsave(&it87_gpio->lock, flags);
 
 	rc = superio_enter();
 	if (rc)
@@ -181,7 +213,7 @@ static int it87_gpio_request(struct gpio_chip *chip, unsigned gpio_num)
 	 * them allow all the lines to be set/unset to Simple I/O.
 	 */
 	if (group < it87_gpio->simple_size)
-		superio_set_mask(mask, group + it87_gpio->simple_base);
+		simple_or_alternative(it87_gpio, gpio_num);
 
 	/* clear output enable, setting the pin to input, as all the
 	 * newly-exported GPIO interfaces are set to input.
@@ -191,7 +223,7 @@ static int it87_gpio_request(struct gpio_chip *chip, unsigned gpio_num)
 	superio_exit();
 
 exit:
-	spin_unlock(&it87_gpio->lock);
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
 	return rc;
 }
 
@@ -222,6 +254,8 @@ static int it87_gpio_direction_in(struct gpio_chip *chip, unsigned gpio_num)
 	if (rc)
 		goto exit;
 
+	simple_or_alternative(it87_gpio, gpio_num);
+
 	/* clear the output enable bit */
 	superio_clear_mask(mask, group + it87_gpio->output_base);
 
@@ -277,6 +311,298 @@ exit:
 	return rc;
 }
 
+/* Valid GPIO IRQ mapping using IT' GPxx port naming convention. */
+#define	_P(x)	[(((x)/10)-1)*8 + ((x)%10)] = 1
+static u8
+it8613_valid_irq_mapping[] = {/* Table 8-10 */
+	_P(10),_P(12),_P(13),_P(21),_P(22),_P(23),
+	_P(30),_P(31),_P(32),_P(33),              _P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+},
+#if 0
+it8702_valid_irq_mapping[] = {/* Note 4 */
+	_P(10),_P(11),_P(12),_P(13),_P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(31),_P(32),_P(33),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),_P(46),_P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),
+},
+#endif
+it8728_valid_irq_mapping[] = {/* Table 8-14 */
+	_P(10),_P(11),_P(12),       _P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(31),_P(32),_P(33),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(41),_P(42),_P(43),_P(44),_P(45),       _P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+},
+it8732_valid_irq_mapping[] = {/* Table 8-17 */
+	_P(10),_P(11),_P(12),       _P(14),_P(15),_P(16),_P(17),
+	_P(20),_P(21),_P(22),_P(23),_P(24),_P(25),_P(26),_P(27),
+	_P(30),_P(34),_P(35),_P(36),_P(37),
+	_P(40),_P(42),_P(43),_P(44),_P(47),
+	_P(50),_P(51),_P(52),_P(53),_P(54),_P(55),_P(56),_P(57),
+};
+
+#define _Q(x)	[(x)] = 1
+static u8
+it8613_valid_irq_level[] = {/* Table 8-12 */
+	       _Q(1),        _Q(3), _Q(4), _Q(5), _Q(6), _Q(7),
+	_Q(8), _Q(0), _Q(10),_Q(11),_Q(12),
+},
+it8728_valid_irq_level[] = {/* Table 8-12 */
+	       _Q(1),        _Q(3), _Q(12),
+},
+it8732_valid_irq_level[] = {/* Table 8-16 */
+	       _Q(1),        _Q(3), _Q(4), _Q(5), _Q(6), _Q(7),
+	_Q(8), _Q(0), _Q(10),_Q(11),_Q(12),
+};
+
+/* Clear IRQ status to accept next one. */
+static void it87_gpio_debounce_irq_ack(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct it87_gpio *it87_gpio = to_it87_gpio(gc);
+	u16 reg = it87_gpio->smi_status_reg2;
+	int i;
+
+	superio_enter();
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->debounce); i++) {
+		u8 mask = BIT(i + 6);
+
+		if ((superio_inb(it87_gpio->debounce[i]) & 0x3f) ==
+							d->hwirq + 8 &&
+			(superio_inb(reg) & mask))
+			superio_outb(mask, reg);
+	}
+	superio_exit();
+}
+
+static void it87_gpio_irq_mask(struct irq_data *d)
+{
+}
+
+static void it87_gpio_irq_unmask(struct irq_data *d)
+{
+}
+
+static int it87_goio_irq_set(struct it87_gpio *it87_gpio,
+				unsigned int gpio, bool clear)
+{
+	int i;
+
+	/* Already set in either register? */
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->irq_map_reg); i++)
+		if ((superio_inb(it87_gpio->irq_map_reg[i]) & 0x3f) ==
+				gpio + 8) {
+			superio_outb(clear ? 0 : (gpio + 8) | 0x40,
+					it87_gpio->irq_map_reg[i]);
+			return 0;
+		}
+	/* If not and to clear, we are done. */
+	if (clear)
+		return 0;
+	/* Look for a vacant register. */
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->irq_map_reg); i++)
+		if (!superio_inb(it87_gpio->irq_map_reg[i])) {
+			superio_outb((gpio + 8) | 0x40,
+					it87_gpio->irq_map_reg[i]);
+			return 0;
+		}
+	pr_err("%s: No vacant IRQ slot register.\n", __func__);
+	return -EBUSY;
+}
+
+/* De-bounce IRQ corresponds to a negative pulse whose polarity is subject
+ * to polarity control. To avoide confusion with GPIO polarity control,
+ * we let de-bounce IRQ always respond to a negative pulse regardless of
+ * irq_type.
+ */
+static int it87_gpio_irq_set_type(struct irq_data *d, unsigned int type)
+{
+	unsigned long flags;
+	int err = 0;
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	unsigned int gpio = irqd_to_hwirq(d);
+	struct it87_gpio *it87_gpio = to_it87_gpio(gc);
+	u8 mask = BIT(gpio % 8);
+	u8 group = gpio / 8;
+	u16 reg = it87_gpio->polarity_base + group;
+	bool debounce;
+
+	if (!it87_gpio->valid_irq_mapping[gpio]) {
+		pr_err("%s: gpionum %d (a.k.a.GP%o) cannot be mapped "
+			"for IRQ\n", __func__, gpio, gpio + 8);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&it87_gpio->lock, flags);
+	if ((err = superio_enter()))
+		goto exit;
+
+	switch (type) {
+	case IRQ_TYPE_NONE:	/* Dsiable IRQ for this GPIO. */
+		err = it87_goio_irq_set(it87_gpio, gpio, true);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+	case IRQ_TYPE_LEVEL_LOW:
+		err = it87_goio_irq_set(it87_gpio, gpio, false);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	if (err || type == IRQ_TYPE_NONE)
+		goto exit2;
+
+	debounce = (superio_inb(it87_gpio->debounce[0]) & 0x7f) ==
+							((gpio + 8) | 0x40) ||
+			(superio_inb(it87_gpio->debounce[1]) & 0x7f) ==
+							((gpio + 8) | 0x40);
+	if (type == IRQ_TYPE_LEVEL_LOW && !debounce)
+		superio_set_mask(mask, reg);
+	else
+		superio_clear_mask(mask, reg);
+
+	/* Select simple or alternative. */
+	simple_or_alternative(it87_gpio, gpio);
+
+	/* Set IRQ level register. */
+	if (debounce)
+		superio_outb(it87_gpio->irq_base, it87_gpio->irq_level_reg);
+	else if ((superio_inb(it87_gpio->ext_routing[0]) & 0x7f) ==
+							((gpio + 8) | 0x40)) {
+		u8 v = superio_inb(it87_gpio->irq_level_reg) & 0xf0;
+		superio_outb(v | it87_gpio->irq_base, it87_gpio->irq_level_reg);
+	} else if ((superio_inb(it87_gpio->ext_routing[1]) & 0x7f) ==
+							((gpio + 8) | 0x40)) {
+		u8 v = superio_inb(it87_gpio->irq_level_reg) & 0x0f;
+		superio_outb(v | (it87_gpio->irq_base << 4),
+				it87_gpio->irq_level_reg);
+	}
+exit2:
+	superio_exit();
+exit:
+	spin_unlock_irqrestore(&it87_gpio->lock, flags);
+	return err;
+}
+
+static struct irq_chip it87_gpio_irq_chip = {
+	.irq_ack	= it87_gpio_debounce_irq_ack,
+	.irq_mask	= it87_gpio_irq_mask,
+	.irq_unmask	= it87_gpio_irq_unmask,
+	.irq_set_type	= it87_gpio_irq_set_type,
+};
+
+static void it87_gpio_debounce_irq_handler(struct irq_desc *desc)
+{
+	struct irq_data *data	= irq_desc_get_irq_data(desc);
+	struct gpio_chip *gc	= irq_desc_get_handler_data(desc);
+	struct it87_gpio *it87_gpio = to_it87_gpio(gc);
+	struct irq_chip *ichip	= irq_data_get_irq_chip(data);
+	u8 smi_stat2;
+	int i;
+
+	superio_enter();
+	smi_stat2 = superio_inb(it87_gpio->smi_status_reg2);
+
+	for (i = 0; i < ARRAY_SIZE(it87_gpio->debounce); i++) {
+		const u8 mask = BIT(i + 6);
+
+		if (smi_stat2 & mask) {
+			unsigned int gpio =
+			(superio_inb(it87_gpio->debounce[i]) & 0x3f) - 8;
+			unsigned int virq =
+				irq_find_mapping(gc->irqdomain, gpio);
+
+			generic_handle_irq(virq);
+		}
+	}
+	superio_exit();
+	ichip->irq_eoi(data);
+}
+
+static int it87_gpio_irq_probe(struct platform_device *pdev)
+{
+	struct it87_gpio *it87_gpio = &it87_gpio_chip;
+	struct resource *rsc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	int err;
+
+	if (!rsc || !rsc->start) {
+		pr_err("%s: No IRQ resource.\n", __func__);
+		return -ENODEV;
+	}
+
+	if (rsc->start >= 16 || !it87_gpio->valid_irq_level[rsc->start]) {
+		pr_err("%s: Bad IRQ level %u.\n",
+			__func__, (unsigned int)rsc->start);
+		return -EINVAL;
+	}
+
+	it87_gpio->chip.dev = &pdev->dev;
+
+	err = gpiochip_irqchip_add(&it87_gpio->chip, &it87_gpio_irq_chip, 0,
+					handle_simple_irq, IRQ_TYPE_NONE);
+	if (err) {
+		pr_err("%s: failed in irqchip_add (%d)\n", __func__, err);
+		return err;
+	}
+
+	it87_gpio->irq_base = rsc->start;
+	gpiochip_set_chained_irqchip(&it87_gpio->chip,
+					&it87_gpio_irq_chip,
+					it87_gpio->irq_base,
+					it87_gpio_debounce_irq_handler);
+	superio_enter();
+	superio_outb(0, it87_gpio->irq_map_reg[0]);
+	superio_outb(0, it87_gpio->irq_map_reg[1]);
+	superio_exit();
+	return 0;
+}
+
+static struct resource it87_gpio_resources[] = {
+	{
+		.name	= "gpio_it87_irq",
+		.start	= 10,
+		.flags	= IORESOURCE_IRQ,
+	}, {}
+};
+
+const static struct platform_device_info pdi __initconst = {
+	.name	= KBUILD_MODNAME,
+	.res	= it87_gpio_resources,
+	.num_res	= ARRAY_SIZE(it87_gpio_resources),
+};
+
+static struct platform_driver it87_gpio_irq_driver = {
+	.probe	= it87_gpio_irq_probe,
+	.driver	= {
+		.name	= KBUILD_MODNAME,
+	},
+};
+
+static int it87_gpio_irq_init(struct it87_gpio *it87_gpio)
+{
+	struct platform_device *pdev = platform_device_register_full(&pdi);
+
+	if (IS_ERR_OR_NULL(pdev)) {
+		int err = pdev ? PTR_ERR(pdev) : -EIO;
+
+		pr_err("%s: failed in platform_device_register (%d)\n",
+			__func__, err);
+		return err;
+	}
+	it87_gpio->pdev = pdev;
+	return platform_driver_register(&it87_gpio_irq_driver);
+}
+
+static void it87_gpio_irq_exit(struct it87_gpio *it87_gpio)
+{
+	platform_device_unregister(it87_gpio->pdev);
+	platform_driver_unregister(&it87_gpio_irq_driver);
+}
+
 static struct gpio_chip it87_template_chip = {
 	.label			= KBUILD_MODNAME,
 	.owner			= THIS_MODULE,
@@ -291,32 +617,60 @@ static struct gpio_chip it87_template_chip = {
 static int __init it87_gpio_init(void)
 {
 	int rc = 0, i;
-	u16 chip_type;
 	u8 chip_rev, gpio_ba_reg;
 	char *labels, **labels_table;
 
 	struct it87_gpio *it87_gpio = &it87_gpio_chip;
 
+	spin_lock_init(&it87_gpio->lock);
 	rc = superio_enter();
 	if (rc)
 		return rc;
 
-	chip_type = superio_inw(CHIPID);
+	it87_gpio->chip_type = superio_inw(CHIPID);
 	chip_rev  = superio_inb(CHIPREV) & 0x0f;
 	superio_exit();
 
 	it87_gpio->chip = it87_template_chip;
 
-	switch (chip_type) {
+	switch (it87_gpio->chip_type) {
 	case IT8613_ID:
+		if (!it87_gpio->valid_irq_mapping)
+			it87_gpio->valid_irq_mapping = it8613_valid_irq_mapping;
+		if (!it87_gpio->valid_irq_level)
+			it87_gpio->valid_irq_level = it8613_valid_irq_level;
+		/* Falls through. */
 	case IT8728_ID:
+		if (!it87_gpio->valid_irq_mapping)
+			it87_gpio->valid_irq_mapping = it8728_valid_irq_mapping;
+		if (!it87_gpio->valid_irq_level)
+			it87_gpio->valid_irq_level = it8728_valid_irq_level;
+		/* Falls through. */
 	case IT8732_ID:
+		if (!it87_gpio->valid_irq_mapping)
+			it87_gpio->valid_irq_mapping = it8732_valid_irq_mapping;
+		if (!it87_gpio->valid_irq_level)
+			it87_gpio->valid_irq_level = it8732_valid_irq_level;
 		gpio_ba_reg = 0x62;
 		it87_gpio->io_size = 8;
 		it87_gpio->output_base = 0xc8;
 		it87_gpio->simple_base = 0xc0;
 		it87_gpio->simple_size = 5;
 		it87_gpio->chip.ngpio = 64;
+
+		it87_gpio->polarity_base	= 0xb0;
+		it87_gpio->debounce_irq		= 0x70;
+		it87_gpio->debounce[0]		= 0xe0;
+		it87_gpio->debounce[1]		= 0xe1;
+		it87_gpio->ext_routing_irq	= 0xe4;
+		it87_gpio->ext_routing[0]	= 0xe2;
+		it87_gpio->ext_routing[1]	= 0xe3;
+		it87_gpio->smi_status_reg2	= 0xf3;
+		/* Default to use DEBOUNCE for both routes. TODO */
+		it87_gpio->irq_level_reg	= it87_gpio->debounce_irq;
+		it87_gpio->irq_map_reg[0]	= it87_gpio->debounce[0];
+		it87_gpio->irq_map_reg[1]	= it87_gpio->debounce[1];
+
 		break;
 	case IT8761_ID:
 		gpio_ba_reg = 0x60;
@@ -330,7 +684,7 @@ static int __init it87_gpio_init(void)
 		return -ENODEV;
 	default:
 		pr_err("Unknown Chip found, Chip %04x Revision %x\n",
-		       chip_type, chip_rev);
+		       it87_gpio->chip_type, chip_rev);
 		return -ENODEV;
 	}
 
@@ -338,15 +692,13 @@ static int __init it87_gpio_init(void)
 	if (rc)
 		return rc;
 
-	superio_select(GPIO);
-
 	/* fetch GPIO base address */
 	it87_gpio->io_base = superio_inw(gpio_ba_reg);
 
 	superio_exit();
 
 	pr_info("Found Chip IT%04x rev %x. %u GPIO lines starting at %04xh\n",
-		chip_type, chip_rev, it87_gpio->chip.ngpio,
+		it87_gpio->chip_type, chip_rev, it87_gpio->chip.ngpio,
 		it87_gpio->io_base);
 
 	if (!request_region(it87_gpio->io_base, it87_gpio->io_size,
@@ -386,6 +738,10 @@ static int __init it87_gpio_init(void)
 	if (rc)
 		goto labels_free;
 
+	rc = it87_gpio_irq_init(it87_gpio);
+	if (rc)
+		goto labels_free;
+
 	return 0;
 
 labels_free:
@@ -399,6 +755,7 @@ static void __exit it87_gpio_exit(void)
 {
 	struct it87_gpio *it87_gpio = &it87_gpio_chip;
 
+	it87_gpio_irq_exit(it87_gpio);
 	gpiochip_remove(&it87_gpio->chip);
 	release_region(it87_gpio->io_base, it87_gpio->io_size);
 	kfree(it87_gpio->chip.names[0]);
-- 
1.9.1

