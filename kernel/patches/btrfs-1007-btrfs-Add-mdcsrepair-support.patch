From 3cdf1d9900fdb2877ebbd4c44ea9897e277bd3fe Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Wed, 30 Nov 2016 13:46:28 -0800
Subject: [PATCH 1007/1016] btrfs: Add mdcsrepair support

a.k.a Bit Rot Protection.  Send a netlink event to userland when a csum
mismatch is detected.
---
 fs/btrfs/Kconfig           |   8 ++
 fs/btrfs/Makefile          |   2 +
 fs/btrfs/check-integrity.c |   9 ++
 fs/btrfs/compression.c     |  31 ++++-
 fs/btrfs/cslink.c          | 333 +++++++++++++++++++++++++++++++++++++++++++++
 fs/btrfs/cslink.h          | 107 +++++++++++++++
 fs/btrfs/disk-io.c         |  43 +++++-
 fs/btrfs/inode.c           | 103 ++++++++++++++
 fs/btrfs/scrub.c           |  76 ++++++++++-
 9 files changed, 700 insertions(+), 12 deletions(-)
 create mode 100644 fs/btrfs/cslink.c
 create mode 100644 fs/btrfs/cslink.h

diff --git a/fs/btrfs/Kconfig b/fs/btrfs/Kconfig
index 7ecbadd..394116c 100644
--- a/fs/btrfs/Kconfig
+++ b/fs/btrfs/Kconfig
@@ -96,3 +96,11 @@ config BTRFS_ASSERT
 	  any of the assertions trip.  This is meant for btrfs developers only.
 
 	  If unsure, say N.
+
+config BTRFS_MDCSREPAIR
+	bool "Btrfs RAID-based auto data repair"
+	depends on BTRFS_FS
+	help
+	  Enable kernel to user program NETLINK communication for
+	  automtically repairing of corrupted data using CRC chechsum
+	  and RAID data redundancy.
diff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile
index 6d1d0b9..f3356b1 100644
--- a/fs/btrfs/Makefile
+++ b/fs/btrfs/Makefile
@@ -17,3 +17,5 @@ btrfs-$(CONFIG_BTRFS_FS_CHECK_INTEGRITY) += check-integrity.o
 btrfs-$(CONFIG_BTRFS_FS_RUN_SANITY_TESTS) += tests/free-space-tests.o \
 	tests/extent-buffer-tests.o tests/btrfs-tests.o \
 	tests/extent-io-tests.o tests/inode-tests.o tests/qgroup-tests.o
+
+btrfs-$(CONFIG_BTRFS_MDCSREPAIR) += cslink.o
diff --git a/fs/btrfs/check-integrity.c b/fs/btrfs/check-integrity.c
index 0340c57..f816899 100644
--- a/fs/btrfs/check-integrity.c
+++ b/fs/btrfs/check-integrity.c
@@ -106,6 +106,10 @@
 #include "check-integrity.h"
 #include "rcu-string.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 #define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000
 #define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000
 #define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100
@@ -1809,6 +1813,11 @@ static int btrfsic_test_for_metadata(struct btrfsic_state *state,
 		crc = btrfs_crc32c(crc, data, sublen);
 	}
 	btrfs_csum_final(crc, csum);
+	__MDCS(h->csum, csum, state->csum_size,
+		num_pages * PAGE_CACHE_SIZE - BTRFS_CSUM_SIZE,
+		state->latest_superblock->dev_bytenr + BTRS_CSUM_SIZE,
+		state->dev_state->bdev ?
+		state->dev_state->bdev->dev : 0, 0);
 	if (memcmp(csum, h->csum, state->csum_size))
 		return 1;
 
diff --git a/fs/btrfs/compression.c b/fs/btrfs/compression.c
index e110be0..8a0fbfc 100644
--- a/fs/btrfs/compression.c
+++ b/fs/btrfs/compression.c
@@ -42,6 +42,10 @@
 #include "extent_io.h"
 #include "extent_map.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 struct compressed_bio {
 	/* number of bios pending for this compressed extent */
 	atomic_t pending_bios;
@@ -115,6 +119,7 @@ static int check_compressed_csum(struct inode *inode,
 		return 0;
 
 	for (i = 0; i < cb->nr_pages; i++) {
+		dev_t dev;
 		page = cb->compressed_pages[i];
 		csum = ~(u32)0;
 
@@ -122,14 +127,26 @@ static int check_compressed_csum(struct inode *inode,
 		csum = btrfs_csum_data(kaddr, csum, PAGE_CACHE_SIZE);
 		btrfs_csum_final(csum, (char *)&csum);
 		kunmap_atomic(kaddr);
-
+		__MDCS(cb_sum, &csum, sizeof csum,
+			PAGE_CACHE_SIZE, disk_start,
+			BTRFS_I(inode)->root->sbdev.anon_dev,
+			btrfs_ino(inode));
 		if (csum != *cb_sum) {
-			btrfs_info(BTRFS_I(inode)->root->fs_info,
-			   "csum failed ino %llu extent %llu csum %u wanted %u mirror %d",
-			   btrfs_ino(inode), disk_start, csum, *cb_sum,
-			   cb->mirror_num);
-			ret = -EIO;
-			goto fail;
+			(void)btrfs_log2phys(inode, disk_start, PAGE_CACHE_SIZE, &dev);
+			__btrfs_cslink(csum != *cb_sum,
+					btrfs_ino(inode),
+					(u8 *)cb_sum, (u8 *)&csum, sizeof csum,
+					btrfs_csum_final, disk_start, PAGE_CACHE_SIZE,
+					dev, BTRFS_I(inode)->root->sbdev.anon_dev,
+					(u64)~0, 0);
+			if (csum != *cb_sum) {
+				btrfs_info(BTRFS_I(inode)->root->fs_info,
+				   "csum failed ino %llu extent %llu csum %u wanted %u mirror %d",
+				   btrfs_ino(inode), disk_start, csum, *cb_sum,
+				   cb->mirror_num);
+				ret = -EIO;
+				goto fail;
+			}
 		}
 		cb_sum++;
 
diff --git a/fs/btrfs/cslink.c b/fs/btrfs/cslink.c
new file mode 100644
index 0000000..46aa6fe
--- /dev/null
+++ b/fs/btrfs/cslink.c
@@ -0,0 +1,333 @@
+/*
+ * Copyright (C) 2014,2015 NETGEAR, Inc.  All rights reserved.
+ * Copyright (C) 2014,2015 Hiro Sugawara  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public
+ * License v2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 021110-1307, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/proc_fs.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <net/netlink.h>
+#include <net/genetlink.h>
+#include "ctree.h"
+#include "disk-io.h"
+#include "cslink.h"
+
+char *__btrfs_proc_mdcsrepair_debug;
+
+static struct {
+	void *func;
+	u8 inverted;	/* Keep this u8 or results are unpredictable. */
+	char *name;
+} csfunc2algo[] = {
+	{(void *)btrfs_csum_final, ~0, "crc32c_le"},
+	{(void *)btrfs_csum_data, 0, "crc32c_le"},
+	{NULL, 0, NULL},
+};
+
+/* Current actual message length ~ 300 (5/28/2014) */
+#define MAX_XML	(512 - sizeof(struct list_head))
+
+static struct mdcs_msg {
+	struct list_head list;
+	char buffer[];
+} mdcs_msg_q;
+static spinlock_t mdcs_lock;
+static DECLARE_WAIT_QUEUE_HEAD(mdcs_waiter);
+static atomic_t mdcs_q_len = ATOMIC_INIT(0);
+#define MDCS_Q_MAX	200
+
+static struct mdcs_msg *retrieve_q(void)
+{
+	struct mdcs_msg *m = NULL;
+
+	spin_lock(&mdcs_lock);
+	if (!list_empty(&mdcs_msg_q.list)) {
+		m = list_first_entry(&mdcs_msg_q.list, struct mdcs_msg, list);
+		list_del(&m->list);
+	}
+	spin_unlock(&mdcs_lock);
+	if (m)
+		atomic_dec(&mdcs_q_len);
+
+	return m;
+}
+
+static void append_q(struct mdcs_msg *msg)
+{
+	spin_lock(&mdcs_lock);
+	list_add_tail(&msg->list, &mdcs_msg_q.list);
+	spin_unlock(&mdcs_lock);
+	atomic_inc(&mdcs_q_len);
+	wake_up(&mdcs_waiter);
+}
+
+/*
+ * Do not change this function name as it is used to validate the XML
+ * message by the user land code.
+ */
+void mdcsrepair_procfs(const char *filesystem, const char *place,
+		u64 inum,
+		const u8 *expected, const u8 *computed, size_t cslen,
+		const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, dev_t adev, u64 fpos, u64 flags)
+{
+	char expbuf[cslen * 2 + 1], compbuf[cslen * 2 + 1];
+	char *p, *name = NULL;
+	int i, remainder;
+	unsigned int inverted = 0;
+	struct mdcs_msg *msg;
+
+	if (dpos == (u64)~0) {
+		pr_err("%s: Invalid dpos (-1)\n", __func__);
+		return;
+	}
+
+	if ((i = atomic_read(&mdcs_q_len)) > MDCS_Q_MAX) {
+		pr_warn("%s: Too many (%d) checksum failures in queue.",
+			__func__, i);
+		return;
+	}
+
+	if (!dev)
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(csfunc2algo); i++)
+		if (csfunc2algo[i].func == csfunc) {
+			name = csfunc2algo[i].name;
+			inverted = csfunc2algo[i].inverted;
+			break;
+		}
+
+	if (!name) {
+		pr_err("%s: checksum algorithm not found for %p\n",
+			__func__, csfunc);
+		return;
+	}
+
+	for (i = 0, p = expbuf; i < cslen; i++) {
+		sprintf(p, "%02x", expected[i] ^ inverted);
+		p +=2;
+	}
+	*p = '\0';
+	for (i = 0, p = compbuf; i < cslen; i++) {
+		sprintf(p, "%02x", computed[i] ^ inverted);
+		p +=2;
+	}
+	*p = '\0';
+
+	if (!(msg = kmalloc(MAX_XML + sizeof(*msg), GFP_ATOMIC))) {
+		pr_err("%s: get_free_page failed.", __func__);
+		return;
+	}
+
+	remainder = MAX_XML - (strlen("/></>") + strlen(__func__));
+	if (snprintf(msg->buffer, remainder,
+		"<?xml version=\"1.0\" encoding=\"UTF-8\"?><%s>"
+		"<data offset=\"%llu\" length=\"%lu\" position=\"%s\"/>"
+		"<checksum expected=\"%s\" computed=\"%s\" "
+			"length=\"%lu\" algorithm=\"%s\"/>"
+		"<device major=\"%u\" minor=\"%u\" filesystem=\"%s\"/>"
+		"<place function=\"%s\"/>"
+		"<file inode=\"%llu\"",
+		__func__,
+		dpos, (unsigned long)len,
+		(flags & CSL_INTRAFILEPOS) ? "file" : "disk",
+		expbuf, compbuf, (unsigned long)cslen, name,
+		MAJOR(dev), MINOR(dev),
+		filesystem,
+		place ? place : "UNKOWN",
+		inum
+		) >= remainder) {
+		pr_err("%s: Buffer overflowed\n", __func__);
+		goto nlmsg_failure2;
+	}
+	remainder -= strlen(msg->buffer);
+
+	if (fpos != (u64)~0) {
+		int len;
+		p = msg->buffer + strlen(msg->buffer);
+		if ((len = snprintf(p, remainder, " offset=\"%llu\"", fpos)) >=
+				remainder) {
+			pr_err("%s: Buffer overflowed\n", __func__);
+			goto nlmsg_failure2;
+		}
+		remainder -= len;
+	}
+	strncat(msg->buffer, "/>", remainder);
+
+	if (adev) {
+		int len;
+		p = msg->buffer + strlen(msg->buffer);
+		if ((len = snprintf(p, remainder,
+			"<anondevice major=\"%u\" minor=\"%d\"/>",
+			MAJOR(adev), MINOR(adev))) >= remainder) {
+			pr_err("%s: Buffer overflowed\n", __func__);
+			goto nlmsg_failure2;
+		}
+		remainder -= len;
+	}
+
+	p = msg->buffer + strlen(msg->buffer);
+	sprintf(p, "</%s>", __func__);
+
+	append_q(msg);
+	return;
+
+nlmsg_failure2:
+	kfree(msg);
+}
+
+/*
+ * For debugging, "src/file.c:function" enables a fake checksum failure
+ * to send netlink message whenever the function is called.
+ * A null string for src/file.c or function works as a wild card; thus
+ * ":" catches every checksum calculation. A null string or NULL pointer
+ * ("") disables debugging.
+ */
+static struct proc_dir_entry *btrfs_proc_root,
+				*btrfs_proc_mdcsrepair, *btrfs_proc_mdcsevent;
+
+static int btrfs_proc_mdcsrepair_read(struct seq_file *f, void *v)
+{
+	if (__btrfs_proc_mdcsrepair_debug && *__btrfs_proc_mdcsrepair_debug)
+		seq_printf(f, "%s", __btrfs_proc_mdcsrepair_debug);
+	seq_putc(f, '\n');
+	return 0;
+}
+
+static ssize_t btrfs_proc_mdcsrepair_write(struct file *file,
+			const char __user *buffer,
+			size_t count, loff_t *ppos)
+{
+	ssize_t rv;
+
+	kfree(__btrfs_proc_mdcsrepair_debug);
+	if (!(__btrfs_proc_mdcsrepair_debug = kmalloc(count + 1, GFP_KERNEL)))
+		return -ENOMEM;
+	if ((rv = copy_from_user(__btrfs_proc_mdcsrepair_debug,
+				buffer, count))) {
+		kfree(__btrfs_proc_mdcsrepair_debug);
+		__btrfs_proc_mdcsrepair_debug = NULL;
+		return rv;
+	}
+	if (__btrfs_proc_mdcsrepair_debug[count - 1] == '\n')
+		__btrfs_proc_mdcsrepair_debug[count - 1] = '\0';
+	else
+		__btrfs_proc_mdcsrepair_debug[count] = '\0';
+	if (!__btrfs_proc_mdcsrepair_debug[0]) {
+		kfree(__btrfs_proc_mdcsrepair_debug);
+		__btrfs_proc_mdcsrepair_debug = NULL;
+	}
+	return count;
+}
+
+static int btrfs_proc_mdcsrepair_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, btrfs_proc_mdcsrepair_read, NULL);
+}
+
+static const struct file_operations btrfs_proc_mdcsrepair_fops = {
+	.owner	= THIS_MODULE,
+	.llseek	= seq_lseek,
+	.read	= seq_read,
+	.write	= btrfs_proc_mdcsrepair_write,
+	.open	= btrfs_proc_mdcsrepair_open,
+	.release= single_release,
+};
+
+static int btrfs_proc_mdcsevent_read(struct seq_file *f, void *v)
+{
+	struct mdcs_msg *m = NULL;
+	int err = 0;
+
+	do {
+		/* wait for repair requests to come */
+		err = wait_event_interruptible(mdcs_waiter,
+				!list_empty(&mdcs_msg_q.list));
+	} while (!err && !(m = retrieve_q()));
+
+	if (m) {
+		seq_printf(f, "%s", m->buffer);
+		kfree(m);
+	}
+	return err;
+}
+
+static int btrfs_proc_mdcsevent_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, btrfs_proc_mdcsevent_read, NULL);
+}
+
+static const struct file_operations btrfs_proc_mdcsevent_fops = {
+	.owner	= THIS_MODULE,
+	.llseek	= seq_lseek,
+	.read	= seq_read,
+	.open	= btrfs_proc_mdcsevent_open,
+	.release= single_release,
+};
+
+static int __init btrfs_mdcs_init(void)
+{
+	spin_lock_init(&mdcs_lock);
+	INIT_LIST_HEAD(&mdcs_msg_q.list);
+	atomic_set(&mdcs_q_len, 0);
+
+	if (!(btrfs_proc_root = proc_mkdir("fs/btrfs", NULL))) {
+		return -EIO;
+	}
+	if (!(btrfs_proc_mdcsrepair =
+		proc_create("mdcsrepair",
+			S_IFREG | S_IRUGO | S_IWUSR, btrfs_proc_root,
+			&btrfs_proc_mdcsrepair_fops))) {
+		remove_proc_entry("fs/btrfs", NULL);
+		return -EIO;
+	}
+
+	if (!(btrfs_proc_mdcsevent =
+		proc_create("mdcsevent",
+			S_IFREG | S_IRUSR, btrfs_proc_root,
+			&btrfs_proc_mdcsevent_fops))) {
+		remove_proc_entry("fs/btrfs/mdcsrepair", NULL);
+		remove_proc_entry("fs/btrfs", NULL);
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static void __exit btrfs_mdcs_exit(void)
+{
+	struct mdcs_msg *m;
+
+	while ((m = retrieve_q()))
+		kfree(m);
+	remove_proc_entry("fs/btrfs/mdcsevent", NULL);
+	remove_proc_entry("fs/btrfs/mdcsrepair", NULL);
+	kfree(__btrfs_proc_mdcsrepair_debug);
+	__btrfs_proc_mdcsrepair_debug = NULL;
+}
+
+module_init(btrfs_mdcs_init);
+module_exit(btrfs_mdcs_exit);
+
+MODULE_AUTHOR("<hiro.sugawara@netgear.com>");
+MODULE_DESCRIPTION("BTRFS checksum corrector");
+MODULE_LICENSE("GPL");
diff --git a/fs/btrfs/cslink.h b/fs/btrfs/cslink.h
new file mode 100644
index 0000000..86f1a39
--- /dev/null
+++ b/fs/btrfs/cslink.h
@@ -0,0 +1,107 @@
+#ifndef __BTRFS_CSLINK__
+#define __BTRFS_CSLINK__
+
+#include <linux/ctype.h>
+
+#define	CSL_INTRAFILEPOS	(1<<0)	/* Obsolete */
+
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+void mdcsrepair_procfs(const char *filesystem, const char *place,
+		u64 inum,
+		const u8 *expected, const u8 *computed,
+		size_t cslen, const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, dev_t adev, u64 fpos, u64 flags);
+
+/*
+ * For debugging, <file>:<func> or :<inum> is compared to simulate
+ * a CRC error for each code execution.
+ * A nil string before and after ":" works as a wild card,
+ * so that ":" alone matches any (i.e. will always generate fake error).
+ */
+extern char *__btrfs_proc_mdcsrepair_debug;
+
+#if defined(DEBUG_CSLINK)
+#define btrfs_mdcsrepair_hit(...)	true
+#else
+static bool inline
+btrfs_mdcsrepair_hit(bool cond, const void *expected,
+			const char *__file, const char *__func, u64 inum)
+{
+	const char *colon = __btrfs_proc_mdcsrepair_debug;
+
+	if (cond && *((u32 *)expected))
+		return true;
+
+	if (!colon || !*colon)
+		return false;
+
+	/* Check for <file> field before ":" */
+	if (*colon != ':' &&
+		(strncmp(colon, __file, strlen(__file)) ||
+			*(colon += strlen(__file)) != ':'))
+		return false;
+
+	/* Now colon points to ':'. */
+	colon++;
+	if (isdigit(*colon)) {
+		char *end;
+		u64 restrict_inum = simple_strtoull(colon, &end, 10);
+
+		return !*end && inum == restrict_inum;
+	}
+	return !*colon || !strcmp(colon, __func);
+}
+#endif
+/* Definition in inode.c */
+u64 btrfs_log2phys(struct inode *inode, u64 logical, u64 len, dev_t *dev);
+#else
+static
+void inline mdcsrepair_procfs(const char *filesystem, const char *place,
+		const u8 *expected, const u8 *computed,
+		size_t cslen, const void *csfunc,
+		u64 dpos, size_t len,
+		dev_t dev, u64 inum, u64 fpos, u64 flags) {}
+
+static u64
+inline btrfs_log2phys(struct inode *inode, u64 logical, u64 len, dev_t *dev)
+{
+	*dev = 0;
+	return (u64)~0;
+}
+#endif
+
+/* Debug macros */
+#if defined(DEBUG_MDCS)
+#define __MDCS(_good, _bad, _size, _len, _pos, _dev, _ino)	\
+	do {	\
+		u8 *_gp = (u8 *)(_good), *_bp = (u8 *)(_bad); int _i;	\
+		pr_emerg("%s:%d G:", __FILE__, __LINE__);	\
+		for (_i = 0; _i < (_size); _i++)	\
+			pr_emerg("%02x", _gp[_i]);	\
+		pr_emerg(" B:");	\
+		for (_i = 0; _i < (_size); _i++)	\
+			pr_emerg("%02x", _bp[_i]);	\
+		pr_emerg(" %lu @ %llu dev=%u:%u ino=%llu\n",	\
+			(size_t)(_len), (_pos),		\
+			(unsigned int)MAJOR(_dev),	\
+			(unsigned int)MINOR(_dev),	\
+			(u64)(_ino));	\
+	} while (0)
+#else
+#define __MDCS(...)	do {} while(0)
+#endif
+
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+#define __btrfs_cslink(cond, inum, expected, ...)       \
+	do {	\
+		if (btrfs_mdcsrepair_hit(cond, expected,	\
+			__FILE__, __func__, (inum)))		\
+			mdcsrepair_procfs("btrfs", __func__,	\
+					inum, expected, __VA_ARGS__);	\
+	} while (0)
+#else
+#define __btrfs_cslink(...)	do {} while(0)
+#endif
+
+#endif	/* __BTRFS_CSLINK__ */
diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c
index 40b150b..88ab25a 100644
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -50,6 +50,10 @@
 #include "sysfs.h"
 #include "qgroup.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 #ifdef CONFIG_X86
 #include <asm/cpufeature.h>
 #endif
@@ -76,6 +80,8 @@ static int btrfs_destroy_pinned_extent(struct btrfs_root *root,
 				       struct extent_io_tree *pinned_extents);
 static int btrfs_cleanup_transaction(struct btrfs_root *root);
 static void btrfs_error_commit_super(struct btrfs_root *root);
+static struct buffer_head *__btrfs_read_dev_super(struct block_device *bdev,
+					u64 *bytenrp);
 
 /*
  * btrfs_end_io_wq structs are used to do processing in task context when an IO
@@ -402,7 +408,9 @@ out:
  * Return 0 if the superblock checksum type matches the checksum value of that
  * algorithm. Pass the raw disk superblock data.
  */
-static int btrfs_check_super_csum(char *raw_disk_sb)
+static int btrfs_check_super_csum(char *raw_disk_sb, unsigned long long start,
+				struct block_device *bdev,
+				struct btrfs_fs_info *fs_info)
 {
 	struct btrfs_super_block *disk_sb =
 		(struct btrfs_super_block *)raw_disk_sb;
@@ -421,10 +429,25 @@ static int btrfs_check_super_csum(char *raw_disk_sb)
 		 */
 		crc = btrfs_csum_data(raw_disk_sb + BTRFS_CSUM_SIZE,
 				crc, BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE);
+
+		__MDCS(raw_disk_sb, result, csum_size,
+			BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE,
+			start + BTRFS_CSUM_SIZE,
+			bdev->bd_dev,
+			0);
+
 		btrfs_csum_final(crc, result);
 
 		if (memcmp(raw_disk_sb, result, csum_size))
 			ret = 1;
+
+		__btrfs_cslink(ret, 0,
+				raw_disk_sb, result, csum_size,
+				btrfs_csum_final,
+				start + BTRFS_CSUM_SIZE,
+				BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE,
+				bdev->bd_dev, 0,
+				(u64)~0, 0);
 	}
 
 	if (csum_type >= ARRAY_SIZE(btrfs_csum_sizes)) {
@@ -2494,6 +2517,7 @@ int open_ctree(struct super_block *sb,
 	int num_backups_tried = 0;
 	int backup_index = 0;
 	int max_active;
+	u64 super_bytenr;
 
 	tree_root = fs_info->tree_root = btrfs_alloc_root(fs_info);
 	chunk_root = fs_info->chunk_root = btrfs_alloc_root(fs_info);
@@ -2678,7 +2702,7 @@ int open_ctree(struct super_block *sb,
 	/*
 	 * Read super block and check the signature bytes only
 	 */
-	bh = btrfs_read_dev_super(fs_devices->latest_bdev);
+	bh = __btrfs_read_dev_super(fs_devices->latest_bdev, &super_bytenr);
 	if (IS_ERR(bh)) {
 		err = PTR_ERR(bh);
 		goto fail_alloc;
@@ -2688,7 +2712,9 @@ int open_ctree(struct super_block *sb,
 	 * We want to check superblock checksum, the type is stored inside.
 	 * Pass the whole disk block of size BTRFS_SUPER_INFO_SIZE (4k).
 	 */
-	if (btrfs_check_super_csum(bh->b_data)) {
+	if (btrfs_check_super_csum(bh->b_data, super_bytenr,
+					fs_devices->latest_bdev,
+					fs_info)) {
 		printk(KERN_ERR "BTRFS: superblock checksum mismatch\n");
 		err = -EINVAL;
 		brelse(bh);
@@ -3231,7 +3257,8 @@ int btrfs_read_dev_one_super(struct block_device *bdev, int copy_num,
 }
 
 
-struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)
+static struct buffer_head *__btrfs_read_dev_super(struct block_device *bdev,
+						   u64 *bytenrp)
 {
 	struct buffer_head *bh;
 	struct buffer_head *latest = NULL;
@@ -3264,9 +3291,17 @@ struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)
 	if (!latest)
 		return ERR_PTR(ret);
 
+	if (bytenrp)
+		*bytenrp = btrfs_super_bytenr(super);
+
 	return latest;
 }
 
+struct buffer_head *btrfs_read_dev_super(struct block_device *bdev)
+{
+	return __btrfs_read_dev_super(bdev, NULL);
+}
+
 /*
  * this should be called twice, once with wait == 0 and
  * once with wait == 1.  When wait == 0 is done, all the buffer heads
diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c
index 67ac478..9b8b046 100644
--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -21,6 +21,7 @@
 #include <linux/buffer_head.h>
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/device.h>
 #include <linux/pagemap.h>
 #include <linux/highmem.h>
 #include <linux/time.h>
@@ -61,6 +62,10 @@
 #include "props.h"
 #include "qgroup.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 struct btrfs_iget_args {
 	struct btrfs_key *location;
 	struct btrfs_root *root;
@@ -3048,6 +3053,96 @@ static int btrfs_writepage_end_io_hook(struct page *page, u64 start, u64 end,
 	return 0;
 }
 
+#if defined(CONFIG_BTRFS_MDCSREPAIR)
+/*
+ * map logical device position to physical device position and its device ID.
+ *
+ * simplified excerpts from volumes.c:__btrfs_map_block() and
+ * volumes.c:btrfs_map_bio().
+ */
+u64 btrfs_log2phys(struct inode *inode, u64 logical, u64 len, dev_t *dev)
+{
+	struct btrfs_fs_info *fs_info = BTRFS_I(inode)->root->fs_info;
+	struct extent_map_tree *em_tree = &fs_info->mapping_tree.map_tree;
+	struct extent_map *em;
+	struct map_lookup *map;
+	u64 physical, offset, stripe_nr, stripe_offset, stripe_index;
+
+	read_lock(&em_tree->lock);
+	em = lookup_extent_mapping(em_tree, logical, len);
+	read_unlock(&em_tree->lock);
+
+	if (!em) {
+		pr_warn("%s: cannot lookup extent mapping for %llu\n",
+				__func__, logical);
+		return (u64)~0;
+	}
+
+	map = (struct map_lookup *)em->bdev;
+	if (map->type & (BTRFS_BLOCK_GROUP_RAID1|BTRFS_BLOCK_GROUP_RAID10)) {
+		pr_warn("%s: not supporting RAID1/10", __func__);
+		return (u64)~0;
+	}
+
+	offset = logical - em->start;
+	stripe_nr = offset;
+	do_div(stripe_nr, map->stripe_len);
+	stripe_offset = offset - stripe_nr * map->stripe_len;
+	stripe_index = do_div(stripe_nr, map->num_stripes);
+
+	/* TODO: Untested for multiple stipe cases (RAID0). */
+	physical =  map->stripes[stripe_index].physical +
+			stripe_offset + stripe_nr * map->stripe_len;
+	*dev = map->stripes[stripe_index].dev->bdev->bd_dev;
+	free_extent_map(em);
+	return physical;
+}
+
+/*
+ * map file position to physical device position and its device ID.
+ *
+ *	Done in 2 stages
+ *		#1: logical extent - FIEMAP equivalent
+ *		#2: physical extent - call to btrfs_log2phys() above
+ */
+static u64 fpos2phys(struct inode *inode, u64 fpos, u64 len, dev_t *dev)
+{
+	struct extent_map *em;
+	u64 logical;
+
+	em = btrfs_get_extent(inode, NULL, 0, fpos, len, 0);
+	if (IS_ERR(em) || !em) {
+		pr_err("%s: cannot get extent mapping for %llu\n",
+				__func__, fpos);
+		return (u64)~0;
+	}
+	logical = em->block_start + fpos - em->start;
+	free_extent_map(em);
+
+	return btrfs_log2phys(inode, logical, len, dev);
+}
+
+/* Keep this a macro as we pass __FILE__ and __func_ to other functions. */
+#define __btrfs_cslink_inode(cond, expected, computed, csumlen,	\
+				csfunc, fpos, length, inode)	\
+do {	\
+	if (btrfs_mdcsrepair_hit((cond), (expected),		\
+			__FILE__, __func__, btrfs_ino(inode))) {	\
+		dev_t dev;					\
+		u64 physical = fpos2phys((inode), (fpos), (length), &dev); \
+		\
+		mdcsrepair_procfs("btrfs", __func__,    	\
+			btrfs_ino((inode)),			\
+			(expected), (computed), (csumlen),	\
+			(csfunc), physical, (length),		\
+			dev, BTRFS_I(inode)->root->sbdev.anon_dev,	\
+			(fpos), 0);	\
+	}	\
+} while (0)
+#else
+#define __btrfs_cslink_inode(...)	do {} while (0)
+#endif
+
 static int __readpage_endio_check(struct inode *inode,
 				  struct btrfs_io_bio *io_bio,
 				  int icsum, struct page *page,
@@ -3062,6 +3157,14 @@ static int __readpage_endio_check(struct inode *inode,
 	kaddr = kmap_atomic(page);
 	csum = btrfs_csum_data(kaddr + pgoff, csum,  len);
 	btrfs_csum_final(csum, (char *)&csum);
+
+	__MDCS((void *)&csum_expected, (void *)&csum, 4, len,
+		start, BTRFS_I(inode)->root->sbdev.anon_dev, btrfs_ino(inode));
+	__btrfs_cslink_inode(csum != csum_expected,
+				(u8 *)&csum_expected, (u8 *)&csum, sizeof csum,
+				btrfs_csum_final,
+				start, len,
+				inode);
 	if (csum != csum_expected)
 		goto zeroit;
 
diff --git a/fs/btrfs/scrub.c b/fs/btrfs/scrub.c
index cb519cd..08b1c1b 100644
--- a/fs/btrfs/scrub.c
+++ b/fs/btrfs/scrub.c
@@ -30,6 +30,10 @@
 #include "rcu-string.h"
 #include "raid56.h"
 
+/*#define DEBUG_MDCS*/
+/*#define DEBUG_CSLINK*/
+#include "cslink.h"
+
 /*
  * This is only the first step towards a full-features scrub. It reads all
  * extent and super block and verifies the checksums. In case a bad checksum
@@ -305,6 +309,49 @@ static void scrub_blocked_if_needed(struct btrfs_fs_info *fs_info);
 static void scrub_put_ctx(struct scrub_ctx *sctx);
 
 
+#define __BTRFS_CSLINK(cond, exp, comp, size, sb, offset, blklen)	\
+	__btrfs_cslink(cond, scrub_get_inum(sb),	\
+			(exp), (comp), (size),	\
+			btrfs_csum_final,	\
+			(sb)->pagev[0]->physical + (offset),	\
+			(blklen) - (offset),	\
+			(sb)->pagev[0]->dev->bdev->bd_dev, 0,	\
+			(u64)~0, 0)
+
+#ifdef CONFIG_BTRFS_MDCSREPAIR
+static int scrub_get_inum_cb(u64 inum, u64 offset, u64 root, void *inump)
+{
+	*(u64 *)inump = inum;
+	return 0;
+}
+
+static u64 scrub_get_inum(struct scrub_block *sblock)
+{
+	struct btrfs_key found_key;
+	u64 flags = 0;
+	struct btrfs_path *path = btrfs_alloc_path();
+	u64 extent_item_pos;
+	u64 inum = 0;
+
+	if (!path)
+		return inum;
+
+	if (extent_from_logical(sblock->sctx->dev_root->fs_info,
+		sblock->pagev[0]->logical, path, &found_key, &flags) < 0)
+		goto out;
+	extent_item_pos = sblock->pagev[0]->logical - found_key.objectid;
+	if (!(flags & BTRFS_EXTENT_FLAG_TREE_BLOCK))
+		iterate_extent_inodes(sblock->sctx->dev_root->fs_info,
+				found_key.objectid,
+				extent_item_pos, 1,
+				scrub_get_inum_cb, &inum);
+	btrfs_release_path(path);
+out:
+	btrfs_free_path(path);
+	return inum;
+}
+#endif
+
 static void scrub_pending_bio_inc(struct scrub_ctx *sctx)
 {
 	atomic_inc(&sctx->refs);
@@ -1847,8 +1894,17 @@ static int scrub_checksum_data(struct scrub_block *sblock)
 	}
 
 	btrfs_csum_final(crc, csum);
+	__MDCS(on_disk_csum, calculated_csum, sctx->csum_size,
+		sblock->page_count * PAGE_SIZE - BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->physical + BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->dev->bdev->bd_dev,
+		scrub_get_inum(sblock));
 	if (memcmp(csum, on_disk_csum, sctx->csum_size))
 		sblock->checksum_error = 1;
+	__BTRFS_CSLINK(sblock->checksum_error,
+			on_disk_csum, csum, sctx->csum_size,
+			sblock, BTRFS_CSUM_SIZE,
+			sblock->page_count * PAGE_SIZE);
 
 	return sblock->checksum_error;
 }
@@ -1917,8 +1973,15 @@ static int scrub_checksum_tree_block(struct scrub_block *sblock)
 	}
 
 	btrfs_csum_final(crc, calculated_csum);
+	__MDCS(csum, calculated_csum, csum_size,
+		sblock->page_count * PAGE_SIZE - BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->physical + BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->dev->bdev->bd_dev,
+		scrub_get_inum(sblock));
 	if (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))
 		sblock->checksum_error = 1;
+	__BTRFS_CSLINK(sblock->checksum_error, on_disk_csum, calculated_csum,
+				sctx->csum_size, sblock, 0, sctx->sectorsize);
 
 	return sblock->header_error || sblock->checksum_error;
 }
@@ -1934,6 +1997,7 @@ static int scrub_checksum_super(struct scrub_block *sblock)
 	u64 mapped_size;
 	void *p;
 	u32 crc = ~(u32)0;
+	int fail_crc = 0;
 	int fail_gen = 0;
 	int fail_cor = 0;
 	u64 len;
@@ -1976,8 +2040,18 @@ static int scrub_checksum_super(struct scrub_block *sblock)
 	}
 
 	btrfs_csum_final(crc, calculated_csum);
-	if (memcmp(calculated_csum, on_disk_csum, sctx->csum_size))
+	__MDCS(on_disk_csum, calculated_csum, sctx->csum_size,
+		BTRFS_SUPER_INFO_SIZE - BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->physical + BTRFS_CSUM_SIZE,
+		sblock->pagev[0]->dev->bdev->bd_dev,
+		scrub_get_inum(sblock));
+	if (memcmp(calculated_csum, on_disk_csum, sctx->csum_size)) {
 		++fail_cor;
+		++fail_crc;
+	}
+	__BTRFS_CSLINK(fail_crc,
+			on_disk_csum, calculated_csum, sctx->csum_size,
+			sblock, BTRFS_CSUM_SIZE, BTRFS_SUPER_INFO_SIZE);
 
 	if (fail_cor + fail_gen) {
 		/*
-- 
1.9.1

