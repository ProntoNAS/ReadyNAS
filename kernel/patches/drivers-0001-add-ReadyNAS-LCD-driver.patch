From f6ee59293fc73be1d4f24c69550cd340a4048c91 Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Fri, 23 Oct 2015 11:14:00 -0700
Subject: [PATCH 1/6] add ReadyNAS LCD driver

---
 .../devicetree/bindings/misc/hd44780-lcd.txt       |  33 ++
 .../devicetree/bindings/misc/readynas-lcd.txt      |  22 +
 drivers/platform/Kconfig                           |   1 +
 drivers/platform/Makefile                          |   1 +
 drivers/platform/readynas/Kconfig                  |  28 +
 drivers/platform/readynas/Makefile                 |   6 +
 drivers/platform/readynas/hd44780-lcd.c            | 626 +++++++++++++++++++++
 drivers/platform/readynas/hd44780-lcd.h            |  97 ++++
 drivers/platform/readynas/readynas-lcd.c           | 501 +++++++++++++++++
 9 files changed, 1315 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/misc/hd44780-lcd.txt
 create mode 100644 Documentation/devicetree/bindings/misc/readynas-lcd.txt
 create mode 100644 drivers/platform/readynas/Kconfig
 create mode 100644 drivers/platform/readynas/Makefile
 create mode 100644 drivers/platform/readynas/hd44780-lcd.c
 create mode 100644 drivers/platform/readynas/hd44780-lcd.h
 create mode 100644 drivers/platform/readynas/readynas-lcd.c

diff --git a/Documentation/devicetree/bindings/misc/hd44780-lcd.txt b/Documentation/devicetree/bindings/misc/hd44780-lcd.txt
new file mode 100644
index 0000000..6fffdfd
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/hd44780-lcd.txt
@@ -0,0 +1,33 @@
+Driver to drive Hitachi HD44780 based LCD displays through GPIO lines.
+
+This is a generic HD44780-based LCD driver not using GPIO.
+
+Required properties:
+- compatible : should be "gpio-lcd" or "hd44780-lcd".
+- lcm-bits : an array of 4 or 8 GPIO line references. The 3rd argument
+  (polarity or active high/low) is honored.
+  lcm-en, lcm-rs, lcm-rw : GPIO line references to the corresponding
+  HD44780 signals, EN, RS, and RW.
+  lcm-bl : a GPIO line reference to control LCD backlight.
+  locm-data-4bit : a boolean property to indicate 4-bit data mode.
+
+Optional properties:
+- lcm-lines : the number of LCD lines (default is 2). The HD44780 does not
+  support more than 2 lines.
+- lcm-cols : the number of LCD columns. Currently ignored.
+
+Example:
+
+gpio_lcd: gpio_lcd {
+	compatible = "gpio-lcd";
+	lcm-data-4bit;
+	lcm-lines  = <2>;
+	lcm-bits = <&gpio4 4 0>,
+		   <&gpio4 5 0>,
+		   <&gpio4 6 0>,
+		   <&gpio4 7 0>;
+	lcm-rs   = <&gpio4 3 0>;
+	lcm-bl   = <&gpio5 0 0>;
+	lcm-rw   = <&gpio5 1 0>;
+	lcm-en   = <&gpio5 2 0>;
+};
diff --git a/Documentation/devicetree/bindings/misc/readynas-lcd.txt b/Documentation/devicetree/bindings/misc/readynas-lcd.txt
new file mode 100644
index 0000000..aa915c3
--- /dev/null
+++ b/Documentation/devicetree/bindings/misc/readynas-lcd.txt
@@ -0,0 +1,22 @@
+Driver to implement NETGEAR ReadyNAS's LCD user land API over the procfs
+using the Hitachi HD44780 based LCD driver "gpio-lcd."
+
+This driver creates the following /proc entries:
+/proc/LCD : 'echo 1 \"Hello\" > /proc/LCD' displays "Hello" on line #1.
+          : 'echo 2 \"World\" > /proc/LCD' displays "World" on line #2.
+          : 'echo 3 > /proc/LCD' turns LCD on.
+          : 'echo 4 > /proc/LCD' turns LCD off.
+          : 'echo 0 > /proc/LCD' clears LCD.
+/proc/LCDstatus : a read-only entry to return LCD on/off status.
+/proc/LCDinfo : a read-only entry to return LCD information
+
+Required properties:
+- compatible : should be "readynas-lcd."
+- lcd-device : a reference to the HD33780 device.
+
+Example:
+
+readynas_lcd {
+	compatible = "readynas-lcd";
+	lcd-device = <&gpio_lcd>;
+};
diff --git a/drivers/platform/Kconfig b/drivers/platform/Kconfig
index 0adccbf..45042c4 100644
--- a/drivers/platform/Kconfig
+++ b/drivers/platform/Kconfig
@@ -9,3 +9,4 @@ source "drivers/platform/goldfish/Kconfig"
 endif
 
 source "drivers/platform/chrome/Kconfig"
+source "drivers/platform/readynas/Kconfig"
diff --git a/drivers/platform/Makefile b/drivers/platform/Makefile
index ca26925..55bf250 100644
--- a/drivers/platform/Makefile
+++ b/drivers/platform/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_MIPS)		+= mips/
 obj-$(CONFIG_OLPC)		+= olpc/
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
+obj-$(CONFIG_READYNAS_PLATFORMS)	+= readynas/
diff --git a/drivers/platform/readynas/Kconfig b/drivers/platform/readynas/Kconfig
new file mode 100644
index 0000000..ff0f95f
--- /dev/null
+++ b/drivers/platform/readynas/Kconfig
@@ -0,0 +1,28 @@
+#
+# Platform support for ReadyNAS hardware
+#
+
+menuconfig READYNAS_PLATFORMS
+	bool "Platform support for ReadyNAS hardware"
+	depends on X86 || ARM
+	---help---
+	  Say Y here to get to see options for platform support for
+	  various ReadyNAS models. This option alone does not add any kernel code.
+
+	  If you say N, all options in this submenu will be skipped and disabled.
+
+if READYNAS_PLATFORMS
+
+config HD44780_LCD
+	tristate "Hitachi HD44780 LCD using GPIO"
+	---help---
+	  Say yes here to enable the alpha numeric LCD driver using
+	  Hitachi HD44780 accessed by GPIO.
+
+config READYNAS_LCD
+	tristate "NETGEAR ReadyNAS LCD driver"
+	depends on HD44780_LCD
+	---help---
+	  Alpha numeric LCD driver for NETGEAR ReadyNAS.
+
+endif # READYNAS_PLATFORMS
diff --git a/drivers/platform/readynas/Makefile b/drivers/platform/readynas/Makefile
new file mode 100644
index 0000000..5056b2c
--- /dev/null
+++ b/drivers/platform/readynas/Makefile
@@ -0,0 +1,6 @@
+
+#
+# Keep module loading order
+#
+obj-$(CONFIG_HD44780_LCD)	+= hd44780-lcd.o
+obj-$(CONFIG_READYNAS_LCD)	+= readynas-lcd.o
diff --git a/drivers/platform/readynas/hd44780-lcd.c b/drivers/platform/readynas/hd44780-lcd.c
new file mode 100644
index 0000000..01c5b1d
--- /dev/null
+++ b/drivers/platform/readynas/hd44780-lcd.c
@@ -0,0 +1,626 @@
+/*
+ * hd44780-lcd.c
+ *
+ * LCD alpha numeric display driver for Hitach HD44780 driven by GPIO
+ *
+ * Copyright (c)2015 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ */
+
+#include "hd44780-lcd.h"
+#include <../drivers/gpio/gpiolib.h>
+
+static bool lcd_backlight_state(struct hd44780_lcd *gl)
+{
+	return !!gl->get_value(gl->lcm_bl);
+}
+
+static void pin_write(struct hd44780_lcd *gl, struct gpio_desc *pin, int value)
+{
+	gl->set_value(pin, value);
+	udelay(1);
+}
+
+static unsigned char lcm_read4(struct hd44780_lcd *gl)
+{
+	unsigned char c = 0;
+
+	c  =  gl->get_value(gl->lcm_data[7]) ? (1 << 7) : 0;
+	c |= (gl->get_value(gl->lcm_data[6]) ? (1 << 6) : 0);
+	c |= (gl->get_value(gl->lcm_data[5]) ? (1 << 5) : 0);
+	c |= (gl->get_value(gl->lcm_data[4]) ? (1 << 4) : 0);
+
+	return c;
+}
+
+static unsigned char lcm_read8(struct hd44780_lcd *gl)
+{
+	unsigned char c = lcm_read4(gl);
+
+	c |=  gl->get_value(gl->lcm_data[3]) ? (1 << 3) : 0;
+	c |= (gl->get_value(gl->lcm_data[2]) ? (1 << 2) : 0);
+	c |= (gl->get_value(gl->lcm_data[1]) ? (1 << 1) : 0);
+	c |= (gl->get_value(gl->lcm_data[0]) ? (1 << 0) : 0);
+
+	return c;
+}
+
+static unsigned char lcm_read(struct hd44780_lcd *gl)
+{
+	unsigned char c;
+
+	pin_write(gl, gl->lcm_rw, 1);
+	pin_write(gl, gl->lcm_en, 1);
+	udelay(50);
+	c = (gl->lcm_data_4bit) ? lcm_read4(gl) : lcm_read8(gl);
+	pin_write(gl, gl->lcm_en, 0);
+
+	if (gl->lcm_data_4bit) {
+		c &= 0xf0;
+		pin_write(gl, gl->lcm_en, 1);
+		udelay(50);
+		c |= lcm_read4(gl) >> 4;
+		pin_write(gl, gl->lcm_en, 0);
+	}
+	udelay(50);
+	return c;
+}
+
+static void wait_busy(struct hd44780_lcd *gl)
+{
+	int try = 10;
+
+	pin_write(gl, gl->lcm_rs, 0);
+	while (try-- > 0) {
+		if (!(lcm_read(gl) & 0x80))
+			break;
+		mdelay(1);
+	}
+}
+
+static void lcm_write4(struct hd44780_lcd *gl, unsigned char c)
+{
+	gl->set_value(gl->lcm_data[7], !!(c & (1 << 7)));
+	gl->set_value(gl->lcm_data[6], !!(c & (1 << 6)));
+	gl->set_value(gl->lcm_data[5], !!(c & (1 << 5)));
+	gl->set_value(gl->lcm_data[4], !!(c & (1 << 4)));
+}
+
+static void lcm_write8(struct hd44780_lcd *gl, unsigned char c)
+{
+	lcm_write4(gl, c);
+	gl->set_value(gl->lcm_data[3], !!(c & (1 << 3)));
+	gl->set_value(gl->lcm_data[2], !!(c & (1 << 2)));
+	gl->set_value(gl->lcm_data[1], !!(c & (1 << 1)));
+	gl->set_value(gl->lcm_data[0], !!(c & (1 << 0)));
+}
+
+static void lcm_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	pin_write(gl, gl->lcm_rw, 0);
+	pin_write(gl, gl->lcm_en, 1);
+	if (gl->lcm_data_4bit)
+		lcm_write4(gl, c);
+	else
+		lcm_write8(gl, c);
+	udelay(50);
+	pin_write(gl, gl->lcm_en, 0);
+	udelay(50);
+	if (gl->lcm_data_4bit) {
+		pin_write(gl, gl->lcm_en, 1);
+		lcm_write4(gl, c << 4);
+		udelay(50);
+		pin_write(gl, gl->lcm_en, 0);
+		udelay(50);
+	}
+}
+
+static void lcd_data_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	wait_busy(gl);
+	pin_write(gl, gl->lcm_rs, 1);
+	lcm_write(gl, c);
+}
+
+static void command_write(struct hd44780_lcd *gl, unsigned char c)
+{
+	wait_busy(gl);
+	pin_write(gl, gl->lcm_rs, 0);
+	lcm_write(gl, c);
+}
+
+static void lcd_sync_data_len(struct hd44780_lcd *gl)
+{
+	/* Regardless of current data length...*/
+	pin_write(gl, gl->lcm_rs, 0);
+	pin_write(gl, gl->lcm_rw, 0);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode again. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	pin_write(gl, gl->lcm_en, 1);
+	/* Force 8bit mode again more. */
+	lcm_write4(gl, 0x30);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+	if (!gl->lcm_data_4bit)
+		return;
+	pin_write(gl, gl->lcm_en, 1);
+	lcm_write4(gl, 0x20);
+	udelay(100);
+	pin_write(gl, gl->lcm_en, 0);
+	mdelay(5);
+}
+
+static void lcd_entry_mode_set(struct hd44780_lcd *gl, int l2r, int scroll)
+{
+	command_write(gl, 0x04 | (l2r << 1) | scroll);
+}
+
+static void lcd_cursor_set(struct hd44780_lcd *gl, int row, int col)
+{
+	command_write(gl, 0x80 | (row << 6) | col);
+	udelay(53);
+}
+
+static void lcd_clear_display(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_clear_display);
+	mdelay(2);
+}
+
+static void lcd_return_home(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_return_home);
+	mdelay(2);
+}
+
+static void lcd_entry_mode_id(struct hd44780_lcd *gl, bool incr)
+{
+	gl->lcm_entry_mode &= ~0x02;
+	if (incr)
+		gl->lcm_entry_mode |= 0x02;
+	command_write(gl, gl->lcm_entry_mode);
+}
+
+static void lcd_entry_mode_shift(struct hd44780_lcd *gl, bool shift)
+{
+	gl->lcm_entry_mode &= ~0x01;
+	if (shift)
+		gl->lcm_entry_mode |= 0x01;
+	command_write(gl, gl->lcm_entry_mode);
+}
+
+static void lcd_entry_display_on(struct hd44780_lcd *gl, bool on)
+{
+	gl->lcm_display_control &= ~0x04;
+	if (on)
+		gl->lcm_display_control |= 0x04;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_display_cursor_on(struct hd44780_lcd *gl, bool on)
+{
+	gl->lcm_display_control &= ~0x02;
+	if (on)
+		gl->lcm_display_control |= 0x02;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_display_cursor_blink(struct hd44780_lcd *gl, bool blink)
+{
+	gl->lcm_display_control &= ~0x01;
+	if (blink)
+		gl->lcm_display_control |= 0x01;
+	command_write(gl, gl->lcm_display_control);
+}
+
+static void lcd_shift_display(struct hd44780_lcd *gl, bool right)
+{
+	gl->lcm_display_shift &= ~0x04;
+	gl->lcm_display_shift |= ~0x08;
+	if (right)
+		gl->lcm_display_shift |= 0x04;
+	command_write(gl, gl->lcm_display_shift);
+}
+
+static void lcd_shift_cursor(struct hd44780_lcd *gl, bool right)
+{
+	gl->lcm_display_shift &= ~0x0c;
+	if (right)
+		gl->lcm_display_shift |= 0x04;
+	command_write(gl, gl->lcm_display_shift);
+}
+
+static void lcd_function_8bit(struct hd44780_lcd *gl, bool _8bit)
+{
+	gl->lcm_function &= ~0x10;
+	if (_8bit)
+		gl->lcm_function |= 0x10;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_function_2line(struct hd44780_lcd *gl, bool _2line)
+{
+	gl->lcm_function &= ~0x08;
+	if (_2line)
+		gl->lcm_function |= 0x08;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_function_5x11(struct hd44780_lcd *gl, bool _5x11)
+{
+	gl->lcm_function &= ~0x04;
+	if (_5x11)
+		gl->lcm_function |= 0x04;
+	command_write(gl, gl->lcm_function);
+}
+
+static void lcd_set_cgram_address(struct hd44780_lcd *gl, unsigned char offset)
+{
+	gl->lcm_cgram_address &= ~0x1f;
+	if (offset)
+		gl->lcm_cgram_address |= (offset & 0x1f);
+	command_write(gl, gl->lcm_cgram_address);
+}
+
+static void lcd_set_cursor_pos(struct hd44780_lcd *gl,
+				unsigned char row, unsigned char col)
+{
+	if (gl->lcm_num_rows == 2) {
+		if (col > 0x27)
+			col = 0x27;
+	} else {
+		if (col > 0x4f)
+			col = 0x4f;
+		row = 0;
+	}
+	command_write(gl, 0x80 | (row << 6) | col);
+}
+
+static void lcd_backlight_on(struct hd44780_lcd *gl, bool on)
+{
+	pin_write(gl, gl->lcm_bl, on);
+	gl->backlight_status = on;
+}
+
+static void lcd_add_custom_character(struct hd44780_lcd *gl)
+{
+	command_write(gl, gl->lcm_cgram_address | (1 << 3)); /* slot 1 */
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x00);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+	lcd_data_write(gl, 0x1f);
+}
+
+static int lcd_init(struct hd44780_lcd *gl)
+{
+	lcd_sync_data_len(gl);
+
+	lcd_function_8bit(gl, !gl->lcm_data_4bit);
+	lcd_function_2line(gl, (gl->lcm_num_rows == 2));
+
+	lcd_clear_display(gl);
+	lcd_entry_mode_set(gl, 1, 0);
+	lcd_cursor_set(gl, 0, 0);	/* 1st line 1st col */
+	lcd_entry_display_on(gl, 1);	/* turn LCD on */
+	lcd_backlight_on(gl, 1);	/* turn backlight on */
+	lcd_add_custom_character(gl);	/* add half block custom character */
+
+	return 0;
+}
+
+static void lcd_exit(struct hd44780_lcd *gl)
+{
+}
+
+#ifndef CONFIG_OF_GPIO
+static int gpio_match_labels(struct gpio_chip *gc, void *data)
+{
+	return !strcmp(gc->label, (const char *)data);
+}
+
+static struct gpio_chip *gpiochip_find_by_label(const char *label)
+{
+	return gpiochip_find((void *)label, gpio_match_labels);
+}
+
+#define SETUP_GPIO(label, member)	\
+	{ label, offsetof(struct hd44780_lcd, member), true }
+#define SETUP_NON(label, member)	\
+	{ label, offsetof(struct hd44780_lcd, member), false }
+#define SETUP_GPIO2(name)	\
+	SETUP_GPIO("lcm-"#name, lcm_##name)
+static const struct {
+	const char *label;
+	const size_t offset;
+	const bool is_gpiod;
+} setup_item[] = {
+	SETUP_GPIO2(rs),
+	SETUP_GPIO2(rw),
+	SETUP_GPIO2(en),
+	SETUP_GPIO2(bl),
+	SETUP_NON("lcm-lines", lcm_num_rows),
+	SETUP_NON("lcm-cols", lcm_num_cols),
+	SETUP_NON("lcm-data-4bit", lcm_data_4bit),
+	SETUP_GPIO("lcm-bit0", lcm_data[0]),
+	SETUP_GPIO("lcm-bit1", lcm_data[1]),
+	SETUP_GPIO("lcm-bit2", lcm_data[2]),
+	SETUP_GPIO("lcm-bit3", lcm_data[3]),
+	SETUP_GPIO("lcm-bit4", lcm_data[4]),
+	SETUP_GPIO("lcm-bit5", lcm_data[5]),
+	SETUP_GPIO("lcm-bit6", lcm_data[6]),
+	SETUP_GPIO("lcm-bit7", lcm_data[7]),
+	{}
+};
+
+static int setup_gpiomap(struct hd44780_lcd *gl,
+				struct gpio_lcd_map const *setup)
+{
+	struct gpio_chip *gc;
+	int i = 0, err = 0;
+
+	gl->lcm_num_rows = 2;
+	gl->lcm_num_cols = 16;
+
+	if (!setup)
+		return -EINVAL;
+
+	gc = gpiochip_find_by_label(setup->gpio_label);
+	if (IS_ERR(gc))
+		err = PTR_ERR(gc);
+	else if (!gc)
+		err = -ENODEV;
+	if (err) {
+		pr_err("%s: cannot find LCD GPIO %s.\n",
+			__func__, setup->gpio_label);
+		return err;
+	}
+
+	while (setup->map[i].label) {
+		int j = 0;
+
+		while (setup_item[j].label) {
+			void *vp;
+
+			if (strcmp(setup_item[j].label, setup->map[i].label)) {
+				j++;
+				continue;
+			}
+
+			vp = (void *)gl + setup_item[j].offset;
+			if (setup_item[j].is_gpiod) {
+				struct gpio_desc *gd =
+					gpio_to_desc(setup->map[i].val +
+							gc->base);
+				if (setup->map[i].active_low)
+					set_bit(FLAG_ACTIVE_LOW, &gd->flags);
+				gpiod_direction_output(gd, 0);
+				*(struct gpio_desc **)vp = gd;
+			} else
+				*(unsigned int *)vp = setup->map[i].val;
+			break;
+		}
+		if (!setup_item[j].label)
+			return -EINVAL;
+		i++;
+	}
+
+	if (!gl->lcm_rs || !gl->lcm_rw || !gl->lcm_en || !gl->lcm_bl ||
+		!gl->lcm_data[7] || !gl->lcm_data[6] ||
+		!gl->lcm_data[5] || !gl->lcm_data[4])
+		return -EINVAL;
+	if (!gl->lcm_data_4bit &&
+		(!gl->lcm_data[3] || !gl->lcm_data[2] ||
+		!gl->lcm_data[1] || !gl->lcm_data[0]))
+		return -EINVAL;
+
+	if (gl->lcm_num_rows == 2)
+		gl->function_2line(gl, 1);
+
+	return 0;
+}
+
+static int gpio_lcd_match(struct device *dev, void *data)
+{
+	struct gpio_lcd_map *map = dev_get_drvdata(dev);
+
+	return map ?
+		!strncmp(map->magic, (const char *)data, sizeof map->magic) : 0;
+}
+
+static struct gpio_lcd_map *find_gpio_lcd_map(void)
+{
+	struct device *dev = bus_find_device(&platform_bus_type, NULL,
+						GPIO_LCD_MAGIC, gpio_lcd_match);
+	return dev ? dev_get_drvdata(dev) : NULL;
+}
+#endif
+
+static int hd44780_lcd_probe(struct platform_device *pdev)
+{
+	struct hd44780_lcd *gl;
+	int err = 0;
+#ifdef CONFIG_OF_GPIO
+	int i, j;
+	struct device_node *np = pdev->dev.of_node;
+
+	if (!np)
+		return -ENODEV;
+#else
+	struct gpio_lcd_map *gpio_map = find_gpio_lcd_map();
+
+	if (!gpio_map)
+		return -ENODEV;
+#endif
+	if (!(gl = devm_kzalloc(&pdev->dev, sizeof *gl, GFP_KERNEL)))
+		return -ENOMEM;
+
+	memcpy(gl->magic, LCD_PLATFORM_MAGIC, sizeof gl->magic);
+	platform_set_drvdata(pdev, gl);
+
+	gl->lcm_clear_display	= 0x01;
+	gl->lcm_return_home	= 0x02;
+	gl->lcm_entry_mode	= 0x04;
+	gl->lcm_display_control	= 0x08;
+	gl->lcm_display_shift	= 0x10;
+	gl->lcm_function	= 0x20;
+	gl->lcm_cgram_address	= 0x40;
+	gl->lcm_ddram_address	= 0x80;
+
+	gl->init	= lcd_init;
+	gl->exit	= lcd_exit;
+
+	gl->get_value = gpiod_get_value;
+	gl->set_value = gpiod_set_value;
+
+	gl->clear_lcd 		= lcd_clear_display;
+	gl->return_home		= lcd_return_home;
+	gl->entry_mode_id	= lcd_entry_mode_id;
+	gl->entry_mode_shift	= lcd_entry_mode_shift;
+	gl->entry_display_on	= lcd_entry_display_on;
+	gl->display_cursor_on	= lcd_display_cursor_on;
+	gl->display_cursor_blink= lcd_display_cursor_blink;
+	gl->shift_display	= lcd_shift_display;
+	gl->shift_cursor	= lcd_shift_cursor;
+	gl->function_8bit	= lcd_function_8bit;
+	gl->function_2line	= lcd_function_2line;
+	gl->function_5x11	= lcd_function_5x11;
+	gl->set_cgram_address	= lcd_set_cgram_address;
+	gl->set_cursor_pos	= lcd_set_cursor_pos;
+
+	gl->backlight_on	= lcd_backlight_on;
+	gl->backlight_state	= lcd_backlight_state;
+	gl->data_write		= lcd_data_write;
+	gl->command_write	= command_write;
+
+	mutex_init(&gl->lcm_lock);
+#ifdef CONFIG_OF_GPIO
+	/* gpiolib is weird. flags' FLAG_ACTIVE_LOW needs to be set outisde. */
+#define GET_GPIO_PIN(np, gl, pin, name, idx)	\
+	do {					\
+		struct gpio_desc *_desc;	\
+		enum of_gpio_flags _flags;	\
+		if (IS_ERR_OR_NULL(_desc =	\
+			of_get_named_gpiod_flags((np),(name),(idx),&_flags))) {\
+			err = PTR_ERR(_desc);	\
+			goto fail;	\
+		}	\
+		if (_flags & OF_GPIO_ACTIVE_LOW)	\
+			set_bit(FLAG_ACTIVE_LOW, &_desc->flags);	\
+		gpiod_direction_output(_desc, 0);	\
+		(gl)->pin = _desc;	\
+	} while (0)
+
+	for (i = 0, j = 4; i < 4; i++, j++)
+		GET_GPIO_PIN(np, gl, lcm_data[j], "lcm-bits", i);
+
+	if (!(gl->lcm_data_4bit = of_get_property(np, "lcm-data-4bit", NULL))) {
+		for ( ; i < 8; i++, j++)
+			GET_GPIO_PIN(np, gl, lcm_data[j], "lcm-bits", i);
+	}
+
+	GET_GPIO_PIN(np, gl, lcm_rs, "lcm-rs", 0);
+	GET_GPIO_PIN(np, gl, lcm_rw, "lcm-rw", 0);
+	GET_GPIO_PIN(np, gl, lcm_en, "lcm-en", 0);
+	GET_GPIO_PIN(np, gl, lcm_bl, "lcm-bl", 0);
+	if (of_property_read_u32(np, "lcm-lines", (u32 *)&gl->lcm_num_rows))
+		gl->lcm_num_rows = 2;
+	if (of_property_read_u32(np, "lcm-cols", (u32 *)&gl->lcm_num_cols))
+		gl->lcm_num_cols = 16;
+#else
+	if ((err = setup_gpiomap(gl, gpio_map)))
+		goto fail;
+#endif
+	if ((err = gl->init(gl)))
+		goto fail;
+	return 0;
+
+fail:
+	devm_kfree(&pdev->dev, gl);
+	return err;
+}
+
+static int hd44780_lcd_remove(struct platform_device *pdev)
+{
+	struct hd44780_lcd *gl = platform_get_drvdata(pdev);
+
+	if (gl && gl->exit)
+		gl->exit(gl);
+	devm_kfree(&pdev->dev, gl);
+	return 0;
+}
+
+static struct of_device_id hd44780_lcd_dt_ids[] = {
+	{
+		.compatible = "hd44780-lcd",
+	}, {
+		.compatible = "gpio-lcd",
+	}, {},
+};
+
+MODULE_DEVICE_TABLE(of, hd44780_lcd_ds_ids);
+
+static struct platform_driver hd44780_lcd_driver = {
+	.probe	= hd44780_lcd_probe,
+	.remove = hd44780_lcd_remove,
+	.driver = {
+		.name = "hd44780-lcd",
+		.of_match_table = hd44780_lcd_dt_ids,
+	},
+};
+
+#ifdef CONFIG_OF_GPIO
+module_platform_driver(hd44780_lcd_driver);
+#else
+static struct platform_device *hd44780_lcd_pdev;
+
+static int __init hd44780_lcd_init(void)
+{
+	int err = platform_driver_register(&hd44780_lcd_driver);
+
+	if (err)
+		return err;
+
+	hd44780_lcd_pdev =
+		platform_device_register_simple(hd44780_lcd_driver.driver.name,
+						-1, NULL, 0);
+	if (IS_ERR(hd44780_lcd_pdev))
+		err = PTR_ERR(hd44780_lcd_pdev);
+	else if (!hd44780_lcd_pdev)
+		err = -ENODEV;
+
+	if (err)
+		platform_driver_unregister(&hd44780_lcd_driver);
+	return err;
+}
+
+static void __exit hd44780_lcd_exit(void)
+{
+	platform_device_unregister(hd44780_lcd_pdev);
+	platform_driver_unregister(&hd44780_lcd_driver);
+}
+
+device_initcall_sync(hd44780_lcd_init);
+module_exit(hd44780_lcd_exit);
+#endif
+
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
+MODULE_DESCRIPTION("generic HD44780 LCD driver");
diff --git a/drivers/platform/readynas/hd44780-lcd.h b/drivers/platform/readynas/hd44780-lcd.h
new file mode 100644
index 0000000..da0de15
--- /dev/null
+++ b/drivers/platform/readynas/hd44780-lcd.h
@@ -0,0 +1,97 @@
+/*
+ * hd44780-lcd.h
+ *
+ * LCD alpha numeric display driver for Hitach HD44780 driven by GPIO
+ *
+ * Copyright (c)2015 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation
+ */
+
+#include <linux/module.h>
+#include <linux/string.h>
+#ifdef CONFIG_OF_GPIO
+#include <linux/of_fdt.h>
+#endif
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <asm/uaccess.h>
+
+#include <linux/slab.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+
+#ifdef CONFIG_OF_GPIO
+#include <linux/of.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+#else
+
+#define	GPIO_LCD_MAGIC		"gpio-lcd"
+struct gpio_lcd_map {
+	char magic[16];
+	const char *gpio_label;
+	struct {
+		const char *label;
+		const unsigned int val;
+		const bool active_low;
+	} map[];
+};
+#endif
+
+#define	LCD_PLATFORM_MAGIC	"lcd-device"
+struct hd44780_lcd {
+	char magic[12];
+	bool lcm_data_4bit;
+	int  lcm_num_rows;
+	int  lcm_num_cols;
+	struct gpio_desc *lcm_data[8];
+	struct gpio_desc *lcm_rw;
+	struct gpio_desc *lcm_en;
+	struct gpio_desc *lcm_rs;
+	struct gpio_desc *lcm_bl;
+	struct mutex lcm_lock;
+
+	int  (*init)(struct hd44780_lcd *);
+	void (*exit)(struct hd44780_lcd *);
+
+	int  (*get_value)(const struct gpio_desc *);
+	void (*set_value)(struct gpio_desc *, int);
+
+	void (*clear_lcd)(struct hd44780_lcd *);
+	void (*return_home)(struct hd44780_lcd *);
+	void (*entry_mode_id)(struct hd44780_lcd *, bool);
+	void (*entry_mode_shift)(struct hd44780_lcd *, bool);
+	void (*entry_display_on)(struct hd44780_lcd *, bool);
+	void (*display_cursor_on)(struct hd44780_lcd *, bool);
+	void (*display_cursor_blink)(struct hd44780_lcd *, bool);
+	void (*shift_display)(struct hd44780_lcd *, bool);
+	void (*shift_cursor)(struct hd44780_lcd *, bool);
+	void (*function_8bit)(struct hd44780_lcd *, bool);
+	void (*function_2line)(struct hd44780_lcd *, bool);
+	void (*function_5x11)(struct hd44780_lcd *, bool);
+	void (*set_cgram_address)(struct hd44780_lcd *, unsigned char);
+	void (*set_cursor_pos)(struct hd44780_lcd *, unsigned char, unsigned char);
+
+	void (*backlight_on)(struct hd44780_lcd *, bool);
+	bool (*backlight_state)(struct hd44780_lcd *);
+	void (*data_write)(struct hd44780_lcd *, unsigned char);
+	void (*command_write)(struct hd44780_lcd *, unsigned char);
+	bool backlight_status;
+
+	struct platform_device *pdev;
+
+	unsigned char lcm_clear_display;	/* 0x01 */
+	unsigned char lcm_return_home;		/* 0x02 */
+	unsigned char lcm_entry_mode;		/* 0x04 */
+	unsigned char lcm_display_control;	/* 0x08 */
+	unsigned char lcm_display_shift;	/* 0x10 */
+	unsigned char lcm_function;		/* 0x20 */
+	unsigned char lcm_cgram_address;	/* 0x40 */
+	unsigned char lcm_ddram_address;	/* 0x80 */
+};
diff --git a/drivers/platform/readynas/readynas-lcd.c b/drivers/platform/readynas/readynas-lcd.c
new file mode 100644
index 0000000..d332e96
--- /dev/null
+++ b/drivers/platform/readynas/readynas-lcd.c
@@ -0,0 +1,501 @@
+/*
+ * readynas-lcd.c
+ *
+ * NETGEAR ReadyNAS LCD alpha numeric display driver using Hitach HD44780
+ *
+ * Copyright (c)2015-2016 NETGEAR, INC.
+ * Author: Hiro Sugawara <hiro.sugawara@netgear.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "hd44780-lcd.h"
+#ifdef CONFIG_READYNAS_LCD_PROC_INTERNAL
+#include <../fs/proc/internal.h>
+#endif
+#include <linux/ctype.h>
+#include <linux/kdebug.h>
+#include <linux/kallsyms.h>
+#include <asm/stacktrace.h>
+
+/*#define DEBUG_LCD_PANIC_OOPS*/
+
+static struct hd44780_lcd *phys_lcd;
+
+static ssize_t LCD_proc_write(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	char buf[40], c;
+	const char *p, *pm;
+
+	if (!phys_lcd)
+		return -ENODEV;
+	if (!buffer || !count)
+		return 0;
+
+	memset(buf, 0, sizeof(buf));
+
+	if (copy_from_user(buf, buffer, min_t(size_t, count, sizeof buf) - 1))
+		return -EFAULT;
+
+	for (p = buf; *p && isspace(*p); p++)
+		;
+	if (!*p)
+		return count;
+	c = *p++;
+	if (*p && !isspace(*p))
+		return count;
+
+	mutex_lock(&phys_lcd->lcm_lock);
+	switch (c) {
+	case '0':
+		/* Clear LCD */
+		phys_lcd->clear_lcd(phys_lcd);
+		break;
+	case '1':
+	case '2': /* echo 1 \"test LCD\" */
+		/* collect strings bewteen 2 of '\"'  */
+		while (*p && *p != '"')
+			p++;
+		if (!*p)
+			break;
+		pm = ++p;
+		if (!*p)
+			break;
+
+		while (*p && *p != '"')
+			p++;
+
+		if (!*p)
+			break;
+		/* Set line; */
+		phys_lcd->set_cursor_pos(phys_lcd, c - '1', 0);
+
+		/* Put chars */
+		while (pm < p)
+			phys_lcd->data_write(phys_lcd, *pm++);
+		break;
+	case '3':
+		/* Turn on BL */
+		phys_lcd->entry_display_on(phys_lcd, 1);
+		phys_lcd->backlight_on(phys_lcd, 1);
+		break;
+	case '4':
+		/* Turn off BL */
+		phys_lcd->entry_display_on(phys_lcd, 0);
+		phys_lcd->backlight_on(phys_lcd, 0);
+		break;
+	case '7':
+		/* Set command. */
+		if (!p || !*p)
+			break;
+		while (*p && isspace(*p))
+			p++;
+		if (isxdigit(*p))
+			phys_lcd->command_write(phys_lcd,
+						simple_strtoul(p, NULL, 16));
+		break;
+	case '9':
+		phys_lcd->init(phys_lcd);
+		break;
+	default:
+		count = -EINVAL;
+		break;
+	}
+	mutex_unlock(&phys_lcd->lcm_lock);
+
+	return count;
+}
+
+static int LCDstatus_show(struct seq_file *s, void *p)
+{
+	if (!phys_lcd)
+		return -ENODEV;
+
+	seq_printf(s, "%d\n", phys_lcd->backlight_state ?
+					phys_lcd->backlight_state(phys_lcd) :
+					phys_lcd->backlight_status);
+	return 0;
+}
+
+static int LCDstatus_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, LCDstatus_show, NULL);
+}
+
+static int LCDinfo_show(struct seq_file *s, void *p)
+{
+	if (!phys_lcd)
+		return -ENODEV;
+
+	seq_printf(s, "%dx%d\n",
+			phys_lcd->lcm_num_cols, phys_lcd->lcm_num_rows);
+	return 0;
+}
+
+static int LCDinfo_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, LCDinfo_show, NULL);
+}
+
+#ifdef DEBUG_LCD_PANIC_OOPS
+static ssize_t LCD_proc_panic(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	panic("%s:%d",__FILE__,__LINE__);
+	return 0;
+}
+
+static ssize_t LCD_proc_oops(struct file *file, const char __user *buffer,
+				size_t count, loff_t *data)
+{
+	*(int *)0 = 0;
+	return 0;
+}
+#endif
+
+static struct lcd_proc {
+	const char *name;
+	struct proc_dir_entry *proc;
+	const struct file_operations fops;
+} lcd_procs[] = {
+	{
+		.name		= "LCD",
+		.fops.write	= LCD_proc_write,
+	},
+	{
+		.name		= "LCDstatus",
+		.fops.open	= LCDstatus_open,
+		.fops.read	= seq_read,
+		.fops.llseek	= seq_lseek,
+		.fops.release	= single_release,
+	},
+	{
+		.name		= "LCDinfo",
+		.fops.open	= LCDinfo_open,
+		.fops.read	= seq_read,
+		.fops.llseek	= seq_lseek,
+		.fops.release	= single_release,
+	},
+#ifdef DEBUG_LCD_PANIC_OOPS
+	{
+		.name		= "LCDpanic",
+		.fops.write	= LCD_proc_panic,
+	},
+	{
+		.name		= "LCDoops",
+		.fops.write	= LCD_proc_oops,
+	},
+#endif
+	{}
+};
+
+static void __lcd_symbol_dump(unsigned long raddr)
+{
+	static char namebuf[KSYM_NAME_LEN];
+
+	unsigned long addr = (unsigned long)raddr;
+	int bufsiz = phys_lcd->lcm_num_rows * phys_lcd->lcm_num_cols;
+	char buf[bufsiz + 1];
+	const char *p = buf;
+	const char *pm = p + phys_lcd->lcm_num_cols;
+	int row;
+	unsigned long symbolsize, offset;
+	const char *symbol =
+		    kallsyms_lookup(addr, &symbolsize, &offset, NULL, namebuf);
+
+	snprintf(buf, bufsiz, "%s+%lx", symbol, offset);
+
+	phys_lcd->clear_lcd(phys_lcd);
+	phys_lcd->entry_display_on(phys_lcd, 1);
+	phys_lcd->backlight_on(phys_lcd, 1);
+
+	for (row = 0; row < phys_lcd->lcm_num_rows;
+				row++, pm += phys_lcd->lcm_num_cols) {
+		phys_lcd->set_cursor_pos(phys_lcd, row, 0);
+		while (p < pm && *p)
+			phys_lcd->data_write(phys_lcd, *p++);
+		if (!*p)
+			break;
+	}
+}
+
+static inline void lcd_symbol_dump(unsigned long addr)
+{
+	if (phys_lcd)
+		__lcd_symbol_dump(addr);
+}
+
+static int lcd_panic_handler(struct notifier_block *this,
+			unsigned long event, void *data)
+{
+#if defined(CONFIG_ARM)
+	struct stackframe frame;
+	int urc;
+#elif defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	unsigned long raddrs[] = {
+		(unsigned long)__builtin_return_address(2),
+		(unsigned long)__builtin_return_address(3),
+		(unsigned long)__builtin_return_address(4),
+		(unsigned long)__builtin_return_address(5),
+		(unsigned long)__builtin_return_address(6),
+		(unsigned long)__builtin_return_address(7),
+		0UL
+	};
+	int i;
+#define ret_addr(x)	raddrs[(x)]
+#else
+#error "Unsupported architecture."
+#endif
+	unsigned long symbolsize, offset;
+	unsigned long p, p1 = (unsigned long)panic, p2 = 0;
+
+	if (test_taint(TAINT_DIE) || oops_in_progress > 1)
+		return NOTIFY_OK;
+
+	/*
+	 * Heuristically determine nesting level, i.e. depth from panic()
+	 * caller, to get the panic() caller's stack frame.
+	 */
+	/* First, obtain panic()'s text range. */
+	if (!kallsyms_lookup_size_offset(p1, &symbolsize, &offset) || offset)
+		return NOTIFY_OK;
+	for (p = p1 + 1; p < p1 + 10000; p++) {
+		if (!kallsyms_lookup_size_offset(p, &symbolsize, &offset))
+			return NOTIFY_OK;
+		/* Out of panic()'s text range (new symbol with zero offset)? */
+		if (!offset) {
+			p2 = p;
+			break;
+		}
+	}
+
+	if (!p2)
+		return NOTIFY_OK;
+	/* Next, look for level to panic(). */
+#if defined(CONFIG_ARM)
+	frame.fp = (unsigned long)__builtin_frame_address(0);
+	frame.sp = current_stack_pointer;
+	frame.lr = (unsigned long)__builtin_return_address(0);
+	frame.pc = (unsigned long)lcd_panic_handler;
+
+	while ((urc = unwind_frame(&frame)) >= 0 &&
+		(frame.pc < p1 || p2 <= frame.pc))
+			;
+
+	/* panic() caller is one level above. */
+	/* Adjust one insn size (4 bytes). */
+	if (urc >= 0 && unwind_frame(&frame) >= 0)
+		lcd_symbol_dump(frame.pc - 4);
+#elif defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	for (i = 0; ret_addr(i + 1); i++)
+		if (p1 <= ret_addr(i) && ret_addr(i) < p2)
+			break;
+
+	/* panic() caller is one level above. */
+	/* Adjust call/callq insn size (5 bytes). */
+	if (ret_addr(++i))
+		lcd_symbol_dump(ret_addr(i) - 5);
+#else
+#error "Unsupported architecture."
+#endif
+	return NOTIFY_OK;
+}
+
+static struct notifier_block lcd_panic_notifier = {
+	.notifier_call	= lcd_panic_handler,
+	.next		= NULL,
+	.priority	= 100,
+};
+
+#ifndef GET_IP
+#ifdef ARM_pc
+#define GET_IP(regs)	(regs)->ARM_pc
+#endif
+#endif
+
+static int lcd_die_handler(struct notifier_block *this,
+			unsigned long event, void *data)
+{
+	struct die_args *da	= data;
+
+#if defined(CONFIG_X86) || defined(CONFIG_X86_64)
+	if (event == DIE_INT3 || event == DIE_DEBUG)
+		return NOTIFY_DONE;
+#endif
+	lcd_symbol_dump(GET_IP(da->regs));
+	return NOTIFY_OK;
+}
+
+static struct notifier_block lcd_die_notifier = {
+	.notifier_call	= lcd_die_handler,
+	.next		= NULL,
+	.priority	= 100,
+};
+
+#ifndef CONFIG_OF
+static int lcd_dev_match(struct device *dev, void *data)
+{
+	struct hd44780_lcd *gl = dev_get_drvdata(dev);
+
+	return gl && !strncmp(gl->magic, (const char *)data, sizeof gl->magic);
+}
+#endif
+
+static int readynas_lcd_probe(struct platform_device *pdev)
+{
+	struct proc_dir_entry *parent = NULL;
+	int i;
+#ifdef CONFIG_OF
+	struct platform_device *lcd_pdev;
+	phandle phandle = 0;
+	struct device_node *np = pdev->dev.of_node, *np2;
+
+	if (!np || of_property_read_u32(np, "lcd-device", &phandle) ||
+		!(np2 = of_find_node_by_phandle(phandle)))
+		return -ENODEV;
+
+	lcd_pdev = of_find_device_by_node(np2);
+	if (IS_ERR(lcd_pdev))
+		return PTR_ERR(lcd_pdev);
+	else if (!lcd_pdev)
+		return -ENODEV;
+	phys_lcd = platform_get_drvdata(lcd_pdev);
+#else
+	struct device *phys_dev = bus_find_device(&platform_bus_type, NULL,
+					LCD_PLATFORM_MAGIC, lcd_dev_match);
+	if (!phys_dev) {
+		pr_debug("%s: platform device with \"%s\" magic not found.\n",
+			__func__, LCD_PLATFORM_MAGIC);
+		return -ENODEV;
+	}
+	phys_lcd = dev_get_drvdata(phys_dev);
+#endif
+	if (!phys_lcd)
+		return -ENODEV;
+
+	mutex_init(&phys_lcd->lcm_lock);
+
+#ifdef CONFG_READYNAS_LCD_PROC_INTERNAL
+	/* If procs internal is available, set LCD and LCDstatus under
+	 * /proc/readynas.
+	 */
+	{
+		mm_segment_t fs = get(fs);
+		struct file *f;
+
+		set_fs(get_ds());
+		f = filp_open((char __user *)"/proc/readynas", O_RDONLY, 0);
+		if (!IS_ERR(f)) {
+			parent = PDE(file_inode(f));
+			filp_close(f, NULL);
+		}
+		set_fs(fs);
+	}
+#endif
+
+	for (i = 0; lcd_procs[i].name; i++) {
+		umode_t mode = 0;
+
+		if (lcd_procs[i].fops.read)
+			mode |= 0444;
+		if (lcd_procs[i].fops.write)
+			mode |= 0200;
+		lcd_procs[i].proc =
+			proc_create(lcd_procs[i].name, mode, parent,
+					&lcd_procs[i].fops);
+		if (!lcd_procs[i].proc)
+			break;
+	}
+
+	if (lcd_procs[i].name) {
+		while (--i >= 0)
+			proc_remove(lcd_procs[i].proc);
+		return -EIO;
+	}
+
+	atomic_notifier_chain_register(&panic_notifier_list,
+					&lcd_panic_notifier);
+	register_die_notifier(&lcd_die_notifier);
+	return 0;
+}
+
+static int readynas_lcd_remove(struct platform_device *pdev)
+{
+	int i;
+
+	unregister_die_notifier(&lcd_die_notifier);
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					&lcd_panic_notifier);
+	for (i = 0; lcd_procs[i].name; i++)
+		proc_remove(lcd_procs[i].proc);
+	return 0;
+}
+
+static struct of_device_id readynas_lcd_dt_ids[] = {
+	{
+		.compatible = "readynas-lcd",
+	}, {},
+};
+
+static struct platform_driver readynas_lcd_driver = {
+	.probe	= readynas_lcd_probe,
+	.remove	= readynas_lcd_remove,
+	.driver = {
+		.name = "readynas-lcd",
+		.of_match_table = readynas_lcd_dt_ids,
+	},
+};
+
+#ifdef CONFIG_OF
+module_platform_driver(readynas_lcd_driver);
+#else
+static struct platform_device *readynas_lcd_pdev;
+
+static int __init readynas_lcd_init(void)
+{
+	int err;
+
+	pr_info("%s: installing ReadyNAS LCD driver.\n", __func__);
+	if ((err  = platform_driver_register(&readynas_lcd_driver)))
+		return err;
+
+	readynas_lcd_pdev =
+		platform_device_register_simple(readynas_lcd_driver.driver.name,
+						-1, NULL, 0);
+	if (IS_ERR(readynas_lcd_pdev))
+		err = PTR_ERR(readynas_lcd_pdev);
+	else if (!readynas_lcd_pdev)
+		err = -ENODEV;
+	if (err) {
+		platform_driver_unregister(&readynas_lcd_driver);
+		return err;
+	} else if (!phys_lcd) {
+		platform_device_unregister(readynas_lcd_pdev);
+		platform_driver_unregister(&readynas_lcd_driver);
+		return -ENODEV;
+	} else {
+		const char str[] = "Booting..";
+		phys_lcd->set_cursor_pos(phys_lcd, 0, 0);
+		for (err = 0; err < sizeof(str)-1; err++)
+			phys_lcd->data_write(phys_lcd, str[err]);
+	}
+	return 0;
+}
+
+static void __exit readynas_lcd_exit(void)
+{
+	platform_device_unregister(readynas_lcd_pdev);
+	platform_driver_unregister(&readynas_lcd_driver);
+}
+
+/* This module must be loaded after readynas-io. */
+device_initcall_sync(readynas_lcd_init);
+module_exit(readynas_lcd_exit);
+#endif
+
+MODULE_AUTHOR("hiro.sugawara@netgear.com");
+MODULE_DESCRIPTION("ReadyNAS LCD driver");
+MODULE_LICENSE("GPL");
-- 
1.9.1

