From 014ca7e4bbc9f493877ac0c59d10fe189d37a491 Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Wed, 24 Feb 2016 11:11:41 -0800
Subject: [PATCH 07/12] alpine: fix sata hotplug

From Slava @ Annapurna:

The failure occurs during hotplug (in my case I only see it if AHCI ports
IRQs have different affinity) because AHCI driver uses threaded IRQ which
consists of two parts: IRQ handler and thread handler. IRQ handler unmasks
the interrupt but the thread handler is not scheduled fast enough to handle
link status change interrupt (hotplug) from the port.

So, in case of hotplug, after  >100000 interrupts received by Linux without
being handled, Linux disables the interrupt internally and then all further
operations on this port are performed in polling mode. This is the reason
for the low HDD throughput.

The fix goes as follows: interrupt has to be unmasked in the thread
context, instead of IRQ handler - please find the patch attached. I run
some tests on Alpine DB platform - after applying this patch there are no
more unhandled interrupts, and there's no performance degrade after a
hotplug. Please let me know if this patch fixes the issue on RN214 as well.
---
 drivers/ata/libahci.c | 37 ++++++++++++-------------------------
 1 file changed, 12 insertions(+), 25 deletions(-)

diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c
index 3781f95..620540b 100644
--- a/drivers/ata/libahci.c
+++ b/drivers/ata/libahci.c
@@ -1785,6 +1785,9 @@ static irqreturn_t ahci_port_thread_fn(int irq, void *dev_instance)
 	struct ahci_port_priv *pp = ap->private_data;
 	void __iomem *port_mmio = ahci_port_base(ap);
 	u32 status;
+#ifdef CONFIG_AHCI_ALPINE
+	struct ata_host *host = ap->host;
+#endif
 
 	status = atomic_xchg(&pp->intr_status, 0);
 	if (!status)
@@ -1793,6 +1796,13 @@ static irqreturn_t ahci_port_thread_fn(int irq, void *dev_instance)
 	spin_lock_bh(ap->lock);
 	ahci_handle_port_interrupt(ap, port_mmio, status);
 	spin_unlock_bh(ap->lock);
+
+#ifdef CONFIG_AHCI_ALPINE
+	spin_lock(&host->lock);
+	alpine_clean_cause(ap);
+	spin_unlock(&host->lock);
+#endif
+
 	return IRQ_HANDLED;
 }
 
@@ -1923,29 +1933,6 @@ static irqreturn_t ahci_single_level_irq_intr(int irq, void *dev_instance)
 
 #ifdef CONFIG_AHCI_ALPINE
 
-irqreturn_t al_hw_port_interrupt_handler(int irq, void *dev_instance)
-{
-	struct ata_port *ap_this = dev_instance;
-	struct ata_host *host = ap_this->host;
-	void __iomem *port_mmio = ahci_port_base(ap_this);
-	struct ahci_port_priv *pp = ap_this->private_data;
-	u32 status;
-
-	VPRINTK("ENTER\n");
-
-	status = readl(port_mmio + PORT_IRQ_STAT);
-	writel(status, port_mmio + PORT_IRQ_STAT);
-	atomic_or(status, &pp->intr_status);
-
-	spin_lock(&host->lock);
-	alpine_clean_cause(ap_this);
-	spin_unlock(&host->lock);
-
-	VPRINTK("EXIT\n");
-
-	return IRQ_WAKE_THREAD;
-}
-
 /* 1 on not anapurna, 0 on success, <0 on error */
 static int al_ahci_request_irq(struct ata_host *host, int port)
 {
@@ -1963,8 +1950,8 @@ static int al_ahci_request_irq(struct ata_host *host, int port)
 		return port_irq;
 
 	return devm_request_threaded_irq(host->dev, port_irq,
-				al_hw_port_interrupt_handler,
-				ahci_port_thread_fn, IRQF_SHARED,
+				ahci_multi_irqs_intr,
+				ahci_port_thread_fn, 0,
 				pp->irq_desc, host->ports[port]);
 }
 
-- 
1.9.1

