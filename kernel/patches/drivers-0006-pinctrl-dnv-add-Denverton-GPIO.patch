From 740ae40627dfa2b085181b9bfa2152eaf276214a Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Wed, 30 Nov 2016 17:40:24 -0800
Subject: [PATCH 6/6] pinctrl: dnv: add Denverton GPIO

---
 drivers/pinctrl/intel/Kconfig       |   6 +
 drivers/pinctrl/intel/Makefile      |   1 +
 drivers/pinctrl/intel/pinctrl-dnv.c | 870 ++++++++++++++++++++++++++++++++++++
 3 files changed, 877 insertions(+)
 create mode 100644 drivers/pinctrl/intel/pinctrl-dnv.c

diff --git a/drivers/pinctrl/intel/Kconfig b/drivers/pinctrl/intel/Kconfig
index 4d2efad..919ce49 100644
--- a/drivers/pinctrl/intel/Kconfig
+++ b/drivers/pinctrl/intel/Kconfig
@@ -50,3 +50,9 @@ config PINCTRL_SUNRISEPOINT
 	  Sunrisepoint is the PCH of Intel Skylake. This pinctrl driver
 	  provides an interface that allows configuring of PCH pins and
 	  using them as GPIOs.
+
+config PINCTRL_DNV
+	tristate "Intel Denverton pinctrl and GPIO driver"
+	select PINCTRL_INTEL
+	help
+	  Enables ATOM Deverton's pinctrl/GPIO druver.
diff --git a/drivers/pinctrl/intel/Makefile b/drivers/pinctrl/intel/Makefile
index 03bc68e..56be5f4 100644
--- a/drivers/pinctrl/intel/Makefile
+++ b/drivers/pinctrl/intel/Makefile
@@ -5,3 +5,4 @@ obj-$(CONFIG_PINCTRL_CHERRYVIEW)	+= pinctrl-cherryview.o
 obj-$(CONFIG_PINCTRL_INTEL)		+= pinctrl-intel.o
 obj-$(CONFIG_PINCTRL_BROXTON)		+= pinctrl-broxton.o
 obj-$(CONFIG_PINCTRL_SUNRISEPOINT)	+= pinctrl-sunrisepoint.o
+obj-$(CONFIG_PINCTRL_DNV)		+= pinctrl-dnv.o
diff --git a/drivers/pinctrl/intel/pinctrl-dnv.c b/drivers/pinctrl/intel/pinctrl-dnv.c
new file mode 100644
index 0000000..b0da679
--- /dev/null
+++ b/drivers/pinctrl/intel/pinctrl-dnv.c
@@ -0,0 +1,870 @@
+/*
+ * Pinctrl GPIO driver for Intel Denverton
+ * Copyright (c) 2012-2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+//#include <linux/acpi.h>
+#include <linux/platform_device.h>
+#include <linux/seq_file.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/pinctrl/pinctrl.h>
+#include <linux/sizes.h>
+
+/* memory mapped register offsets */
+#define DNV_PAD_CONF0_REG	0x0
+#define DNV_PAD_CONF1_REG       0x4
+
+#define DNV_PADBAR		0xc
+#define DNV_GPI_GPE_EN		0x160
+#define DNV_GPI_GPE_STS		0x140
+#define DNV_HOSTSW_OWN		0xC0
+#define DNV_PADCFGLOCK		0x90
+
+/* DNV_PAD_CONF0_REG register bits */
+#define DNV_RXEVCFG_26		BIT(26)
+#define DNV_RXEVCFG_25		BIT(25)
+#define DNV_RXINV		BIT(23)
+#define DNV_GPIROUTSCI		BIT(19)
+#define DNV_PMODE1		BIT(11)
+#define DNV_PMODE0		BIT(10)
+#define DNV_INPUT_DIS		BIT(9)  /* 0: input enabled (active low)*/
+#define DNV_OUTPUT_DIS		BIT(8)  /* 0: output enabled (active low)*/
+#define DNV_RXSTATE		BIT(1)
+#define DNV_LEVEL		BIT(0)
+
+#define DNV_TRIG_LVL		~(DNV_RXEVCFG_25 | DNV_RXEVCFG_26)
+#define DNV_TRIG_EDGE		DNV_RXEVCFG_25
+
+/* Restore */
+#define DNV_DIR_MASK		(BIT(8) | BIT(9))
+#define DNV_CONF0_RESTORE_MASK	(DNV_LEVEL | DNV_DIR_MASK | DNV_PMODE0 | DNV_PMODE1	\
+				 | DNV_GPIROUTSCI | DNV_RXINV | DNV_RXEVCFG_25		\
+				 | DNV_RXEVCFG_26 | BIT(28) | BIT(29) | BIT(30)		\
+				 | BIT(31))
+#define DNV_CONF1_RESTORE_MASK	(BIT(10) | BIT(11) | BIT(12) | BIT(13))
+
+#define DNV_NGPIO		153
+#define DNV_GPIO_NUM_HOLE	0xFFFF
+
+static const int gpio_base = -1;
+//module_param(gpio_base, int, 0);
+
+/*
+ * Denverton gpio controller consist of two separate Sideband.
+ *
+ * GPIO numbering is _not_ ordered meaning that gpio # 0 in ACPI namespace does
+ * _not_ correspond to the first gpio register at controller's gpio base.
+ * There is no logic or pattern in mapping gpio numbers to registers (pads) so
+ * each sub-controller needs to have its own mapping table
+ */
+
+/* DNV_pins[gpio_nr] = pad_nr */
+
+static unsigned const DNV_pins[DNV_NGPIO] = {
+	27, 33, 34, 612, 545, 546, 547, 548, 557, 558,
+	598, 599, 518, 519, 0, 1, 2, 3, 4, 5,
+	6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
+	16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
+	26, 28, 29, 30, 31, 32, DNV_GPIO_NUM_HOLE, 35, 36, 37,
+	38, 39, 40, 500, 501, 502, 503, 504, 505, 506,
+	507, 508, 509, 510, 590, 591, 592, 593, 594, 595,
+	596, 597, 582, 583, 584, 585, 586, 587, 588, 571,
+	572, 573, 574, 575, 576, 577, 578, 579, 580, 581,
+	549, 550, 551, 552, 553, 554, 555, 556, 520, 521,
+	522, 523, 524, 525, 526, 527, 528, 529, 530, 531,
+	532, 533, 534, 535, 536, 537, 538, 539, 540, 541,
+	542, 543, 544, 601, 602, 603, 604, 605, 606, 607,
+	608, 609, 610, 611, 511, 512, 513, 514, 515, 516,
+	517, DNV_GPIO_NUM_HOLE, DNV_GPIO_NUM_HOLE, DNV_GPIO_NUM_HOLE, DNV_GPIO_NUM_HOLE, DNV_GPIO_NUM_HOLE, 564, 565, 566, 567,
+	568, 560, 570,
+};
+
+static u32 pin_to_offset(u32 pin)
+{
+	if (pin < 500)
+		return pin % 32;
+	else if (500 <= pin && pin < 518)
+		return (pin - 500) % 32;
+	else if (518 <= pin && pin < 571)
+		return (pin - 518) % 32;
+	else if (571 <= pin && pin < 613)
+		return (pin - 571) % 32;
+	return 0;
+}
+
+static struct pinctrl_gpio_range dnv_ranges[] = {
+	{
+		.name = "0",
+		.npins = DNV_NGPIO,
+		.pins = DNV_pins,
+	}, { },
+};
+
+struct dnv_gpio_pin_context {
+	u32 conf0;
+	u32 conf1;
+};
+
+struct dnv_gpio {
+	struct gpio_chip		chip;
+	struct platform_device		*pdev;
+	raw_spinlock_t			lock;
+	void __iomem			*reg_base;
+	struct pinctrl_gpio_range	*range;
+	struct dnv_gpio_pin_context	*saved_context;
+};
+
+#define to_dnv_gpio(c)	container_of(c, struct dnv_gpio, chip)
+
+static void __iomem *dnv_gpio_reg(struct gpio_chip *chip, unsigned offset,
+		int reg)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	u32 reg_offset = vg->range->pins[offset];
+
+	switch (reg) {
+	case DNV_GPI_GPE_EN:
+	case DNV_GPI_GPE_STS:
+	case DNV_HOSTSW_OWN:
+		if (reg_offset < 500)
+			return vg->reg_base + reg + (reg_offset / 32) * 4;
+		/* C5 */
+		else if (500 <= reg_offset && reg_offset < 518)
+			return vg->reg_base + 0x30000 + reg + 0x0 +
+				((reg_offset - 500) / 32) * 4;
+		else if (518 <= reg_offset && reg_offset < 571)
+			return vg->reg_base + 0x30000 + reg + 0x4 +
+				((reg_offset - 518) / 32) * 4;
+		else if (571 <= reg_offset && reg_offset < 613)
+			return vg->reg_base + 0x30000 + reg + 0xc +
+				((reg_offset - 571) / 32) * 4;
+		break;
+	case DNV_PADCFGLOCK:
+		if (reg_offset < 500)
+			return vg->reg_base + reg + (reg_offset / 32) * 8;
+		/* C5 */
+		else if (500 <= reg_offset && reg_offset < 518)
+			return vg->reg_base + 0x30000 + reg + 0x0 +
+				((reg_offset - 500) / 32) * 8;
+		else if (518 <= reg_offset && reg_offset < 571)
+			return vg->reg_base + 0x30000 + reg + 0x8 +
+				((reg_offset - 518) / 32) * 8;
+		else if (571 <= reg_offset && reg_offset < 613)
+			return vg->reg_base + 0x30000 + reg + 0x18 +
+				((reg_offset - 571) / 32) * 8;
+		break;
+	case DNV_PAD_CONF0_REG:
+	case DNV_PAD_CONF1_REG:
+		if (reg_offset < 500)
+			return vg->reg_base + 0x400 + (reg_offset << 3) + reg;
+		/* C5 */
+		else if (500 <= reg_offset && reg_offset < 613)
+			return vg->reg_base + 0x30400 +
+					((reg_offset - 500) << 3) + reg;
+	default:
+		break;
+	}
+
+	return NULL;/* Error!!! */
+}
+
+static void dnv_gpio_clear_triggering(struct dnv_gpio *vg, unsigned offset)
+{
+	void __iomem *reg = dnv_gpio_reg(&vg->chip, offset, DNV_PAD_CONF0_REG);
+	unsigned long flags;
+	u32 value, bit_offset = 0;
+
+	if (!reg)
+		return;
+	raw_spin_lock_irqsave(&vg->lock, flags);
+	value = readl(reg);
+	value &= ~(DNV_GPIROUTSCI);
+	writel(value, reg);
+
+	/* EN */
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_GPI_GPE_EN);
+	value = readl(reg);
+
+	bit_offset = pin_to_offset(vg->range->pins[offset]);
+	value &= ~(1 << bit_offset);
+	writel(value, reg);
+
+	/* STS */
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_GPI_GPE_STS);
+	value = readl(reg);
+	value |= (1 << bit_offset);
+	writel(value, reg);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+}
+
+static int dnv_gpio_request(struct gpio_chip *chip, unsigned offset)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	void __iomem *reg = dnv_gpio_reg(chip, offset, DNV_PAD_CONF0_REG);
+	u32 value;
+	unsigned long flags;
+
+	if (!reg)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+
+	/*
+	 * In most cases, func pin mux 000 means GPIO function.
+	 * But, some pins may have func pin mux 001 represents
+	 * GPIO function.
+	 *
+	 * Because there are devices out there where some pins were not
+	 * configured correctly we allow changing the mux value from
+	 * request (but print out warning about that).
+	 */
+	value = readl(reg) & DNV_PMODE0;
+	if (WARN_ON(0 != value)) {
+		value = readl(reg) & ~DNV_PMODE0;
+		writel(value, reg);
+
+		dev_warn(&vg->pdev->dev,
+				"pin %u forcibly re-configured as GPIO\n", offset);
+	}
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+
+	pm_runtime_get(&vg->pdev->dev);
+
+	return 0;
+}
+
+static void dnv_gpio_free(struct gpio_chip *chip, unsigned offset)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+
+	dnv_gpio_clear_triggering(vg, offset);
+	pm_runtime_put(&vg->pdev->dev);
+}
+
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 2, 0)
+static inline struct irq_desc *irq_data_to_desc(struct irq_data *data)
+{
+	return container_of(data, struct irq_desc, irq_data);
+}
+/**
+ * irq_set_handler_locked - Set irq handler from a locked region
+ * @data:       Pointer to the irq_data structure which identifies the irq
+ * @handler:    Flow control handler function for this interrupt
+ *
+ * Sets the handler in the irq descriptor associated to @data.
+ *
+ * Must be called with irq_desc locked and valid parameters. Typical
+ * call site is the irq_set_type() callback.
+ */
+static inline void irq_set_handler_locked(struct irq_data *data,
+                                          irq_flow_handler_t handler)
+{
+	struct irq_desc *desc = irq_data_to_desc(data);
+
+	desc->handle_irq = handler;
+}
+#endif
+
+static int dnv_irq_type(struct irq_data *d, unsigned type)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(irq_data_get_irq_chip_data(d));
+	u32 offset = irqd_to_hwirq(d);
+	u32 value;
+	unsigned long flags;
+	void __iomem *reg = dnv_gpio_reg(&vg->chip, offset, DNV_PAD_CONF0_REG);
+
+	if (offset >= vg->chip.ngpio || !reg)
+		return -EINVAL;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+	value = readl(reg);
+
+	/* For level trigges the DNV_TRIG_EDGE and DNV_TRIG_NEG bits
+	 * are used to indicate high and low level triggering
+	 */
+	value &= ~(DNV_RXEVCFG_25 | DNV_RXEVCFG_26);
+	value |= DNV_RXEVCFG_26;/* 2h = Drive '0' */
+	writel(value, reg);
+
+	if (type & IRQ_TYPE_EDGE_BOTH)
+		irq_set_handler_locked(d, handle_edge_irq);
+	else if (type & IRQ_TYPE_LEVEL_MASK)
+		irq_set_handler_locked(d, handle_level_irq);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+
+	return 0;
+}
+
+static int dnv_gpio_get(struct gpio_chip *chip, unsigned offset)
+{
+	void __iomem *reg = dnv_gpio_reg(chip, offset, DNV_PAD_CONF0_REG);
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	unsigned long flags;
+	u32 val;
+
+        if (!reg)
+                return -EINVAL;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+	val = readl(reg);
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+	if (DNV_INPUT_DIS & val)
+		return val & DNV_LEVEL;
+
+	return val & DNV_RXSTATE;
+}
+
+static void dnv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	void __iomem *reg = dnv_gpio_reg(chip, offset, DNV_PAD_CONF0_REG);
+	unsigned long flags;
+	u32 old_val;
+
+        if (!reg)
+                return;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+
+	old_val = readl(reg);
+
+	if (value)
+		writel(old_val | DNV_LEVEL, reg);
+	else
+		writel(old_val & ~DNV_LEVEL, reg);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+}
+
+static int dnv_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	void __iomem *reg = dnv_gpio_reg(chip, offset, DNV_PAD_CONF0_REG);
+	unsigned long flags;
+	u32 value;
+
+        if (!reg)
+                return -EINVAL;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+
+	value = readl(reg) | DNV_DIR_MASK;
+	value &= ~DNV_INPUT_DIS;	/* active low */
+	writel(value, reg);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+
+	return 0;
+}
+
+static int dnv_gpio_direction_output(struct gpio_chip *chip,
+				     unsigned gpio, int value)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	void __iomem *reg = dnv_gpio_reg(chip, gpio, DNV_PAD_CONF0_REG);
+	unsigned long flags;
+	u32 reg_val;
+
+        if (!reg)
+                return -EINVAL;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+
+	reg_val = readl(reg) | DNV_DIR_MASK;
+	reg_val &= ~DNV_OUTPUT_DIS;
+
+	if (value)
+		writel(reg_val | DNV_LEVEL, reg);
+	else
+		writel(reg_val & ~DNV_LEVEL, reg);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+
+	return 0;
+}
+
+static void dnv_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)
+{
+	struct dnv_gpio *vg = to_dnv_gpio(chip);
+	int i;
+	u32 conf0, conf1;
+
+	for (i = 0; i < vg->chip.ngpio; i++) {
+		unsigned long flags;
+		const char *label;
+		if(vg->range->pins[i] == DNV_GPIO_NUM_HOLE)
+			continue;
+		raw_spin_lock_irqsave(&vg->lock, flags);
+		conf0 = readl(dnv_gpio_reg(chip, i, DNV_PAD_CONF0_REG));
+		conf1 = readl(dnv_gpio_reg(chip, i, DNV_PAD_CONF1_REG));
+		raw_spin_unlock_irqrestore(&vg->lock, flags);
+
+		label = gpiochip_is_requested(chip, i);
+		if (!label)
+			label = "Unrequested";
+
+
+		seq_printf(s,
+			   " gpio-%-3d (%-20.20s) pad-%-3d conf0:0x%08x conf1:0x%08x ",
+			   i, label, vg->range->pins[i], conf0, conf1
+			   );
+
+		seq_puts(s, "\n");
+	}
+}
+#if 0
+static void dnv_gpio_irq_handler(struct irq_desc *desc)
+{
+	struct irq_data *data = irq_desc_get_irq_data(desc);
+	struct dnv_gpio *vg = to_dnv_gpio(irq_desc_get_handler_data(desc));
+	struct irq_chip *chip = irq_data_get_irq_chip(data);
+#else
+static irqreturn_t dnv_gpio_irq_handler(int irq, void *dev_id)
+{
+	struct dnv_gpio *vg = (struct dnv_gpio *)dev_id;
+#endif
+	int ret = 0, pin;
+
+	/* check from GPIO controller which pin triggered the interrupt */
+	for (pin = 0; pin < vg->chip.ngpio; pin++) {
+		void __iomem *reg, *reg_conf0;
+		unsigned virq;
+		u32 value, bit_offset, conf0 = 0;
+		u32 tmp = vg->range->pins[pin];
+
+		if (tmp == DNV_GPIO_NUM_HOLE)
+			continue;
+
+		bit_offset = pin_to_offset(tmp);
+
+		/* STS */
+		reg = dnv_gpio_reg(&vg->chip, pin, DNV_GPI_GPE_STS);
+		value = readl(reg);
+		value &= (1 << bit_offset);
+		if (value) {
+			reg_conf0 = dnv_gpio_reg(&vg->chip, pin, DNV_PAD_CONF0_REG);
+			conf0 = readl(reg_conf0);
+			writel((DNV_RXINV & conf0)?(conf0 & ~DNV_RXINV):(conf0 | DNV_RXINV), reg_conf0);
+			ret = 1;
+			writel(value, reg);//libolibo write to clear
+			virq = irq_find_mapping(vg->chip.irqdomain, pin);
+			generic_handle_irq(virq);
+		}
+	}
+#if 0
+	chip->irq_eoi(data);
+#else
+	if (ret)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+#endif
+}
+
+static void dnv_irq_ack(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct dnv_gpio *vg = to_dnv_gpio(gc);
+	unsigned offset = irqd_to_hwirq(d);
+	void __iomem *reg;
+	u32 value, bit_offset = 0;
+
+	u32 tmp = vg->range->pins[offset];
+
+	if (tmp == DNV_GPIO_NUM_HOLE)
+		return;
+	bit_offset = pin_to_offset(tmp);
+
+	raw_spin_lock(&vg->lock);
+
+	/* STS */
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_GPI_GPE_STS);
+	value = readl(reg);
+	value |= (1 << bit_offset);
+	writel(value, reg);
+
+	raw_spin_unlock(&vg->lock);
+}
+
+static void dnv_irq_unmask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct dnv_gpio *vg = to_dnv_gpio(gc);
+	unsigned offset = irqd_to_hwirq(d);
+	unsigned long flags;
+	void __iomem *reg;
+	u32 value, bit_offset = 0;
+
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_PAD_CONF0_REG);
+        if(reg == 0)
+                return;
+
+	raw_spin_lock_irqsave(&vg->lock, flags);
+	value = readl(reg);
+
+	/* Clean Level/Edge configuration bits */
+	value &= ~(DNV_RXEVCFG_25 | DNV_RXEVCFG_26);
+	switch (irqd_get_trigger_type(d)) {
+	//case IRQ_TYPE_LEVEL_HIGH:
+	//	value |= DNV_TRIG_LVL;
+	//case IRQ_TYPE_EDGE_RISING:
+	//	value |= DNV_TRIG_EDGE;
+	//	break;
+	//case IRQ_TYPE_LEVEL_LOW:
+	//	value |= DNV_TRIG_LVL;
+	//case IRQ_TYPE_EDGE_FALLING:
+	//	value |= DNV_TRIG_NEG;
+	//	break;
+	case IRQ_TYPE_LEVEL_MASK:
+		value |= (DNV_TRIG_LVL);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		value |= (DNV_TRIG_EDGE);
+		break;
+	}
+
+	value |= DNV_GPIROUTSCI;
+	writel(value, reg);
+
+	bit_offset = pin_to_offset(vg->range->pins[offset]);
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_GPI_GPE_EN);
+	value = readl(reg);
+	value |= (1 << bit_offset);
+	writel(value, reg);
+
+	reg = dnv_gpio_reg(&vg->chip, offset, DNV_HOSTSW_OWN);
+	value = readl(reg);
+	value &= ~(1 << bit_offset);
+	writel(value, reg);
+
+	raw_spin_unlock_irqrestore(&vg->lock, flags);
+}
+
+static void dnv_irq_mask(struct irq_data *d)
+{
+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
+	struct dnv_gpio *vg = to_dnv_gpio(gc);
+
+	dnv_gpio_clear_triggering(vg, irqd_to_hwirq(d));
+}
+
+static struct irq_chip dnv_irqchip = {
+	.name = "DNV-GPIO",
+	.irq_ack = dnv_irq_ack,
+	.irq_mask = dnv_irq_mask,
+	.irq_unmask = dnv_irq_unmask,
+	.irq_set_type = dnv_irq_type,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static void dnv_gpio_irq_init_hw(struct dnv_gpio *vg)
+{
+	int i;
+
+	/*
+	 * Clear interrupt triggers for all pins that are GPIOs and
+	 * do not use direct IRQ mode. This will prevent spurious
+	 * interrupts from misconfigured pins.
+	 */
+	for (i = 0; i < vg->chip.ngpio; i++) {
+		if (vg->range->pins[i] == DNV_GPIO_NUM_HOLE)
+			continue;
+		dnv_gpio_clear_triggering(vg, i);
+		dev_dbg(&vg->pdev->dev, "disabling GPIO %d\n", i);
+	}
+
+}
+
+static int dnv_gpio_probe(struct platform_device *pdev)
+{
+	struct dnv_gpio *vg;
+	struct gpio_chip *gc;
+	struct resource *mem_rc, *irq_rc;
+	struct device *dev = &pdev->dev;
+	//struct acpi_device *acpi_dev;
+	struct pinctrl_gpio_range *range;
+	//acpi_handle handle = ACPI_HANDLE(dev);
+	void __iomem	*reg_base;
+	int ret;
+
+	//if (acpi_bus_get_device(handle, &acpi_dev))
+		//return -ENODEV;
+
+	mem_rc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	reg_base = devm_ioremap_resource(dev, mem_rc);
+	if (IS_ERR(reg_base))
+		return PTR_ERR(reg_base);
+	if (readl(reg_base + DNV_PADBAR) != 0x400)
+		return -ENODEV;
+
+	vg = devm_kzalloc(dev, sizeof(struct dnv_gpio), GFP_KERNEL);
+	if (!vg) {
+		dev_err(&pdev->dev, "can't allocate dnv_gpio chip data\n");
+		return -ENOMEM;
+	}
+
+	for (range = dnv_ranges; range->name; range++) {
+		vg->chip.ngpio = range->npins;
+		vg->range = range;
+	}
+
+	if (!vg->chip.ngpio || !vg->range)
+		return -ENODEV;
+
+	vg->pdev = pdev;
+	platform_set_drvdata(pdev, vg);
+
+	vg->reg_base = reg_base;
+	raw_spin_lock_init(&vg->lock);
+
+	gc = &vg->chip;
+	gc->label = dev_name(&pdev->dev);
+	gc->owner = THIS_MODULE;
+	gc->request = dnv_gpio_request;
+	gc->free = dnv_gpio_free;
+	gc->direction_input = dnv_gpio_direction_input;
+	gc->direction_output = dnv_gpio_direction_output;
+	gc->get = dnv_gpio_get;
+	gc->set = dnv_gpio_set;
+	gc->dbg_show = dnv_gpio_dbg_show;
+	gc->base = gpio_base;
+	gc->can_sleep = false;
+	gc->dev = dev;
+
+#ifdef CONFIG_PM_SLEEP
+	vg->saved_context = devm_kcalloc(&pdev->dev, gc->ngpio,
+				       sizeof(*vg->saved_context), GFP_KERNEL);
+#endif
+
+	ret = gpiochip_add(gc);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add dnv-gpio chip\n");
+		goto err;
+	}
+
+	/* set up interrupts  */
+	irq_rc = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (irq_rc && irq_rc->start) {
+		dnv_gpio_irq_init_hw(vg);
+		ret = gpiochip_irqchip_add(gc, &dnv_irqchip, 0,
+					   handle_simple_irq, IRQ_TYPE_NONE);
+		if (ret) {
+			dev_err(dev, "failed to add irqchip\n");
+			gpiochip_remove(gc);
+			goto err;
+		}
+#if 0
+		gpiochip_set_chained_irqchip(gc, &dnv_irqchip,
+				(unsigned)irq_rc->start,
+				dnv_gpio_irq_handler);
+#else
+		ret = request_irq((unsigned)irq_rc->start, dnv_gpio_irq_handler,
+					IRQF_SHARED, "gpio-dnv", gc);
+		if (ret) {
+			dev_err(dev, "failed to request parent irq\n");
+			gpiochip_remove(gc);
+			goto err;
+		}
+#endif
+	}
+
+	pm_runtime_enable(dev);
+
+	return 0;
+err:
+	if (vg->saved_context)
+		devm_kfree(dev, vg->saved_context);
+	devm_kfree(dev, vg);
+	return ret;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int dnv_gpio_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dnv_gpio *vg = platform_get_drvdata(pdev);
+	int pin;
+
+        for (pin = 0; pin < vg->chip.ngpio; pin++) {
+		void __iomem *reg;
+                u32 bit_offset, value, tmp = vg->range->pins[pin];
+
+                if (tmp == DNV_GPIO_NUM_HOLE)
+                        continue;
+		bit_offset = pin_to_offset(tmp);
+
+                /* LOCK */
+                reg = dnv_gpio_reg(&vg->chip, pin, DNV_PADCFGLOCK);
+                value = readl(reg);
+                value &= (1 << bit_offset);
+                if (value)	/* Locked */
+			continue;
+
+		reg = dnv_gpio_reg(&vg->chip, pin, DNV_PAD_CONF0_REG);
+		value = readl(reg) & DNV_CONF0_RESTORE_MASK;
+		vg->saved_context[pin].conf0 = value;
+
+		reg = dnv_gpio_reg(&vg->chip, pin, DNV_PAD_CONF1_REG);
+		value = readl(reg) & DNV_CONF1_RESTORE_MASK;
+		vg->saved_context[pin].conf1 = value;
+        }
+
+	return 0;
+}
+
+static int dnv_gpio_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct dnv_gpio *vg = platform_get_drvdata(pdev);
+	int pin;
+
+        for (pin = 0; pin < vg->chip.ngpio; pin++) {
+		void __iomem *reg;
+                u32 bit_offset, value, tmp = vg->range->pins[pin];
+
+                if (tmp == DNV_GPIO_NUM_HOLE)
+                        continue;
+		bit_offset = pin_to_offset(tmp);
+
+                /* LOCK */
+                reg = dnv_gpio_reg(&vg->chip, pin, DNV_PADCFGLOCK);
+                value = readl(reg);
+                value &= (1 << bit_offset);
+                if (value)	/* Locked */
+			continue;
+
+		reg = dnv_gpio_reg(&vg->chip, pin, DNV_PAD_CONF0_REG);
+		value = readl(reg);
+		if ((value & DNV_CONF0_RESTORE_MASK) !=
+		     vg->saved_context[pin].conf0) {
+			value &= ~DNV_CONF0_RESTORE_MASK;
+			value |= vg->saved_context[pin].conf0;
+			writel(value, reg);
+			dev_info(dev, "restored pin %d conf0 %#08x", pin, value);
+		}
+		reg = dnv_gpio_reg(&vg->chip, pin, DNV_PAD_CONF1_REG);
+		value = readl(reg);
+		if ((value & DNV_CONF1_RESTORE_MASK) !=
+		     vg->saved_context[pin].conf1) {
+			value &= ~DNV_CONF1_RESTORE_MASK;
+			value |= vg->saved_context[pin].conf1;
+			writel(value, reg);
+			dev_info(dev, "restored pin %d conf1 %#08x", pin, value);
+		}
+        }
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_PM
+static int dnv_gpio_runtime_suspend(struct device *dev)
+{
+	return 0;
+}
+
+static int dnv_gpio_runtime_resume(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+static const struct dev_pm_ops dnv_gpio_pm_ops = {
+	SET_LATE_SYSTEM_SLEEP_PM_OPS(dnv_gpio_suspend, dnv_gpio_resume)
+	SET_RUNTIME_PM_OPS(dnv_gpio_runtime_suspend, dnv_gpio_runtime_resume,
+			   NULL)
+};
+#if 0
+static const struct acpi_device_id dnv_gpio_acpi_match[] = {
+	{ "INT33B2", 0 },
+	{ "INT33FC", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(acpi, dnv_gpio_acpi_match);
+#endif
+static int dnv_gpio_remove(struct platform_device *pdev)
+{
+	struct dnv_gpio *vg = platform_get_drvdata(pdev);
+
+	pm_runtime_disable(&pdev->dev);
+	gpiochip_remove(&vg->chip);
+
+	return 0;
+}
+
+static struct platform_driver dnv_gpio_driver = {
+	.probe          = dnv_gpio_probe,
+	.remove         = dnv_gpio_remove,
+	.driver         = {
+		.name   = "gpio_dnv",
+		.pm	= &dnv_gpio_pm_ops,
+		.owner	= THIS_MODULE,
+		//.acpi_match_table = ACPI_PTR(dnv_gpio_acpi_match),
+	},
+};
+
+static struct resource dnv_gpio_resources[] = {
+	{
+		.name   = "gpio_dnv",
+		.start  = 0xfdc20000,
+		.end    = 0xfdc20000 + SZ_256K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	{
+		.name   = "gpio_dnv_int",
+		//.start  = 9,
+		.start  = 30,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static const struct platform_device_info pi __initconst = {
+        .name           = "gpio_dnv",
+        .id             = 0,
+        .res            = dnv_gpio_resources,
+        .num_res        = ARRAY_SIZE(dnv_gpio_resources),
+};
+
+struct platform_device *pdev;
+static int __init dnv_gpio_init(void)
+{
+
+        pdev = platform_device_register_full(&pi);
+        if (IS_ERR(pdev)) {
+                return PTR_ERR(pdev);
+        }
+
+	return platform_driver_register(&dnv_gpio_driver);
+}
+subsys_initcall(dnv_gpio_init);
+
+static void __exit dnv_gpio_exit(void)
+{
+	platform_device_unregister(pdev);
+	platform_driver_unregister(&dnv_gpio_driver);
+}
+module_exit(dnv_gpio_exit);
+
+MODULE_AUTHOR("LiBo <bo_li@usish.com>");
+MODULE_DESCRIPTION("Intel Denverton pinctrl/GPIO core driver");
+MODULE_LICENSE("GPL v2");
-- 
1.9.1

