diff -urp proftpd-1.3.4a-/contrib/mod_dynmasq.c proftpd-1.3.4a/contrib/mod_dynmasq.c
--- proftpd-1.3.4a-/contrib/mod_dynmasq.c	2012-04-17 15:07:04.255899278 -0700
+++ proftpd-1.3.4a/contrib/mod_dynmasq.c	2012-04-17 14:39:21.634596897 -0700
@@ -33,6 +33,7 @@
 #if 1 //JM: Set the initial timer to 15 seconds, and stay that way we get our first successful lookup.
 #include <netinet/in.h>
 #include <arpa/nameser.h>
+#include <arpa/inet.h>
 #include <resolv.h>
 #define INITIAL_TIMER 15
 #endif
@@ -58,8 +59,13 @@ static pool *dynmasq_act_pool = NULL;
 static ctrls_acttab_t dynmasq_acttab[];
 #endif /* PR_USE_CTRLS */
 
+static int dynmasq_refresh_cb(CALLBACK_FRAME);
 static void dynmasq_refresh(void) {
   server_rec *s;
+  struct addrinfo hints, *result = NULL;
+  struct sockaddr_in *ipv4;
+  static char buf[INET_ADDRSTRLEN];
+  int ret;
 
   /* Clear the netaddr cache.  Sadly, this is required in order for any
    * updates to be discovered this way.
@@ -76,6 +82,28 @@ static void dynmasq_refresh(void) {
       FALSE);
 
     if (c) {
+      memset(&hints, 0, sizeof(struct addrinfo));
+      hints.ai_family = AF_INET;
+      ret = getaddrinfo((const char *) c->argv[1], NULL, &hints, &result);
+      if (ret) {
+        pr_log_pri(PR_LOG_NOTICE, MOD_DYNMASQ_VERSION
+          ": unable to resolve '%s', keeping previous address: %s",
+          (const char *) c->argv[1], gai_strerror(ret));
+        return;
+      }
+      if (!result) {
+        pr_log_pri(PR_LOG_NOTICE, MOD_DYNMASQ_VERSION
+          ": unable to resolve '%s', keeping previous address",
+          (const char *) c->argv[1]);
+        return;
+      }
+      ipv4 = (struct sockaddr_in *) result->ai_addr;
+      if (!inet_ntop(AF_INET, &ipv4->sin_addr, buf, sizeof(buf)) ||
+          !strcmp(pr_netaddr_get_ipstr(c->argv[0]), inet_ntop(AF_INET, &ipv4->sin_addr, buf, sizeof(buf))))
+      {
+        goto unchanged;
+      }
+
       pr_netaddr_t *na = pr_netaddr_get_addr(s->pool, c->argv[1], NULL);
 
       if (na) {
@@ -103,6 +131,7 @@ static void dynmasq_refresh(void) {
           dynmasq_timer_id = pr_timer_add(dynmasq_timer_interval, -1,
             &dynmasq_module, dynmasq_refresh_cb, "dynmasq address refresh");
         } else {
+unchanged:
           pr_log_debug(DEBUG2, MOD_DYNMASQ_VERSION
             ": MasqueradeAddress '%s' has not changed addresses",
             (const char *) c->argv[1]);
@@ -113,6 +142,7 @@ static void dynmasq_refresh(void) {
           ": unable to resolve '%s', keeping previous address",
           (const char *) c->argv[1]);
       }
+      freeaddrinfo(result);
     }
   }
 
