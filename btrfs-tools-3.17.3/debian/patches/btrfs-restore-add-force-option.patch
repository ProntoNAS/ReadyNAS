diff --git a/cmds-restore.c b/../cmds-restore.c
index 2e41921..f03bd90 100644
--- a/cmds-restore.c
+++ b/cmds-restore.c
@@ -54,6 +54,7 @@ static int ignore_errors = 0;
 static int overwrite = 0;
 static int get_xattrs = 0;
 static int dry_run = 0;
+static int force = 0;
 
 #define LZO_LEN 4
 #define PAGE_CACHE_SIZE 4096
@@ -546,7 +547,7 @@ static int copy_file(struct btrfs_root *root, int fd, struct btrfs_key *key,
 	int ret;
 	int extent_type;
 	int compression;
-	int loops = 0;
+	int loops = force ? -1 : 0;
 	u64 found_size = 0;
 
 	path = btrfs_alloc_path();
@@ -1124,6 +1125,7 @@ const char * const cmd_restore_usage[] = {
 	"-d              find dir",
 	"-l              list tree roots",
 	"-D|--dry-run    dry run (only list files that would be recovered)",
+	"-F              force (do not prompt on large files looping frequently)",
 	"--path-regex <regex>",
 	"                restore only filenames matching regex,",
 	"                you have to use following syntax (possibly quoted):",
@@ -1151,7 +1153,7 @@ int cmd_restore(int argc, char **argv)
 	regex_t match_reg, *mreg = NULL;
 	char reg_err[256];
 
-	while ((opt = getopt_long(argc, argv, "sxviot:u:df:r:lDc", long_options,
+	while ((opt = getopt_long(argc, argv, "sxviot:u:df:r:lDFc", long_options,
 					&option_index)) != -1) {
 
 		switch (opt) {
@@ -1193,6 +1195,9 @@ int cmd_restore(int argc, char **argv)
 			case 'D':
 				dry_run = 1;
 				break;
+			case 'F':
+				force = 1;
+				break;
 			case 'c':
 				match_cflags |= REG_ICASE;
 				break;
