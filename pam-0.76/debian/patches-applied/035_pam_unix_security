This is roughly an upstream patch version 1.15 of support.c
and 1.9 of   unix_chkpwd.c
However those patches conflicted with the password aging stuff and the password aging stuff was wrong for unix_chkpwd,
so this patch depends on the Debian pam_unix patch and changes that patch.
In short a real mess.
l
Index: Linux-PAM/modules/pam_unix/support.c
===================================================================
RCS file: /afs/sipb/project/debian/cvs/pam/Linux-PAM/modules/pam_unix/support.c,v
retrieving revision 1.6
diff -u -r1.6 support.c
--- Linux-PAM/modules/pam_unix/support.c	21 Sep 2002 18:35:57 -0000	1.6
+++ Linux-PAM/modules/pam_unix/support.c	15 Oct 2002 14:21:11 -0000
@@ -608,49 +608,50 @@
 			retval = PAM_AUTHINFO_UNAVAIL;
 		}
 	} else {
-		if (!strlen(salt)) {
-			/* the stored password is NULL */
-			if (off(UNIX__NONULL, ctrl)) {	/* this means we've succeeded */
-				D(("user has empty password - access granted"));
-				retval = PAM_SUCCESS;
-			} else {
-				D(("user has empty password - access denied"));
-				retval = PAM_AUTH_ERR;
-			}
-		} else if (!p) {
-				retval = PAM_AUTH_ERR;
+	    int salt_len = strlen(salt);
+	    if (!salt_len) {
+		/* the stored password is NULL */
+		if (off(UNIX__NONULL, ctrl)) {/* this means we've succeeded */
+		    D(("user has empty password - access granted"));
+		    retval = PAM_SUCCESS;
 		} else {
+		    D(("user has empty password - access denied"));
+		    retval = PAM_AUTH_ERR;
+		}
+	    } else if (!p || (*salt == '*') || (salt_len < 13)) {
+		retval = PAM_AUTH_ERR;
+	    } else {
 			/* Hack off sysv pw aging foo */
 			if (strrchr(salt, ',')) *(strrchr(salt, ',')) = '\0';
-			if (!strncmp(salt, "$1$", 3)) {
-				pp = Goodcrypt_md5(p, salt);
-				if (strcmp(pp, salt) != 0) {
-					_pam_delete(pp);
-					pp = Brokencrypt_md5(p, salt);
-				}
-			} else {
-				pp = bigcrypt(p, salt);
-			}
-			p = NULL;		/* no longer needed here */
+		if (!strncmp(salt, "$1$", 3)) {
+		    pp = Goodcrypt_md5(p, salt);
+		    if (strcmp(pp, salt) != 0) {
+			_pam_delete(pp);
+			pp = Brokencrypt_md5(p, salt);
+		    }
+		} else {
+		    pp = bigcrypt(p, salt);
+		}
+		p = NULL;		/* no longer needed here */
 
-			/* the moment of truth -- do we agree with the password? */
-			D(("comparing state of pp[%s] and salt[%s]", pp, salt));
+		/* the moment of truth -- do we agree with the password? */
+		D(("comparing state of pp[%s] and salt[%s]", pp, salt));
 
-			/*
-			 * Note, we are comparing the bigcrypt of the password with
-			 * the contents of the password field. If the latter was
-			 * encrypted with regular crypt (and not bigcrypt) it will
-			 * have been truncated for storage relative to the output
-			 * of bigcrypt here. As such we need to compare only the
-			 * stored string with the subset of bigcrypt's result.
-			 * Bug 521314: The strncmp comparison is for legacy support.
-			 */
-			if (strncmp(pp, salt, strlen(salt)) == 0) {
-				retval = PAM_SUCCESS;
-			} else {
-				retval = PAM_AUTH_ERR;
-			}
+		/*
+		 * Note, we are comparing the bigcrypt of the password with
+		 * the contents of the password field. If the latter was
+		 * encrypted with regular crypt (and not bigcrypt) it will
+		 * have been truncated for storage relative to the output
+		 * of bigcrypt here. As such we need to compare only the
+		 * stored string with the subset of bigcrypt's result.
+		 * Bug 521314: The strncmp comparison is for legacy support.
+		 */
+		if (strncmp(pp, salt, salt_len) == 0) {
+		    retval = PAM_SUCCESS;
+		} else {
+		    retval = PAM_AUTH_ERR;
 		}
+	    }
 	}
 
 	if (retval == PAM_SUCCESS) {
Index: Linux-PAM/modules/pam_unix/unix_chkpwd.c
===================================================================
RCS file: /afs/sipb/project/debian/cvs/pam/Linux-PAM/modules/pam_unix/unix_chkpwd.c,v
retrieving revision 1.10
diff -u -r1.10 unix_chkpwd.c
--- Linux-PAM/modules/pam_unix/unix_chkpwd.c	21 Sep 2002 18:35:58 -0000	1.10
+++ Linux-PAM/modules/pam_unix/unix_chkpwd.c	15 Oct 2002 14:21:11 -0000
@@ -101,6 +101,7 @@
 	char *salt = NULL;
 	char *pp = NULL;
 	int retval = UNIX_FAILED;
+	int salt_len;
 
 	/* UNIX passwords area */
 	setpwent();
@@ -140,8 +141,10 @@
 		return retval;
 	}
 
-	if (strlen(salt) == 0)
+	salt_len = strlen(salt);
+	if (salt_len == 0) {
 		return (opt == 0) ? UNIX_FAILED : UNIX_PASSED;
+	}
 	else if (p == NULL || strlen(p) == 0)
 		return UNIX_FAILED;
 
@@ -149,7 +152,7 @@
 	{
 	    char *tmp;
 
-	    if ((tmp = strrchr(p, ',')) != NULL) *tmp = '\0';
+	    if ((tmp = strrchr(salt, ',')) != NULL) *tmp = '\0';
 	}
 
 	/* the moment of truth -- do we agree with the password? */
@@ -163,6 +166,8 @@
 			if (strcmp(pp, salt) == 0)
 				retval = UNIX_PASSED;
 		}
+	} else if ((*salt == '*') || (salt_len < 13)) {
+	    retval = UNIX_FAILED;
 	} else {
 		pp = bigcrypt(p, salt);
 		/*
@@ -174,7 +179,7 @@
 		 * stored string with the subset of bigcrypt's result.
 		 * Bug 521314: the strncmp comparison is for legacy support.
 		 */
-		if (strncmp(pp, salt, strlen(salt)) == 0) {
+		if (strncmp(pp, salt, salt_len) == 0) {
 			retval = UNIX_PASSED;
 		}
 	}
