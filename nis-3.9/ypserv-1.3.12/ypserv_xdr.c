/*
 * And thus spoke RPCGEN:
 *    Please do not edit this file.
 *    It was generated using rpcgen.
 *
 * And thus replied Lpd@NannyMUD:
 *    Who cares? :-) /Peter Eriksson <pen@signum.se>
 *
 *
 * Modification history:
 *    940616 pen@signum.se	Major cleanups.
 *    940713 pen@signum.se	Added SunOS 4 prototypes.
 */

#include "system.h"
#include "yp.h"

#ifndef NULL
#define NULL 0
#endif

xdr_ypall_cb_t xdr_ypall_cb;

bool_t
xdr_ypstat(XDR *xdrs, ypstat *objp)
{
    if (!xdr_enum(xdrs, (enum_t *)objp))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypxfrstat(XDR *xdrs, ypxfrstat *objp)
{
    if (!xdr_enum(xdrs, (enum_t *)objp))
	return FALSE;

    return TRUE;
}

bool_t
xdr_domainname(XDR *xdrs, domainname *objp)
{
    if (!xdr_string(xdrs, objp, YPMAXDOMAIN))
	return FALSE;

    return TRUE;
}

bool_t
xdr_mapname(XDR *xdrs, mapname *objp)
{
    if (!xdr_string(xdrs, objp, YPMAXMAP))
	return FALSE;

    return TRUE;
}

bool_t
xdr_peername(XDR *xdrs, peername *objp)
{
    if (!xdr_string(xdrs, objp, YPMAXPEER))
	return FALSE;

    return TRUE;
}

bool_t
xdr_keydat(XDR *xdrs, keydat *objp)
{
    if (!xdr_bytes(xdrs, (char **)&objp->keydat_val,
		   (u_int *)&objp->keydat_len, ~0))
	return FALSE;

    return TRUE;
}

bool_t
xdr_valdat(XDR *xdrs, valdat *objp)
{
    if (!xdr_bytes(xdrs, (char **)&objp->valdat_val,
		   (u_int *)&objp->valdat_len, ~0))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypmap_parms(XDR *xdrs, ypmap_parms *objp)
{
    if (!xdr_domainname(xdrs, &objp->domain))
	return FALSE;

    if (!xdr_mapname(xdrs, &objp->map))
	return FALSE;

    if (!xdr_u_int(xdrs, &objp->ordernum))
	return FALSE;

    if (!xdr_peername(xdrs, &objp->peer))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypreq_key(XDR *xdrs, ypreq_key *objp)
{
    if (!xdr_domainname(xdrs, &objp->domain))
	return FALSE;

    if (!xdr_mapname(xdrs, &objp->map))
	return FALSE;

    if (!xdr_keydat(xdrs, &objp->key))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypreq_nokey(XDR *xdrs, ypreq_nokey *objp)
{
    if (!xdr_domainname(xdrs, &objp->domain))
	return FALSE;

    if (!xdr_mapname(xdrs, &objp->map))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypreq_xfr(XDR *xdrs, ypreq_xfr *objp)
{
    if (!xdr_ypmap_parms(xdrs, &objp->map_parms))
	return FALSE;

    if (!xdr_u_int(xdrs, &objp->transid))
	return FALSE;

    if (!xdr_u_int(xdrs, &objp->prog))
	return FALSE;

    if (!xdr_u_int(xdrs, &objp->port))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypresp_val(XDR *xdrs, ypresp_val *objp)
{
    if (!xdr_ypstat(xdrs, &objp->stat))
	return FALSE;

    if (!xdr_valdat(xdrs, &objp->val))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypresp_key_val(XDR *xdrs, ypresp_key_val *objp)
{
    if (!xdr_ypstat(xdrs, &objp->stat))
	return FALSE;

#if 0 /* The Sun-supplied yp.x RPC input file have these in the wrong order */
    if (!xdr_keydat(xdrs, &objp->key))
	return FALSE;

    if (!xdr_valdat(xdrs, &objp->val))
	return FALSE;
#else
    if (!xdr_valdat(xdrs, &objp->val))
	return FALSE;

    if (!xdr_keydat(xdrs, &objp->key))
	return FALSE;
#endif
    return TRUE;
}

bool_t
xdr_ypresp_master(XDR *xdrs, ypresp_master *objp)
{
    if (!xdr_ypstat(xdrs, &objp->stat))
	return FALSE;

    if (!xdr_peername(xdrs, &objp->peer))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypresp_order(XDR *xdrs, ypresp_order *objp)
{
    if (!xdr_ypstat(xdrs, &objp->stat))
	return FALSE;

    if (!xdr_u_int(xdrs, &objp->ordernum))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypresp_all(XDR *xdrs, ypresp_all *objp)
{
  if (xdrs->x_op == XDR_ENCODE)
    {
      while (1)
	{
          if (xdr_bool(xdrs, &objp->more) == FALSE ||
              xdr_ypresp_key_val(xdrs, &objp->ypresp_all_u.val) == FALSE)
            {
              if (xdr_ypall_cb.u.close != NULL)
                (*(xdr_ypall_cb.u.close))(xdr_ypall_cb.data);
              
              xdr_ypall_cb.data = NULL;
              
              return FALSE;
            }
          
          if ((objp->ypresp_all_u.val.stat != YP_TRUE) ||
              (*xdr_ypall_cb.u.encode)(&objp->ypresp_all_u.val,
                                       xdr_ypall_cb.data) != YP_TRUE)
            {
              objp->more = FALSE;
              
              if (xdr_ypall_cb.u.close != NULL)
                (*(xdr_ypall_cb.u.close))(xdr_ypall_cb.data);
              
              xdr_ypall_cb.data = NULL;
              
              if (!xdr_bool(xdrs, &objp->more))
                return FALSE;
              
              return TRUE;
	    }
	}
    }      
#ifdef NOTYET /* This code isn't needed in the server */
  else if (xdrs->x_op == XDR_DECODE)
    {
      int more = 0;
      
      while (1)
	{
	  if (!xdr_bool(xdrs, &objp->more))
	    return FALSE;
	  
	  switch (objp->more)
	    {
	    case TRUE:
	      if (!xdr_ypresp_key_val(xdrs, &objp->ypresp_all_u.val))
		return FALSE;
	      
	      if (more == 0)
		more = (*xdr_ypall_callback->foreach.decoder)
		  (&objp->ypresp_all_u.val, xdr_ypall_callback->data);
	      break;
	      
	    case FALSE:
	      return TRUE;
	      
	    default:
	      return FALSE;
	    }
	}
      return FALSE;
    }
#endif
  
  return TRUE;
}

bool_t
xdr_ypresp_xfr(XDR *xdrs, ypresp_xfr *objp)
{
    if (!xdr_u_int(xdrs, &objp->transid))
	return FALSE;

    if (!xdr_ypxfrstat(xdrs, &objp->xfrstat))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypmaplist(XDR *xdrs, ypmaplist *objp)
{
    if (!xdr_mapname(xdrs, &objp->map))
	return FALSE;

    if (!xdr_pointer(xdrs, (char **)&objp->next, sizeof(ypmaplist),
		     (xdrproc_t)xdr_ypmaplist))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypresp_maplist(XDR *xdrs, ypresp_maplist *objp)
{
    if (!xdr_ypstat(xdrs, &objp->stat))
	return FALSE;

    if (!xdr_pointer(xdrs, (char **)&objp->maps, sizeof(ypmaplist),
		     (xdrproc_t)xdr_ypmaplist))
	return FALSE;

    return TRUE;
}

bool_t
xdr_yppush_status(XDR *xdrs, yppush_status *objp)
{
    if (!xdr_enum(xdrs, (enum_t *)objp))
	return FALSE;

    return TRUE;
}

bool_t
xdr_yppushresp_xfr(XDR *xdrs, yppushresp_xfr *objp)
{
    if (!xdr_u_int(xdrs, &objp->transid))
	return FALSE;

    if (!xdr_yppush_status(xdrs, &objp->status))
	return FALSE;

    return TRUE;
}

bool_t
xdr_ypreqtype (XDR *xdrs, ypreqtype *objp)
{
  if (!xdr_enum (xdrs, (enum_t *) objp))
    return FALSE;
  return TRUE;
}

bool_t
xdr_ypresptype (XDR *xdrs, ypresptype *objp)
{
  if (!xdr_enum (xdrs, (enum_t *) objp))
    return FALSE;
  return TRUE;
}

bool_t
xdr_yprequest (XDR *xdrs, yprequest *objp)
{
  if (!xdr_ypreqtype (xdrs, &objp->yp_reqtype))
    return FALSE;
  switch (objp->yp_reqtype) {
  case YPREQ_KEY:
    if (!xdr_ypreq_key (xdrs, &objp->yprequest_u.yp_req_keytype))
      return FALSE;
    break;
  case YPREQ_NOKEY:
    if (!xdr_ypreq_nokey (xdrs, &objp->yprequest_u.yp_req_nokeytype))
      return FALSE;
    break;
  case YPREQ_MAP_PARMS:
    if (!xdr_ypmap_parms (xdrs, &objp->yprequest_u.yp_req_map_parmstype))
      return FALSE;
    break;
  default:
    return FALSE;
  }
  return TRUE;
}

bool_t
xdr_ypresponse (XDR *xdrs, ypresponse *objp)
{
  if (!xdr_ypresptype (xdrs, &objp->yp_resptype))
    return FALSE;
  switch (objp->yp_resptype) {
  case YPRESP_VAL:
    if (!xdr_ypresp_val (xdrs, &objp->ypresponse_u.yp_resp_valtype))
      return FALSE;
    break;
  case YPRESP_KEY_VAL:
    if (!xdr_ypresp_key_val (xdrs, &objp->ypresponse_u.yp_resp_key_valtype))
      return FALSE;
    break;
  case YPRESP_MAP_PARMS:
    if (!xdr_ypmap_parms (xdrs, &objp->ypresponse_u.yp_resp_map_parmstype))
      return FALSE;
    break;
  default:
    return FALSE;
  }
  return TRUE;
}
