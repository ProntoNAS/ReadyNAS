#! /bin/sh -e

# DP: 2004-05-09  Andrew Pinski  <pinskia@physics.uc.edu>
# DP:
# DP:	* parse.y (check_pkg_class_access): Add new argument
# DP:	and use it when cl is NULL to call lookup_cl on it.
# DP:	(parser_check_super_interface): Do not call lookup_cl.
# DP:	Pass this_decl to check_pkg_class_access and NULL
# DP:	instead of lookup_cl.
# DP:	(parser_check_super): Update for change in
# DP:	check_pkg_class_access.
# DP:	(do_resolve_class): Likewise.
# DP:	(process_imports): Likewise.
# DP:	(find_in_imports_on_demand): Likewise.

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        #cd ${dir}gcc && autoconf
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        #rm ${dir}gcc/configure
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

--- gcc/java/parse.y.orig	2004-02-26 12:13:57.000000000 +0100
+++ gcc/java/parse.y	2004-05-09 17:22:34.000000000 +0200
@@ -101,7 +101,7 @@
 static int find_in_imports_on_demand PARAMS ((tree, tree));
 static void find_in_imports PARAMS ((tree, tree));
 static void check_inner_class_access PARAMS ((tree, tree, tree));
-static int check_pkg_class_access PARAMS ((tree, tree, bool));
+static int check_pkg_class_access PARAMS ((tree, tree, bool, tree));
 static void register_package PARAMS ((tree));
 static tree resolve_package PARAMS ((tree, tree *, tree *));
 static tree resolve_class PARAMS ((tree, tree, tree, tree));
@@ -5115,7 +5115,7 @@
      access rules (6.6.1). */
   if (! INNER_CLASS_P (super_type)
       && check_pkg_class_access (DECL_NAME (super_decl),
-				 lookup_cl (this_decl), true))
+				 NULL_TREE, true, this_decl))
     return 1;
 
   SOURCE_FRONTEND_DEBUG (("Completing interface %s with %s",
@@ -5154,7 +5154,7 @@
   /* Check top-level class scope. Inner classes are subject to member access
      rules (6.6.1). */
   if (! INNER_CLASS_P (super_type)
-      && (check_pkg_class_access (DECL_NAME (super_decl), wfl, true)))
+      && (check_pkg_class_access (DECL_NAME (super_decl), wfl, true, NULL_TREE)))
     return 1;
 
   SOURCE_FRONTEND_DEBUG (("Completing class %s with %s",
@@ -5904,7 +5904,7 @@
      by the caller. */
   if (cl)
     {
-      if (check_pkg_class_access (TYPE_NAME (class_type), cl, true))
+      if (check_pkg_class_access (TYPE_NAME (class_type), cl, true, NULL_TREE))
         return NULL_TREE;
     }
 
@@ -6770,7 +6770,7 @@
 	  QUALIFIED_P (to_be_found) = 1;
 	  load_class (to_be_found, 0);
 	  error_found =
-	    check_pkg_class_access (to_be_found, TREE_PURPOSE (import), true);
+	    check_pkg_class_access (to_be_found, TREE_PURPOSE (import), true, NULL_TREE);
 
 	  /* We found it, we can bail out */
 	  if (IDENTIFIER_CLASS_VALUE (to_be_found))
@@ -7017,7 +7017,7 @@
 	}
       if (decl && ! INNER_CLASS_P (TREE_TYPE (decl)))
 	access_check = check_pkg_class_access (node, TREE_PURPOSE (import),
-					       false);
+					       false, NULL_TREE);
       else
 	/* 6.6.1: Inner classes are subject to member access rules. */
 	access_check = 0;
@@ -7206,13 +7206,15 @@
 /* Accessibility check for top-level classes. If CLASS_NAME is in a
    foreign package, it must be PUBLIC. Return 0 if no access
    violations were found, 1 otherwise. If VERBOSE is true and an error
-   was found, it is reported and accounted for.  */
+   was found, it is reported and accounted for.  If cl is NULL then 
+   lookup it up with THIS_DECL.  */
 
 static int
-check_pkg_class_access (class_name, cl, verbose)
+check_pkg_class_access (class_name, cl, verbose, this_decl)
      tree class_name;
      tree cl;
      bool verbose;
+     tree this_decl;
 {
   tree type;
 
@@ -7237,7 +7239,8 @@
 
       if (verbose)
 	parse_error_context
-	  (cl, "Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed",
+	  (cl == NULL ? lookup_cl (this_decl): cl,
+           "Can't access %s `%s'. Only public classes and interfaces in other packages can be accessed",
 	   (CLASS_INTERFACE (TYPE_NAME (type)) ? "interface" : "class"),
 	   IDENTIFIER_POINTER (class_name));
       return 1;
