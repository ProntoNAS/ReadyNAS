#! /bin/sh -e

# DP: Update gpc driver to recognize recent specs options

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        #cd ${dir}gcc && autoconf
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        #rm ${dir}gcc/configure
        ;;
    *)
        echo >&2 "`basename $0`: script expects -patch|-unpatch as argument"
        exit 1
esac
exit 0

--- gcc/p/gpc.c	2004-01-01 00:25:07.000000000 +0100
+++ gcc/p/gpc.c	2004-07-25 11:50:03.000000000 +0200
@@ -95,6 +95,13 @@
 #endif
 #include "config.h"
 #include "system.h"
+#ifdef GCC_3_4
+#include "coretypes.h"
+#include "multilib.h" /* before tm.h */
+#include "tm.h"
+#else
+#include "multilib.h" 
+#endif
 #include <signal.h>
 #if ! defined( SIGCHLD ) && defined( SIGCLD )
 #  define SIGCHLD SIGCLD
@@ -161,6 +168,16 @@
 
 #define lang_specific_extra_outfiles 0
 
+#ifndef EGCS97
+#undef bool
+#define bool int
+#undef false
+#define false 0
+#undef true 
+#define true 1
+#define ISIDNUM(c) (isalnum(c)||(c) == '_')
+#endif
+
 extern int lang_specific_pre_link PARAMS ((void));
 int
 lang_specific_pre_link ()
@@ -234,7 +251,7 @@
 #include <sys/resource.h>
 #endif
 #if defined (HAVE_DECL_GETRUSAGE) && !HAVE_DECL_GETRUSAGE
-extern int getrusage PARAMS ((int, struct rusage *));
+extern int getrusage (int, struct rusage *);
 #endif
 
 #ifdef EGCS97
@@ -335,6 +352,14 @@
 
 #endif
 
+#ifndef GCC_3_4
+static const struct {
+	  const char *name, *value;
+} configure_default_options[1] = { {NULL, NULL} }; 
+#define IS_ABSOLUTE_PATH(STR) IS_ABSOLUTE_PATHNAME (STR)
+#endif
+
+
 #ifndef VMS
 /* FIXME: the location independence code for VMS is hairier than this,
    and hasn't been written.  */
@@ -345,8 +370,10 @@
 
 static const char dir_separator_str[] = { DIR_SEPARATOR, 0 };
 
+#ifndef GCC_3_3
 #define obstack_chunk_alloc xmalloc
 #define obstack_chunk_free free
+#endif
 
 #ifndef GET_ENVIRONMENT
 #define GET_ENVIRONMENT(VAR,NAME)     do { (VAR) = getenv (NAME); } while (0)
@@ -434,11 +461,37 @@
 
 static int report_times;
 
+/* Nonzero means place this string before uses of /, so that include
+   and library files can be found in an alternate location.  */
+
+#ifdef TARGET_SYSTEM_ROOT
+static const char *target_system_root = TARGET_SYSTEM_ROOT;
+#else
+static const char *target_system_root = 0;
+#endif
+
+/* Nonzero means pass the updated target_system_root to the compiler.  */
+
+static int target_system_root_changed;
+
+/* Nonzero means append this string to target_system_root.  */
+
+static const char *target_sysroot_suffix = 0;
+
+/* Nonzero means append this string to target_system_root for headers.  */
+
+static const char *target_sysroot_hdrs_suffix = 0;
+
 /* Nonzero means write "temp" files in source directory
    and use the source file's name in them, and don't delete them.  */
 
 static int save_temps_flag;
 
+/* Nonzero means use pipes to communicate between subprocesses.
+   Overridden by either of the above two flags.  */
+
+static int use_pipes;
+
 /* The compiler version.  */
 
 static const char *compiler_version;
@@ -503,74 +556,79 @@
 /* Forward declaration for prototypes.  */
 struct path_prefix;
 
-static void init_spec           PARAMS ((void));
+static void init_spec (void);
 #if !defined (GCC_3_3) && !defined (VMS)
-static char **split_directories PARAMS ((const char *, int *));
-static void free_split_directories PARAMS ((char **));
-static char *make_relative_prefix PARAMS ((const char *, const char *, const char *));
-#endif
-static void store_arg           PARAMS ((const char *, int, int));
-static char *load_specs         PARAMS ((const char *));
-static void read_specs          PARAMS ((const char *, int));
-static void set_spec            PARAMS ((const char *, const char *));
-static struct compiler *lookup_compiler PARAMS ((const char *, size_t, const char *));
-static char *build_search_list  PARAMS ((struct path_prefix *, const char *, int));
-static void putenv_from_prefixes PARAMS ((struct path_prefix *, const char *));
-static int access_check         PARAMS ((const char *, int));
-static char *find_a_file        PARAMS ((struct path_prefix *, const char *,
-                                         int, int));
-static void add_prefix          PARAMS ((struct path_prefix *, const char *,
-                                         const char *, int, int, int *, int));
-static void translate_options   PARAMS ((int *, const char *const **));
-static char *skip_whitespace    PARAMS ((char *));
-static void delete_if_ordinary  PARAMS ((const char *));
-static void delete_temp_files   PARAMS ((void));
-static void delete_failure_queue PARAMS ((void));
-static void clear_failure_queue PARAMS ((void));
-static int check_live_switch    PARAMS ((int, int));
-static const char *handle_braces PARAMS ((const char *));
-static const struct spec_function *lookup_spec_function PARAMS ((const char *));
-static const char *eval_spec_function   PARAMS ((const char *, const char *));
-static const char *handle_spec_function PARAMS ((const char *));
-static char *save_string        PARAMS ((const char *, int));
-static void set_collect_gcc_options PARAMS ((void));
-static int do_spec_1            PARAMS ((const char *, int, const char *));
-static int do_spec_2            PARAMS ((const char *));
-static void do_self_spec        PARAMS ((const char *));
-static const char *find_file    PARAMS ((const char *));
-static int is_directory         PARAMS ((const char *, const char *, int));
-static void validate_switches   PARAMS ((const char *));
-static void validate_all_switches PARAMS ((void));
-static void give_switch         PARAMS ((int, int, int));
-static int used_arg             PARAMS ((const char *, int));
-static int default_arg          PARAMS ((const char *, int));
-static void set_multilib_dir    PARAMS ((void));
-static void print_multilib_info PARAMS ((void));
-static void perror_with_name    PARAMS ((const char *));
-static void pfatal_pexecute     PARAMS ((const char *, const char *))
-  ATTRIBUTE_NORETURN;
-static void notice              PARAMS ((const char *, ...))
-  ATTRIBUTE_PRINTF_1;
-static void display_help        PARAMS ((void));
-static void add_preprocessor_option     PARAMS ((const char *, int));
-static void add_assembler_option        PARAMS ((const char *, int));
-static void add_linker_option           PARAMS ((const char *, int));
-static void process_command             PARAMS ((int, const char *const *));
-static int execute                      PARAMS ((void));
-static void alloc_args                  PARAMS ((void));
-static void clear_args                  PARAMS ((void));
-static void fatal_error                 PARAMS ((int));
+static char **split_directories (const char *, int *);
+static void free_split_directories (char **);
+static char *make_relative_prefix (const char *, const char *, const char *);
+#endif
+static void store_arg (const char *, int, int);
+static char *load_specs (const char *);
+static void read_specs (const char *, int);
+static void set_spec (const char *, const char *);
+static struct compiler *lookup_compiler (const char *, size_t, const char *);
+static char *build_search_list (struct path_prefix *, const char *, int);
+static void putenv_from_prefixes (struct path_prefix *, const char *);
+static int access_check (const char *, int);
+static char *find_a_file (struct path_prefix *, const char *, int, int);
+static void add_prefix (struct path_prefix *, const char *, const char *,
+			int, int, int *, int);
+static void add_sysrooted_prefix (struct path_prefix *, const char *,
+				  const char *, int, int, int *, int);
+static void translate_options (int *, const char *const **);
+static char *skip_whitespace (char *);
+static void delete_if_ordinary (const char *);
+static void delete_temp_files (void);
+static void delete_failure_queue (void);
+static void clear_failure_queue (void);
+static int check_live_switch (int, int);
+static const char *handle_braces (const char *);
+static inline bool input_suffix_matches (const char *, const char *);
+static inline bool switch_matches (const char *, const char *, int);
+static inline void mark_matching_switches (const char *, const char *, int);
+static inline void process_marked_switches (void);
+static const char *process_brace_body (const char *, const char *, const char *, int, int);
+static const struct spec_function *lookup_spec_function (const char *);
+static const char *eval_spec_function (const char *, const char *);
+static const char *handle_spec_function (const char *);
+static char *save_string (const char *, int);
+static void set_collect_gcc_options (void);
+static int do_spec_1 (const char *, int, const char *);
+static int do_spec_2 (const char *);
+static void do_option_spec (const char *, const char *);
+static void do_self_spec (const char *);
+static const char *find_file (const char *);
+static int is_directory (const char *, const char *, int);
+static const char *validate_switches (const char *);
+static void validate_all_switches (void);
+static inline void validate_switches_from_spec (const char *);
+static void give_switch (int, int);
+static int used_arg (const char *, int);
+static int default_arg (const char *, int);
+static void set_multilib_dir (void);
+static void print_multilib_info (void);
+static void perror_with_name (const char *);
+static void pfatal_pexecute (const char *, const char *) ATTRIBUTE_NORETURN;
+static void notice (const char *, ...) ATTRIBUTE_PRINTF_1;
+static void display_help (void);
+static void add_preprocessor_option (const char *, int);
+static void add_assembler_option (const char *, int);
+static void add_linker_option (const char *, int);
+static void process_command (int, const char **);
+static int execute (void);
+static void alloc_args (void);
+static void clear_args (void);
+static void fatal_error (int);
 #ifdef ENABLE_SHARED_LIBGCC
-static void init_gcc_specs              PARAMS ((struct obstack *,
-                                                 const char *, const char *,
-                                                 const char *));
+static void init_gcc_specs (struct obstack *, const char *, const char *,
+			    const char *);
 #endif
 #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
-static const char *convert_filename     PARAMS ((const char *, int, int));
+static const char *convert_filename (const char *, int, int);
 #endif
 
-static const char *if_exists_spec_function PARAMS ((int, const char **));
-static const char *if_exists_else_spec_function PARAMS ((int, const char **));
+static const char *if_exists_spec_function (int, const char **);
+static const char *if_exists_else_spec_function (int, const char **);
 
 /* The Specs Language
 
@@ -605,6 +663,12 @@
         with a file name chosen once per compilation, without regard
         to any appended suffix (which was therefore treated just like
         ordinary text), making such attacks more likely to succeed.
+ %|SUFFIX
+	like %g, but if -pipe is in effect, expands simply to "-".
+ %mSUFFIX
+        like %g, but if -pipe is in effect, expands to nothing.  (We have both
+	%| and %m to accommodate differences between system assemblers; see
+	the AS_NEEDS_DASH_FOR_PIPED_INPUT target macro.)
  %uSUFFIX
         like %g, but generates a new temporary file name even if %uSUFFIX
         was already seen.
@@ -633,6 +697,7 @@
  %w     marks the argument containing or following the %w as the
         "output file" of this compilation.  This puts the argument
         into the sequence of arguments that %o will substitute later.
+ %V	indicates that this compilation produces no "output file".
  %W{...}
         like %{...} but mark last argument supplied within
         as a file to be deleted on failure.
@@ -651,12 +716,9 @@
         except that %g, %u, and %U do not currently support additional
         SUFFIX characters following %O as they would following, for
         example, `.o'.
- %p     substitutes the standard macro predefinitions for the
-        current target machine.  Use this when running cpp.
- %P     like %p, but puts `__' before and after the name of each macro.
-        (Except macros that already have __.)
-        This is for ANSI C.
- %I     Substitute a -iprefix option made from GCC_EXEC_PREFIX.
+ %I	Substitute any of -iprefix (made from GCC_EXEC_PREFIX), -isysroot
+	(made from TARGET_SYSTEM_ROOT), and -isystem (made from COMPILER_PATH
+	and -B options) as necessary.
  %s     current argument is the name of a library or startup file of some sort.
         Search for that file in a standard list of directories
         and substitute the full name found.
@@ -667,12 +729,6 @@
  %X     Output the accumulated linker options specified by compilations.
  %Y     Output the accumulated assembler options specified by compilations.
  %Z     Output the accumulated preprocessor options specified by compilations.
- %v1    Substitute the major version number of GCC.
-        (For version 2.5.3, this is 2.)
- %v2    Substitute the minor version number of GCC.
-        (For version 2.5.3, this is 5.)
- %v3    Substitute the patch level number of GCC.
-        (For version 2.5.3, this is 3.)
  %a     process ASM_SPEC as a spec.
         This allows config.h to specify part of the spec for running as.
  %A     process ASM_FINAL_SPEC as a spec.  A capital A is actually
@@ -690,10 +746,15 @@
  %C     process CPP_SPEC as a spec.
  %1     process CC1_SPEC as a spec.
  %2     process CC1PLUS_SPEC as a spec.
- %|     output "-" if the input for the current command is coming from a pipe.
  %*     substitute the variable part of a matched option.  (See below.)
         Note that each comma in the substituted string is replaced by
         a single space.
+ %<S    remove all occurrences of -S from the command line.
+        Note - this command is position dependent.  % commands in the
+        spec string before this one will see -S, % commands in the
+        spec string after this one will not.
+ %<S*	remove all occurrences of all switches beginning with -S from the
+        command line.
  %:function(args)
         Call the named function FUNCTION, passing it ARGS.  ARGS is
         first processed as a nested spec string, then split into an
@@ -708,33 +769,40 @@
         arguments.  CC considers `-o foo' as being one switch whose
         name starts with `o'.  %{o*} would substitute this text,
         including the space; thus, two arguments would be generated.
- %{^S*} likewise, but don't put a blank between a switch and any args.
  %{S*&T*} likewise, but preserve order of S and T options (the order
         of S and T in the spec is not significant).  Can be any number
         of ampersand-separated variables; for each the wild card is
         optional.  Useful for CPP as %{D*&U*&A*}.
- %{S*:X} substitutes X if one or more switches whose names start with -S are
-        specified to CC.  Note that the tail part of the -S option
-        (i.e. the part matched by the `*') will be substituted for each
-        occurrence of %* within X.
- %{<S}  remove all occurrences of -S from the command line.
-        Note - this option is position dependent.  % commands in the
-        spec string before this option will see -S, % commands in the
-        spec string after this option will not.
- %{S:X} substitutes X, but only if the -S switch was given to CC.
- %{!S:X} substitutes X, but only if the -S switch was NOT given to CC.
- %{|S:X} like %{S:X}, but if no S switch, substitute `-'.
- %{|!S:X} like %{!S:X}, but if there is an S switch, substitute `-'.
- %{.S:X} substitutes X, but only if processing a file with suffix S.
- %{!.S:X} substitutes X, but only if NOT processing a file with suffix S.
- %{S|P:X} substitutes X if either -S or -P was given to CC.  This may be
-          combined with ! and . as above binding stronger than the OR.
+
+ %{S:X}   substitutes X, if the -S switch was given to CC.
+ %{!S:X}  substitutes X, if the -S switch was NOT given to CC.
+ %{S*:X}  substitutes X if one or more switches whose names start
+          with -S was given to CC.  Normally X is substituted only
+          once, no matter how many such switches appeared.  However,
+          if %* appears somewhere in X, then X will be substituted
+          once for each matching switch, with the %* replaced by the
+          part of that switch that matched the '*'.
+ %{.S:X}  substitutes X, if processing a file with suffix S.
+ %{!.S:X} substitutes X, if NOT processing a file with suffix S.
+
+ %{S|T:X} substitutes X if either -S or -T was given to CC.  This may be
+	  combined with !, ., and * as above binding stronger than the OR.
+	  If %* appears in X, all of the alternatives must be starred, and
+	  only the first matching alternative is substituted.
+ %{S:X;   if S was given to CC, substitutes X;
+   T:Y;   else if T was given to CC, substitutes Y;
+    :D}   else substitutes D.  There can be as many clauses as you need.
+          This may be combined with ., !, |, and * as above.
+
  %(Spec) processes a specification defined in a specs file as *Spec:
  %[Spec] as above, but put __ around -D arguments
 
-The conditional text X in a %{S:X} or %{!S:X} construct may contain
+The conditional text X in a %{S:X} or similar construct may contain
 other nested % constructs or spaces, or even newlines.  They are
-processed as usual, as described above.
+processed as usual, as described above.  Trailing white space in X is
+ignored.  White space may also appear anywhere on the left side of the
+colon in these constructs, except between . or * and the corresponding
+word.
 
 The -O, -f, -m, and -W switches are handled specifically in these
 constructs.  If another value of -O or the negated form of a -f, -m, or
@@ -864,6 +932,14 @@
 #define LINK_GCC_C_SEQUENCE_SPEC "%G %L %G"
 #endif
 
+#ifndef LINK_PIE_SPEC
+#ifdef HAVE_LD_PIE
+#define LINK_PIE_SPEC "%{pie:-pie} "
+#else
+#define LINK_PIE_SPEC "%{pie:} "
+#endif
+#endif
+
 /* -u* was put back because both BSD and SysV seem to support it.  */
 /* %{static:} simply prevents an error message if the target machine
    doesn't handle -static.  */
@@ -873,9 +949,10 @@
 #ifndef LINK_COMMAND_SPEC
 #define LINK_COMMAND_SPEC "\
 %{!fsyntax-only:%{!c:%{!M:%{!MM:%{!E:%{!S:\
-    %(linker) %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r} %{s} %{t}\
-    %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
-    %{static:} %{L*} %(link_libgcc) %o %{!nostdlib:%{!nodefaultlibs:%(link_gcc_c_sequence)}}\
+    %(linker) %l " LINK_PIE_SPEC "%X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n} %{r}\
+    %{s} %{t} %{u*} %{x} %{z} %{Z} %{!A:%{!nostdlib:%{!nostartfiles:%S}}}\
+    %{static:} %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate:-lgcov}\
+    %{!nostdlib:%{!nodefaultlibs:%(link_gcc_c_sequence)}}\
     %{!A:%{!nostdlib:%{!nostartfiles:%E}}} %{T*} }}}}}}"
 #endif
 
@@ -893,9 +970,24 @@
 # define STARTFILE_PREFIX_SPEC ""
 #endif
 
+#ifndef SYSROOT_SUFFIX_SPEC
+# define SYSROOT_SUFFIX_SPEC ""
+#endif
+
+#ifndef SYSROOT_HEADERS_SUFFIX_SPEC
+# define SYSROOT_HEADERS_SUFFIX_SPEC ""
+#endif
+
+#ifndef GCC_3_3
+#include "cpp_predef.h"
+#else
+# define GPC_CPP_PREDEFINES ""
+#endif
+
+
 static const char *asm_debug = "";
 static const char *cpp_spec = CPP_SPEC;
-static const char *cpp_predefines = CPP_PREDEFINES;
+static const char *cpp_predefines = GPC_CPP_PREDEFINES;
 static const char *cc1_spec = CC1_SPEC;
 static const char *cc1plus_spec = CC1PLUS_SPEC;
 static const char *link_gcc_c_sequence_spec = LINK_GCC_C_SEQUENCE_SPEC;
@@ -911,6 +1003,8 @@
 static const char *link_command_spec = LINK_COMMAND_SPEC;
 static const char *link_libgcc_spec = LINK_LIBGCC_SPEC;
 static const char *startfile_prefix_spec = STARTFILE_PREFIX_SPEC;
+static const char *sysroot_suffix_spec = SYSROOT_SUFFIX_SPEC;
+static const char *sysroot_hdrs_suffix_spec = SYSROOT_HEADERS_SUFFIX_SPEC;
 
 /* Standard options to cpp, cc1, and as, to reduce duplication in specs.
    There should be no need to override these in target dependent files,
@@ -928,16 +1022,13 @@
    therefore no dependency entry, confuses make into thinking a .o
    file that happens to exist is up-to-date.  */
 static const char *cpp_unique_options =
-"%{C:%{!E:%eGNU C does not support -C without using -E}}\
- %{CC:%{!E:%eGNU C does not support -CC without using -E}}\
+"%{C|CC:%{!E:%eGCC does not support -C or -CC without -E}}\
  %{nostdinc*} %{C} %{CC} %{v} %{I*} %{P} %I\
  %{MD:-MD %{!o:%b.d}%{o*:%.d%*}}\
  %{MMD:-MMD %{!o:%b.d}%{o*:%.d%*}}\
  %{M} %{MM} %{MF*} %{MG} %{MP} %{MQ*} %{MT*}\
  %{!E:%{!M:%{!MM:%{MD|MMD:%{o*:-MQ %*}}}}}\
- %{!no-gcc:-D__GNUC__=%v1 -D__GNUC_MINOR__=%v2 -D__GNUC_PATCHLEVEL__=%v3}\
- %{!undef:%{!ansi:%{!std=*:%p}%{std=gnu*:%p}} %P} %{trigraphs}\
- %{remap} %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\
+ %{trigraphs} %{remap} %{g3:-dD} %{H} %C %{D*&U*&A*} %{i*} %Z %i\
  %{E|M|MM:%W{o*}}";
 
 /* This contains cpp options which are common with cc1_options and are passed
@@ -947,7 +1038,7 @@
    in turn cause preprocessor symbols to be defined specially.  */
 static const char *cpp_options =
 "%(cpp_unique_options) %1 %{m*} %{std*} %{ansi} %{W*&pedantic*} %{w} %{f*}\
- %{O*} %{undef}";
+ %{g*:%{!g0:%{!fno-working-directory:-fworking-directory}}} %{O*} %{undef}";
 
 /* This contains cpp options which are not passed when the preprocessor
    output will be used by another program.  */
@@ -969,7 +1060,15 @@
 "%a %Y %{c:%W{o*}%{!o*:-o %w%b%O}}%{!c:-o %d%w%u%O}";
 
 static const char *invoke_as =
+#ifdef GCC_3_4
+#ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT
+"%{!S:-o %|.s |\n as %(asm_options) %|.s %A }";
+#else
+"%{!S:-o %|.s |\n as %(asm_options) %m.s %A }";
+#endif
+#else
 "%{!S:-o %{|!pipe:%g.s} |\n as %(asm_options) %{!pipe:%g.s} %A }";
+#endif
 
 /* Some compilers have limits on line lengths, and the multilib_select
    and/or multilib_matches strings can be very long, so we build them at
@@ -979,7 +1078,6 @@
 static const char *multilib_matches;
 static const char *multilib_defaults;
 static const char *multilib_exclusions;
-#include "multilib.h"
 
 /* Check whether a particular argument is a default argument.  */
 
@@ -995,6 +1093,19 @@
 
 static const char *const driver_self_specs[] = { DRIVER_SELF_SPECS };
 
+#ifndef OPTION_DEFAULT_SPECS
+#define OPTION_DEFAULT_SPECS { "", "" }
+#endif
+
+struct default_spec
+{
+  const char *name;
+  const char *spec;
+};
+
+static const struct default_spec
+  option_default_specs[] = { OPTION_DEFAULT_SPECS };
+
 struct user_specs
 {
   struct user_specs *next;
@@ -1093,7 +1204,7 @@
   {".m",  "#Objective-C", 0}, {".mi",  "#Objective-C", 0},
   {".cc", "#C++", 0}, {".cxx", "#C++", 0}, {".cpp", "#C++", 0},
   {".cp", "#C++", 0}, {".c++", "#C++", 0}, {".C", "#C++", 0},
-  {".ii", "#C++", 0},
+  {".CPP", "#C++", 0}, {".ii", "#C++", 0},
   {".ads", "#Ada", 0}, {".adb", "#Ada", 0},
   {".f", "#Fortran", 0}, {".for", "#Fortran", 0}, {".fpp", "#Fortran", 0},
   {".F", "#Fortran", 0}, {".FOR", "#Fortran", 0}, {".FPP", "#Fortran", 0},
@@ -1112,8 +1223,9 @@
           %{traditional|ftraditional:\
 %eGNU C no longer supports -traditional without -E}\
           %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \
-                %(cpp_options) %{save-temps:%b.i} %{!save-temps:%g.i} \n\
-                    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} %(cc1_options)}\
+		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
+		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
+			%(cc1_options)}\
           %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
                 cc1 %(cpp_unique_options) %(cc1_options)}}}\
         %{!fsyntax-only:%(invoke_as)}}}}", 0},
@@ -1149,9 +1261,20 @@
     %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)", 0},
   {".h", "@c-header", 0},
   {"@c-header",
-   "%{!E:%ecompilation of header file requested} \
-    %(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)",
-   0},
+   /* cc1 has an integrated ISO C preprocessor.  We should invoke the
+      external preprocessor if -save-temps is given.  */
+     "%{E|M|MM:%(trad_capable_cpp) %(cpp_options) %(cpp_debug_options)}\
+      %{!E:%{!M:%{!MM:\
+	  %{save-temps|traditional-cpp|no-integrated-cpp:%(trad_capable_cpp) \
+		%(cpp_options) -o %{save-temps:%b.i} %{!save-temps:%g.i} \n\
+		    cc1 -fpreprocessed %{save-temps:%b.i} %{!save-temps:%g.i} \
+			%(cc1_options)\
+                        -o %g.s %{!o*:--output-pch=%i.gch}\
+                        %W{o*:--output-pch=%*}%V}\
+	  %{!save-temps:%{!traditional-cpp:%{!no-integrated-cpp:\
+		cc1 %(cpp_unique_options) %(cc1_options)\
+                    -o %g.s %{!o*:--output-pch=%i.gch}\
+                    %W{o*:--output-pch=%*}%V}}}}}}", 0},
   {".i", "@cpp-output", 0},
   {"@cpp-output",
    "%{!M:%{!MM:%{!E:cc1 -fpreprocessed %i %(cc1_options) %{!fsyntax-only:%(invoke_as)}}}}", 0},
@@ -1160,12 +1283,21 @@
    "%{!M:%{!MM:%{!E:%{!S:as %(asm_debug) %(asm_options) %i %A }}}}", 0},
   {".S", "@assembler-with-cpp", 0},
   {"@assembler-with-cpp",
+#ifdef AS_NEEDS_DASH_FOR_PIPED_INPUT
    "%(trad_capable_cpp) -lang-asm %(cpp_options)\
       %{E|M|MM:%(cpp_debug_options)}\
-      %{!M:%{!MM:%{!E:%{!S:-o %{|!pipe:%g.s} |\n\
-       as %(asm_debug) %(asm_options) %{!pipe:%g.s} %A }}}}", 0},
+      %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\
+       as %(asm_debug) %(asm_options) %|.s %A }}}}"
+#else
+   "%(trad_capable_cpp) -lang-asm %(cpp_options)\
+      %{E|M|MM:%(cpp_debug_options)}\
+      %{!M:%{!MM:%{!E:%{!S:-o %|.s |\n\
+       as %(asm_debug) %(asm_options) %m.s %A }}}}"
+#endif
+   , 0},
+
 #include "specs.h"
-  /* Mark end of table */
+  /* Mark end of table.  */
   {0, 0, 0}
 };
 
@@ -1258,6 +1390,7 @@
    {"--param", "--param", "a"},
    {"--pedantic", "-pedantic", 0},
    {"--pedantic-errors", "-pedantic-errors", 0},
+   {"--pie", "-pie", 0},
    {"--pipe", "-pipe", 0},
    {"--prefix", "-B", "a"},
    {"--preprocess", "-E", 0},
@@ -1280,14 +1413,12 @@
    {"--static", "-static", 0},
    {"--std", "-std=", "aj"},
    {"--symbolic", "-symbolic", 0},
-   {"--target", "-b", "a"},
    {"--time", "-time", 0},
    {"--trace-includes", "-H", 0},
    {"--traditional", "-traditional", 0},
    {"--traditional-cpp", "-traditional-cpp", 0},
    {"--trigraphs", "-trigraphs", 0},
    {"--undefine-macro", "-U", "aj"},
-   {"--use-version", "-V", "a"},
    {"--user-dependencies", "-MM", 0},
    {"--verbose", "-v", 0},
    {"--warn-", "-W", "*j"},
@@ -1313,9 +1444,7 @@
    and store its length in *ARGVC.  */
 
 static void
-translate_options (argcp, argvp)
-     int *argcp;
-     const char *const **argvp;
+translate_options (int *argcp, const char *const **argvp)
 {
   int i;
   int argc = *argcp;
@@ -1325,8 +1454,7 @@
 #else
   int newvsize = (argc + 2) * 2 * sizeof (const char *);
 #endif
-  const char **newv =
-    (const char **) xmalloc (newvsize);
+  const char **newv = xmalloc (newvsize);
   int newindex = 0;
 
   i = 0;
@@ -1356,7 +1484,7 @@
                 }
 
               newvsize += spaces * sizeof (const char *);
-              newv = (const char **) xrealloc (newv, newvsize);
+	      newv =  xrealloc (newv, newvsize);
 
               sp = target_option_translations[tott_idx].replacements;
               np = xstrdup (sp);
@@ -1500,6 +1628,10 @@
             nskip += 1;
           else if (! strcmp (p, "Xlinker"))
             nskip += 1;
+	  else if (! strcmp (p, "Xpreprocessor"))
+	    nskip += 1;
+	  else if (! strcmp (p, "Xassembler"))
+	    nskip += 1;
 
           /* Watch out for an option at the end of the command line that
              is missing arguments, and avoid skipping past the end of the
@@ -1552,8 +1684,7 @@
 }
 
 static char *
-skip_whitespace (p)
-     char *p;
+skip_whitespace (char *p)
 {
   while (1)
     {
@@ -1622,6 +1753,10 @@
 
 static const char *gcc_exec_prefix;
 
+/* Adjusted value of standard_libexec_prefix.  */
+
+static const char *gcc_libexec_prefix;
+
 /* Default prefixes to attach to command names.  */
 
 #ifdef CROSS_COMPILE  /* Don't use these prefixes for a cross compiler.  */
@@ -1655,9 +1790,18 @@
 #ifndef STANDARD_BINDIR_PREFIX
 #define STANDARD_BINDIR_PREFIX "/usr/local/bin"
 #endif
+#ifndef STANDARD_LIBEXEC_PREFIX
+#define STANDARD_LIBEXEC_PREFIX "/usr/local/libexec/gcc/"
+#endif
+
 
 static const char *const standard_exec_prefix = STANDARD_EXEC_PREFIX;
+#ifndef GCC_3_4
 static const char *const standard_exec_prefix_1 = "/usr/lib/gcc/";
+#else
+static const char *const standard_exec_prefix_1 = "/usr/libexec/gcc/";
+#endif
+static const char *const standard_exec_prefix_2 = "/usr/lib/gcc/";
 static const char *md_exec_prefix = MD_EXEC_PREFIX;
 
 static const char *md_startfile_prefix = MD_STARTFILE_PREFIX;
@@ -1671,6 +1815,8 @@
 
 static const char *const standard_bindir_prefix = STANDARD_BINDIR_PREFIX;
 
+static const char *standard_libexec_prefix = STANDARD_LIBEXEC_PREFIX;
+
 /* Subdirectory to use for locating libraries.  Set by
    set_multilib_dir based on the compilation options.  */
 
@@ -1741,6 +1887,8 @@
   INIT_STATIC_SPEC ("md_startfile_prefix",      &md_startfile_prefix),
   INIT_STATIC_SPEC ("md_startfile_prefix_1",    &md_startfile_prefix_1),
   INIT_STATIC_SPEC ("startfile_prefix_spec",    &startfile_prefix_spec),
+  INIT_STATIC_SPEC ("sysroot_suffix_spec",	&sysroot_suffix_spec),
+  INIT_STATIC_SPEC ("sysroot_hdrs_suffix_spec",	&sysroot_hdrs_suffix_spec),
 };
 
 #ifdef EXTRA_SPECS              /* additional specs needed */
@@ -1781,11 +1929,8 @@
 
 #ifdef ENABLE_SHARED_LIBGCC
 static void
-init_gcc_specs (obstack, shared_name, static_name, eh_name)
-     struct obstack *obstack;
-     const char *shared_name;
-     const char *static_name;
-     const char *eh_name;
+init_gcc_specs (struct obstack *obstack, const char *shared_name,
+		const char *static_name, const char *eh_name)
 {
   char *buf;
 
@@ -1810,7 +1955,7 @@
 /* Initialize the specs lookup routines.  */
 
 static void
-init_spec ()
+init_spec (void)
 {
   struct spec_list *next = (struct spec_list *) 0;
   struct spec_list *sl   = (struct spec_list *) 0;
@@ -1823,8 +1968,8 @@
     notice ("Using built-in specs.\n");
 
 #ifdef EXTRA_SPECS
-  extra_specs = (struct spec_list *)
-    xcalloc (sizeof (struct spec_list), ARRAY_SIZE (extra_specs_1));
+  extra_specs = xcalloc (sizeof (struct spec_list),
+			 ARRAY_SIZE (extra_specs_1));
 
   for (i = ARRAY_SIZE (extra_specs_1) - 1; i >= 0; i--)
     {
@@ -1895,7 +2040,12 @@
 #endif
                             ,
                             "-lgcc",
-                            "-lgcc_eh");
+			    "-lgcc_eh"
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+			    " -lunwind"
+#endif
+			    );
+
             p += 5;
             in_sep = 0;
           }
@@ -1911,7 +2061,11 @@
 #endif
                             ,
                             "libgcc.a%s",
-                            "libgcc_eh.a%s");
+			    "libgcc_eh.a%s"
+#ifdef USE_LIBUNWIND_EXCEPTIONS
+			    " -lunwind"
+#endif
+			    );
             p += 10;
             in_sep = 0;
           }
@@ -1951,9 +2105,7 @@
    current spec.  */
 
 static void
-set_spec (name, spec)
-     const char *name;
-     const char *spec;
+set_spec (const char *name, const char *spec)
 {
   struct spec_list *sl;
   const char *old_spec;
@@ -1981,7 +2133,7 @@
   if (!sl)
     {
       /* Not found - make it.  */
-      sl = (struct spec_list *) xmalloc (sizeof (struct spec_list));
+      sl = xmalloc (sizeof (struct spec_list));
       sl->name = xstrdup (name);
       sl->name_len = name_len;
       sl->ptr_spec = &sl->ptr;
@@ -2003,7 +2155,7 @@
 
   /* Free the old spec.  */
   if (old_spec && sl->alloc_p)
-    free ((PTR) old_spec);
+    free ((void *) old_spec);
 
   sl->alloc_p = 1;
 }
@@ -2050,16 +2202,16 @@
 /* Allocate the argument vector.  */
 
 static void
-alloc_args ()
+alloc_args (void)
 {
   argbuf_length = 10;
-  argbuf = (const char **) xmalloc (argbuf_length * sizeof (const char *));
+  argbuf = xmalloc (argbuf_length * sizeof (const char *));
 }
 
 /* Clear out the vector of arguments (after a command is executed).  */
 
 static void
-clear_args ()
+clear_args (void)
 {
   argbuf_index = 0;
 }
@@ -2072,14 +2224,10 @@
     and the file should be deleted if this compilation fails.  */
 
 static void
-store_arg (arg, delete_always, delete_failure)
-     const char *arg;
-     int delete_always, delete_failure;
+store_arg (const char *arg, int delete_always, int delete_failure)
 {
   if (argbuf_index + 1 == argbuf_length)
-    argbuf
-      = (const char **) xrealloc (argbuf,
-                                  (argbuf_length *= 2) * sizeof (const char *));
+    argbuf = xrealloc (argbuf, (argbuf_length *= 2) * sizeof (const char *));
 
   argbuf[argbuf_index++] = arg;
   argbuf[argbuf_index] = 0;
@@ -2093,8 +2241,7 @@
    a single \n.  */
 
 static char *
-load_specs (filename)
-     const char *filename;
+load_specs (const char *filename)
 {
   int desc;
   int readlen;
@@ -2158,9 +2305,7 @@
    Anything invalid in the file is a fatal error.  */
 
 static void
-read_specs (filename, main_p)
-     const char *filename;
-     int main_p;
+read_specs (const char *filename, int main_p)
 {
   char *buffer;
   char *p;
@@ -2302,7 +2447,7 @@
 
               set_spec (p2, *(sl->ptr_spec));
               if (sl->alloc_p)
-                free ((PTR) *(sl->ptr_spec));
+		free ((void *) *(sl->ptr_spec));
 
               *(sl->ptr_spec) = "";
               sl->alloc_p = 0;
@@ -2372,9 +2517,8 @@
         {
           /* Add this pair to the vector.  */
           compilers
-            = ((struct compiler *)
-               xrealloc (compilers,
-                         (n_compilers + 2) * sizeof (struct compiler)));
+	    = xrealloc (compilers,
+			(n_compilers + 2) * sizeof (struct compiler));
 
           compilers[n_compilers].suffix = suffix;
           compilers[n_compilers].spec = spec;
@@ -2430,10 +2574,7 @@
    otherwise delete it in any case.  */
 
 void
-record_temp_file (filename, always_delete, fail_delete)
-     const char *filename;
-     int always_delete;
-     int fail_delete;
+record_temp_file (const char *filename, int always_delete, int fail_delete)
 {
   char *const name = xstrdup (filename);
 
@@ -2444,7 +2585,7 @@
         if (! strcmp (name, temp->name))
           goto already1;
 
-      temp = (struct temp_file *) xmalloc (sizeof (struct temp_file));
+      temp = xmalloc (sizeof (struct temp_file));
       temp->next = always_delete_queue;
       temp->name = name;
       always_delete_queue = temp;
@@ -2459,7 +2600,7 @@
         if (! strcmp (name, temp->name))
           goto already2;
 
-      temp = (struct temp_file *) xmalloc (sizeof (struct temp_file));
+      temp = xmalloc (sizeof (struct temp_file));
       temp->next = failure_delete_queue;
       temp->name = name;
       failure_delete_queue = temp;
@@ -2471,8 +2612,7 @@
 /* Delete all the temporary files whose names we previously recorded.  */
 
 static void
-delete_if_ordinary (name)
-     const char *name;
+delete_if_ordinary (const char *name)
 {
   struct stat st;
 #ifdef DEBUG
@@ -2494,7 +2634,7 @@
 }
 
 static void
-delete_temp_files ()
+delete_temp_files (void)
 {
   struct temp_file *temp;
 
@@ -2524,7 +2664,7 @@
 /* Delete all the files to be deleted on error.  */
 
 static void
-delete_failure_queue ()
+delete_failure_queue (void)
 {
   struct temp_file *temp;
 
@@ -2533,7 +2673,7 @@
 }
 
 static void
-clear_failure_queue ()
+clear_failure_queue (void)
 {
   failure_delete_queue = 0;
 }
@@ -2545,10 +2685,8 @@
    It is also used by the --print-search-dirs flag.  */
 
 static char *
-build_search_list (paths, prefix, check_dir_p)
-     struct path_prefix *paths;
-     const char *prefix;
-     int check_dir_p;
+build_search_list (struct path_prefix *paths, const char *prefix,
+		   int check_dir_p)
 {
   int suffix_len = (machine_suffix) ? strlen (machine_suffix) : 0;
   int just_suffix_len
@@ -2607,9 +2745,7 @@
    for collect.  */
 
 static void
-putenv_from_prefixes (paths, env_var)
-     struct path_prefix *paths;
-     const char *env_var;
+putenv_from_prefixes (struct path_prefix *paths, const char *env_var)
 {
   putenv (build_search_list (paths, env_var, 1));
 }
@@ -2858,9 +2994,7 @@
    except that it never considers directories to be executable.  */
 
 static int
-access_check (name, mode)
-     const char *name;
-     int mode;
+access_check (const char *name, int mode)
 {
   if (mode == X_OK)
     {
@@ -2879,10 +3013,8 @@
    Return 0 if not found, otherwise return its name, allocated with malloc.  */
 
 static char *
-find_a_file (pprefix, name, mode, multilib)
-     struct path_prefix *pprefix;
-     const char *name;
-     int mode, multilib;
+find_a_file (struct path_prefix *pprefix, const char *name, int mode,
+	     int multilib)
 {
   char *temp;
   const char *const file_suffix =
@@ -2924,7 +3056,7 @@
 
   /* Determine the filename to execute (special case for absolute paths).  */
 
-  if (IS_ABSOLUTE_PATHNAME (name))
+  if (IS_ABSOLUTE_PATH (name))
     {
       if (access (name, mode) == 0)
         {
@@ -3042,7 +3174,7 @@
   PREFIX_PRIORITY_LAST
 };
 
-/* Add an entry for PREFIX in PLIST.  The PLIST is kept in assending
+/* Add an entry for PREFIX in PLIST.  The PLIST is kept in ascending
    order according to PRIORITY.  Within each PRIORITY, new entries are
    appended.
 
@@ -3057,15 +3189,9 @@
    2 means try both machine_suffix and just_machine_suffix.  */
 
 static void
-add_prefix (pprefix, prefix, component, priority, require_machine_suffix,
-            warn, os_multilib)
-     struct path_prefix *pprefix;
-     const char *prefix;
-     const char *component;
-     /* enum prefix_priority */ int priority;
-     int require_machine_suffix;
-     int *warn;
-     int os_multilib;
+add_prefix (struct path_prefix *pprefix, const char *prefix,
+	    const char *component, /* enum prefix_priority */ int priority,
+	    int require_machine_suffix, int *warn, int os_multilib)
 {
   struct prefix_list *pl, **prev;
   int len;
@@ -3075,14 +3201,14 @@
        prev = &(*prev)->next)
     ;
 
-  /* Keep track of the longest prefix */
+  /* Keep track of the longest prefix.  */
 
   prefix = update_path (prefix, component);
   len = strlen (prefix);
   if (len > pprefix->max_len)
     pprefix->max_len = len;
 
-  pl = (struct prefix_list *) xmalloc (sizeof (struct prefix_list));
+  pl = xmalloc (sizeof (struct prefix_list));
   pl->prefix = prefix;
   pl->require_machine_suffix = require_machine_suffix;
   pl->used_flag_ptr = warn;
@@ -3091,11 +3217,36 @@
   if (warn)
     *warn = 0;
 
-  /* Insert after PREV */
+  /* Insert after PREV.  */
   pl->next = (*prev);
   (*prev) = pl;
 }
 
+/* Same as add_prefix, but prepending target_system_root to prefix.  */
+static void
+add_sysrooted_prefix (struct path_prefix *pprefix, const char *prefix,
+		      const char *component,
+		      /* enum prefix_priority */ int priority,
+		      int require_machine_suffix, int *warn, int os_multilib)
+{
+  if (!IS_ABSOLUTE_PATH (prefix))
+    abort ();
+
+  if (target_system_root)
+    {
+      if (target_sysroot_suffix)
+	  prefix = concat (target_sysroot_suffix, prefix, NULL);
+      prefix = concat (target_system_root, prefix, NULL);
+
+      /* We have to override this because GCC's notion of sysroot
+	 moves along with GCC.  */
+      component = "GCC";
+    }
+
+  add_prefix (pprefix, prefix, component, priority,
+	      require_machine_suffix, warn, os_multilib);
+}
+
 /* Execute the command specified by the arguments on the current line of spec.
    When using pipes, this includes several piped-together commands
    with `|' between them.
@@ -3103,7 +3254,7 @@
    Return 0 if successful, -1 if failed.  */
 
 static int
-execute ()
+execute (void)
 {
   int i;
   int n_commands;               /* # of command.  */
@@ -3126,7 +3277,7 @@
       n_commands++;
 
   /* Get storage for each command.  */
-  commands = (struct command *) alloca (n_commands * sizeof (struct command));
+  commands = alloca (n_commands * sizeof (struct command));
 
   /* Split argbuf into its separate piped processes,
      and record info about each one.
@@ -3196,7 +3347,14 @@
         }
       fflush (stderr);
       if (verbose_only_flag != 0)
+        {
+	  /* verbose_only_flag should act as if the spec was
+	     executed, so increment execution_count before
+	     returning.  This prevents spurious warnings about
+	     unused linker input files, etc.  */
+	  execution_count++;
         return 0;
+        }
 #ifdef DEBUG
       notice ("\nGo ahead? (y or n) ");
       fflush (stderr);
@@ -3211,7 +3369,7 @@
     }
 
 #ifdef ENABLE_VALGRIND_CHECKING
-  /* Run the each command through valgrind.  To simplifiy prepending the
+  /* Run the each command through valgrind.  To simplify prepending the
      path to valgrind and the option "-q" (for quiet operation unless
      something triggers), we allocate a separate argv array.  */
 
@@ -3259,7 +3417,7 @@
         pfatal_pexecute (errmsg_fmt, errmsg_arg);
 
       if (string != commands[i].prog)
-        free ((PTR) string);
+	free ((void *) string);
     }
 
   execution_count++;
@@ -3361,7 +3519,7 @@
    0 when initialized
    1 if the switch is true in a conditional spec,
    -1 if false (overridden by a later switch)
-   -2 if this switch should be ignored (used in %{<S})
+   -2 if this switch should be ignored (used in %<S)
    The `validated' field is nonzero if any spec has looked at this switch;
    if it remains zero at the end of the run, it must be meaningless.  */
 
@@ -3395,6 +3553,11 @@
 
 int n_infiles;
 
+/* True if multiple input files are being compiled to a single
+   assembly file.  */
+
+static bool combine_inputs;
+
 /* This counts the number of libraries added by lang_specific_driver, so that
    we can tell if there were any user supplied any files or libraries.  */
 
@@ -3420,10 +3583,8 @@
    is true if we should look for an object suffix.  */
 
 static const char *
-convert_filename (name, do_exe, do_obj)
-     const char *name;
-     int do_exe ATTRIBUTE_UNUSED;
-     int do_obj ATTRIBUTE_UNUSED;
+convert_filename (const char *name, int do_exe ATTRIBUTE_UNUSED,
+		  int do_obj ATTRIBUTE_UNUSED)
 {
 #if defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
   int i;
@@ -3473,7 +3634,7 @@
 
 /* Display the command line switches accepted by gcc.  */
 static void
-display_help ()
+display_help (void)
 {
   printf (_("Usage: %s [options] file...\n"), programname);
   fputs (_("Options:\n"), stdout);
@@ -3498,6 +3659,8 @@
   fputs (_("  -Wa,<options>            Pass comma-separated <options> on to the assembler\n"), stdout);
   fputs (_("  -Wp,<options>            Pass comma-separated <options> on to the preprocessor\n"), stdout);
   fputs (_("  -Wl,<options>            Pass comma-separated <options> on to the linker\n"), stdout);
+  fputs (_("  -Xassembler <arg>        Pass <arg> on to the assembler\n"), stdout);
+  fputs (_("  -Xpreprocessor <arg>     Pass <arg> on to the preprocessor\n"), stdout);
   fputs (_("  -Xlinker <arg>           Pass <arg> on to the linker\n"), stdout);
   fputs (_("  -save-temps              Do not delete intermediate files\n"), stdout);
   fputs (_("  -pipe                    Use pipes rather than intermediate files\n"), stdout);
@@ -3531,18 +3694,14 @@
 }
 
 static void
-add_preprocessor_option (option, len)
-     const char *option;
-     int len;
+add_preprocessor_option (const char *option, int len)
 {
   n_preprocessor_options++;
 
   if (! preprocessor_options)
-    preprocessor_options
-      = (char **) xmalloc (n_preprocessor_options * sizeof (char *));
+    preprocessor_options = xmalloc (n_preprocessor_options * sizeof (char *));
   else
-    preprocessor_options
-      = (char **) xrealloc (preprocessor_options,
+    preprocessor_options = xrealloc (preprocessor_options,
                             n_preprocessor_options * sizeof (char *));
 
   preprocessor_options [n_preprocessor_options - 1] =
@@ -3550,36 +3709,28 @@
 }
 
 static void
-add_assembler_option (option, len)
-     const char *option;
-     int len;
+add_assembler_option (const char *option, int len)
 {
   n_assembler_options++;
 
   if (! assembler_options)
-    assembler_options
-      = (char **) xmalloc (n_assembler_options * sizeof (char *));
+    assembler_options = xmalloc (n_assembler_options * sizeof (char *));
   else
-    assembler_options
-      = (char **) xrealloc (assembler_options,
+    assembler_options = xrealloc (assembler_options,
                             n_assembler_options * sizeof (char *));
 
   assembler_options [n_assembler_options - 1] = save_string (option, len);
 }
 
 static void
-add_linker_option (option, len)
-     const char *option;
-     int len;
+add_linker_option (const char *option, int len)
 {
   n_linker_options++;
 
   if (! linker_options)
-    linker_options
-      = (char **) xmalloc (n_linker_options * sizeof (char *));
+    linker_options = xmalloc (n_linker_options * sizeof (char *));
   else
-    linker_options
-      = (char **) xrealloc (linker_options,
+    linker_options = xrealloc (linker_options,
                             n_linker_options * sizeof (char *));
 
   linker_options [n_linker_options - 1] = save_string (option, len);
@@ -3589,9 +3740,7 @@
    Store its length in `n_switches'.  */
 
 static void
-process_command (argc, argv)
-     int argc;
-     const char *const *argv;
+process_command (int argc, const char **argv)
 {
   int i;
   const char *temp;
@@ -3687,34 +3836,55 @@
   /* Set up the default search paths.  If there is no GCC_EXEC_PREFIX,
      see if we can create it from the pathname specified in argv[0].  */
 
+  gcc_libexec_prefix = standard_libexec_prefix;
 #ifndef VMS
   /* FIXME: make_relative_prefix doesn't yet work for VMS.  */
   if (!gcc_exec_prefix)
     {
       gcc_exec_prefix = make_relative_prefix (argv[0], standard_bindir_prefix,
                                               standard_exec_prefix);
+      gcc_libexec_prefix = make_relative_prefix (argv[0], 
+						 standard_bindir_prefix,
+						 standard_libexec_prefix);
       if (gcc_exec_prefix)
         putenv (concat ("GCC_EXEC_PREFIX=", gcc_exec_prefix, NULL));
     }
+  else
+    gcc_libexec_prefix = make_relative_prefix (gcc_exec_prefix,
+					       standard_exec_prefix,
+					       standard_libexec_prefix);
+#else
 #endif
 
   if (gcc_exec_prefix)
     {
       int len = strlen (gcc_exec_prefix);
-
+#ifndef GCC_3_4
       if (len > (int) sizeof ("/lib/gcc-lib/") - 1
+#else
+      if (len > (int) sizeof ("/lib/gcc/") - 1
+#endif
           && (IS_DIR_SEPARATOR (gcc_exec_prefix[len-1])))
         {
+#ifndef GCC_3_4
           temp = gcc_exec_prefix + len - sizeof ("/lib/gcc-lib/") + 1;
+#else
+	  temp = gcc_exec_prefix + len - sizeof ("/lib/gcc/") + 1;
+#endif
           if (IS_DIR_SEPARATOR (*temp)
               && strncmp (temp + 1, "lib", 3) == 0
-              && IS_DIR_SEPARATOR (temp[4])
+	      && IS_DIR_SEPARATOR (temp[5])
+#ifndef GCC_3_4
               && strncmp (temp + 5, "gcc-lib", 7) == 0)
             len -= sizeof ("/lib/gcc-lib/") - 1;
+#else
+	      && strncmp (temp + 5, "gcc", 3) == 0)
+	    len -= sizeof ("/lib/gcc/") - 1;
+#endif
         }
 
       set_std_prefix (gcc_exec_prefix, len);
-      add_prefix (&exec_prefixes, gcc_exec_prefix, "GCC",
+      add_prefix (&exec_prefixes, gcc_libexec_prefix, "GCC",
                   PREFIX_PRIORITY_LAST, 0, NULL, 0);
       add_prefix (&startfile_prefixes, gcc_exec_prefix, "GCC",
                   PREFIX_PRIORITY_LAST, 0, NULL, 0);
@@ -3727,7 +3897,7 @@
   if (temp)
     {
       const char *startp, *endp;
-      char *nstore = (char *) alloca (strlen (temp) + 3);
+      char *nstore = alloca (strlen (temp) + 3);
 
       startp = endp = temp;
       while (1)
@@ -3762,7 +3932,7 @@
   if (temp && *cross_compile == '0')
     {
       const char *startp, *endp;
-      char *nstore = (char *) alloca (strlen (temp) + 3);
+      char *nstore = alloca (strlen (temp) + 3);
 
       startp = endp = temp;
       while (1)
@@ -3795,7 +3965,7 @@
   if (temp && *cross_compile == '0')
     {
       const char *startp, *endp;
-      char *nstore = (char *) alloca (strlen (temp) + 3);
+      char *nstore = alloca (strlen (temp) + 3);
 
       startp = endp = temp;
       while (1)
@@ -3829,11 +3999,11 @@
 #endif
 
   /* Convert new-style -- options to old-style.  */
-  translate_options (&argc, &argv);
+  translate_options (&argc, (const char *const **) &argv);
 
 #ifdef LANG_SPECIFIC_DRIVER
   /* Do language-specific adjustment/addition of flags.  */
-  lang_specific_driver (&argc, &argv, &added_libraries);
+  lang_specific_driver (&argc, (const char *const **) &argv, &added_libraries);
 #endif
 
   /* Scan argv twice.  Here, the first time, just count how many switches
@@ -3866,8 +4036,8 @@
         {
           /* translate_options () has turned --version into -fversion.  */
           printf (_("%s %s, based on gcc-%s\n"), programname, GPC_RELEASE_STRING, version_string);
-          fputs (_("Copyright (C) 1987-2004 Free Software Foundation, Inc.\n"),
-                 stdout);
+	  printf ("Copyright %s 2004 Free Software Foundation, Inc.\n",
+		  _("(C)"));
           fputs (_("This is free software; see the source for copying conditions.  There is NO\n\
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"),
                  stdout);
@@ -3974,6 +4144,20 @@
           n_infiles++;
           i++;
         }
+      else if (strcmp (argv[i], "-Xpreprocessor") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to `-Xpreprocessor' is missing");
+
+	  add_preprocessor_option (argv[i+1], strlen (argv[i+1]));
+	}
+      else if (strcmp (argv[i], "-Xassembler") == 0)
+	{
+	  if (i + 1 == argc)
+	    fatal ("argument to `-Xassembler' is missing");
+
+	  add_assembler_option (argv[i+1], strlen (argv[i+1]));
+	}
       else if (strcmp (argv[i], "-l") == 0)
         {
           if (i + 1 == argc)
@@ -3991,8 +4175,7 @@
         }
       else if (strcmp (argv[i], "-specs") == 0)
         {
-          struct user_specs *user = (struct user_specs *)
-            xmalloc (sizeof (struct user_specs));
+	  struct user_specs *user = xmalloc (sizeof (struct user_specs));
           if (++i >= argc)
             fatal ("argument to `-specs' is missing");
 
@@ -4006,8 +4189,7 @@
         }
       else if (strncmp (argv[i], "-specs=", 7) == 0)
         {
-          struct user_specs *user = (struct user_specs *)
-            xmalloc (sizeof (struct user_specs));
+	  struct user_specs *user = xmalloc (sizeof (struct user_specs));
           if (strlen (argv[i]) == 7)
             fatal ("argument to `-specs=' is missing");
 
@@ -4021,6 +4203,13 @@
         }
       else if (strcmp (argv[i], "-time") == 0)
         report_times = 1;
+      else if (strcmp (argv[i], "-pipe") == 0)
+	{
+	  /* -pipe has to go into the switches array as well as
+	     setting a flag.  */
+	  use_pipes = 1;
+	  n_switches++;
+	}
       else if (strcmp (argv[i], "-###") == 0)
         {
           /* This is similar to -v except that there is no execution
@@ -4176,8 +4365,7 @@
               for (j = 0; j < ARRAY_SIZE (modify_target); j++)
                 if (! strcmp (argv[i], modify_target[j].sw))
                   {
-                    char *new_name
-                      = (char *) xmalloc (strlen (modify_target[j].str)
+		    char *new_name = xmalloc (strlen (modify_target[j].str)
                                           + strlen (spec_machine));
                     const char *p, *r;
                     char *q;
@@ -4223,8 +4411,20 @@
         }
     }
 
-  if (have_c && have_o && lang_n_infiles > 1)
-    fatal ("cannot specify -o with -c or -S and multiple compilations");
+  combine_inputs = (have_c && have_o && lang_n_infiles > 1);
+
+  if ((save_temps_flag || report_times) && use_pipes)
+    {
+      /* -save-temps overrides -pipe, so that temp files are produced */
+      if (save_temps_flag)
+	error ("warning: -pipe ignored because -save-temps specified");
+      /* -time overrides -pipe because we can't get correct stats when
+	 multiple children are running at once.  */
+      else if (report_times)
+	error ("warning: -pipe ignored because -time specified");
+
+      use_pipes = 0;
+    }
 
   /* Set up the search paths before we go looking for config files.  */
 
@@ -4233,17 +4433,21 @@
   /* Use 2 as fourth arg meaning try just the machine as a suffix,
      as well as trying the machine and the version.  */
 #ifndef OS2
-  add_prefix (&exec_prefixes, standard_exec_prefix, "GCC",
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "GCC",
               PREFIX_PRIORITY_LAST, 1, warn_std_ptr, 0);
+  add_prefix (&exec_prefixes, standard_libexec_prefix, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
   add_prefix (&exec_prefixes, standard_exec_prefix, "BINUTILS",
               PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
   add_prefix (&exec_prefixes, standard_exec_prefix_1, "BINUTILS",
               PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
+  add_prefix (&exec_prefixes, standard_exec_prefix_2, "BINUTILS",
+	      PREFIX_PRIORITY_LAST, 2, warn_std_ptr, 0);
 #endif
 
   add_prefix (&startfile_prefixes, standard_exec_prefix, "BINUTILS",
               PREFIX_PRIORITY_LAST, 1, warn_std_ptr, 0);
-  add_prefix (&startfile_prefixes, standard_exec_prefix_1, "BINUTILS",
+  add_prefix (&startfile_prefixes, standard_exec_prefix_2, "BINUTILS",
               PREFIX_PRIORITY_LAST, 1, warn_std_ptr, 0);
 
   tooldir_prefix = concat (tooldir_base_prefix, spec_machine,
@@ -4256,7 +4460,7 @@
      directories, so that we can search both the user specified directory
      and the standard place.  */
 
-  if (!IS_ABSOLUTE_PATHNAME (tooldir_prefix))
+  if (!IS_ABSOLUTE_PATH (tooldir_prefix))
     {
       if (gcc_exec_prefix)
         {
@@ -4286,14 +4490,31 @@
               concat (tooldir_prefix, "lib", dir_separator_str, NULL),
               "BINUTILS", PREFIX_PRIORITY_LAST, 0, NULL, 1);
 
+#if defined(TARGET_SYSTEM_ROOT_RELOCATABLE) && !defined(VMS)
+  /* If the normal TARGET_SYSTEM_ROOT is inside of $exec_prefix,
+     then consider it to relocate with the rest of the GCC installation
+     if GCC_EXEC_PREFIX is set.
+     ``make_relative_prefix'' is not compiled for VMS, so don't call it.  */
+  if (target_system_root && gcc_exec_prefix)
+    {
+      char *tmp_prefix = make_relative_prefix (argv[0],
+					       standard_bindir_prefix,
+					       target_system_root);
+      if (tmp_prefix && access_check (tmp_prefix, F_OK) == 0)
+	{
+	  target_system_root = tmp_prefix;
+	  target_system_root_changed = 1;
+	}
+    }
+#endif
+
   /* More prefixes are enabled in main, after we read the specs file
      and determine whether this is cross-compilation or not.  */
 
   /* Then create the space for the vectors and scan again.  */
 
-  switches = ((struct switchstr *)
-              xmalloc ((n_switches + 1) * sizeof (struct switchstr)));
-  infiles = (struct infile *) xmalloc ((n_infiles + 1) * sizeof (struct infile));
+  switches = xmalloc ((n_switches + 1) * sizeof (struct switchstr));
+  infiles = xmalloc ((n_infiles + 1) * sizeof (struct infile));
   n_switches = 0;
   n_infiles = 0;
   last_language_n_infiles = -1;
@@ -4375,6 +4596,16 @@
           infiles[n_infiles].language = "*";
           infiles[n_infiles++].name = argv[++i];
         }
+      else if (strcmp (argv[i], "-Xassembler") == 0)
+	{
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = argv[++i];
+	}
+      else if (strcmp (argv[i], "-Xpreprocessor") == 0)
+	{
+	  infiles[n_infiles].language = "*";
+	  infiles[n_infiles++].name = argv[++i];
+	}
       else if (strcmp (argv[i], "-l") == 0)
         { /* POSIX allows separation of -l and the lib arg;
              canonicalize by concatenating -l with its arg */
@@ -4392,17 +4623,6 @@
         ;
       else if (strcmp (argv[i], "-time") == 0)
         ;
-      else if ((save_temps_flag || report_times)
-               && strcmp (argv[i], "-pipe") == 0)
-        {
-          /* -save-temps overrides -pipe, so that temp files are produced */
-          if (save_temps_flag)
-            error ("warning: -pipe ignored because -save-temps specified");
-          /* -time overrides -pipe because we can't get correct stats when
-             multiple children are running at once.  */
-          else if (report_times)
-            error ("warning: -pipe ignored because -time specified");
-        }
       else if (strcmp (argv[i], "-###") == 0)
         ;
       else if (argv[i][0] == '-' && argv[i][1] != 0)
@@ -4443,7 +4663,7 @@
               if (i + n_args >= argc)
                 fatal ("argument to `-%s' is missing", p);
               switches[n_switches].args
-                = (const char **) xmalloc ((n_args + 1) * sizeof(const char *));
+		= xmalloc ((n_args + 1) * sizeof(const char *));
               while (j < n_args)
                 switches[n_switches].args[j++] = argv[++i];
               /* Null-terminate the vector.  */
@@ -4453,13 +4673,12 @@
             {
               /* On some systems, ld cannot handle some options without
                  a space.  So split the option from its argument.  */
-              char *part1 = (char *) xmalloc (2);
+	      char *part1 = xmalloc (2);
               part1[0] = c;
               part1[1] = '\0';
 
               switches[n_switches].part1 = part1;
-              switches[n_switches].args
-                = (const char **) xmalloc (2 * sizeof (const char *));
+	      switches[n_switches].args = xmalloc (2 * sizeof (const char *));
               switches[n_switches].args[0] = xstrdup (p+1);
               switches[n_switches].args[1] = 0;
             }
@@ -4469,10 +4688,11 @@
           switches[n_switches].live_cond = SWITCH_OK;
           switches[n_switches].validated = 0;
           switches[n_switches].ordering = 0;
-          /* These are always valid, since gcc.c itself understands it.  */
+	  /* These are always valid, since gcc.c itself understands them.  */
           if (!strcmp (p, "save-temps")
               || !strcmp (p, "static-libgcc")
-              || !strcmp (p, "shared-libgcc"))
+	      || !strcmp (p, "shared-libgcc")
+	      || !strcmp (p, "pipe"))
             switches[n_switches].validated = 1;
           else
             {
@@ -4539,11 +4759,11 @@
   infiles[n_infiles].name = 0;
 }
 
-/* Store switches not filtered out by %{<S} in spec in COLLECT_GCC_OPTIONS
+/* Store switches not filtered out by %<S in spec in COLLECT_GCC_OPTIONS
    and place that in the environment.  */
 
 static void
-set_collect_gcc_options ()
+set_collect_gcc_options (void)
 {
   int i;
   int first_time;
@@ -4605,7 +4825,7 @@
    sans all directory names, and basename_length is the number
    of characters starting there excluding the suffix .c or whatever.  */
 
-const char *input_filename;
+static const char *input_filename;
 static int input_file_number;
 size_t input_filename_length;
 static int basename_length;
@@ -4648,8 +4868,7 @@
    Returns 0 if the spec is successfully processed; -1 if failed.  */
 
 int
-do_spec (spec)
-     const char *spec;
+do_spec (const char *spec)
 {
   int value;
 
@@ -4680,9 +4899,11 @@
 }
 
 static int
-do_spec_2 (spec)
-     const char *spec;
+do_spec_2 (const char *spec)
 {
+  const char *string;
+  int result;
+
   clear_args ();
   arg_going = 0;
   delete_this_arg = 0;
@@ -4691,7 +4912,22 @@
   input_from_pipe = 0;
   suffix_subst = NULL;
 
-  return do_spec_1 (spec, 0, NULL);
+  result = do_spec_1 (spec, 0, NULL);
+
+  /* End any pending argument.  */
+  if (arg_going)
+    {
+      obstack_1grow (&obstack, 0);
+      string = obstack_finish (&obstack);
+      if (this_is_library_file)
+	string = find_file (string);
+      store_arg (string, delete_this_arg, this_is_output_file);
+      if (this_is_output_file)
+	outfiles[input_file_number] = string;
+      arg_going = 0;
+    }
+
+  return result;
 }
 
 
@@ -4699,8 +4935,56 @@
    of the switches/n_switches array.  */
 
 static void
-do_self_spec (spec)
-     const char *spec;
+do_option_spec (const char *name, const char *spec)
+{
+  unsigned int i, value_count, value_len;
+  const char *p, *q, *value;
+  char *tmp_spec, *tmp_spec_p;
+
+  if (configure_default_options[0].name == NULL)
+    return;
+
+  for (i = 0; i < ARRAY_SIZE (configure_default_options); i++)
+    if (strcmp (configure_default_options[i].name, name) == 0)
+      break;
+  if (i == ARRAY_SIZE (configure_default_options))
+    return;
+
+  value = configure_default_options[i].value;
+  value_len = strlen (value);
+
+  /* Compute the size of the final spec.  */
+  value_count = 0;
+  p = spec;
+  while ((p = strstr (p, "%(VALUE)")) != NULL)
+    {
+      p ++;
+      value_count ++;
+    }
+
+  /* Replace each %(VALUE) by the specified value.  */
+  tmp_spec = alloca (strlen (spec) + 1
+		     + value_count * (value_len - strlen ("%(VALUE)")));
+  tmp_spec_p = tmp_spec;
+  q = spec;
+  while ((p = strstr (q, "%(VALUE)")) != NULL)
+    {
+      memcpy (tmp_spec_p, q, p - q);
+      tmp_spec_p = tmp_spec_p + (p - q);
+      memcpy (tmp_spec_p, value, value_len);
+      tmp_spec_p += value_len;
+      q = p + strlen ("%(VALUE)");
+    }
+  strcpy (tmp_spec_p, q);
+
+  do_self_spec (tmp_spec);
+}
+
+/* Process the given spec string and add any new options to the end
+   of the switches/n_switches array.  */
+
+static void
+do_self_spec (const char *spec)
 {
   do_spec_2 (spec);
   do_spec_1 (" ", 0, NULL);
@@ -4746,10 +5030,7 @@
    and the command on that line reported an error.  */
 
 static int
-do_spec_1 (spec, inswitch, soft_matched_part)
-     const char *spec;
-     int inswitch;
-     const char *soft_matched_part;
+do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)
 {
   const char *p = spec;
   int c;
@@ -4779,17 +5060,12 @@
 
         if (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], "|"))
           {
-            for (i = 0; i < n_switches; i++)
-              if (!strcmp (switches[i].part1, "pipe"))
-                break;
-
             /* A `|' before the newline means use a pipe here,
                but only if -pipe was specified.
                Otherwise, execute now and don't pass the `|' as an arg.  */
-            if (i < n_switches)
+	    if (use_pipes)
               {
                 input_from_pipe = 1;
-                switches[i].validated = 1;
                 break;
               }
             else
@@ -4878,7 +5154,7 @@
             {
               struct prefix_list *pl = startfile_prefixes.plist;
               size_t bufsize = 100;
-              char *buffer = (char *) xmalloc (bufsize);
+	      char *buffer = xmalloc (bufsize);
               int idx;
 
               for (; pl; pl = pl->next)
@@ -4889,7 +5165,7 @@
                   /* Relative directories always come from -B,
                      and it is better not to use them for searching
                      at run time.  In particular, stage1 loses.  */
-                  if (!IS_ABSOLUTE_PATHNAME (pl->prefix))
+		  if (!IS_ABSOLUTE_PATH (pl->prefix))
                     continue;
 #endif
                   /* Try subdirectory if there is one.  */
@@ -4906,7 +5182,7 @@
                               >= bufsize)
                             bufsize = (strlen (pl->prefix)
                                        + strlen (machine_suffix)) * 2 + 1;
-                          buffer = (char *) xrealloc (buffer, bufsize);
+			  buffer = xrealloc (buffer, bufsize);
                           strcpy (buffer, pl->prefix);
                           strcat (buffer, machine_suffix);
                           if (is_directory (buffer, multilib_dir, 1))
@@ -4948,7 +5224,7 @@
                           /* Remove slash from machine_suffix.  */
                           if (strlen (machine_suffix) >= bufsize)
                             bufsize = strlen (machine_suffix) * 2 + 1;
-                          buffer = (char *) xrealloc (buffer, bufsize);
+			  buffer = xrealloc (buffer, bufsize);
                           strcpy (buffer, machine_suffix);
                           idx = strlen (buffer);
                           if (IS_DIR_SEPARATOR (buffer[idx - 1]))
@@ -4969,7 +5245,7 @@
                           /* Remove slash from pl->prefix.  */
                           if (strlen (pl->prefix) >= bufsize)
                             bufsize = strlen (pl->prefix) * 2 + 1;
-                          buffer = (char *) xrealloc (buffer, bufsize);
+			  buffer = xrealloc (buffer, bufsize);
                           strcpy (buffer, pl->prefix);
                           idx = strlen (buffer);
                           if (IS_DIR_SEPARATOR (buffer[idx - 1]))
@@ -4992,7 +5268,7 @@
               char *buf;
               while (*p != 0 && *p != '\n')
                 p++;
-              buf = (char *) alloca (p - q + 1);
+	      buf = alloca (p - q + 1);
               strncpy (buf, q, p - q);
               buf[p - q] = 0;
               error ("%s", buf);
@@ -5006,7 +5282,7 @@
               char *buf;
               while (*p != 0 && *p != '\n')
                 p++;
-              buf = (char *) alloca (p - q + 1);
+	      buf = alloca (p - q + 1);
               strncpy (buf, q, p - q);
               buf[p - q] = 0;
               notice ("%s\n", buf);
@@ -5019,10 +5295,10 @@
             {
               struct stat st;
 
-              /* If save_temps_flag is off, and the HOST_BIT_BUCKET is defined,
-                 and it is not a directory, and it is writable, use it.
-                 Otherwise, fall through and treat this like any other
-                 temporary file.  */
+	      /* If save_temps_flag is off, and the HOST_BIT_BUCKET is
+		 defined, and it is not a directory, and it is
+		 writable, use it.  Otherwise, treat this like any
+		 other temporary file.  */
 
               if ((!save_temps_flag)
                   && (stat (HOST_BIT_BUCKET, &st) == 0) && (!S_ISDIR (st.st_mode))
@@ -5035,9 +5311,45 @@
                   break;
                 }
             }
+	    goto create_temp_file;
+	  case '|':
+	    if (use_pipes)
+#ifdef GCC_3_4
+	      {
+		obstack_1grow (&obstack, '-');
+		delete_this_arg = 0;
+		arg_going = 1;
+
+		/* consume suffix */
+		while (*p == '.' || ISALPHA ((unsigned char) *p))
+		  p++;
+		if (p[0] == '%' && p[1] == 'O')
+		  p += 2;
+
+		break;
+	      }
+	    goto create_temp_file;
+#else
+              do_spec_1 ("-", 0, NULL);
+            break;
+#endif
+              
+	  case 'm':
+	    if (use_pipes)
+	      {
+		/* consume suffix */
+		while (*p == '.' || ISALPHA ((unsigned char) *p))
+		  p++;
+		if (p[0] == '%' && p[1] == 'O')
+		  p += 2;
+
+		break;
+	      }
+	    goto create_temp_file;
           case 'g':
           case 'u':
           case 'U':
+	  create_temp_file:
               {
                 struct temp_name *t;
                 int suffix_length;
@@ -5058,7 +5370,7 @@
                     else
                       {
                         saved_suffix
-                          = (char *) xmalloc (suffix_length
+			  = xmalloc (suffix_length
                                               + strlen (TARGET_OBJECT_SUFFIX));
                         strncpy (saved_suffix, suffix, suffix_length);
                         strcpy (saved_suffix + suffix_length,
@@ -5121,7 +5433,7 @@
                 for (t = temp_names; t; t = t->next)
                   if (t->length == suffix_length
                       && strncmp (t->suffix, suffix, suffix_length) == 0
-                      && t->unique == (c != 'g'))
+		      && t->unique == (c == 'u' || c == 'U' || c == 'j'))
                     break;
 
                 /* Make a new association if needed.  %u and %j
@@ -5130,7 +5442,7 @@
                   {
                     if (t == 0)
                       {
-                        t = (struct temp_name *) xmalloc (sizeof (struct temp_name));
+			t = xmalloc (sizeof (struct temp_name));
                         t->next = temp_names;
                         temp_names = t;
                       }
@@ -5142,7 +5454,7 @@
                       }
                     else
                       t->suffix = save_string (suffix, suffix_length);
-                    t->unique = (c != 'g');
+		    t->unique = (c == 'u' || c == 'U' || c == 'j');
                     temp_filename = make_temp_file (t->suffix);
                     temp_filename_length = strlen (temp_filename);
                     t->filename = temp_filename;
@@ -5159,8 +5471,16 @@
             break;
 
           case 'i':
+	    if (combine_inputs)
+	      {
+		for (i = 0; (int) i < n_infiles; i++)
+		  store_arg (infiles[i].name, 0, 0);
+	      }
+	    else
+	      {
             obstack_grow (&obstack, input_filename, input_filename_length);
             arg_going = 1;
+	      }
             break;
 
           case 'I':
@@ -5176,6 +5496,18 @@
                   do_spec_1 (" ", 0, NULL);
                 }
 
+	      if (target_system_root_changed ||
+		  (target_system_root && target_sysroot_hdrs_suffix))
+		{
+		  do_spec_1 ("-isysroot", 1, NULL);
+		  /* Make this a separate argument.  */
+		  do_spec_1 (" ", 0, NULL);
+		  do_spec_1 (target_system_root, 1, NULL);
+		  if (target_sysroot_hdrs_suffix)
+		    do_spec_1 (target_sysroot_hdrs_suffix, 1, NULL);
+		  do_spec_1 (" ", 0, NULL);
+		}
+
               for (; pl; pl = pl->next)
                 {
                   do_spec_1 ("-isystem", 1, NULL);
@@ -5207,6 +5539,10 @@
             this_is_library_file = 1;
             break;
 
+	  case 'V':
+	    outfiles[input_file_number] = NULL;
+	    break;
+
           case 'w':
             this_is_output_file = 1;
             break;
@@ -5247,6 +5583,18 @@
               p = handle_braces (p + 1);
               if (p == 0)
                 return -1;
+	      /* End any pending argument.  */
+	      if (arg_going)
+		{
+		  obstack_1grow (&obstack, 0);
+		  string = obstack_finish (&obstack);
+		  if (this_is_library_file)
+		    string = find_file (string);
+		  store_arg (string, delete_this_arg, this_is_output_file);
+		  if (this_is_output_file)
+		    outfiles[input_file_number] = string;
+		  arg_going = 0;
+		}
               /* If any args were output, mark the last one for deletion
                  on failure.  */
               if (argbuf_index != cur_index)
@@ -5555,6 +5903,19 @@
             }
             break;
 
+	  case 'R':
+	    /* We assume there is a directory
+	       separator at the end of this string.  */
+	    if (target_system_root)
+	      {
+	        obstack_grow (&obstack, target_system_root,
+			      strlen (target_system_root));
+		if (target_sysroot_suffix)
+		  obstack_grow (&obstack, target_sysroot_suffix,
+				strlen (target_sysroot_suffix));
+	      }
+	    break;
+
           case 'S':
             value = do_spec_1 (startfile_spec, 0, NULL);
             if (value != 0)
@@ -5590,6 +5951,32 @@
             }
             break;
 
+	   /* Henceforth ignore the option(s) matching the pattern
+	      after the %<.  */
+	  case '<':
+	    {
+	      unsigned len = 0;
+	      int have_wildcard = 0;
+	      int i;
+
+	      while (p[len] && p[len] != ' ' && p[len] != '\t')
+		len++;
+
+	      if (p[len-1] == '*')
+		have_wildcard = 1;
+
+	      for (i = 0; i < n_switches; i++)
+		if (!strncmp (switches[i].part1, p, len - have_wildcard)
+		    && (have_wildcard || switches[i].part1[len] == '\0'))
+		  {
+		    switches[i].live_cond = SWITCH_IGNORE;
+		    switches[i].validated = 1;
+		  }
+
+	      p += len;
+	    }
+	    break;
+
           case '*':
             if (soft_matched_part)
               {
@@ -5645,7 +6032,7 @@
                     }
                   else
                     {
-                      char *x = (char *) alloca (strlen (name) * 2 + 1);
+		      char *x = alloca (strlen (name) * 2 + 1);
                       char *buf = x;
                       const char *y = name;
                       int flag = 0;
@@ -5748,11 +6135,6 @@
             }
             break;
 
-          case '|':
-            if (input_from_pipe)
-              do_spec_1 ("-", 0, NULL);
-            break;
-
           default:
             error ("spec failure: unrecognized spec option '%c'", c);
             break;
@@ -5763,7 +6145,7 @@
         /* Backslash: treat next character as ordinary.  */
         c = *p++;
 
-        /* fall through */
+	/* Fall through.  */
       default:
         /* Ordinary character: put it into the current argument.  */
         obstack_1grow (&obstack, c);
@@ -5790,8 +6172,7 @@
 /* Look up a spec function.  */
 
 static const struct spec_function *
-lookup_spec_function (name)
-     const char *name;
+lookup_spec_function (const char *name)
 {
   static const struct spec_function * const spec_function_tables[] =
   {
@@ -5814,8 +6195,7 @@
 /* Evaluate a spec function.  */
 
 static const char *
-eval_spec_function (func, args)
-     const char *func, *args;
+eval_spec_function (const char *func, const char *args)
 {
   const struct spec_function *sf;
   const char *funcval;
@@ -5887,8 +6267,7 @@
    NULL if no processing is required.  */
 
 static const char *
-handle_spec_function (p)
-     const char *p;
+handle_spec_function (const char *p)
 {
   char *func, *args;
   const char *endp, *funcval;
@@ -5943,273 +6322,305 @@
   return p;
 }
 
-/* Return 0 if we call do_spec_1 and that returns -1.  */
+/* Inline subroutine of handle_braces.  Returns true if the current
+   input suffix matches the atom bracketed by ATOM and END_ATOM.  */
+static inline bool
+input_suffix_matches (const char *atom, const char *end_atom)
+{
+  return (input_suffix
+	  && !strncmp (input_suffix, atom, end_atom - atom)
+	  && input_suffix[end_atom - atom] == '\0');
+}
 
-static const char *
-handle_braces (p)
-     const char *p;
+/* Inline subroutine of handle_braces.  Returns true if a switch
+   matching the atom bracketed by ATOM and END_ATOM appeared on the
+   command line.  */
+static inline bool
+switch_matches (const char *atom, const char *end_atom, int starred)
 {
-  const char *filter, *body = NULL, *endbody = NULL;
-  int pipe_p = 0;
-  int true_once = 0;    /* If, in %{a|b:d}, at least one of a,b was seen.  */
-  int negate;
-  int suffix;
-  int include_blanks = 1;
-  int elide_switch = 0;
-  int ordered = 0;
-
-  if (*p == '^')
-    {
-      /* A '^' after the open-brace means to not give blanks before args.  */
-      include_blanks = 0;
-      ++p;
-    }
-
-  if (*p == '|')
-    {
-      /* A `|' after the open-brace means,
-         if the test fails, output a single minus sign rather than nothing.
-         This is used in %{|!pipe:...}.  */
-      pipe_p = 1;
-      ++p;
-    }
-
-  if (*p == '<')
-    {
-      /* A `<' after the open-brace means that the switch should be
-         removed from the command-line.  */
-      elide_switch = 1;
-      ++p;
-    }
-
-next_member:
-  negate = suffix = 0;
+  int i;
+  int len = end_atom - atom;
+  int plen = starred ? len : -1;
 
-  if (*p == '!')
-    /* A `!' after the open-brace negates the condition:
-       succeed if the specified switch is not present.  */
-    negate = 1, ++p;
+  for (i = 0; i < n_switches; i++)
+    if (!strncmp (switches[i].part1, atom, len)
+	&& (starred || switches[i].part1[len] == '\0')
+	&& check_live_switch (i, plen))
+      return true;
+
+  return false;
+}
+
+/* Inline subroutine of handle_braces.  Mark all of the switches which
+   match ATOM (extends to END_ATOM; STARRED indicates whether there
+   was a star after the atom) for later processing.  */
+static inline void
+mark_matching_switches (const char *atom, const char *end_atom, int starred)
+{
+  int i;
+  int len = end_atom - atom;
+  int plen = starred ? len : -1;
 
-  if (*p == '.')
-    /* A `.' after the open-brace means test against the current suffix.  */
-    {
-      if (pipe_p)
-        abort ();
+  for (i = 0; i < n_switches; i++)
+    if (!strncmp (switches[i].part1, atom, len)
+	&& (starred || switches[i].part1[len] == '\0')
+	&& check_live_switch (i, plen))
+      switches[i].ordering = 1;
+}
 
-      suffix = 1;
-      ++p;
-    }
+/* Inline subroutine of handle_braces.  Process all the currently
+   marked switches through give_switch, and clear the marks.  */
+static inline void
+process_marked_switches (void)
+{
+  int i;
 
-  if (elide_switch && (negate || pipe_p || suffix))
+  for (i = 0; i < n_switches; i++)
+    if (switches[i].ordering == 1)
     {
-      /* It doesn't make sense to mix elision with other flags.  We
-         could fatal() here, but the standard seems to be to abort.  */
-      abort ();
+	switches[i].ordering = 0;
+	give_switch (i, 0);
     }
+}
 
- next_ampersand:
-  filter = p;
-  while (*p != ':' && *p != '}' && *p != '|' && *p != '&')
-    p++;
-
-  if (*p == '|' && (pipe_p || ordered))
-    abort ();
+/* Handle a %{ ... } construct.  P points just inside the leading {.
+   Returns a pointer one past the end of the brace block, or 0
+   if we call do_spec_1 and that returns -1.  */
 
-  if (!body)
-    {
-      if (*p != '}' && *p != '&')
-        {
-          int count = 1;
-          const char *q = p;
+static const char *
+handle_braces (const char *p)
+{
+  const char *atom, *end_atom;
+  const char *d_atom = NULL, *d_end_atom = NULL;
 
-          while (*q++ != ':')
-            continue;
-          body = q;
+  bool a_is_suffix;
+  bool a_is_starred;
+  bool a_is_negated;
+  bool a_matched;
+
+  bool a_must_be_last = false;
+  bool ordered_set    = false;
+  bool disjunct_set   = false;
+  bool disj_matched   = false;
+  bool disj_starred   = true;
+  bool n_way_choice   = false;
+  bool n_way_matched  = false;
+  bool pipe_p = false;
 
-          while (count > 0)
-            {
-              if (*q == '{')
-                count++;
-              else if (*q == '}')
-                count--;
-              else if (*q == 0)
-                fatal ("mismatched braces in specs");
-              q++;
-            }
-          endbody = q;
-        }
-      else
-        body = p, endbody = p + 1;
-    }
+#define SKIP_WHITE() do { while (*p == ' ' || *p == '\t') p++; } while (0)
 
-  if (suffix)
+  do
     {
-      int found = (input_suffix != 0
-                   && (long) strlen (input_suffix) == (long) (p - filter)
-                   && strncmp (input_suffix, filter, p - filter) == 0);
-
-      if (body[0] == '}')
+      if (a_must_be_last)
+      abort ();
+        if (*p == '|')
+	  {
+            /* A `|' after the open-brace means, if the test fails,
+	       output a single minus sign rather than nothing.
+	       This is used in %{|!pipe:...}.  */
+	    a_must_be_last = pipe_p = true;
+	    p++;
+    }
+
+      /* Scan one "atom" (S in the description above of %{}, possibly
+	 with !, ., or * modifiers).  */
+      a_matched = a_is_suffix = a_is_starred = a_is_negated = false;
+
+      SKIP_WHITE();
+      if (*p == '!')
+	p++, a_is_negated = true;
+
+      SKIP_WHITE();
+      if (*p == '.')
+	p++, a_is_suffix = true;
+
+      atom = p;
+      while (ISIDNUM(*p) || *p == '-' || *p == '+' || *p == '='
+	     || *p == ',' || *p == '.' || *p == '@' || *p == '$')
+	p++;
+      end_atom = p;
+
+      if (*p == '*')
+	p++, a_is_starred = 1;
+
+      SKIP_WHITE();
+      if (*p == '&' || *p == '}')
+    {
+	  /* Substitute the switch(es) indicated by the current atom.  */
+	  ordered_set = true;
+	  if (disjunct_set || n_way_choice || a_is_negated || a_is_suffix
+	      || atom == end_atom)
         abort ();
 
-      if (negate != found
-          && do_spec_1 (save_string (body, endbody-body-1), 0, NULL) < 0)
-        return 0;
+	  mark_matching_switches (atom, end_atom, a_is_starred);
+
+	  if (*p == '}')
+	    process_marked_switches ();
     }
-  else if (p[-1] == '*' && (p[0] == '}' || p[0] == '&'))
+      else if (*p == '|' || *p == ':')
     {
-      /* Substitute all matching switches as separate args.  */
-      int i;
+	  /* Substitute some text if the current atom appears as a switch
+	     or suffix.  */
+	  disjunct_set = true;
+	  if (ordered_set)
+	    abort ();
 
-      for (i = 0; i < n_switches; i++)
-        if (!strncmp (switches[i].part1, filter, p - 1 - filter)
-            && check_live_switch (i, p - 1 - filter))
-          {
-            if (elide_switch)
+	  if (atom == end_atom)
               {
-                switches[i].live_cond = SWITCH_IGNORE;
-                switches[i].validated = 1;
-              }
-            else
-              ordered = 1, switches[i].ordering = 1;
-          }
+	      if (!n_way_choice || disj_matched || *p == '|'
+		  || a_is_negated || a_is_suffix || a_is_starred)
+		abort ();
+
+	      /* An empty term may appear as the last choice of an
+		 N-way choice set; it means "otherwise".  */
+	      a_must_be_last = true;
+	      disj_matched = !n_way_matched;
+	      disj_starred = false;
     }
   else
     {
-      /* Test for presence of the specified switch.  */
-      int i;
-      int present = 0;
+	       if (a_is_suffix && a_is_starred)
+		 abort ();
 
-      /* If name specified ends in *, as in {x*:...},
-         check for %* and handle that case.  */
-      if (p[-1] == '*' && !negate)
-        {
-          int substitution;
-          const char *r = body;
+	       if (!a_is_starred)
+		 disj_starred = false;
 
-          /* First see whether we have %*.  */
-          substitution = 0;
-          while (r < endbody)
-            {
-              if (*r == '%' && r[1] == '*')
-                substitution = 1;
-              r++;
-            }
-          /* If we do, handle that case.  */
-          if (substitution)
-            {
-              /* Substitute all matching switches as separate args.
-                 But do this by substituting for %*
-                 in the text that follows the colon.  */
-
-              unsigned hard_match_len = p - filter - 1;
-              char *string = save_string (body, endbody - body - 1);
+	       /* Don't bother testing this atom if we already have a
+                  match.  */
+	       if (!disj_matched && !n_way_matched)
+            {
+		   if (a_is_suffix)
+		     a_matched = input_suffix_matches (atom, end_atom);
+		   else
+		     a_matched = switch_matches (atom, end_atom, a_is_starred);
 
-              for (i = 0; i < n_switches; i++)
-                if (!strncmp (switches[i].part1, filter, hard_match_len)
-                    && check_live_switch (i, -1))
+		   if (a_matched != a_is_negated)
                   {
-                    do_spec_1 (string, 0, &switches[i].part1[hard_match_len]);
-                    /* Pass any arguments this switch has.  */
-                    give_switch (i, 1, 1);
-                    suffix_subst = NULL;
+		       disj_matched = true;
+		       d_atom = atom;
+		       d_end_atom = end_atom;
                   }
-
-              /* We didn't match.  Try again.  */
-              if (*p++ == '|')
-                goto next_member;
-              return endbody;
             }
         }
 
-      /* If name specified ends in *, as in {x*:...},
-         check for presence of any switch name starting with x.  */
-      if (p[-1] == '*')
+	  if (*p == ':')
         {
-          for (i = 0; i < n_switches; i++)
-            {
-              unsigned hard_match_len = p - filter - 1;
-
-              if (!strncmp (switches[i].part1, filter, hard_match_len)
-                  && check_live_switch (i, hard_match_len))
-                {
-                  present = 1;
-                  break;
+	      /* Found the body, that is, the text to substitute if the
+		 current disjunction matches.  */
+	      p = process_brace_body (p + 1, d_atom, d_end_atom, disj_starred,
+				      disj_matched && !n_way_matched);
+	      if (p == 0)
+		return 0;
+
+	      /* If we have an N-way choice, reset state for the next
+		 disjunction.  */
+	      if (*p == ';')
+		{
+		  n_way_choice = true;
+		  n_way_matched |= disj_matched;
+		  disj_matched = false;
+		  disj_starred = true;
+		  d_atom = d_end_atom = NULL;
                 }
             }
         }
-      /* Otherwise, check for presence of exact name specified.  */
       else
+	abort ();
+      if (pipe_p && /* use_pipes */ ! (n_way_matched || disj_matched) )
         {
-          for (i = 0; i < n_switches; i++)
-            {
-              if (!strncmp (switches[i].part1, filter, p - filter)
-                  && switches[i].part1[p - filter] == 0
-                  && check_live_switch (i, -1))
-                {
-                  present = 1;
-                  break;
-                }
+	  /* Here if a %{|...} conditional fails: output a minus sign,
+	     which means "standard output" or "standard input".  */
+	  do_spec_1 ("-", 0, NULL);
             }
         }
+  while (*p++ != '}');
 
-      /* If it is as desired (present for %{s...}, absent for %{!s...})
-         then substitute either the switch or the specified
-         conditional text.  */
-      if (present != negate)
-        {
-          if (elide_switch)
+  return p;
+
+#undef SKIP_WHITE
+}
+
+/* Subroutine of handle_braces.  Scan and process a brace substitution body
+   (X in the description of %{} syntax).  P points one past the colon;
+   ATOM and END_ATOM bracket the first atom which was found to be true
+   (present) in the current disjunction; STARRED indicates whether all
+   the atoms in the current disjunction were starred (for syntax validation);
+   MATCHED indicates whether the disjunction matched or not, and therefore
+   whether or not the body is to be processed through do_spec_1 or just
+   skipped.  Returns a pointer to the closing } or ;, or 0 if do_spec_1
+   returns -1.  */
+
+static const char *
+process_brace_body (const char *p, const char *atom, const char *end_atom,
+		    int starred, int matched)
+{
+  const char *body, *end_body;
+  unsigned int nesting_level;
+  bool have_subst     = false;
+
+  /* Locate the closing } or ;, honoring nested braces.
+     Trim trailing whitespace.  */
+  body = p;
+  nesting_level = 1;
+  for (;;)
             {
-              switches[i].live_cond = SWITCH_IGNORE;
-              switches[i].validated = 1;
-            }
-          else if (ordered || *p == '&')
-            ordered = 1, switches[i].ordering = 1;
+      if (*p == '{')
+	nesting_level++;
           else if (*p == '}')
-            give_switch (i, 0, include_blanks);
-          else
-            /* Even if many alternatives are matched, only output once.  */
-            true_once = 1;
-        }
-      else if (pipe_p)
         {
-          /* Here if a %{|...} conditional fails: output a minus sign,
-             which means "standard output" or "standard input".  */
-          do_spec_1 ("-", 0, NULL);
-          return endbody;
+	  if (!--nesting_level)
+	    break;
         }
-    }
+      else if (*p == ';' && nesting_level == 1)
+	break;
+      else if (*p == '%' && p[1] == '*' && nesting_level == 1)
+	have_subst = true;
+      else if (*p == '\0')
+	abort ();
+      p++;
+    }
+
+  end_body = p;
+  while (end_body[-1] == ' ' || end_body[-1] == '\t')
+    end_body--;
 
-  /* We didn't match; try again.  */
-  if (*p++ == '|')
-    goto next_member;
+  if (have_subst && !starred)
+    abort ();
 
-  if (p[-1] == '&')
+  if (matched)
+    {
+      /* Copy the substitution body to permanent storage and execute it.
+	 If have_subst is false, this is a simple matter of running the
+	 body through do_spec_1...  */
+      char *string = save_string (body, end_body - body);
+      if (!have_subst)
     {
-      body = 0;
-      goto next_ampersand;
+	  if (do_spec_1 (string, 0, NULL) < 0)
+	    return 0;
     }
-
-  if (ordered)
+      else
     {
+	  /* ... but if have_subst is true, we have to process the
+	     body once for each matching switch, with %* set to the
+	     variant part of the switch.  */
+	  unsigned int hard_match_len = end_atom - atom;
       int i;
-      /* Doing this set of switches later preserves their command-line
-         ordering.  This is needed for e.g. -U, -D and -A.  */
+
       for (i = 0; i < n_switches; i++)
-        if (switches[i].ordering == 1)
+	    if (!strncmp (switches[i].part1, atom, hard_match_len)
+		&& check_live_switch (i, hard_match_len))
           {
-            switches[i].ordering = 0;
-            give_switch (i, 0, include_blanks);
+		if (do_spec_1 (string, 0,
+			       &switches[i].part1[hard_match_len]) < 0)
+		  return 0;
+		/* Pass any arguments this switch has.  */
+		give_switch (i, 1);
+		suffix_subst = NULL;
           }
     }
-  /* Process the spec just once, regardless of match count.  */
-  else if (true_once)
-    {
-      if (do_spec_1 (save_string (body, endbody - body - 1),
-                     0, NULL) < 0)
-        return 0;
     }
 
-  return endbody;
+  return p;
 }
 
 /* Return 0 iff switch number SWITCHNUM is obsoleted by a later switch
@@ -6221,9 +6632,7 @@
    with the "no-", similarly for a switch with the "no-" prefix.  */
 
 static int
-check_live_switch (switchnum, prefix_length)
-     int switchnum;
-     int prefix_length;
+check_live_switch (int switchnum, int prefix_length)
 {
   const char *name = switches[switchnum].part1;
   int i;
@@ -6294,16 +6703,10 @@
    the vector of switches gcc received, which is `switches'.
    This cannot fail since it never finishes a command line.
 
-   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.
-
-   If INCLUDE_BLANKS is nonzero, then we include blanks before each argument
-   of the switch.  */
+   If OMIT_FIRST_WORD is nonzero, then we omit .part1 of the argument.  */
 
 static void
-give_switch (switchnum, omit_first_word, include_blanks)
-     int switchnum;
-     int omit_first_word;
-     int include_blanks;
+give_switch (int switchnum, int omit_first_word)
 {
   if (switches[switchnum].live_cond == SWITCH_IGNORE)
     return;
@@ -6321,7 +6724,6 @@
         {
           const char *arg = *p;
 
-          if (include_blanks)
             do_spec_1 (" ", 0, NULL);
           if (suffix_subst)
             {
@@ -6354,8 +6756,7 @@
    Return the absolute file name found.  If nothing is found, return NAME.  */
 
 static const char *
-find_file (name)
-     const char *name;
+find_file (const char *name)
 {
   char *newname;
 
@@ -6380,14 +6781,11 @@
    limit.  */
 
 static int
-is_directory (path1, path2, linker)
-     const char *path1;
-     const char *path2;
-     int linker;
+is_directory (const char *path1, const char *path2, int linker)
 {
   int len1 = strlen (path1);
   int len2 = strlen (path2);
-  char *path = (char *) alloca (3 + len1 + len2);
+  char *path = alloca (3 + len1 + len2);
   char *cp;
   struct stat st;
 
@@ -6425,8 +6823,7 @@
    the input file named FILENAME.  */
 
 void
-set_input (filename)
-     const char *filename;
+set_input (const char *filename)
 {
   const char *p;
 
@@ -6467,8 +6864,7 @@
 /* On fatal signals, delete all the temporary files.  */
 
 static void
-fatal_error (signum)
-     int signum;
+fatal_error (int signum)
 {
   signal (signum, SIG_DFL);
   delete_failure_queue ();
@@ -6478,16 +6874,15 @@
   kill (getpid (), signum);
 }
 
-extern int main PARAMS ((int, const char *const *));
+extern int main (int, const char **);
 
 int
-main (argc, argv)
-     int argc;
-     const char *const *argv;
+main (int argc, const char **argv)
 {
   size_t i;
   int value;
   int linker_was_run = 0;
+  int num_linker_inputs = 0;
   char *explicit_link_files;
   char *specs_file;
   const char *p;
@@ -6598,18 +6993,11 @@
 
   process_command (argc, argv);
 
-  /* Process DRIVER_SELF_SPECS, adding any new options to the end
-     of the command line.  */
-
-  for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)
-    do_self_spec (driver_self_specs[i]);
-
   /* Initialize the vector of specs to just the default.
      This means one element containing 0s, as a terminator.  */
 
-  compilers = (struct compiler *) xmalloc (sizeof default_compilers);
-  memcpy ((char *) compilers, (char *) default_compilers,
-          sizeof default_compilers);
+  compilers = xmalloc (sizeof default_compilers);
+  memcpy (compilers, default_compilers, sizeof default_compilers);
   n_compilers = n_default_compilers;
 
   /* Read specs from a file if there is one.  */
@@ -6627,9 +7015,8 @@
 
   /* We need to check standard_exec_prefix/just_machine_suffix/specs
      for any override of as, ld and libraries.  */
-  specs_file = (char *) alloca (strlen (standard_exec_prefix)
-                                + strlen (just_machine_suffix)
-                                + sizeof ("specs"));
+  specs_file = alloca (strlen (standard_exec_prefix)
+		       + strlen (just_machine_suffix) + sizeof ("specs"));
 
   strcpy (specs_file, standard_exec_prefix);
   strcat (specs_file, just_machine_suffix);
@@ -6637,40 +7024,92 @@
   if (access (specs_file, R_OK) == 0)
     read_specs (specs_file, TRUE);
 
+  /* Process any configure-time defaults specified for the command line
+     options, via OPTION_DEFAULT_SPECS.  */
+  for (i = 0; i < ARRAY_SIZE (option_default_specs); i++)
+    do_option_spec (option_default_specs[i].name,
+		    option_default_specs[i].spec);
+
+  /* Process DRIVER_SELF_SPECS, adding any new options to the end
+     of the command line.  */
+
+  for (i = 0; i < ARRAY_SIZE (driver_self_specs); i++)
+    do_self_spec (driver_self_specs[i]);
+
 #ifdef GPC
   init_automake_temp_file (argc, argv);
   check_amtmpfile_switch ();
 #endif
 
-  /* If not cross-compiling, look for startfiles in the standard places.
-     Similarly, don't add the standard prefixes if startfile handling
-     will be under control of startfile_prefix_spec.  */
-  if (*cross_compile == '0' && *startfile_prefix_spec == 0)
+  /* If not cross-compiling, look for executables in the standard
+     places.  */
+  if (*cross_compile == '0')
     {
       if (*md_exec_prefix)
         {
           add_prefix (&exec_prefixes, md_exec_prefix, "GCC",
                       PREFIX_PRIORITY_LAST, 0, NULL, 0);
-          add_prefix (&startfile_prefixes, md_exec_prefix, "GCC",
-                      PREFIX_PRIORITY_LAST, 0, NULL, 0);
+	}
         }
 
-      if (*md_startfile_prefix)
-        add_prefix (&startfile_prefixes, md_startfile_prefix, "GCC",
+  /* Process sysroot_suffix_spec.  */
+  if (*sysroot_suffix_spec != 0
+      && do_spec_2 (sysroot_suffix_spec) == 0)
+    {
+      if (argbuf_index > 1)
+        error ("spec failure: more than one arg to SYSROOT_SUFFIX_SPEC.");
+      else if (argbuf_index == 1)
+        target_sysroot_suffix = xstrdup (argbuf[argbuf_index -1]);
+    }
+
+  /* Process sysroot_hdrs_suffix_spec.  */
+  if (*sysroot_hdrs_suffix_spec != 0
+      && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)
+    {
+      if (argbuf_index > 1)
+        error ("spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC.");
+      else if (argbuf_index == 1)
+        target_sysroot_hdrs_suffix = xstrdup (argbuf[argbuf_index -1]);
+    }
+
+  /* Look for startfiles in the standard places.  */
+  if (*startfile_prefix_spec != 0
+      && do_spec_2 (startfile_prefix_spec) == 0
+      && do_spec_1 (" ", 0, NULL) == 0)
+    {
+      int ndx;
+      for (ndx = 0; ndx < argbuf_index; ndx++)
+	add_sysrooted_prefix (&startfile_prefixes, argbuf[ndx], "BINUTILS",
                     PREFIX_PRIORITY_LAST, 0, NULL, 1);
+    }
+  /* We should eventually get rid of all these and stick to
+     startfile_prefix_spec exclusively.  */
+  else if (*cross_compile == '0' || target_system_root)
+    {
+      if (*md_exec_prefix)
+	add_sysrooted_prefix (&startfile_prefixes, md_exec_prefix, "GCC",
+			      PREFIX_PRIORITY_LAST, 0, NULL, 1);
+
+      if (*md_startfile_prefix)
+	add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix,
+			      "GCC", PREFIX_PRIORITY_LAST, 0, NULL, 1);
 
       if (*md_startfile_prefix_1)
-        add_prefix (&startfile_prefixes, md_startfile_prefix_1, "GCC",
-                    PREFIX_PRIORITY_LAST, 0, NULL, 1);
+	add_sysrooted_prefix (&startfile_prefixes, md_startfile_prefix_1,
+			      "GCC", PREFIX_PRIORITY_LAST, 0, NULL, 1);
 
       /* If standard_startfile_prefix is relative, base it on
          standard_exec_prefix.  This lets us move the installed tree
          as a unit.  If GCC_EXEC_PREFIX is defined, base
-         standard_startfile_prefix on that as well.  */
-      if (IS_ABSOLUTE_PATHNAME (standard_startfile_prefix))
-        add_prefix (&startfile_prefixes, standard_startfile_prefix, "BINUTILS",
+	 standard_startfile_prefix on that as well.
+
+         If the prefix is relative, only search it for native compilers;
+         otherwise we will search a directory containing host libraries.  */
+      if (IS_ABSOLUTE_PATH (standard_startfile_prefix))
+	add_sysrooted_prefix (&startfile_prefixes,
+			      standard_startfile_prefix, "BINUTILS",
                     PREFIX_PRIORITY_LAST, 0, NULL, 1);
-      else
+      else if (*cross_compile == '0')
         {
           if (gcc_exec_prefix)
             add_prefix (&startfile_prefixes,
@@ -6684,34 +7123,15 @@
                       NULL, PREFIX_PRIORITY_LAST, 0, NULL, 1);
         }
 
-      add_prefix (&startfile_prefixes, standard_startfile_prefix_1,
+      add_sysrooted_prefix (&startfile_prefixes, standard_startfile_prefix_1,
                   "BINUTILS", PREFIX_PRIORITY_LAST, 0, NULL, 1);
-      add_prefix (&startfile_prefixes, standard_startfile_prefix_2,
+      add_sysrooted_prefix (&startfile_prefixes, standard_startfile_prefix_2,
                   "BINUTILS", PREFIX_PRIORITY_LAST, 0, NULL, 1);
 #if 0 /* Can cause surprises, and one can use -B./ instead.  */
       add_prefix (&startfile_prefixes, "./", NULL,
                   PREFIX_PRIORITY_LAST, 1, NULL, 0);
 #endif
     }
-  else
-    {
-      if (!IS_ABSOLUTE_PATHNAME (standard_startfile_prefix)
-          && gcc_exec_prefix)
-        add_prefix (&startfile_prefixes,
-                    concat (gcc_exec_prefix, machine_suffix,
-                            standard_startfile_prefix, NULL),
-                    "BINUTILS", PREFIX_PRIORITY_LAST, 0, NULL, 1);
-    }
-
-  if (*startfile_prefix_spec != 0
-      && do_spec_2 (startfile_prefix_spec) == 0
-      && do_spec_1 (" ", 0, NULL) == 0)
-    {
-      int ndx;
-      for (ndx = 0; ndx < argbuf_index; ndx++)
-        add_prefix (&startfile_prefixes, argbuf[ndx], "BINUTILS",
-                    PREFIX_PRIORITY_LAST, 0, NULL, 1);
-    }
 
   /* Process any user specified specs in the order given on the command
      line.  */
@@ -6865,14 +7285,35 @@
 
   i = n_infiles;
   i += lang_specific_extra_outfiles;
-  outfiles = (const char **) xcalloc (i, sizeof (char *));
+  outfiles = xcalloc (i, sizeof (char *));
 
   /* Record which files were specified explicitly as link input.  */
 
   explicit_link_files = xcalloc (1, n_infiles);
 
+  if (combine_inputs)
+    {
+       int lang_n_infiles = 0;
   for (i = 0; (int) i < n_infiles; i++)
     {
+	   const char *name = infiles[i].name;
+	   struct compiler *compiler
+	     = lookup_compiler (name, strlen (name), infiles[i].language);
+	   if (compiler == NULL)
+	     error ("%s: linker input file unused because linking not done",
+		    name);
+	   else if (lang_n_infiles > 0 && compiler != input_file_compiler)
+	     fatal ("cannot specify -o with -c or -S and multiple languages");
+	   else
+	     {
+	       lang_n_infiles++;
+	       input_file_compiler = compiler;
+	     }
+	 }
+    }
+  
+  for (i = 0; (int) i < (combine_inputs ? 1 : n_infiles); i++)
+    {
       int this_file_error = 0;
 
       /* Tell do_spec what to substitute for %i.  */
@@ -6886,6 +7327,7 @@
 
       /* Figure out which compiler from the file's suffix.  */
 
+      if (! combine_inputs)
       input_file_compiler
         = lookup_compiler (infiles[i].name, input_filename_length,
                            infiles[i].language);
@@ -6941,9 +7383,15 @@
         error_count++;
     }
 
+  /* Determine if there are any linker input files.  */
+  num_linker_inputs = 0;
+  for (i = 0; (int) i < n_infiles; i++)
+    if (explicit_link_files[i] || outfiles[i] != NULL)
+      num_linker_inputs++;
+
   /* Run ld to link all the compiler output files.  */
 
-  if (error_count == 0)
+  if (num_linker_inputs > 0 && error_count == 0)
     {
       int tmp = execution_count;
 
@@ -7000,10 +7448,7 @@
    or 0 if this file is to be passed to the linker.  */
 
 static struct compiler *
-lookup_compiler (name, length, language)
-     const char *name;
-     size_t length;
-     const char *language;
+lookup_compiler (const char *name, size_t length, const char *language)
 {
   struct compiler *cp;
 
@@ -7069,9 +7514,7 @@
 }
 
 static char *
-save_string (s, len)
-     const char *s;
-     int len;
+save_string (const char *s, int len)
 {
   char *result = xmalloc (len + 1);
 
@@ -7081,8 +7524,7 @@
 }
 
 void
-pfatal_with_name (name)
-     const char *name;
+pfatal_with_name (const char *name)
 {
   perror_with_name (name);
   delete_temp_files ();
@@ -7090,16 +7532,13 @@
 }
 
 static void
-perror_with_name (name)
-     const char *name;
+perror_with_name (const char *name)
 {
   error ("%s: %s", name, xstrerror (errno));
 }
 
 static void
-pfatal_pexecute (errmsg_fmt, errmsg_arg)
-     const char *errmsg_fmt;
-     const char *errmsg_arg;
+pfatal_pexecute (const char *errmsg_fmt, const char *errmsg_arg)
 {
   if (errmsg_arg)
     {
@@ -7116,136 +7555,153 @@
   pfatal_with_name (errmsg_fmt);
 }
 
-/* Output an error message and exit */
+/* Output an error message and exit.  */
 
 void
-fancy_abort ()
+fancy_abort (void)
 {
   fatal ("internal gpc abort");
 }
 
-/* Output an error message and exit */
+/* Output an error message and exit.  */
 
 void
-fatal VPARAMS ((const char *msgid, ...))
+fatal (const char *msgid, ...)
 {
-  VA_OPEN (ap, msgid);
-  VA_FIXEDARG (ap, const char *, msgid);
+  va_list ap;
+
+  va_start (ap, msgid);
 
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, _(msgid), ap);
-  VA_CLOSE (ap);
+  va_end (ap);
   fprintf (stderr, "\n");
   delete_temp_files ();
   safe_exit (1);
 }
 
 void
-error VPARAMS ((const char *msgid, ...))
+error (const char *msgid, ...)
 {
-  VA_OPEN (ap, msgid);
-  VA_FIXEDARG (ap, const char *, msgid);
+  va_list ap;
 
+  va_start (ap, msgid);
   fprintf (stderr, "%s: ", programname);
   vfprintf (stderr, _(msgid), ap);
-  VA_CLOSE (ap);
+  va_end (ap);
 
   fprintf (stderr, "\n");
 }
 
 static void
-notice VPARAMS ((const char *msgid, ...))
+notice (const char *msgid, ...)
 {
-  VA_OPEN (ap, msgid);
-  VA_FIXEDARG (ap, const char *, msgid);
+  va_list ap;
 
+  va_start (ap, msgid);
   vfprintf (stderr, _(msgid), ap);
-  VA_CLOSE (ap);
+  va_end (ap);
+}
+
+static inline void
+validate_switches_from_spec (const char *spec)
+{
+  const char *p = spec;
+  char c;
+  while ((c = *p++))
+    if (c == '%' && (*p == '{' || *p == '<' || (*p == 'W' && *++p == '{')))
+      /* We have a switch spec.  */
+      p = validate_switches (p + 1);
 }
 
 static void
-validate_all_switches ()
+validate_all_switches (void)
 {
   struct compiler *comp;
-  const char *p;
-  char c;
   struct spec_list *spec;
 
   for (comp = compilers; comp->spec; comp++)
-    {
-      p = comp->spec;
-      while ((c = *p++))
-        if (c == '%' && (*p == '{' || (*p == 'W' && *++p == '{')))
-          /* We have a switch spec.  */
-          validate_switches (p + 1);
-    }
+    validate_switches_from_spec (comp->spec);
 
   /* Look through the linked list of specs read from the specs file.  */
   for (spec = specs; spec; spec = spec->next)
-    {
-      p = *(spec->ptr_spec);
-      while ((c = *p++))
-        if (c == '%' && (*p == '{' || (*p == 'W' && *++p == '{')))
-          /* We have a switch spec.  */
-          validate_switches (p + 1);
-    }
+    validate_switches_from_spec (*spec->ptr_spec);
 
-  p = link_command_spec;
-  while ((c = *p++))
-    if (c == '%' && (*p == '{' || (*p == 'W' && *++p == '{')))
-      /* We have a switch spec.  */
-      validate_switches (p + 1);
+  validate_switches_from_spec (link_command_spec);
 }
 
 /* Look at the switch-name that comes after START
    and mark as valid all supplied switches that match it.  */
 
-static void
-validate_switches (start)
-     const char *start;
+static const char *
+validate_switches (const char *start)
 {
   const char *p = start;
-  const char *filter;
+  const char *atom;
+  size_t len;
   int i;
-  int suffix;
+  bool suffix = false;
+  bool starred = false;
 
-  if (*p == '|')
-    ++p;
+#define SKIP_WHITE() do { while (*p == ' ' || *p == '\t') p++; } while (0)
 
 next_member:
+  SKIP_WHITE ();
+
   if (*p == '!')
-    ++p;
+    p++;
 
-  suffix = 0;
+  SKIP_WHITE ();
   if (*p == '.')
-    suffix = 1, ++p;
+    suffix = true, p++;
 
-  filter = p;
-  while (*p != ':' && *p != '}' && *p != '|' && *p != '&')
+  atom = p;
+  while (ISIDNUM (*p) || *p == '-' || *p == '+' || *p == '='
+	 || *p == ',' || *p == '.' || *p == '@')
     p++;
+  len = p - atom;
 
-  if (suffix)
-    ;
-  else if (p[-1] == '*')
+  if (*p == '*')
+    starred = true, p++;
+
+  SKIP_WHITE ();
+
+  if (!suffix)
     {
       /* Mark all matching switches as valid.  */
       for (i = 0; i < n_switches; i++)
-        if (!strncmp (switches[i].part1, filter, p - filter - 1))
+	if (!strncmp (switches[i].part1, atom, len)
+	    && (starred || switches[i].part1[len] == 0))
           switches[i].validated = 1;
     }
-  else
+
+  if (*p) p++;
+  if (*p && (p[-1] == '|' || p[-1] == '&'))
+    goto next_member;
+
+  if (*p && p[-1] == ':')
     {
-      /* Mark an exact matching switch as valid.  */
-      for (i = 0; i < n_switches; i++)
+      while (*p && *p != ';' && *p != '}')
         {
-          if (!strncmp (switches[i].part1, filter, p - filter)
-              && switches[i].part1[p - filter] == 0)
-            switches[i].validated = 1;
+	  if (*p == '%')
+	    {
+	      p++;
+	      if (*p == '{' || *p == '<')
+		p = validate_switches (p+1);
+	      else if (p[0] == 'W' && p[1] == '{')
+		p = validate_switches (p+2);
         }
+	  else
+	    p++;
     }
 
-  if (*p++ == '|' || p[-1] == '&')
+      if (*p) p++;
+      if (*p && p[-1] == ';')
     goto next_member;
+    }
+
+  return p;
+#undef SKIP_WHITE
 }
 
 struct mdswitchstr
@@ -7261,9 +7717,7 @@
    canonicalize the switches to keep only the ones we care about.  */
 
 static int
-used_arg (p, len)
-     const char *p;
-     int len;
+used_arg (const char *p, int len)
 {
   struct mswitchstr
   {
@@ -7289,8 +7743,7 @@
         if (*q == ';')
           cnt++;
 
-      matches =
-        (struct mswitchstr *) alloca ((sizeof (struct mswitchstr)) * cnt);
+      matches = alloca ((sizeof (struct mswitchstr)) * cnt);
       i = 0;
       q = multilib_matches;
       while (*q != '\0')
@@ -7322,8 +7775,7 @@
          xmalloc from calling fatal, and prevents us from re-executing this
          block of code.  */
       mswitches
-        = (struct mswitchstr *)
-          xmalloc (sizeof (struct mswitchstr)
+	= xmalloc (sizeof (struct mswitchstr)
                    * (n_mdswitches + (n_switches ? n_switches : 1)));
       for (i = 0; i < n_switches; i++)
         {
@@ -7401,9 +7853,7 @@
 }
 
 static int
-default_arg (p, len)
-     const char *p;
-     int len;
+default_arg (const char *p, int len)
 {
   int i;
 
@@ -7426,7 +7876,7 @@
    will be used.  */
 
 static void
-set_multilib_dir ()
+set_multilib_dir (void)
 {
   const char *p;
   unsigned int this_path_len;
@@ -7452,9 +7902,7 @@
     {
       int i = 0;
 
-      mdswitches
-        = (struct mdswitchstr *) xmalloc (sizeof (struct mdswitchstr)
-                                          * n_mdswitches);
+      mdswitches = xmalloc (sizeof (struct mdswitchstr) * n_mdswitches);
       for (start = multilib_defaults; *start != '\0'; start = end + 1)
         {
           while (*start == ' ' || *start == '\t')
@@ -7661,7 +8109,7 @@
    the exclusions.  */
 
 static void
-print_multilib_info ()
+print_multilib_info (void)
 {
   const char *p = multilib_select;
   const char *last_path = 0, *this_path;
@@ -7909,12 +8357,10 @@
    (whose name has been expanded with %s).  */
 
 static const char *
-if_exists_spec_function (argc, argv)
-     int argc;
-     const char **argv;
+if_exists_spec_function (int argc, const char **argv)
 {
   /* Must have only one argument.  */
-  if (argc == 1 && IS_ABSOLUTE_PATHNAME (argv[0]) && ! access (argv[0], R_OK))
+  if (argc == 1 && IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
     return argv[0];
 
   return NULL;
@@ -7926,15 +8372,13 @@
    is returned if the first argument does not exist.  */
 
 static const char *
-if_exists_else_spec_function (argc, argv)
-     int argc;
-     const char **argv;
+if_exists_else_spec_function (int argc, const char **argv)
 {
   /* Must have exactly two arguments.  */
   if (argc != 2)
     return NULL;
 
-  if (IS_ABSOLUTE_PATHNAME (argv[0]) && ! access (argv[0], R_OK))
+  if (IS_ABSOLUTE_PATH (argv[0]) && ! access (argv[0], R_OK))
     return argv[0];
 
   return argv[1];
@@ -7978,7 +8422,7 @@
     }
   if (!new_argc)
     return;
-  argv = (const char **) xmalloc ((argc + new_argc + 1) * sizeof (const char *));
+  argv = (const char **) xmalloc ((argc + new_argc+1) * sizeof (const char *));
   memcpy (argv, *argvp, argc * sizeof (const char *));
   memcpy (argv + argc, new_argv, new_argc * sizeof (const char *));
   argv [argc + new_argc] = NULL;
@@ -8236,7 +8680,7 @@
 {
   printf("\
 GNU Pascal version %s, based on gcc-%s.\n\
-Copyright (C) 1987-2004 Free Software Foundation, Inc.\n\
+Copyright (C) 1987-2003 Free Software Foundation, Inc.\n\
 \n\
 GNU Pascal is free software; you can redistribute it and/or modify\n\
 it under the terms of the GNU General Public License as published by\n\
@@ -8359,6 +8803,7 @@
 }
 #endif
 
+#ifndef GCC_3_4
 #ifndef HAVE_PUTENV
 void
 putenv (str)
@@ -8398,6 +8843,7 @@
          sizeof (char *) * (num_envs+1));
 }
 #endif
+#endif
 
 #ifndef EGCS
 /* We need to provide a type for gcc_uint64_t.  */
