Index: cyrus-sasl2-2.1.25.dfsg1/saslauthd/auth_rimap.c
===================================================================
--- cyrus-sasl2-2.1.25.dfsg1.orig/saslauthd/auth_rimap.c	2013-05-16 15:36:35.000000000 +0000
+++ cyrus-sasl2-2.1.25.dfsg1/saslauthd/auth_rimap.c	2013-05-16 15:43:24.000000000 +0000
@@ -1,3 +1,4 @@
+
 /* MODULE: auth_rimap */
 
 /* COPYRIGHT
@@ -367,6 +368,39 @@
     alarm(NETWORK_IO_TIMEOUT);
     rc = read(s, rbuf, sizeof(rbuf));
     alarm(0);
+    if ( rc>0 ) {
+        /* check if there is more to read */
+        fd_set         perm;
+        int            fds, ret, loopc;
+        struct timeval timeout;
+
+        FD_ZERO(&perm);
+        FD_SET(s, &perm);
+        fds = s +1;
+
+        timeout.tv_sec  = 1;
+        timeout.tv_usec = 0;
+        loopc = 0;
+        while( select (fds, &perm, NULL, NULL, &timeout ) >0 ) {
+           if ( FD_ISSET(s, &perm) ) {
+              ret = read(s, rbuf+rc, sizeof(rbuf)-rc);
+              if ( ret<0 ) {
+                 rc = ret;
+                 break;
+              } else {
+                 if (ret == 0) {
+                   loopc += 1;
+                 } else {
+                   loopc = 0;
+                 }
+                 if (loopc > sizeof(rbuf)) { // arbitrary chosen value
+                   break;
+                 }
+                 rc += ret;
+              }
+           }
+        }
+    }
     if (rc == -1) {
 	syslog(LOG_WARNING, "auth_rimap: read (banner): %m");
 	(void) close(s);
@@ -456,6 +490,39 @@
     alarm(NETWORK_IO_TIMEOUT);
     rc = read(s, rbuf, sizeof(rbuf));
     alarm(0);
+    if ( rc>0 ) {
+        /* check if there is more to read */
+        fd_set         perm;
+        int            fds, ret, loopc;
+        struct timeval timeout;
+
+        FD_ZERO(&perm);
+        FD_SET(s, &perm);
+        fds = s +1;
+
+        timeout.tv_sec  = 1;
+        timeout.tv_usec = 0;
+        loopc = 0;
+        while( select (fds, &perm, NULL, NULL, &timeout ) >0 ) {
+           if ( FD_ISSET(s, &perm) ) {
+              ret = read(s, rbuf+rc, sizeof(rbuf)-rc);
+              if ( ret<0 ) {
+                 rc = ret;
+                 break;
+              } else {
+                 if (ret == 0) {
+                   loopc += 1;
+                 } else {
+                   loopc = 0;
+                 }
+                 if (loopc > sizeof(rbuf)) { // arbitrary chosen value
+                   break;
+                 }
+                 rc += ret;
+              }
+           }
+        }
+    }
     (void) close(s);			/* we're done with the remote */
     if (rc == -1) {
 	syslog(LOG_WARNING, "auth_rimap: read (response): %m");
Index: cyrus-sasl2-2.1.25.dfsg1/lib/checkpw.c
===================================================================
--- cyrus-sasl2-2.1.25.dfsg1.orig/lib/checkpw.c	2013-05-16 15:36:35.000000000 +0000
+++ cyrus-sasl2-2.1.25.dfsg1/lib/checkpw.c	2013-05-16 15:36:53.000000000 +0000
@@ -587,16 +587,14 @@
 	    /* Timeout. */
 	    errno = ETIMEDOUT;
 	    return -1;
-	case +1:
-	    if (FD_ISSET(fd, &rfds)) {
-		/* Success, file descriptor is readable. */
-		return 0;
-	    }
-	    return -1;
 	case -1:
 	    if (errno == EINTR || errno == EAGAIN)
 		continue;
 	default:
+	    if (FD_ISSET(fd, &rfds)) {
+		/* Success, file descriptor is readable. */
+		return 0;
+	    }
 	    /* Error catch-all. */
 	    return -1;
 	}
