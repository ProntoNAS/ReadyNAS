Description: CVE-2016-4570
 The mxmlDelete function in mxml-node.c in mxml allows remote attackers to cause
 a denial of service (stack consumption) via crafted xml file

---
Author: Abhijith PA <abhijith@debian.org>
Origin: https://github.com/michaelrsweet/mxml/commit/d8c0ba900728d47523d76ba4acf33176cd04647c
Bug-Debian: https://bugs.debian.org/825855
Last-Update: 2019-01-23

--- mxml-2.6.orig/mxml-node.c
+++ mxml-2.6/mxml-node.c
@@ -46,6 +46,7 @@
  * Local functions...
  */
 
+static void		mxml_free(mxml_node_t *node);
 static mxml_node_t	*mxml_new(mxml_node_t *parent, mxml_type_t type);
 
 
@@ -197,7 +198,8 @@ mxmlAdd(mxml_node_t *parent,		/* I - Par
 void
 mxmlDelete(mxml_node_t *node)		/* I - Node to delete */
 {
-  int	i;				/* Looping var */
+  mxml_node_t	*current,		/* Current node */
+		*next;			/* Next node */
 
 
 #ifdef DEBUG
@@ -221,60 +223,50 @@ mxmlDelete(mxml_node_t *node)		/* I - No
   * Delete children...
   */
 
-  while (node->child)
-    mxmlDelete(node->child);
+    for (current = node->child; current; current = next)
+  {
+   /*
+    * Get the next node...
+    */
 
- /*
-  * Now delete any node data...
-  */
+    if ((next = current->child) != NULL)
+    {
+     /*
+      * Free parent nodes after child nodes have been freed...
+      */
 
-  switch (node->type)
-  {
-    case MXML_ELEMENT :
-        if (node->value.element.name)
-	  free(node->value.element.name);
+      current->child = NULL;
+      continue;
+    }
 
-	if (node->value.element.num_attrs)
-	{
-	  for (i = 0; i < node->value.element.num_attrs; i ++)
-	  {
-	    if (node->value.element.attrs[i].name)
-	      free(node->value.element.attrs[i].name);
-	    if (node->value.element.attrs[i].value)
-	      free(node->value.element.attrs[i].value);
-	  }
+    if ((next = current->next) == NULL)
+    {
+      mxml_node_t *temp = current->parent;
+					/* Pointer to parent node */
 
-          free(node->value.element.attrs);
-	}
-        break;
-    case MXML_INTEGER :
-       /* Nothing to do */
-        break;
-    case MXML_OPAQUE :
-        if (node->value.opaque)
-	  free(node->value.opaque);
-        break;
-    case MXML_REAL :
-       /* Nothing to do */
-        break;
-    case MXML_TEXT :
-        if (node->value.text.string)
-	  free(node->value.text.string);
-        break;
-    case MXML_CUSTOM :
-        if (node->value.custom.data &&
-	    node->value.custom.destroy)
-	  (*(node->value.custom.destroy))(node->value.custom.data);
-	break;
-    default :
-        break;
+      if (temp == node)
+      {
+       /*
+        * Got back to the top node...
+        */
+
+        next = NULL;
+      }
+      else if ((next = temp->next) == NULL)
+      {
+	if ((next = temp->parent) == node)
+	  next = NULL;
+      }
+    }
+
+mxml_free(current);
   }
 
  /*
-  * Free this node...
+  * Then free the memory used by this node...
   */
 
-  free(node);
+  mxml_free(node);
 }
 
 
@@ -720,6 +712,68 @@ mxmlRetain(mxml_node_t *node)		/* I - No
     return (-1);
 }
 
+/*
+ * 'mxml_free()' - Free the memory used by a node.
+ *
+ * Note: Does not free child nodes, does not remove from parent.
+ */
+
+static void
+mxml_free(mxml_node_t *node)		/* I - Node */
+{
+  int	i;				/* Looping var */
+
+
+  switch (node->type)
+  {
+    case MXML_ELEMENT :
+        if (node->value.element.name)
+	  free(node->value.element.name);
+
+	if (node->value.element.num_attrs)
+	{
+	  for (i = 0; i < node->value.element.num_attrs; i ++)
+	  {
+	    if (node->value.element.attrs[i].name)
+	      free(node->value.element.attrs[i].name);
+	    if (node->value.element.attrs[i].value)
+	      free(node->value.element.attrs[i].value);
+	  }
+
+          free(node->value.element.attrs);
+	}
+        break;
+    case MXML_INTEGER :
+       /* Nothing to do */
+        break;
+    case MXML_OPAQUE :
+        if (node->value.opaque)
+	  free(node->value.opaque);
+        break;
+    case MXML_REAL :
+       /* Nothing to do */
+        break;
+    case MXML_TEXT :
+        if (node->value.text.string)
+	  free(node->value.text.string);
+        break;
+    case MXML_CUSTOM :
+        if (node->value.custom.data &&
+	    node->value.custom.destroy)
+	  (*(node->value.custom.destroy))(node->value.custom.data);
+	break;
+    default :
+        break;
+  }
+
+ /*
+  * Free this node...
+  */
+
+  free(node);
+}
+
+
 
 /*
  * 'mxml_new()' - Create a new node.
