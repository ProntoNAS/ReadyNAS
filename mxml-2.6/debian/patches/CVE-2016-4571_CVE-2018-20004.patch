Description: CVE-2016-4571, CVE-2018-20004

 CVE-2018-20004
An issue has been found in Mini-XML (aka mxml) It is a stack-based buffer
overflow in mxml_write_node in mxml-file.c via vectors involving a
double-precision floating point number.

 CVE-2016-4571
mxml_write_node function in mxml-file.c allows remote attackers to cause a
denial of service (stack consumption) via crafted xml file.

---
Author: Abhijith PA <abhijith@debian.org>
Origin: https://github.com/michaelrsweet/mxml/commit/5f74dc212497332d05882660db130a37d2f458eb
        https://github.com/michaelrsweet/mxml/commit/4f5577dd4672d228e4180f06bdbd66f343ea45e0
Bug: https://github.com/michaelrsweet/mxml/issues/233
Bug-Debian: https://bugs.debian.org/825855
            https://bugs.debian.org/918007
Last-Update: 2019-01-23

Index: mxml-2.6/mxml-file.c
===================================================================
--- mxml-2.6.orig/mxml-file.c
+++ mxml-2.6/mxml-file.c
@@ -2680,29 +2680,33 @@ mxml_write_node(mxml_node_t     *node,	/
 		_mxml_putc_cb_t putc_cb,/* I - Output callback */
 		_mxml_global_t  *global)/* I - Global data */
 {
+mxml_node_t	*current,		/* Current node */
+		*next;			/* Next node */
   int		i,			/* Looping var */
 		width;			/* Width of attr + value */
   mxml_attr_t	*attr;			/* Current attribute */
   char		s[255];			/* Temporary string */
 
 
-  while (node != NULL)
-  {
    /*
-    * Print the node value...
+    * Loop through this node and all of its children...
     */
 
-    switch (node->type)
+    for (current = node; current; current = next)
     {
-      case MXML_ELEMENT :
-          col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_OPEN, col, putc_cb);
+     /*
+      * Print the node value...
+      */
 
-          if ((*putc_cb)('<', p) < 0)
+          switch (current->type)
+    {
+      case MXML_ELEMENT :
+	  	  if ((*putc_cb)('<', p) < 0)
 	    return (-1);
-          if (node->value.element.name[0] == '?' ||
-	      !strncmp(node->value.element.name, "!--", 3) ||
-	      !strncmp(node->value.element.name, "![CDATA[", 8))
-          {
+	  if (current->value.element.name[0] == '?' ||
+	      !strncmp(current->value.element.name, "!--", 3) ||
+	      !strncmp(current->value.element.name, "![CDATA[", 8))
+	  {
 	   /*
 	    * Comments, CDATA, and processing instructions do not
 	    * use character entities.
@@ -2711,16 +2715,16 @@ mxml_write_node(mxml_node_t     *node,	/
 	    const char	*ptr;		/* Pointer into name */
 
 
-	    for (ptr = node->value.element.name; *ptr; ptr ++)
+	    for (ptr = current->value.element.name; *ptr; ptr ++)
 	      if ((*putc_cb)(*ptr, p) < 0)
-	        return (-1);
+		return (-1);
 	  }
-	  else if (mxml_write_name(node->value.element.name, p, putc_cb) < 0)
+	  else if (mxml_write_name(current->value.element.name, p, putc_cb) < 0)
 	    return (-1);
 
-          col += strlen(node->value.element.name) + 1;
+          col += strlen(current->value.element.name) + 1;
 
-	  for (i = node->value.element.num_attrs, attr = node->value.element.attrs;
+	  for (i = current->value.element.num_attrs, attr = current->value.element.attrs;
 	       i > 0;
 	       i --, attr ++)
 	  {
@@ -2729,115 +2733,88 @@ mxml_write_node(mxml_node_t     *node,	/
 	    if (attr->value)
 	      width += strlen(attr->value) + 3;
 
-	    if (global->wrap > 0 && (col + width) > global->wrap)
+	    	    if (global->wrap > 0 && (col + width) > global->wrap)
 	    {
 	      if ((*putc_cb)('\n', p) < 0)
-	        return (-1);
+		return (-1);
 
 	      col = 0;
 	    }
 	    else
 	    {
 	      if ((*putc_cb)(' ', p) < 0)
-	        return (-1);
+		return (-1);
 
 	      col ++;
 	    }
 
-            if (mxml_write_name(attr->name, p, putc_cb) < 0)
-	      return (-1);
+	    if (mxml_write_name(attr->name, p, putc_cb) < 0)
+	        return (-1);
 
-	    if (attr->value)
+	      	    if (attr->value)
 	    {
-              if ((*putc_cb)('=', p) < 0)
+	      if ((*putc_cb)('=', p) < 0)
 		return (-1);
-              if ((*putc_cb)('\"', p) < 0)
+	      if ((*putc_cb)('\"', p) < 0)
 		return (-1);
 	      if (mxml_write_string(attr->value, p, putc_cb) < 0)
 		return (-1);
-              if ((*putc_cb)('\"', p) < 0)
+	      if ((*putc_cb)('\"', p) < 0)
 		return (-1);
-            }
+	    }
 
-            col += width;
-	  }
+	    col += width;
+	    }
 
-	  if (node->child)
-	  {
-           /*
+	    if (current->child)
+	    {
+	      	   /*
 	    * Write children...
 	    */
 
 	    if ((*putc_cb)('>', p) < 0)
-	      return (-1);
-	    else
-	      col ++;
-
-            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
-
-	    if ((col = mxml_write_node(node->child, p, cb, col, putc_cb,
-	                               global)) < 0)
-	      return (-1);
-
-           /*
-	    * The ? and ! elements are special-cases and have no end tags...
-	    */
-
-            if (node->value.element.name[0] != '!' &&
-	        node->value.element.name[0] != '?')
-	    {
-              col = mxml_write_ws(node, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
-
-              if ((*putc_cb)('<', p) < 0)
-		return (-1);
-              if ((*putc_cb)('/', p) < 0)
-		return (-1);
-              if (mxml_write_string(node->value.element.name, p, putc_cb) < 0)
-		return (-1);
-              if ((*putc_cb)('>', p) < 0)
-		return (-1);
-
-              col += strlen(node->value.element.name) + 3;
+	        return (-1);
+	      else
+	        col ++;
 
-              col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
+	      col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
 	    }
-	  }
-	  else if (node->value.element.name[0] == '!' ||
-	           node->value.element.name[0] == '?')
+            else if (current->value.element.name[0] == '!' ||
+		   current->value.element.name[0] == '?')
 	  {
-           /*
+	   /*
 	    * The ? and ! elements are special-cases...
 	    */
 
-	    if ((*putc_cb)('>', p) < 0)
+            	    if ((*putc_cb)('>', p) < 0)
 	      return (-1);
 	    else
 	      col ++;
 
-            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
-          }
+	    col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  }
 	  else
-	  {
-            if ((*putc_cb)(' ', p) < 0)
-	      return (-1);
-            if ((*putc_cb)('/', p) < 0)
-	      return (-1);
-            if ((*putc_cb)('>', p) < 0)
-	      return (-1);
+	    {
+              if ((*putc_cb)(' ', p) < 0)
+		return (-1);
+	      if ((*putc_cb)('/', p) < 0)
+		return (-1);
+              if ((*putc_cb)('>', p) < 0)
+		return (-1);
+            }
 
-	    col += 3;
+             col += 3;
 
-            col = mxml_write_ws(node, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
-	  }
-          break;
+	  col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_OPEN, col, putc_cb);
+	  break;
 
-      case MXML_INTEGER :
-	  if (node->prev)
+	case MXML_INTEGER :
+	  if (current->prev)
 	  {
 	    if (global->wrap > 0 && col > global->wrap)
 	    {
 	      if ((*putc_cb)('\n', p) < 0)
-	        return (-1);
+		return (-1);
 
 	      col = 0;
 	    }
@@ -2845,52 +2822,53 @@ mxml_write_node(mxml_node_t     *node,	/
 	      return (-1);
 	    else
 	      col ++;
-          }
+	  }
 
-          sprintf(s, "%d", node->value.integer);
+	  snprintf(s, sizeof(s), "%d", current->value.integer);
 	  if (mxml_write_string(s, p, putc_cb) < 0)
-	    return (-1);
+	      return (-1);
 
-	  col += strlen(s);
-          break;
+            col += strlen(s);
+	  break;
 
-      case MXML_OPAQUE :
-          if (mxml_write_string(node->value.opaque, p, putc_cb) < 0)
+	    case MXML_OPAQUE :
+	  if (mxml_write_string(current->value.opaque, p, putc_cb) < 0)
 	    return (-1);
 
-          col += strlen(node->value.opaque);
-          break;
+           col += strlen(current->value.opaque);
+	  break;
 
-      case MXML_REAL :
-	  if (node->prev)
-	  {
-	    if (global->wrap > 0 && col > global->wrap)
+            case MXML_REAL :
+	  if (current->prev)
+	    {
+              if (global->wrap > 0 && col > global->wrap)
 	    {
 	      if ((*putc_cb)('\n', p) < 0)
-	        return (-1);
+		return (-1);
 
-	      col = 0;
+              col = 0;
 	    }
 	    else if ((*putc_cb)(' ', p) < 0)
-	      return (-1);
-	    else
+		return (-1);
+
+             else
 	      col ++;
-          }
 
-          sprintf(s, "%f", node->value.real);
-	  if (mxml_write_string(s, p, putc_cb) < 0)
-	    return (-1);
 
-	  col += strlen(s);
-          break;
+	      snprintf(s, sizeof(s), "%f", current->value.real);
+	      if (mxml_write_string(s, p, putc_cb) < 0)
+	      return (-1);
 
-      case MXML_TEXT :
-	  if (node->value.text.whitespace && col > 0)
-	  {
-	    if (global->wrap > 0 && col > global->wrap)
+	    col += strlen(s);
+	  break;
+
+            case MXML_TEXT :
+	  if (current->value.text.whitespace && col > 0)
+	    {
+	      	    if (global->wrap > 0 && col > global->wrap)
 	    {
 	      if ((*putc_cb)('\n', p) < 0)
-	        return (-1);
+		return (-1);
 
 	      col = 0;
 	    }
@@ -2899,46 +2877,78 @@ mxml_write_node(mxml_node_t     *node,	/
 	    else
 	      col ++;
           }
-
-          if (mxml_write_string(node->value.text.string, p, putc_cb) < 0)
+             if (mxml_write_string(current->value.text.string, p, putc_cb) < 0)
 	    return (-1);
 
-	  col += strlen(node->value.text.string);
-          break;
+          col += strlen(current->value.text.string);
+	  break;
 
-      case MXML_CUSTOM :
-          if (global->custom_save_cb)
+	        case MXML_CUSTOM :
+	  if (global->custom_save_cb)
 	  {
 	    char	*data;		/* Custom data string */
 	    const char	*newline;	/* Last newline in string */
 
-
-            if ((data = (*global->custom_save_cb)(node)) == NULL)
+      if ((data = (*global->custom_save_cb)(node)) == NULL)
 	      return (-1);
 
-            if (mxml_write_string(data, p, putc_cb) < 0)
-	      return (-1);
+       if (mxml_write_string(data, p, putc_cb) < 0)
+	        return (-1);
 
-            if ((newline = strrchr(data, '\n')) == NULL)
+	      	    if ((newline = strrchr(data, '\n')) == NULL)
 	      col += strlen(data);
 	    else
-              col = strlen(newline);
+	      col = strlen(newline);
 
-            free(data);
+	    free(data);
 	    break;
-	  }
+	    }
 
       default : /* Should never happen */
-          return (-1);
-    }
+	    return (-1);
 
-   /*
-    * Next node...
+	     /*
+    * Figure out the next node...
     */
 
-    node = node->next;
-  }
+	      if ((next = current->child) == NULL)
+    {
+      while ((next = current->next) == NULL)
+      {
+        if (current == node)
+          break;
+
+          /*
+	* The ? and ! elements are special-cases and have no end tags...
+	*/
+
+	  current = current->parent;
 
+      if (current->value.element.name[0] != '!' &&
+	    current->value.element.name[0] != '?')
+	  {
+	    col = mxml_write_ws(current, p, cb, MXML_WS_BEFORE_CLOSE, col, putc_cb);
+
+            if ((*putc_cb)('<', p) < 0)
+	      return (-1);
+
+            	  if ((*putc_cb)('/', p) < 0)
+	    return (-1);
+	  if (mxml_write_string(current->value.element.name, p, putc_cb) < 0)
+	    return (-1);
+	  if ((*putc_cb)('>', p) < 0)
+	      return (-1);
+
+            col += strlen(current->value.element.name) + 3;
+
+            col = mxml_write_ws(current, p, cb, MXML_WS_AFTER_CLOSE, col, putc_cb);
+	  }
+
+      }
+    }
+    }
+   }
+   }
   return (col);
 }
 
