# Mensajes en español para GNU textutils.
# Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
# Enrique Melero Gómez <melero@iprolink.ch>, 1996, 1997.
# Santiago Vila Doncel <sanvila@unex.es>, 1998, 1999.
#
msgid ""
msgstr ""
"Project-Id-Version: GNU textutils 1.22p\n"
"POT-Creation-Date: 1999-08-06 02:10+0200\n"
"PO-Revision-Date: 1999-08-05 17:22+0200\n"
"Last-Translator: Santiago Vila Doncel <sanvila@unex.es>\n"
"Language-Team: Spanish <es@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=iso-8859-1\n"
"Content-Transfer-Encoding: 8-bit\n"

#: src/cat.c:84 src/cksum.c:265 src/comm.c:70 src/csplit.c:1502 src/cut.c:193
#: src/expand.c:104 src/fmt.c:268 src/fold.c:61 src/head.c:79 src/join.c:141
#: src/md5sum.c:100 src/nl.c:171 src/od.c:262 src/paste.c:405 src/pr.c:2772
#: src/ptx.c:1854 src/sort.c:251 src/split.c:83 src/sum.c:57 src/tac.c:124
#: src/tail.c:208 src/tr.c:321 src/tsort.c:89 src/unexpand.c:357 src/uniq.c:96
#: src/wc.c:81
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "Pruebe `%s --help' para más información.\n"

#: src/cat.c:88
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "Modo de empleo: %s [OPCIÓN] [FICHERO]...\n"

#: src/cat.c:92
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Concatena FICHERO(s), o la entrada estándar, en la salida estándar.\n"
"\n"
"  -A, --show-all          lo mismo que -vET\n"
"  -b, --number-nonblank   numera las líneas que no están vacías\n"
"  -e                      lo mismo que -vE\n"
"  -E, --show-ends         muestra '$' al final de cada línea\n"
"  -n, --number            numera todas las líneas\n"
"  -s, --squeeze-blank     nunca muestra más de una línea vacía,\n"
"  -t                      equivalente a -vT\n"
"  -T, --show-tabs         muestra los caracteres de tabulación como ^I\n"
"  -u                      (sin efecto)\n"
"  -v, --show-nonprinting  utiliza la notación ^ y M-, salvo para LFD y TAB\n"
"      --help              muestra esta ayuda y finaliza\n"
"      --version           informa de la versión y finaliza\n"
"\n"
"Sin 'FICHERO', o cuando FICHERO es -, lee la entrada estándar.\n"
"\n"

#: src/cat.c:111
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""
"\n"
"  -B, --binary             usa escrituras binarias al dispositivo de "
"consola.\n"
"\n"

#: src/cat.c:116 src/cksum.c:279 src/comm.c:87 src/csplit.c:1533 src/cut.c:225
#: src/expand.c:124 src/fmt.c:289 src/fold.c:79 src/head.c:103 src/join.c:175
#: src/md5sum.c:126 src/nl.c:213 src/od.c:327 src/paste.c:424 src/pr.c:2859
#: src/sort.c:298 src/split.c:106 src/sum.c:75 src/tac.c:142 src/tail.c:261
#: src/tr.c:383 src/unexpand.c:377 src/uniq.c:124 src/wc.c:100
msgid ""
"\n"
"Report bugs to <bug-textutils@gnu.org>."
msgstr ""
"\n"
"Comunicar `bugs' a <bug-textutils@gnu.org>."

#: src/cat.c:176 src/cat.c:257 src/cat.c:310 src/cat.c:820 src/comm.c:220
#: src/csplit.c:1493 src/cut.c:799 src/expand.c:392 src/fmt.c:416
#: src/fold.c:225 src/fold.c:306 src/head.c:139 src/head.c:169 src/head.c:387
#: src/join.c:871 src/md5sum.c:629 src/nl.c:608 src/od.c:1940 src/paste.c:485
#: src/pr.c:1158 src/tac.c:715 src/tail.c:285 src/tail.c:1518 src/tr.c:1670
#: src/tr.c:1916 src/tr.c:2024 src/tr.c:2031 src/tsort.c:490
#: src/unexpand.c:454
msgid "write error"
msgstr "error de escritura"

# Al igual que en fileutils donde también se hace mención a alguna llamada
# del sistema, creo que se debería traducir por algo así como:
# "No se puede realizar la llamada de sistema "ioctl" sobre..."
# creo que es más "self-explanatory"
# Sí, tienes razón em+
# FIXME: Comunicar al autor. sv
#: src/cat.c:298
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "no se puede ejecutar la función 'ioctl' sobre `%s'"

#: src/cat.c:630 src/od.c:1152
msgid "standard output"
msgstr "salida estándar"

#: src/cat.c:761
#, c-format
msgid "%s: input file is output file"
msgstr "%s: los ficheros de entrada y salida son el mismo"

#: src/cksum.c:269 src/cut.c:197 src/expand.c:108 src/fold.c:65 src/head.c:83
#: src/nl.c:175 src/paste.c:409 src/pr.c:2776 src/sort.c:255 src/sum.c:61
#: src/tac.c:128 src/tail.c:212 src/unexpand.c:361 src/wc.c:85
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"

# ¿¿?? ¿¿Porqué has reformateado para que tengan la misma longitud? ipg
# Me parece que queda más bonito, después de instalar el .po y ver
# un par de mensajes tal y como aparecían creí necesario formatearlo
# un poco. Todavía no hay una regla de formateo oficial para GNU, pero
# es de esperar que dentro de poco la haya. em+
#
# A mí, la verdad, se me hace harto difícil leer con más de un espacio
# entre medias ... *lo odio* ;). ipg
#
# A ver qué os parece la siguiente regla, nunca la había escrito, pero no
# me la acabo de inventar, creo que es la regla implícita que he estado
# usando desde el principio:
#
# Regla de formateo: Ninguna línea excederá de 80 columnas. Cuando haya un
# especificador de formato (tal y como %s) se debe tener en cuenta que
# resultará sustituido por una palabra cuya longitud habrá que estimar.
#
# Hay algunas que pueden ser más largas aposta, porque sean reformateadas
# a pelo. Además, en muchos casos será casi imposible hacer una estimación.
# ipg
#
# En los textos que explican para qué sirve cada opción, se respetará en la
# medida de lo posible la distancia de tabulación del original. Solamente está
# justificado cambiar dicha distancia cuando haya dificultad en respetar
# el límite de 80 columnas.
#
# Ok. ipg
#
# De acuerdo con la regla, *no* está justificado disminuir la distancia
# en la siguiente cadena, así que la dejo como el original. sv
#
#: src/cksum.c:273
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
"  --help      display this help and exit\n"
"  --version   output version information and exit\n"
msgstr ""
"Muestra la suma de comprobación CRC y el número de bytes de cada FICHERO.\n"
"\n"
"  --help      muestra esta ayuda y finaliza\n"
"  --version   informa de la versión y finaliza\n"

#: src/comm.c:74
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "Modo de empleo: %s [OPCIÓN]... FICHERO1 FICHERO2\n"

#  ¿¿cómo se puede explicar esto mejor??
# A mí me parece que está bien ... :-? ipg
#: src/comm.c:78
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines unique to both files\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
msgstr ""
"Compara los ficheros ordenados FICHERO1 y FICHERO2, línea por línea.\n"
"\n"
"  -1              suprime las líneas que sólo están en FICHERO1\n"
"  -2              suprime las líneas que sólo están en FICHERO2\n"
"  -3              muestra las líneas que sólo están en uno de ellos\n"
"      --help      muestra esta ayuda y finaliza\n"
"      --version   informa de la versión y finaliza\n"

#: src/csplit.c:295 src/csplit.c:1488 src/sort.c:561 src/tac-pipe.c:57
#: src/tr.c:1619 src/tr.c:1716 src/tr.c:1760
msgid "read error"
msgstr "error de lectura"

#: src/csplit.c:589
msgid "input disappeared"
msgstr "la entrada dejó de existir"

#: src/csplit.c:711 src/csplit.c:722
#, c-format
msgid "%s: line number out of range"
msgstr "%s: número de línea fuera de rango"

#: src/csplit.c:749
#, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: `%s': número de línea fuera de rango"

# ???
#: src/csplit.c:752 src/csplit.c:804
#, c-format
msgid " on repetition %d\n"
msgstr " repetido %d\n"

#: src/csplit.c:800
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: `%s': ocurrencia no encontrada"

#: src/csplit.c:861 src/csplit.c:901 src/tac.c:258
msgid "error in regular expression search"
msgstr "error en la búsqueda de la expresión regular"

# %s debe de ser un fichero, ¿no? si es así a mí me parece "más natural":
# "en %s" e incluso quizás "sobre %s"... o quizás no... ahí queda eso
# Lo cambio em+
#: src/csplit.c:1004
#, c-format
msgid "write error for `%s'"
msgstr "error al escribir `%s'"

#: src/csplit.c:1076
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: se esperaba un `+' ó un  `-' después del delimitador"

#: src/csplit.c:1080
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: se esperaba un número entero después de `%c'"

#: src/csplit.c:1100
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: se requiere un `}' después del número de repeticiones"

#: src/csplit.c:1110
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: entre `{' y `}' debe especificarse un número entero"

#: src/csplit.c:1137
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: falta el delimitador de cierre `%c'"

#: src/csplit.c:1153
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: la expresión regular no es válida: %s"

#: src/csplit.c:1186
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: plantilla inválida"

#: src/csplit.c:1189
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: el número de línea debe ser mayor que cero"

#: src/csplit.c:1195
#, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "el número de línea `%s' es menor que el número de línea anterior, %s"

#: src/csplit.c:1201
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "atención: el número de línea `%s' es el mismo que el anterior"

#: src/csplit.c:1323
msgid "missing conversion specifier in suffix"
msgstr "falta el especificador de conversión en el sufijo"

#
#: src/csplit.c:1329
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "el especificador de conversión indicado en el sufijo no es válido: %c"

#: src/csplit.c:1332
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr ""
"el especificador de conversión indicado en el sufijo no es válido: \\%.3o"

#: src/csplit.c:1364
msgid "missing %% conversion specification in suffix"
msgstr "falta el especificador de conversión %% en el sufijo"

#: src/csplit.c:1367
msgid "too many %% conversion specifications in suffix"
msgstr "demasiados especificadores de conversión %% en el sufijo"

#: src/csplit.c:1448
#, c-format
msgid "%s: invalid number"
msgstr "%s: número inválido"

#: src/csplit.c:1471
msgid "too few arguments"
msgstr "faltan argumentos"

#: src/csplit.c:1506
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "Modo de empleo: %s [OPCIÓN]... FICHERO PLANTILLA...\n"

#: src/csplit.c:1510
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
"      --help                 display this help and exit\n"
"      --version              output version information and exit\n"
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"Escribe los trozos de FICHERO que estén separados por PLANTILLA(s) en "
"ficheros\n"
"`xx01', `xx02' y muestra el tamaño de cada trozo en la salida estándar.\n"
"\n"
"  -b, --suffix-format=FORMATO usa formato `sprintf' en vez de %%d\n"
"  -f, --prefix=PREFIJO        usa PREFIJO en vez de `xx'\n"
"  -k, --keep-files            no borra los ficheros de salida si hay "
"errores\n"
"  -n, --digits=DÍGITOS        usa el número especificado de DÍGITOS\n"
"                              en vez de 2\n"
"  -s, --quiet, --silent       no muestra el tamaño de los ficheros creados\n"
"  -z, --elide-empty-files     borra los ficheros de salida vacíos\n"
"      --help                  muestra esta ayuda y finaliza\n"
"      --version               informa de la versión y finaliza\n"
"\n"
"Lee la entrada estándar si FICHERO es `-'. Cada PLANTILLA puede ser:\n"
"\n"
" NÚMERO_LÍNEA        copia a partir de este número de línea excluida ella\n"
" /EXPREG/[DESPLAZ]   copia sin incluir las líneas que coincidan con EXPREG\n"
" %%EXPREG%%[DESPLAZ]   comienza a partir de la línea que coincida con "
"EXPREG\n"
" {NÚMERO ENTERO}     repite la plantilla especificada un número de veces\n"
" {*}                 repite la plantilla especificada todas las veces "
"posibles\n"
"\n"
"Un DESPLAZamiento de línea es un número entero precedido de `+' o de `-'.\n"

# Pregunta: ¿por qué se ha eliminado lo de "N-ésimo byte..."? ¿Por espacio?
# Respuesta: en la posicion N = enésimo em+
#: src/cut.c:201
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
"  -f, --fields=LIST       output only these fields\n"
"  -n                      (ignored)\n"
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Extrae las partes seleccionadas de cada FICHERO en la salida estándar:\n"
"\n"
"  -b, --bytes=LISTA           muestra solamente estos bytes\n"
"  -c, --characters=LISTA      muestra solamente estos caracteres\n"
"  -d, --delimiter=DELIM       usa DELIM en vez de caracteres de tabulación\n"
"                              para delimitar los campos\n"
"  -f, --fields=LISTA          muestra solamente estos campos\n"
"  -n                          (no tiene efecto)\n"
"  -s, --only-delimited        no muestra las líneas que no contienen\n"
"                              delimitadores\n"
"      --output-delimiter=CADENA  utiliza CADENA como el delimitador del\n"
"                                 resultado. Por omisión se utiliza el\n"
"                                 delimitador de la entrada\n"
"      --help                  muestra esta ayuda y finaliza\n"
"      --version               informa de la versión y finaliza\n"
"\n"
"Utilice una y sólo una de las opciones -b, -c ó -f. Cada LISTA se compone\n"
"de uno o de más rangos separados por comas. Los rangos pueden ser:\n"
"\n"
"   N    El byte, carácter o campo en la posición N contado desde 1\n"
"   N-   A partir del byte, carácter o campo en la posición N, hasta el "
"final\n"
"        de la línea\n"
"   N-M  Desde el byte, carácter o campo que ocupa la posición N hasta el de\n"
"        la posición M\n"
"   -M   desde el primero hasta el byte, carácter o campo de la posición M\n"
"\n"
"Lee la entrada estándar si no se especifica FICHERO o es `-'.\n"

#: src/cut.c:363 src/cut.c:394 src/cut.c:454
msgid "invalid byte or field list"
msgstr "la lista de bytes o campos no es válida"

#: src/cut.c:717 src/cut.c:726
msgid "only one type of list may be specified"
msgstr "solamente se puede especificar un tipo de lista"

#: src/cut.c:720
msgid "missing list of positions"
msgstr "falta la lista de posiciones"

#: src/cut.c:729
msgid "missing list of fields"
msgstr "falta la lista de campos"

#: src/cut.c:736
msgid "the delimiter must be a single character"
msgstr "el delimitador debe ser un sólo carácter"

#: src/cut.c:766
msgid "you must specify a list of bytes, characters, or fields"
msgstr "se debe indicar una lista de bytes, caracteres o campos"

#: src/cut.c:769
msgid "a delimiter may be specified only when operating on fields"
msgstr "sólo se puede especificar un delimitador cuando se procesan campos"

# FIXME: Comunicar al autor lo de los tabs. sv+
#: src/cut.c:772
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"suprimir las líneas no delimitadas solamente tiene sentido\n"
"cuando se procesan campos"

# FIXME. Este mensaje es prácticamente idéntico a otro que hay.
# Comunicar al autor. sv+
#: src/expand.c:112
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""
"Convierte las tabulaciones de cada FICHERO en espacios, escribiendo el\n"
"resultado en la salida estándar. Si no se especifica FICHERO o FICHERO\n"
"es `-', lee la entrada estándar.\n"
"\n"
"  -i, --initial       sólo convierte las tabulaciones iniciales de cada "
"línea\n"
"  -t, --tabs=NÚMERO   usa N espacios en cada tabulación, en vez de 8\n"
"  -t, --tabs=LISTA    usa la LISTA de posiciones separadas por comas para\n"
"                      definir las posiciones de tabulación\n"
"      --help          muestra esta ayuda y finaliza\n"
"      --version       informa de la versión y finaliza\n"
"\n"
"En vez de `-t N' ó `-t LISTA' puede usarse -N ó -LISTA.\n"

#: src/expand.c:166 src/unexpand.c:139
msgid "tab size contains an invalid character"
msgstr "el tamaño de tabulación contiene un carácter inválido"

#: src/expand.c:184 src/unexpand.c:157
msgid "tab size cannot be 0"
msgstr "el tamaño de tabulación no puede ser 0"

# ??? Mejor que el original, lo estoy dejando :-)
#: src/expand.c:186 src/unexpand.c:159
msgid "tab sizes must be ascending"
msgstr "las posiciones de tabulación deben ir en orden creciente"

#: src/fmt.c:272
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "Modo de empleo: %s [-DÍGITOS] [OPCIÓN]... [FICHERO]...\n"

#: src/fmt.c:273
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
"      --help                display this help and exit\n"
"      --version             output version information and exit\n"
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"Reformatea cada párrafo de FICHERO(s), escribiendo en la salida estándar.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"Los argumentos obligatorios para las opciones largas son también "
"obligatorios\n"
"para las opciones cortas.\n"
"  -c, --crown-margin        mantiene la sangría en las dos primeras líneas\n"
"  -p, --prefix=CADENA       junta sólo las líneas que comiencen con CADENA\n"
"  -s, --split-only          divide las líneas largas de manera que quepan\n"
"                            en el ancho especificado, pero no junta líneas\n"
"  -t, --tagged-paragraph    establece la sangría de la primera línea "
"diferente\n"
"                            de la segunda línea\n"
"  -u, --uniform-spacing     pone un espacio entre palabras, dos entre "
"frases\n"
"  -w, --width=NÚMERO        establece el ancho de línea máximo (por "
"defecto,\n"
"                            75 columnas)\n"
"      --help                muestra esta ayuda y finaliza\n"
"      --version             informa de la versión y finaliza\n"
"\n"
"En `-wNÚMERO' se puede omitir la letra `w'.\n"
"\n"

#: src/fmt.c:372 src/nl.c:494
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "incremento de línea inválido: `%s'"

# Sugerencia: "Ajusta ... de cada FICHERO, o de la entrada ..." sv
# A mí me gusta como está. ipg
#: src/fold.c:69
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
msgstr ""
"Ajusta el ancho de las líneas en cada FICHERO, o entrada estándar si se\n"
"omite FICHERO, y escribe el resultado en la salida estándar\n"
"\n"
"  -b, --bytes         cuenta bytes en vez de columnas\n"
"  -s, --spaces        corta la línea por los espacios\n"
"  -w, --width=ANCHO   utiliza ANCHO columnas en vez de 80\n"
"      --help          muestra esta ayuda y finaliza\n"
"      --version       muestra la versión y finaliza\n"

#: src/fold.c:283
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "el número de columnas no es válido `%s'"

# ¿Qué tal dejar bien claro que "...en vez de 10 por defecto." aunque no
#                                                ^^^^^^^^^^^
# esté en la versión english?
#
#: src/head.c:87
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
"If -VALUE is used as first OPTION, read -c VALUE when one of\n"
"multipliers bkm follows concatenated, else read -n VALUE.\n"
msgstr ""
"Muestra las primeras líneas de cada FICHERO en la salida estándar.\n"
"Si se especifican varios FICHERO(s), se muestra el nombre de cada uno.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"  -c, --bytes=TAMAÑO      muestra los primeros TAMAÑO bytes\n"
"  -n, --lines=N           muestra las N primeras líneas en vez de 10\n"
"  -q, --quiet, --silent   no muestra las cabeceras con el nombre del "
"fichero\n"
"  -v, --verbose           muestra siempre las cabeceras con el nombre del\n"
"                          fichero\n"
"      --help              muestra esta ayuda y finaliza\n"
"      --version           informa de la versión y finaliza\n"
"\n"
"TAMAÑO puede tener un sufijo: `b' para 512, `k' para 1K, `m' para 1 "
"Megabyte.\n"
"Puede especificarse -TAMAÑO como primera opción si va seguido por uno de\n"
"`b', `k' ó `m', si no, toma -N, como si hubiera sido especificado con -n N\n"

#: src/head.c:191 src/md5sum.c:302 src/md5sum.c:632 src/od.c:941 src/od.c:1200
#: src/od.c:1273 src/od.c:1937 src/pr.c:1156 src/pr.c:1365 src/pr.c:1487
#: src/tac.c:485 src/tac.c:491 src/tr.c:2034 src/tsort.c:493
msgid "standard input"
msgstr "entrada estándar"

#: src/head.c:232 src/tail.c:1338
msgid "invalid number of lines"
msgstr "el número de líneas no es válido"

#: src/head.c:233 src/tail.c:1339
msgid "invalid number of bytes"
msgstr "el número de bytes no es válido"

#: src/head.c:239 src/tail.c:1261 src/tail.c:1344
#, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: %s es tan grande que no es representable"

#: src/head.c:240 src/tail.c:1263 src/tail.c:1346
msgid "number of lines"
msgstr "número de líneas"

#: src/head.c:240 src/tail.c:1264 src/tail.c:1346
msgid "number of bytes"
msgstr "número de bytes"

#: src/head.c:317
#, c-format
msgid "unrecognized option `-%c'"
msgstr "opción no reconocida '-%c'"

#: src/join.c:145
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "Modo de empleo: %s [OPCIÓN]... FICHERO1 FICHERO2\n"

# Sugerencia: no los dos a la vez -> pero no ambos. sv
# ¿Pero no ambos a la vez? em
# Eso es repetir el "both". sv
# En lugar de `no los dos a la vez' ¿`nunca los dos a la vez'? ipg
# Eso está mucho mejor em
# OJO. La opción -a ha cambiado. sv
#
# Creo que "si no, los campos se separan con CARÁCTER" es redundante,
# por supuesto al igual que en la versión english.
#
# Por cierto, ¿qué pasa con esta parte que no se ha traducido?
#
# Default FORMAT outputs the join field,\n"
# "the remaining fields from FILE1, the remaining fields from FILE2, all\n"
# "separated by CHAR.\n"
# Gracias em+
#: src/join.c:149
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"      --help        display this help and exit\n"
"      --version     output version information and exit\n"
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"Muestra una línea en la salida estándar por cada par de líneas que "
"contengan\n"
"campos idénticos. El campo a comparar por defecto es el primero, delimitado\n"
"por un espacio en blanco. Si FICHERO1 o FICHERO2 es `-' (nunca dos a la "
"vez),\n"
"lee la entrada estándar.\n"
"\n"
"  -a LADO           muestra una línea por cada línea no emparejable del\n"
"                    fichero LADO\n"
"  -e VACÍO          reemplaza los campos inexistentes por VACÍO\n"
"  -i, --ignore-case no atiende a las diferencias entre mayúsculas y "
"minúsculas\n"
"  -j CAMPO          (Obsoleto) equivalente a '-1 CAMPO -2 CAMPO'\n"
"  -j1 CAMPO         (Obsoleto) equivalente a '-1 CAMPO'\n"
"  -j2 CAMPO         (Obsoleto) equivalente a '-2 CAMPO'\n"
"  -o FORMATO        utiliza FORMATO para mostrar las líneas de salida\n"
"  -t CARÁCTER       Usa CARÁCTER como delimitador de campos, en la entrada y "
"en\n"
"                    la salida\n"
"  -v LADO           Como -a LADO, pero no muestra las líneas emparejadas\n"
"  -1 CAMPO          usa este campo del fichero 1\n"
"  -2 CAMPO          usa este campo del fichero 2\n"
"      --help        muestra esta ayuda y finaliza\n"
"      --version     informa de la versión y finaliza\n"
"\n"
"A menos que se especifique -t CARÁCTER, los espacios en blanco separan "
"campos\n"
"y son pasados por alto, si no, los campos se separan con CARÁCTER. CAMPO es "
"el\n"
"número de campo contado a partir de 1. FORMATO es una lista de elementos de "
"la\n"
"forma `LADO.CAMPO' ó `0', separada por comas o por espacios en blanco. El\n"
"FORMATO por defecto muestra el campo que empareja, los restantes campos de\n"
"FICHERO1 y los de FICHERO2, todos separados por CARÁCTER.\n"
"\n"

#. `0' must be all alone -- no `.FIELD'.
#: src/join.c:640
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "la especificación del campo no es válida: `%s'"

#: src/join.c:654 src/join.c:767 src/join.c:803
#, c-format
msgid "invalid field number: `%s'"
msgstr "número de campo inválido: `%s'"

#: src/join.c:667
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "número de fichero inválido en la especificación del campo: `%s'"

#: src/join.c:787
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "número de campo inválido para el fichero 1: `%s'"

#: src/join.c:796
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "número de campo inválido para el fichero 2: `%s'"

# No sé en qué caso se muestra este mensaje pero creo que es _muy_ ambiguo...
# creo que la solución que se adopta en el siguiente mensaje sería más
# apropiada...
#
# Ahora sí lo has arreglado...
# Decía "número de argumentos insuficiente".
# Pongo "demasiados argumentos".
# Con esto ya están "igualados" este y el siguiente. sv
#
# El único problema ahora es que te comes lo de "non-option", ese matiz
# se pierde en la traducción. sv+
#: src/join.c:828
msgid "too many non-option arguments"
msgstr "demasiados argumentos"

#: src/join.c:850
msgid "too few non-option arguments"
msgstr "número de argumentos insuficiente"

# Me refiero a que si sabe la causa exacta del error, ¿por qué ofrece
# el error de sistema: "No such device"?
# ¿¿Acaso hay sistemas con stdin1 y stdin2?? :-)
#
# Eso es lo de menos :) em+
#: src/join.c:861
msgid "both files cannot be standard input"
msgstr "los dos ficheros no pueden ser a la vez la entrada estándar"

# Creo que no es fiel decir:
#  "no muestra nada, el valor de retorno indica el estado\n"
# y que sería mejor decir algo así como:
# "...el resultado [del chequeo | comprobación]..."
#
#: src/md5sum.c:104
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check MD5 checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --binary            read files in binary mode (default on "
"DOS/Windows)\n"
"  -c, --check             check MD5 sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated MD5 checksum lines\n"
"\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"The sums are computed as described in RFC 1321.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN] [FICHERO]...\n"
"       o bien:  %s [OPCIÓN] --check [FICHERO]\n"
"\n"
"Muestra o comprueba la suma de comprobación MD5.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"  -b, --binary           lee los ficheros en modo binario (por omisión en\n"
"                         DOS/Windows)\n"
"  -c, --check            comprueba las sumas MD5 con la lista dada\n"
"  -t, --text             lee los ficheros en modo de texto (por defecto)\n"
"\n"
"Las siguientes dos opciones son útiles al verificar sumas de comprobación:\n"
"      --status           no muestra nada, el valor de retorno indica el\n"
"                         resultado\n"
"  -w, --warn             avisa de las líneas de comprobación de sumas MD5\n"
"                         que no están correctamente formateadas\n"
"\n"
"      --help             muestra esta ayuda y finaliza\n"
"      --version          informa de la versión y finaliza\n"
"\n"
"Las sumas se calculan tal y como se describe en RFC 1321. Al comprobar, la\n"
"entrada debe ser un resultado anterior de llamar a md5sum. Por defecto se\n"
"muestra una línea con la suma de comprobación, un carácter indicando el "
"tipo\n"
"de fichero (`*' para binario, ` ' para texto), y el nombre de cada FICHERO.\n"

# ¡¡Jau!! Yo venir en son de paz y aceptar propuesta de rostro pálido :).
# ¿Tu fumar pipa de la paz? Yo tener maría de la buena X'D (ya quisiera...) ipg
#
# ¡¡Jau²!! Yo hacer otra propuesta, mía propuesta no ser formateada
# propuesta, yo tener pánico a verborreicos como este...
# "...de comprobación MD5 con formato erróneo."
#
# ipg: ¿y crece por allí? ¡con el frío que hace! }:-)
#: src/md5sum.c:346
#, c-format
msgid "%s: %lu: improperly formatted MD5 checksum line"
msgstr "%s: %lu: línea de suma de comprobación MD5 con formato erróneo"

# Sí, ( no hace falta leerse los coding standards para saberlo, aunque ahí lo
# puedes encontrar también ) %s es el nombre del programa. em
#: src/md5sum.c:367
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: FALLO al abrir o leer\n"

# Puestos a simplificar, a lo mejor podrías poner simplemente
# "coincide" o "no coincide". Cualquiera que use el programa sabe
# perfectamente qué es lo que coincide y lo que no. sv+
#: src/md5sum.c:389
msgid "FAILED"
msgstr "La suma no coincide"

# Yo estoy en contra de utilizar el Ok, por otra parte ahí va mi propuesta
# que se parece mucho a la de Santiago:
# Correcto/incorrecto, o sea no se refieren al resultado de la suma sino
# a la comprobación.... es simple y corto... como el mensaje original....
#
#: src/md5sum.c:389
msgid "OK"
msgstr "La suma coincide"

#: src/md5sum.c:402
#, c-format
msgid "%s: read error"
msgstr "%s: error de lectura"

#. Warn if no tests are found.
#: src/md5sum.c:415
#, c-format
msgid "%s: no properly formatted MD5 checksum lines found"
msgstr ""
"%s: no se encontraron líneas de suma de comprobación MD5 con formato correcto"

#: src/md5sum.c:428
#, c-format
msgid "WARNING: %d of %d listed %s could not be read\n"
msgstr "ATENCIÓN: %d de %d %s listados no se pudieron leer\n"

#: src/md5sum.c:431
msgid "file"
msgstr "fichero"

#: src/md5sum.c:431
msgid "files"
msgstr "ficheros"

#: src/md5sum.c:437
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "ATENCIÓN: %d de las %d %s calculada(s) NO coincidieron"

#: src/md5sum.c:440
msgid "checksum"
msgstr "suma de comprobación"

#: src/md5sum.c:440
msgid "checksums"
msgstr "sumas de comprobación"

# Sugerencia: when verifying -> cuando se verifican (más fiel) sv+
#: src/md5sum.c:517
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr ""
"las opciones --binary y --text no tienen sentido al verificar sumas de "
"comprobación"

#: src/md5sum.c:525
msgid "the --string and --check options are mutually exclusive"
msgstr "las opciones --string y --check son mutuamente excluyentes"

# Lo mismo. sv+
#: src/md5sum.c:532
msgid "the --status option is meaningful only when verifying checksums"
msgstr ""
"la opción --status sólo tiene sentido al verificar sumas de comprobación"

# Lo mismo. sv+
#: src/md5sum.c:539
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "la opción --warn sólo tiene sentido al verificar sumas de comprobación"

# Ahh, aquí sí, ¿eh? sv+
#: src/md5sum.c:549
msgid "no files may be specified when using --string"
msgstr "no se puede especificar FICHERO cuando se usa --string"

#: src/md5sum.c:568
msgid "only one argument may be specified when using --check"
msgstr "cuando se utiliza --check sólo se puede especificar un argumento"

#: src/nl.c:179
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
"      --help                      display this help and exit\n"
"      --version                   output version information and exit\n"
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"Escribe cada FICHERO en la salida estándar, con las líneas numeradas.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"  -b, --body-numbering=ESTILO   usa ESTILO para la numeración de las líneas\n"
"  -d, --section-delimiter=CC    usa CC para separar páginas\n"
"  -f, --footer-numbering=ESTILO usa ESTILO para numerar las líneas finales\n"
"  -h, --header-numbering=ESTILO usa ESTILO para numerar las líneas de "
"cabecera\n"
"  -i, --page-increment=NÚMERO   incrementa en NÚMERO el número de línea en\n"
"                                cada línea\n"
"  -l, --join-blank-lines=NÚMERO un grupo de NÚMERO líneas vacías se cuentan\n"
"                                como una sola\n"
"  -n, --number-format=FORMATO   inserta los números de línea con FORMATO\n"
"  -p, --no-renumber             no reinicializa el número de líneas para "
"cada\n"
"                                página\n"
"  -s, --number-separator=CADENA añade CADENA despúes del número de línea\n"
"  -v, --first-page=NÚMERO       primer número de línea para cada página\n"
"  -w, --number-width=ANCHO      usa ANCHO columnas para los números de "
"línea\n"
"      --help                    muestra esta ayuda y finaliza\n"
"      --version                 informa de la versión y finaliza\n"
"\n"
"Por defecto es `-v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn'. `CC' son dos\n"
"caracteres delimitadores para separar páginas; si sólo se especifica uno\n"
"de ellos, el otro se supone:`.'\n"
"Utilícese \\\\ para obtener \\. ESTILO puede ser uno de lo siguientes:\n"
"\n"
"  a       numera todas las líneas\n"
"  t       numera sólo las líneas no vacías\n"
"  n       no numera ninguna línea\n"
"  pEXPREG numera sólo las líneas que coinciden con la expresión regular "
"REGEXP\n"
"\n"
"FORMATO es uno de los siguientes:\n"
"\n"
"  ln       justificación a la izquierda, sin ceros a la izquierda\n"
"  rn       justificación a la derecha, sin ceros a la izquierda\n"
"  rz       justificación a la derecha, con ceros a la izquierda\n"
"\n"

#: src/nl.c:484
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "número de comienzo de línea inválido: `%s'"

#: src/nl.c:507
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "número de líneas vacías inválido: `%s'"

#: src/nl.c:521
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "ancho para el número de línea inválido: `%s'"

#: src/od.c:266
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]... [FICHERO]...\n"
"       o bien: %s --traditional [FICHERO] [[+]DESPLAZAMIENTO [[+]ETIQUETA]\n"

# Creo que si pones `-' en vez de -, deberías consultarlo primero con
# el autor. Además, no lo has cambiado en todas partes. sv+
#: src/od.c:271
msgid ""
"Write an unambiguous representation, octal bytes by default, of FILE\n"
"to standard output.  With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n"
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in pre-POSIX form\n"
"      --help                  display this help and exit\n"
"      --version               output version information and exit\n"
"\n"
"Pre-POSIX format specifications may be intermixed, they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"Escribe una representación inequívoca, por defecto en base ocho, de FICHERO\n"
"en la salida estándar. Si no se especifica FICHERO o FICHERO es `-', lee la\n"
"entrada estándar.\n"
"\n"
"  -A, --address-radix=BASE    indica cómo se han de mostrar las posiciones\n"
"                              del fichero\n"
"  -N, --read-bytes=BYTES      restringe la salida a BYTES bytes por fichero\n"
"  -j, --skip-bytes=BYTES      descarta los primeros BYTES bytes de cada "
"fichero\n"
"  -s, --strings[=BYTES]       muestra cadenas de caracteres de al menos "
"BYTES\n"
"                              caracteres gráficos\n"
"  -t, --format=TIPO           selecciona el formato o formatos de salida\n"
"  -v, --output-duplicates     no usa * para indicar líneas repetidas\n"
"  -w, --width[=BYTES]         muestra BYTES bytes por línea de salida\n"
"      --traditional           acepta los argumentos en formato pre-POSIX\n"
"      --help                  muestra esta ayuda y finaliza\n"
"      --version               informa de la versión y finaliza\n"
"\n"
"Las especificaciones de formato pre-POSIX pueden estar mezcladas y se "
"acumulan:\n"
"  -a   lo mismo que -t a,  selecciona los caracteres nombrados\n"
"  -b   lo mismo que -t oC, selecciona bytes en base octal\n"
"  -c   lo mismo que -t c,  selecciona caracteres ASCII o secuencias de "
"escape\n"
"  -d   lo mismo que -t u2, selecciona decimales cortos sin signo\n"
"  -f   lo mismo que -t fF, selecciona números en coma flotante\n"
"  -h   lo mismo que -t x2, selecciona hexadecimales cortos\n"
"  -i   lo mismo que -t d2, selecciona decimales cortos\n"
"  -l   lo mismo que -t d4, selecciona decimales largos\n"
"  -o   lo mismo que -t o2, selecciona octales cortos\n"
"  -x   lo mismo que -t x2, selecciona hexadecimales cortos\n"

#: src/od.c:298
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  -s without a number implies 3.  -w without a number implies 32.\n"
"By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
"\n"
"En la sintaxis antigua, DESPLAZAMIENTO significa -j DESPLAZAMIENTO. "
"ETIQUETA\n"
"es la pseudodirección del primer byte mostrado, que se incrementa a la vez\n"
"que se va procesando el volcado. Para DESPLAZAMIENTO y ETIQUETA, el prefijo\n"
"0x ó 0X indica hexadecimal, los sufijos pueden ser `.' para octal y `b' "
"para\n"
"bloques de 512 bytes.\n"
"\n"
"TIPO se construye con una o más de las siguientes especificaciones:\n"
"\n"
"  a          un determinado carácter\n"
"  c          carácter ASCII o secuencia de escape (\\999)\n"
"  d[TAMAÑO]  decimal con signo, TAMAÑO bytes por cada entero\n"
"  f[TAMAÑO]  coma flotante, TAMAÑO bytes por cada entero\n"
"  o[TAMAÑO]  octal, TAMAÑO bytes por cada entero\n"
"  u[TAMAÑO]  decimal sin signo, TAMAÑO bytes por cada entero\n"
"  x[TAMAÑO]  hexadecimal, TAMAÑO bytes por cada entero\n"
"\n"
"TAMAÑO es un número. Para los TIPOs d, o, u ó x, TAMAÑO puede ser también:\n"
"C para `sizeof(char)', S para `sizeof(short)', I para `sizeof(int)' ó L "
"para\n"
"`sizeof(long)'. Si TIPO es f, TAMAÑO puede ser también F para "
"`sizeof(float)',\n"
" D para `sizeof(double)' ó L para `sizeof(long double)'.\n"
"\n"
"BASE es d para decimal, o para octal, x para hexadecimal o n para ninguna.\n"
"BYTES es hexadecimal con 0x ó 0X como prefijo, se multiplica por 512 si el\n"
"sufijo es b, por 1024 si es k y por 1048576 si es m. Si se añade el sufijo\n"
"z a cualquier tipo, se añade un visor de caracteres imprimibles al final de\n"
"cada línea del resultado. -s sin un número implica 3.\n"
"-w sin un número implica 32. Por omisión, od usa `-A o -t d2 -w 16'.\n"

#. The integer at P in S would overflow an unsigned long.
#. A digit string that long is sufficiently odd looking
#. that the following diagnostic is sufficient.
#: src/od.c:676 src/od.c:789
#, c-format
msgid "invalid type string `%s'"
msgstr "tipo de cadena inválido `%s'"

#: src/od.c:686
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"tipo de cadena inválido `%s';\n"
"este sistema no posee el tipo de entero de %lu bytes"

# ## Lo mismo: tipo de coma flotante de %lu bytes. sv
#: src/od.c:799
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"tipo de cadena inválido `%s';\n"
"este sistema no dispone de un tipo de coma flotante de %lu bytes"

#: src/od.c:862
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "carácter inválido `%c' en la cadena de tipo `%s'"

#: src/od.c:1029
msgid "cannot skip past end of combined input"
msgstr ""
"no se puede saltar a un punto que está más allá de la entrada combinada"

#: src/od.c:1341
msgid "old-style offset"
msgstr "desplazamiento al estilo antiguo"

# `set' -> [set] ... no deberíamos cambiar la terminología original, so pena
# de hacernos la picha un lío ... (opino, vamos :) ipg
#: src/od.c:1660
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr ""
"la base de la dirección de salida no es válida `%c'; debe ser uno de [doxn]"

#: src/od.c:1671
msgid "skip argument"
msgstr "pasando por alto este argumento"

# ¿Tiene sentido? ¿No sería `argumento límite'? (no tengo las fuentes,
# sorry O:) ipg
# No lo sé, yo tengo las fuentes, pero a primera vista no concluyo em+
#
# a ver si te acuerdas la próxima vez y "pegas" el trocito de código donde esté,
# así podremos discutir sobre ello....
# FIXME: Asegurarse de que significa eso. sv+
#: src/od.c:1682
msgid "limit argument"
msgstr "limitando este argumento"

# Había un fuzzy y lo he cambiado un poco.
#
# Eso de "representable" no me suena muy bien, ¿podrías explicar a qué se
# refiere?, incluso me parecen dos mensajes distintos...
#
# Pues un número, es un concepto abstracto, y su representación son cosas como
# 1, 2 3i em+
#: src/od.c:1686
#, c-format
msgid ""
"specified number of bytes `%s' is larger than the maximum\n"
"representable value of type `long'"
msgstr ""
"el número especificado de bytes `%s' es más grande que el valor máximo\n"
"representable de tipo `long'"

# ¿longitud mínima de cadena? Es que si no, me suena a spanglish :) ipg
# ok em+
#: src/od.c:1697
msgid "minimum string length"
msgstr "longitud mínima de cadena"

#: src/od.c:1751
msgid "width specification"
msgstr "especificación de ancho"

#: src/od.c:1770
msgid "no type may be specified when dumping strings"
msgstr "no se puede especificar tipo cuando se vuelcan cadenas"

# aunque con "operando no válido" se pueda llegar a la misma conclusión,
# creo que lo que propongo es mucho más claro...
# Creo que está bien así y de la otra forma, a mí me suena igual em+
#: src/od.c:1815
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "segundo operando inválido en el modo de compatibilidad `%s'"

#: src/od.c:1836
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr ""
"en el modo de compatibilidad, los dos últimos argumentos deben ser\n"
"desplazamientos"

#: src/od.c:1843
msgid "compatibility mode supports at most three arguments"
msgstr "el modo de compatibilidad admite como mucho tres argumentos"

#: src/od.c:1911
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "atención: ancho %lu inválido; se usará %d en su lugar"

#: src/od.c:1927
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: fmt=\"%s\" ancho=%d\n"

#: src/paste.c:214
msgid "standard input is closed"
msgstr "la entrada estándar está cerrada"

#: src/paste.c:413
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
msgstr ""
"Escribe secuencialmente en la salida estándar cada línea de los FICHEROs\n"
"especificados, separadas por tabuladores.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"  -d, delimiters=LISTA   usa los caracteres indicados en LISTA en lugar de\n"
"                         tabuladores\n"
"  -s, --serial           usa un fichero cada vez, en lugar de hacerlo en\n"
"                         paralelo\n"
"      --help             muestra esta ayuda y finaliza\n"
"      --version          informa de la versión y finaliza\n"
"\n"

# FIXME: El original es horrible.
#: src/pr.c:788
#, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "`--pages' rango de número de páginas inválido: `%s'"

#: src/pr.c:800
#, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "`--pages' número de página de comienzo inválido: `%s'"

#: src/pr.c:812
#, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "`--pages' número de página final inválido: `%s'"

#: src/pr.c:819
msgid "`--pages' starting page number is larger than ending page number"
msgstr ""
"`--pages' el número de página de comienzo es mayor que el número de página "
"final"

#: src/pr.c:910
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr "`--pages=PRIMERA_PÁGINA[:ÚLTIMA_PÁGINA]' falta un argumento"

#: src/pr.c:921
#, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "`--columns=COLUMNAS' número de columnas inválido: `%s'"

#: src/pr.c:973
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "`-l LONGITUD_PÁGINA' el número de líneas no es válido: `%s'"

#: src/pr.c:997
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "`-N NÚMERO' número de comienzo de línea inválido: `%s'"

#: src/pr.c:1009
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "`-o MARGEN' el desplazamiento de línea no es válido: `%s'"

#: src/pr.c:1050
#, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-w ANCHO_PÁGINA' número inválido de caracteres: `%s'"

#: src/pr.c:1062
#, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-W ANCHO_PÁGINA' número de caracteres inválido: `%s'"

# Me suena mejor "un número de columnas...", aunque solo sea una apreciación
# personal sin ningún criterio añadido, ¿qué os parece? (uac)
#
# Creo que es más correcto como está. em+
# Pues creo que lleva razón, debería ser "un" y no "el". sv+
#: src/pr.c:1080
msgid "Cannot specify number of columns when printing in parallel."
msgstr ""
"No se puede especificar el número de columnas cuando se escribe en paralelo."

#: src/pr.c:1084
msgid "Cannot specify both printing across and printing in parallel."
msgstr ""
"No se puede especificar a la vez impresión en paralelo y transversalmente."

# ¿No sería  "sobran los caracteres `-%c', ... "? sv+
# Por otro lado, ¿a qué viene lo de la opción -s? No está en el original. sv+
#: src/pr.c:1182
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr ""
"`-%c' sobran caracteres, o el argumento de la opción `-s' no es válido : `%s'"

#: src/pr.c:1293
msgid "page width too narrow"
msgstr "ancho de página demasiado estrecho"

#: src/pr.c:1706
#, c-format
msgid "%s%*s%s%*sPage"
msgstr "%s%*s%s%*sPágina"

#: src/pr.c:2389
#, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr ""
"el número de página de comienzo es mayor que el número total de páginas: `%d'"

# FUZZY.
# Sugerencia:
# comienza a imprimir la página PÁGINA\n" --> en/por la página (uac)
# Sugerencia: usado en conjunción con -COLUMNAS
# -> se utiliza en conjunción con -COLUMNAS. sv+
# Sugerencia: trailer -> cola (opuesto a cabecera).
# Si no te gusta el término, pon al menos `trailer'. sv+
#: src/pr.c:2781
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"Pagina o encolumna FICHERO para su impresión.\n"
"\n"
"  +PRIMERA_PAGINA[:ÚLTIMA_PAGINA]\n"
"                    comienza [termina] a imprimir por "
"PRIMERA_[ÚLTIMA_]PÁGINA\n"
"  -COLUMNAS         muestra la salida en el número de columnas indicado, a\n"
"                    menos que se especifique -a. Equilibra el número de "
"líneas\n"
"                    de cada columna en cada página.\n"
"  -a                crea las columnas transversalmente en lugar de en "
"paralelo,\n"
"                    usado en conjunción con -COLUMNAS\n"
"  -c                muestra los caracteres de control con notación\n"
"                    gorro (^G) o secuencias de escape octales\n"
"  -d                salida con espaciado doble\n"
"  -e[CARÁCTER[ANCHO]] sustituye el carácter de tabulación (o el CARÁCTER) "
"por\n"
"                    ANCHO (8) espacios\n"
"  -F, -f            simula saltos de página con una nueva línea para "
"separar\n"
"                    páginas (con una cabecera de página de 3 líneas con -f o "
"\n"
"                    de 5 líneas y trailer sin -f )\n"

# FUZZY.
#: src/pr.c:2803
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    with long headers left-hand-side truncation may occur,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, -S[STRING] sets separators\n"
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""
"  -h CABECERA       usa CABECERA en lugar del nombre de fichero en la "
"salida,\n"
"                    si la línea es demasiado larga se truncará por la "
"derecha\n"
"                    -h \"\\\" muestra una línea en blanco. No usar -h\"\\\"\n"
"  -i[CARÁCTER[ANCHO]] reemplaza los espacios con tabulaciones (o con "
"CARÁCTER)\n"
"                    de ancho ANCHO (8)\n"
"  -j                mezcla líneas completas, desactiva el truncamiento -w "
"de\n"
"                    líneas, no alinea las columnas, -s[CADENA] establece el\n"
"                    separador\n"
"  -l LONG_PÁGINA    establece la longitud de la página en el número "
"indicado\n"
"                    por defecto 66, o 56 si se especifica -f 63\n"

# FUZZY. Mirarlo despacio.
#: src/pr.c:2829
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by an optional STRING, don't use\n"
"                    -S \"STRING\", -S only: No separator used (same as "
"-S\"\"),\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
"  --help            display this help and exit\n"
"  --version         output version information and exit\n"
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"  -s[CAR],--separator[=CAR]\n"
"                    separa las columnas mediante un solo carácter, el valor\n"
"                    predeterminado de CAR es el carácter de <TAB> sin -w y\n"
"                    'ningún carácter' con -w. La opción -s[CAR] desactiva "
"el\n"
"                    truncamiento de líneas de las 3 opciones de columnas\n"
"                    (-COLUMN|-a -COLUMN|-m) excepto si se usa -w.\n"
"  -S[CADENA], --sep-string[=CADENA]\n"
"                    separa las columnas mediante una CADENA opcional, no "
"usar\n"
"                    -S \"CADENA\", -S solamente: No se usa separador (lo "
"mismo\n"
"                    que -S\"\"), sin -S: El separador predeterminado es "
"<TAB>\n"
"                    con -J y <espacio> en caso contrario (lo mismo que\n"
"                    -S\" \"), no hay ningún efecto en las opciones de "
"columnas\n"
"  -t, --omit-header no muestra cabeceras ni colas\n"
"  -T, --omit-pagination\n"
"                    no muestra cabeceras ni colas, descarta cualquier\n"
"                    formato de página establecido con retornos de página en\n"
"                    los ficheros de entrada\n"
"  -v, --show-nonprinting\n"
"                    usa la notación octal de barra invertida\n"
"  -w ANCHO_PÁGINA, --width=ANCHO_PÁGINA\n"
"                    establece el ancho de página en ANCHO_PÁGINA caracteres\n"
"                    (por omisión, 72) solamente para salida de texto en "
"varias\n"
"                    columnas, -s[car] desactiva (?)\n"
"  -W ANCHO_PÁGINA, --page-width=ANCHO_PÁGINA\n"
"                    establece el ancho de página siempre en ANCHO_PÁGINA\n"
"                    caracteres (por omisión 72), trunca las líneas, excepto\n"
"                    si se usa la opción -J, no interfiere con las opciones "
"-S\n"
"                    o -s\n"
"  --help            muestra esta ayuda y finaliza\n"
"  --version         informa de la versión y finaliza\n"
"\n"
"-l nn implica -T cuando nn <= 10 ( ó <= 3 con -F). Si no se especifica "
"ningún\n"
"FICHERO, o cuando FICHERO es -, lee la entrada estándar.\n"

#: src/ptx.c:409
#, c-format
msgid "%s (for regexp `%s')"
msgstr "%s (para la expresión regular `%s')"

#: src/ptx.c:1858
#, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN]... [ENTRADA]...   (sin -G)\n"
"       o bien:  %s -G [OPCIÓN]... [ENTRADA [SALIDA]]\n"

# msgid "Try `%s --help' for more information.\n"
# msgstr "Pruebe `%s --help' para más información.\n"
# ¿Alquien sabe qué coño es gap? No lo he encontrado en el diccionario .. ipg
# Pues gap suele ser una especie de desplazamiento o desajuste,
# lo traduciría aquí como separación em+
# Gracias. ipg
# Usaría 'se comporta' en vez de 'comportarse' em+
# Sentence = frase em
# Ok a los dos :) ipg
# 'genera salida' lo cambiaría por 'genera' o 'muestra' em+
# Pongo `genera el resultado con' ipg
# Por último, 'da información' me resulta antipático, me inclino
# por 'informa' em+
# Ya, esa se me pasó ... yastá :) ipg
# Perdón, pero lo de 'leer de' no me gusta , prefiero 'leer' a secas em+
# ok ipg
#
# Sugerencia: usa -> utiliza. sv
# Hmmm ... prefiero `usa', es más corto e igual de explicativo. Tampoco
# es en exceso coloquial como para no parecer medianamente serio ;) ipg
#
# ¡Pero en mkid me aceptaste la sugerencia! ¿Por qué aquí no? :-) sv
# No sabría decirte ... por el contexto, quizá ... ipg
#
# Bien, pues razóname por qué un contexto es más apropiado para usa
# y el otro es más apropiado para utiliza. sv
#
# ¡Psche! ... es cuestión muy psicológica. Si te fijas, a mí me parece
# un contexto de PM (Persona Mayor, malpensao ;) para ello, y a tí
# no. Creo que no hay por qué darle muchas vueltas ...
#
# Sugerencia (en -F) marcar las líneas -> señalar las líneas. sv
# Prefiero marcar, para mi señala se refiere más a una acción activa,
# `señalar' algún objeto, apuntar a él, no ser un objeto pasivo que
# hace que te fijes en el  objeto, que es lo que será la cadena. ipg
#
# He cambiado un poco lo de "Los argumentos obligatorios...". sv
# aunque todavía no es igual que el que tenía yo...
# Vale gracias :) me gusta más. Dile a Enrique que los revise en
# textutils. ipg
#
# Sugerencia: directivas TeX -> instrucciones TeX. sv
# Aquí prefiero ser fiel al original, ya que hay una traducción
# exacta e unívoca de una a otro (¡¡la función buena persona!! ;). ipg
# ... salvo que "directiva" me recuerda cantidad a las
# "directivas de la Unión Europea" sv
# A las que ni Cristo hace puto caso :) ipg
#
# Propongo: "Considera las minúsculas como mayúsculas para ordenar". sv
#
# Ahí estás considerando que convierte todo a mayúsculas ... ipg
#
# En absoluto: Estamos diciendo que las *considera como*, no que las
# convierta, y sólo *para ordenar*. Léelo bien, hombre. sv
#
# ¿qué tal `No distingue entre mayúsculas y minúsculas al ordenar'?
# (la pongo por ahora en espera de críticas ;) ipg
#
# No está mal, pero lo que yo proponía da más detalles sobre lo que
# hace internamente. Por ejemplo, ¿cómo sabes en qué lugar quedan los códigos
# que hay entre los de las mayúsculas y las minúsculas si solamente dices
# que "considera iguales las mayúsculas y las minúsculas"? sv
#
# Perdona Santiago, pero eso yo lo veo innecesario. Al usuario le da
# *igual* (o al menos le debería) cómo funcione internamente el hecho
# de considerar iguales las mayúsculas y las minúsculas, y el cómo se
# ordene, además de que dependerá del LOCALE, es casi irrelevante, porque
# creo (y digo creo) que las funciones de ordenación (strcoll && friends)
# siempre usan una secuencia de ordenación definida. En mi sistema
# usan la de ascii, pero porque yo no tengo definida la secuencia de
# ordenación para el castellano. Resumiendo: creo que la razón de
# `la posición de los códigos que hay entre mayúsculas y minúsculas'
# no es siempre aplicable.
# Uso mi frase, ¿ok? :) ipg
#
# Bueno, no es tan importante, pero me intriga por qué el autor
# quiso indicar eso dando más información de la que tú das
# en la traducción. sv
# Emoción, intriga, dolor de barriga :) ipg
#: src/ptx.c:1862
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
"\n"
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
"      --help                     display this help and exit\n"
"      --version                  output version information and exit\n"
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""
"Los argumentos obligatorios para las opciones largas lo son también\n"
"para las opciones cortas.\n"
"\n"
"  -A, --auto-reference           muestra automáticamente las referencias\n"
"                                 generadas\n"
"  -C, --copyright                muestra el Copyright y las condiciones\n"
"                                 de copia\n"
"  -G, --traditional              se comporta como el `ptx' de System V\n"
"  -F, --flag-truncation=CADENA   usa CADENA para marcar las líneas "
"truncadas\n"
"  -M, --macro-name=CADENA        usa CADENA como nombre de macro en lugar\n"
"                                 de `xx'\n"
"  -O, --format=roff              genera el resultado con directivas roff\n"
"  -R, --right-side-refs          pone las referencias a la derecha,\n"
"                                 sin contarlas en -w\n"
"  -S, --sentence-regexp=EXPR-REG para finales de línea o frase\n"
"  -T, --format=tex               genera salida como directivas TeX\n"
"  -W, --word-regexp=EXPR-REG     usa EXPR-REG para encontrar las palabras "
"clave\n"
"  -b, --break-file=ARCHIVO       toma de ARCHIVO los caracteres que definen\n"
"                                 las palabras\n"
"  -f, --ignore-case              no distingue entre mayúsculas y minúsculas\n"
"                                 al ordenar\n"
"  -g, --gap-size=NÚMERO          separación en columnas entre campos de "
"salida\n"
"  -i, --ignore-file=ARCHIVO      lee la lista de palabras a pasar por\n"
"                                 alto de ARCHIVO\n"
"  -o, --only-file=ARCHIVO        lee la lista de palabras a mantener de\n"
"                                 ARCHIVO\n"
"  -r, --references               el primer campo de la línea es una "
"referencia\n"
"  -t, --typeset-mode               - no implementado -\n"
"  -w, --width=NÚMERO             anchura de la salida en columnas,\n"
"                                 excluyendo referencias\n"
"      --help                     muestra esta ayuda y finaliza\n"
"      --version                  informa sobre la versión y finaliza\n"
"\n"
"Si no se especifica ARCHIVO o ARCHIVO es `-', lee de la entrada estándar.\n"
"Se toma `-F /' por defecto.\n"

#: src/ptx.c:1962
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""
"Este programa es software libre; puede ser redistribuido y/o\n"
"modificado bajo los términos de la Licencia Pública General de\n"
"GNU tal y como se publica por la Free Software Foundation; bien\n"
"en su versión 2, o (a su elección) cualquier versión posterior.\n"
"\n"
"Este programa se distribuye con la esperanza de que sea útil,\n"
"pero SIN NINGUNA GARANTÍA; ni siquiera la garantía implícita de\n"
"COMERCIABILIDAD o IDONEIDAD PARA UN FIN DETERMINADO. Véase la\n"
"Licencia Pública General de GNU para más detalles.\n"
"\n"
"Usted debería haber recibido una copia de la Licencia Pública\n"
"General de GNU junto con este programa; en caso contrario, escriba\n"
"a la Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n"
"Boston, MA 02111-1307, EE.UU.\n"

# Sugerencia para la -c:
# comprueba si los ficheros ya están ordenados, pero no los ordena.
# Si lo que buscas es algo corto, sugiero cambiar "y no ordena"
# por "pero no ordena", o bien "sin ordenar[los]". sv+
# Nota: Si la traducción "correcta" de la opción -s es eso que has puesto
# deberías pedir al autor que lo explicara un poco mejor. sv+
#: src/sort.c:259
#, c-format
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"  +POS1 [-POS2]    start a key at POS1, end it *before* POS2 (obsolescent)\n"
"\t\t     field numbers and character offsets are numbered\n"
"                     starting with zero (contrast with the -k option)\n"
"  -b               ignore leading blanks in sort fields or keys\n"
"  -c               check if given files already sorted, do not sort\n"
"  -d               consider only [a-zA-Z0-9 ] characters in keys\n"
"  -f               fold lower case to upper case characters in keys\n"
"  -g               compare according to general numerical value, imply -b\n"
"  -i               consider only [\\040-\\0176] characters in keys\n"
"  -k POS1[,POS2]   start a key at POS1, end it *at* POS2\n"
"\t\t     field numbers and character offsets are numbered\n"
"                     starting with one (contrast with zero-based +POS form)\n"
"  -m               merge already sorted files, do not sort\n"
"  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n"
"  -n               compare according to string numerical value, imply -b\n"
"  -o FILE          write result on FILE instead of standard output\n"
"  -r               reverse the result of comparisons\n"
"  -s               stabilize sort by disabling last resort comparison\n"
"  -t SEP           use SEParator instead of non- to whitespace transition\n"
"  -T DIRECTORY     use DIRECTORY for temporary files, not $TMPDIR or %s\n"
"  -u               with -c, check for strict ordering;\n"
"                   with -m, only output the first of an equal sequence\n"
"  -z               end lines with 0 byte, not newline, for find -print0\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
"\n"
msgstr ""
"Muestra la concatenación ordenada de todos los FICHERO(s) en la salida\n"
"estándar.\n"
"\n"
"  +POS1 [-POS2]    comienza una clave en POS1 y la termina *antes* de POS2\n"
"                   (obsoleto)\n"
"                   los números de campo y desplazamientos de caracteres se\n"
"                   numeran comenzando por cero (en contraste con la opción "
"-k\n"
"  -b               descarta espacios al principio de fichero en los campos\n"
"                   y en la clave al ordenar\n"
"  -c               comprueba si los ficheros están ordenados, y no ordena\n"
"  -d               considera sólo los caracteres [a-zA-Z0-9] en las claves\n"
"  -f               convierte a mayúsculas las claves\n"
"  -g               compara de acuerdo con el valor numérico, implica -b\n"
"  -i               considera sólo los caracteres [\\040-\\0176] en las "
"claves\n"
"  -k POS1[,POS2]   comienza una clave en POS1 y la termina *en* POS2\n"
"                   los números de campo y desplazamientos de caracteres se\n"
"                   numeran comenzando por uno (en contraste con la forma "
"+POS)\n"
"  -m               mezcla ficheros que ya están ordenados, no ordena\n"
"  -M               compara (desconocido) < 'JAN' < ... < `DEC', implica -b\n"
"  -n               compara de acuerdo con el valor numérico de la cadena,\n"
"                   implica -b\n"
"  -o FICHERO       escribe el resultado en FICHERO, en vez de salida "
"estándar\n"
"  -r               invierte el resultado de las comparaciones\n"
"  -s               deshabilita la comparación como última alternativa byte "
"por\n"
"                   byte cuando todos los campos resultaron iguales\n"
"  -t SEPARADOR     usa SEPARADOR en lugar de espacio para separar los "
"campos\n"
"  -T DIRECTORIO    usa DIRECTORIO para los ficheros temporales, no $TMPDIR\n"
"                   ni %s\n"
"  -u               con -c, comprueba estrictamente el orden\n"
"                   con -m, muestra solamente la primera repetición\n"
"  -z               termina de compararlas líneas con el byte 0, sin nueva "
"línea\n"
"                   adecuado para find -print()\n"
"       --help      muestra esta ayuda y finaliza\n"
"       --version   informa de la versión y finaliza\n"
"\n"

#: src/sort.c:290
msgid ""
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field, both counted from one with -k, from zero with the obsolescent\n"
"form.  OPTS is made up of one or more of Mbdfinr; this effectively disables\n"
"global -Mbdfinr settings for that key.  If no key is given, use the entire\n"
"line as the key.  With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"POS es F[.C][OPCIONES], donde F es el número de campo y C la posición del\n"
"carácter en el campo, ambos contados desde uno con -k, o desde cero con la\n"
"forma obsoleta. OPCIONES se compone de uno o más de los caracteres "
"[Mbdfinr];\n"
"esto deshabilita las opciones globales -Mbdfinr para esa clave. Si no se da\n"
"ninguna clave, usa la línea entera como clave. Si no se especifica ningún\n"
"FICHERO o FICHERO es `-', lee la entrada estándar.\n"

#: src/sort.c:381
msgid "flushing file"
msgstr "actualizando el fichero"

#: src/sort.c:390
msgid "error closing file"
msgstr "error al cerrar el fichero"

#: src/sort.c:402 src/sort.c:2371 src/sort.c:2376
#, c-format
msgid "%s: write error"
msgstr "%s: error de escritura"

#: src/sort.c:1451
#, c-format
msgid "%s: %s:%d: disorder: "
msgstr "%s: %s:%d fuera de secuencia: "

#: src/sort.c:1454
#, fuzzy
msgid "standard error"
msgstr "stdin: error de lectura"

#: src/sort.c:1816
#, c-format
msgid "invalid field specification `%s'"
msgstr "especificación de campo inválida `%s'"

# cuando se utiliza el estilo de ... sv+
#. Provoke with `sort -9'.
#: src/sort.c:2024
msgid ""
"when using the old-style +POS and -POS key specifiers,\n"
"the +POS specifier must come first"
msgstr ""
"al usar el estilo de parámetros antiguo con +POS y -POS,\n"
"el primero de ellos debe ser +POS"

#: src/sort.c:2060
msgid "option `-k' requires an argument"
msgstr "la opción `-k' requiere un argumento"

#. Provoke with `sort -k0'
#: src/sort.c:2077
msgid "the starting field number argument to the `-k' option must be positive"
msgstr ""
"el número que especifica el primer campo en la opción `-k' debe\n"
"ser positivo"

#. Provoke with `sort -k1.'
#: src/sort.c:2088
msgid "starting field spec has `.' but lacks following character offset"
msgstr ""
"la especificación del campo de comienzo tiene `.' pero carece de número de\n"
"desplazamiento de caracteres"

#. Provoke with `sort -k1.0'
#: src/sort.c:2097
msgid ""
"starting field character offset argument to the `-k' option\n"
"must be positive"
msgstr ""
"el argumento de desplazamiento del campo de comienzo para la opción `-k'\n"
"debe ser positivo."

# OJO: Cambio `.' por `,' sv+
#. Provoke with `sort -k1,'
#: src/sort.c:2125
msgid "field specification has `,' but lacks following field spec"
msgstr ""
"la especificación de campo tiene `,' pero no constan a continuación las\n"
"especificaciones del campo"

#. Provoke with `sort -k1,0'
#: src/sort.c:2135
msgid "ending field number argument to the `-k' option must be positive"
msgstr "el número de campo final para la opción `-k' debe ser positivo"

# Ídem. ipg
#. Provoke with `sort -k1,1.'
#: src/sort.c:2146
msgid "ending field spec has `.' but lacks following character offset"
msgstr ""
"la especificación del campo de final tiene `.' pero no le sigue un\n"
"desplazamiento de caracteres"

#: src/sort.c:2177
msgid "option `-o' requires an argument"
msgstr "la opción `-o' requiere un argumento"

#: src/sort.c:2195
msgid "option `-t' requires an argument"
msgstr "la opción `-t' requiere un argument"

#: src/sort.c:2206
msgid "option `-T' requires an argument"
msgstr "la opción `-T' requiere un argumento"

# Sugerencia: opción `-%c' desconocida. sv+
# ## En cualquier caso, he cambiado la segunda comita por '. sv+
#: src/sort.c:2221
#, c-format
msgid "%s: unrecognized option `-%c'\n"
msgstr "%s: opción desconocida `-%c'\n"

#: src/split.c:87
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "Modo de empleo: %s [OPCIÓN] [FICHERO [PREFIJO]]\n"

# FIXME: ¿Ahora dos espacios es el estándar para mensajes de continuación?
# (before each output file...)
#
# Creo que es importante que se especifique en
#
# ...BYTES puede tener un sufijo... que el sufijo es un factor...
# Sí, no me gustaba tal y como estaba em
#: src/split.c:91
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
"  -NUMBER                 same as -l NUMBER\n"
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"Corta FICHERO en trozos de tamaño fijo y los vuelca en PREFIJOaa, "
"PREFIJOab...\n"
"El prefijo por defecto es `x'. Si no se especifica FICHERO, o fichero es "
"`-',\n"
"lee la entrada estándar.\n"
"\n"
"  -b, --bytes=BYTES       escribe BYTES bytes en cada fichero de salida\n"
"  -C, --line-bytes=BYTES  escribe un máximo de BYTES bytes sin cortar "
"líneas\n"
"  -l, --lines=NÚMERO      pone NÚMERO de líneas en cada fichero de salida\n"
"  -NÚMERO                 lo mismo que -l NÚMERO\n"
"      --verbose           muestra un diagnóstico en la salida de error\n"
"                          estándar antes de que cada fichero sea creado\n"
"       --help             muestra esta ayuda y finaliza\n"
"       --version          informa de la versión y finaliza\n"
"\n"
"BYTES puede tener un factor indicado con el sufijo: b para 512, k para 1K,\n"
"m para 1Meg\n"

#: src/split.c:157
#, c-format
msgid "creating file `%s'\n"
msgstr "creando fichero `%s'\n"

# "no se puede trocear de varias formas distintas"
# (ver fileutils). sv+
#: src/split.c:374 src/split.c:390 src/split.c:406 src/split.c:432
msgid "cannot split in more than one way"
msgstr "no se puede trocear en más de una forma a la vez"

#: src/split.c:381 src/split.c:414
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: número de bytes inválido"

#: src/split.c:397
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: número de líneas inválido"

#: src/split.c:464
msgid "invalid number"
msgstr "número inválido"

#: src/split.c:479 src/tr.c:1852 src/uniq.c:409
msgid "too many arguments"
msgstr "demasiados argumentos"

# usa bloques -> con bloques ... así no se repite tanto :) ipg
# Creo que está bien así em+
#: src/sum.c:65
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"Muestra la suma de comprobación y el número de bloques para cada FICHERO.\n"
"\n"
"  -r            incompatible con -s, usa el algoritmo de BSD, con bloques de "
"1K\n"
"  -s, --sysv    usa el algoritmo de System V, con bloques de 512 bytes\n"
"      --help    muestra esta ayuda y finaliza\n"
"      --version informa de la versión y finaliza\n"
"\n"
"Si no se especifica FICHERO, o si FICHERO es `-', lee la entrada estándar\n"

#: src/tac.c:132
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
msgstr ""
"Escribe cada FICHERO en la salida estándar comenzando por la última línea\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"  -b,  --before           añade el separador antes de cada línea, en lugar "
"de\n"
"                          añadirlo después\n"
"  -r,  --regex            interpreta el separador como una expresión "
"regular\n"
"  -s,  --separator=CADENA usa CADENA como separador, en lugar de un salto "
"de\n"
"                          línea\n"
"       --help             muestra esta ayuda y finaliza\n"
"       --version          informa de la versión y finaliza\n"
"\n"

#: src/tac.c:453 src/tac.c:594
msgid "stdin: read error"
msgstr "stdin: error de lectura"

# "la cadena" ¿de dónde sale eso? sv
# Bueno, siempre he traducido array por cadena, cuando
# he tenido que hacerlo. Lo siento
# ¿Qué pongo? ¿secuencia de caracteres nula? em+
# ¿Y "el separador no puede ser vacío"? sv
# La única cosa que es vacía de la que he oido hablar es el famoso
# conjunto ese. Las demás cosas o están vacías o no están, pero
# no 'son' vacías em
# Yo pondría `el separador no puede ser nulo'. No es muy ortodoxo,
# pero no queda mal. ipg
# Por mí de acuerdo, lo cambio em
#: src/tac.c:638
msgid "separator cannot be empty"
msgstr "el separador no puede ser nulo"

#: src/tail.c:216
#, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"      --retry              keep trying to open a file even if it is\n"
"                             inaccessible when tail starts or if it becomes\n"
"                             inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
"  -f, --follow[={name|descriptor}] output appended data as the file grows;\n"
"                             -f, --follow, and --follow=descriptor are\n"
"                             equivalent\n"
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N see the texinfo documentation\n"
"                             (the default is %d)\n"
"      --max-consecutive-size-changes=N see the texinfo documentation\n"
"                             (the default is %d)\n"
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, sleep S seconds between iterations\n"
"  -v, --verbose            always output headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
"or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
"the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
"or -c +VALUE.\n"
"\n"
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
"\n"
msgstr ""
"Muestra las últimas %d líneas de cada FICHERO en la salida estándar.\n"
"Con más de un FICHERO, precede a cada grupo de líneas con una cabecera.\n"
"Si no se especifica FICHERO o FICHERO es `-', lee la entrada estándar.\n"
"\n"
"      --retry              sigue intentando abrir un fichero incluso si es\n"
"                             inaccesible cuando tail comienza o si se "
"vuelve\n"
"                             inaccesible más tarde -- útil solamente con -f\n"
"  -c, --bytes=N            muestra los últimos N bytes\n"
"  -f, --follow[={nombre|descriptor}] muestra a medida que el fichero crece;\n"
"                             -f, --follow, y --follow=descriptor son\n"
"                             equivalentes\n"
"  -n, --lines              muestra las últimas N líneas en lugar de %d\n"
"      --max-unchanged-stats=N vea la documentación texinfo\n"
"                             (el valor predeterminado es %d)\n"
"      --max-consecutive-size-changes=N vea la documentación texinfo\n"
"                             (el valor predeterminado es %d)\n"
"      --pid=PID            con -f, termina después de que el ID del "
"proceso,\n"
"                             PID, muere\n"
"  -q, --quiet, --silent    no presenta cabeceras para cada fichero\n"
"  -s, --sleep-interval=S   con -F, espera S segundos entre iteraciones\n"
"  -v, --verbose            presenta siempre las cabeceras para cada fichero\n"
"      --help               muestra esta ayuda y finaliza\n"
"      --version            informa de la versión y finaliza\n"
"\n"
"Si el primer carácter de N es un `+', comienza a mostrar en el elemento\n"
"número N contando desde el principio de cada FICHERO, en otro caso, muestra\n"
"los últimos N elementos del fichero. N puede tener diferentes sufijos que\n"
"indican un factor: b para 512 bytes, k para 1024 bytes, m para 1 Megabyte.\n"
"Si la primera opción es -VALOR o +VALOR se trata como si fuese -n VALOR o\n"
"-n +VALOR, a menos que VALOR tenga uno de los sufijos mencionados (bkm), en "
"\n"
"cuyo caso se trata como -c VALOR o -c +VALOR.\n"
"\n"
"Con --follow (-f), tail de forma predeterminada seguirá el descriptor del\n"
"fichero, lo que significa que si se renombra un fichero al que se le hace "
"tail\n"
"tail continuará siguiendo su final. Este comportamiento predeterminado no "
"es\n"
"deseable cuando lo que de verdad quiere seguir es el nombre real del "
"fichero,\n"
"no el descriptor del fichero (p.ej: rotación de ficheros de registro). "
"Utilice\n"
"--follow=nombre en tal caso. Esto hace que tail siga el fichero mencionado\n"
"reabriéndolo periódicamente para ver si ha sido borrado o recreado por "
"algún\n"
"otro programa.\n"
"\n"

# df=descriptor de fichero, por supuesto... sv
#: src/tail.c:293
#, c-format
msgid "closing %s (fd=%d)"
msgstr "cerrando %s (df=%d)"

#. FIXME-maybe: detect the case in which the file first becomes
#. unreadable (perms), and later becomes readable again and can
#. be seen to be the same file (dev/ino).  Otherwise, tail prints
#. the entire contents of the file when it becomes readable.
#: src/tail.c:720
#, c-format
msgid "`%s' has become inaccessible"
msgstr "`%s' se ha vuelto inaccesible"

#: src/tail.c:739
#, c-format
msgid ""
"`%s' has been replaced with a non-regular file;  cannot follow end of "
"non-regular file"
msgstr ""
"`%s' ha sido reemplazado por un fichero no regular;  no se puede localizar\n"
"el final de un fichero no regular"

#: src/tail.c:759
#, c-format
msgid "`%s' has become accessible"
msgstr "`%s' se ha vuelto accesible"

#: src/tail.c:767
#, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "`%s' ha aparecido;  siguiendo el final del nuevo fichero"

#: src/tail.c:778
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr "`%s' ha sido reemplazado;  siguiendo el final del nuevo fichero"

#: src/tail.c:892
msgid "file truncated"
msgstr "fichero truncado"

#: src/tail.c:912
msgid "no files remaining"
msgstr "no queda ningún fichero"

#: src/tail.c:1120
#, c-format
msgid "%s: cannot follow end of non-regular file"
msgstr "%s: no se puede localizar el final de un fichero no regular"

#: src/tail.c:1231
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: el sufijo es inválido en una opción obsoleta"

# FIXME: Es muy raro que después de ; se use mayúscula.
#: src/tail.c:1280
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"demasiados argumentos;  Cuando se utiliza la opción de sintaxis obsoleta de\n"
"tail (%s) no puede haber más de un fichero como argumento. Utilice la "
"opción\n"
"equivalente -n ó -c en su lugar."

#: src/tail.c:1289
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""
"Atención: no es transportable usar dos o más ficheros como argumentos con "
"la\n"
"opción de sintaxis obsoleta (%s). Utilice la opción equivalente -n ó -c\n"
"en su lugar."

#: src/tail.c:1371
#, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr "%s: número máximo de stats entre aperturas inválido"

#: src/tail.c:1383
#, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s: número máximo de cambios de tamaño consecutivos inválido"

#: src/tail.c:1395
#, c-format
msgid "%s: invalid PID"
msgstr "%s: PID inválido"

#: src/tail.c:1413
#, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: número de segundos inválido"

#: src/tail.c:1433
msgid "warning: --retry is useful only when following by name"
msgstr "atención: --retry solamente es útil cuando se sigue por nombre"

# FIXME: "when following"? when following by what? sv
#: src/tail.c:1437
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr "atención: PID descartado; --pid=PID solamente es útil cuando se sigue"

#: src/tr.c:325
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "Modo de empleo: %s [OPCIÓN]... CONJUNTO1 [CONJUNTO2]\n"

#: src/tr.c:329
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace sequence of characters with one\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
msgstr ""
"Traduce, comprime y/o borra caracteres de la entrada estándar, escribiendo\n"
"el resultado en la salida estándar.\n"
"\n"
"  -c,  --complement        opera sobre el complemento (sobre cada carácter\n"
"                           que no coincida)\n"
"  -d,  --delete            borra caracteres de CONJUNTO1, no traduce\n"
"  -s,  --squeeze-repeats   remplaza una secuencia de carateres iguales en "
"uno\n"
"  -t,  --truncate-set1     trunca CONJUNTO1 a la longitud de CONJUNTO2\n"
"       --help              muestra esta ayuda y finaliza\n"
"       --version           informa de la versión y finaliza\n"

# Y el "all". ¿No lo traduces? sv
# Sugerencia: "Pitido audible (BEL)". (Es un carácter llamado así). sv
#: src/tr.c:340
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR1-CHAR2]   same as CHAR1-CHAR2, if both SET1 and SET2 use this\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"\n"
"Los CONJUNTOs se especifican como cadenas de caracteres. La mayoría se\n"
"representan a sí mismos.\n"
"Las secuencias válidas son las siguientes:\n"
"\n"
"  \\NNN            carácter con valor octal NNN (de uno a tres dígitos)\n"
"  \\\\              barra invertida\n"
"  \\a              pitido audible (BEL)\n"
"  \\b              espacio hacia atrás\n"
"  \\f              salto de página\n"
"  \\n              salto de línea\n"
"  \\r              retorno de carro\n"
"  \\t              tabulación horizontal\n"
"  \\v              tabulación vertical\n"
"  CAR1-CAR2       todos los caracteres comprendidos entre CAR1 y CAR2 "
"contados\n"
"                  en orden ascendente\n"
"  [CAR1-CAR2]     lo mismo que CAR1-CAR2, tanto CONJUNTO1 como CONJUNTO2\n"
"                  los usan\n"
"  [CAR*]          en CONJUNTO2, copias de CAR hasta que se alcance la "
"longitud\n"
"                  de CONJUNTO1\n"
"  [CAR*REPITE]    copia REPITE veces CAR; REPITE es octal si comienza con 0\n"
"  [:alnum:]       todas las letras y dígitos\n"
"  [:alpha:]       todas las letras\n"
"  [:blank:]       todos los espacios en blanco horizontales\n"
"  [:cntrl:]       todos los caracteres de control\n"
"  [:digit:]       todos los dígitos\n"
"  [:graph:]       todos los caracteres imprimibles, sin incluir el espacio\n"
"  [:lower:]       todas las letras minúsculas\n"
"  [:print:]       todos los caracteres imprimibles, incluyendo el espacio\n"
"  [:punct:]       todos los caracteres de puntuación\n"
"  [:space:]       todos los espacios en blanco horizontales y verticales\n"
"  [:upper:]       todas las letras mayúsculas\n"
"  [:xdigit:]      todos los números hexadecimales\n"
"  [=CAR=]         todos los caracteres que son igual que CAR\n"

# squeezing -> la compresión; lo has usado tú antes :) ipg
# se me pasó em+
# Sugerencia: Los caracteres que sobran en CONJUNTO2
# no se tienen en cuenta. sv+
# (ánimo, que ya es el único "ignorar" que queda en todo el fichero :-)
#: src/tr.c:372
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"Se produce la traducción si no se especifican CONJUNTO1 y CONJUNTO2, "
"siempre\n"
"y cuando no aparezca la opción -d. -t se puede usar sólo al traducir.\n"
"CONJUNTO2 se expande a la longitud de CONJUNTO1, repitiendo su último\n"
"carácter tantas veces como sea necesario. Los caracteres en exceso de\n"
"CONJUNTO2 se ignoran. Solamente se garantiza que [:lower:] y [:upper:]\n"
"sean expandidos en orden ascendente; si se usa en CONJUNTO2 al traducir,\n"
"sólo se pueden usar en parejas, para especificar conversión a mayúsculas.\n"
"-s usa CONJUNTO1 si no se está traduciendo ni borrando; si no, la\n"
"compresión usa CONJUNTO2 después de la traducción o el borrado.\n"

# Me alegro de que te hayas comido el \t. Creo que lo mismo se puede hacer
# en otro msgstr que hay mucho más atrás. sv
#. Any octal number larger than 0377 won't
#. fit in 8 bits.  So we stop when adding the
#. next digit would put us over the limit and
#. give a warning about the ambiguity.  POSIX
#. isn't clear on this, but one person has said
#. that in his interpretation, POSIX says tr
#. can't even give a warning.
#: src/tr.c:544
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"atención: la secuencia de escape octal ambigua \\%c%c%c\n"
"se interpreta como la secuencia de 2 bytes \\0%c%c, `%c'"

#: src/tr.c:553
msgid "invalid backslash escape at end of string"
msgstr "secuencia de escape inválida al final de la cadena"

#: src/tr.c:559
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "secuencia de escape inválida `\\%c'"

#: src/tr.c:712
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr "los extremos del rango en `%s-%s' están en orden inverso"

# También necesito aquí ayuda em
# Yo creo que queda bien. ipg
#: src/tr.c:927
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "número de repeticiones `%s' inválido en la especificación [c*n]"

#: src/tr.c:1033
#, c-format
msgid "invalid character class `%s'"
msgstr "clase de carácter inválido `%s'"

#: src/tr.c:1058
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: el operador de equivalencia de clase debe ser un sólo carácter"

#: src/tr.c:1530
msgid "the [c*] repeat construct may not appear in string1"
msgstr "el operador de repetición [c*] no puede aparecer en cadena1"

# Cualquiera de las dos siguientes me suena "más español":
# sólo puede aparecer un operador de repetición [c*] en cadena2. sv+
# en cadena2 sólo puede aparecer un operador de repetición. sv+
#: src/tr.c:1540
msgid "only one [c*] repeat construct may appear in string2"
msgstr "sólo un operador de repetición [c*] puede aparecer en cadena2"

#: src/tr.c:1548
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "las expresiones [=c=] no pueden aparecer en cadena2 al traducir"

#: src/tr.c:1561
msgid "when not truncating set1, string2 must be non-empty"
msgstr "si no se está truncando conjunto1, cadena2 debe ser no vacía"

# cuando se traducen... sv+
#: src/tr.c:1570
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"al traducir con clases de caracteres complementarias (que no coinciden),\n"
"cadena2 debe hacer corresponder todos los caracteres del dominio a uno solo"

# cuando se traduce... sv+
#: src/tr.c:1577
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"al traducir, las únicas clases de caracteres que pueden aparecer en cadena2 "
"\n"
"son 'upper' y 'lower'"

#: src/tr.c:1586
msgid "the [c*] construct may appear in string2 only when translating"
msgstr "las expresiones [c*] sólo pueden aparecer en cadena2 al traducir"

#: src/tr.c:1857
msgid "two strings must be given when translating"
msgstr "se deben proporcionar dos cadenas al traducir"

# "cuando se borra y se comprimen repeticiones se deben proporcionar
# dos cadenas". sv+
#: src/tr.c:1860
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr ""
"se deben proporcionar dos cadenas cuando se borra y comprimen repeticiones"

# ## Añado la tilde de sólo. sv+
# "cuando se borra sin comprimir repeticiones sólo se debe especificar una
# cadena" sv+
#: src/tr.c:1874
msgid "only one string may be given when deleting without squeezing repeats"
msgstr ""
"sólo se debe especificar una cadena cuando se borra sin comprimir "
"repeticiones"

# lo mismo... sv+
#: src/tr.c:1880
msgid "at least one string must be given when squeezing repeats"
msgstr ""
"se debe especificar al menos una cadena cuando se comprimen repeticiones"

#: src/tr.c:1971
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "las construcciones [:upper:] y/o [:lower:] están desalinedas"

# ## cambio "mapeo" (spanglish) por *correspondencia*.
# ## En otro lugar ya habías usado esta palabra. sv+
#: src/tr.c:1994
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"correspondencia inválida; cuando se traduce, cualquier construcción [:lower] "
"o\n"
"[:upper:] en la cadena1 debe de estar alineada con la correpondiente\n"
"construcción ([:upper:] o [:lower:], respectivamente) en cadena2"

#: src/tsort.c:93
#, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
msgstr ""
"Modo de empleo: %s [OPCIÓN] [FICHERO]\n"
"Escribe una lista completamente ordenada consistente con el orden parcial "
"en\n"
"FICHERO. Sin ningún FICHERO, o cuando FICHERO es -, lee la entrada "
"estándar.\n"
"\n"
"      --help       muestra esta ayuda y finaliza\n"
"      --version    informa de la versión y finaliza\n"

#: src/tsort.c:101
msgid ""
"\n"
"Report bugs to <textutils-bugs@gnu.org>."
msgstr ""
"\n"
"Comunicar `bugs' a <textutils-bugs@gnu.org>"

#: src/tsort.c:443
#, c-format
msgid "%s: input contains a loop:\n"
msgstr "%s: la entrada contiene un bucle:\n"

#. Should not happen.
#: src/tsort.c:450
msgid "could not find loop"
msgstr "no se puede encontrar un bucle"

#: src/tsort.c:480
msgid "only one argument may be specified"
msgstr "sólo se puede especificar un argumento"

#: src/unexpand.c:365
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""
"Convierte los espacios de cada FICHERO en tabulaciones, escribiendo el\n"
"resultado en la salida estándar. Si no se especifica FICHERO o FICHERO\n"
"es `-', lee la entrada estándar.\n"
"\n"
"  -a, --all           convierte todos los espacios en blanco, no solo los\n"
"                      iniciales\n"
"  -t, --tabs=NÚMERO   usa N espacios en cada tabulación, en vez de 8\n"
"  -t, --tabs=LISTA    usa la LISTA de posiciones separadas por comas para\n"
"                      definir las posiciones de tabulación\n"
"      --help          muestra esta ayuda y finaliza\n"
"      --version       informa de la versión y finaliza\n"
"\n"
"En vez de `-t N' ó `-t LISTA' puede usarse -N ó -LISTA.\n"

#: src/uniq.c:100
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "Modo de empleo: %s [OPCIÓN]... [ENTRADA [SALIDA]]\n"

#: src/uniq.c:104
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
"  -D, --all-repeated    print all duplicate lines\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -w, --check-chars=N   compare no more than N characters in lines\n"
"  -N                    same as -f N\n"
"  +N                    same as -s N\n"
"      --help            display this help and exit\n"
"      --version         output version information and exit\n"
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"Descarta todas las líneas sucesivas idénticas, menos una. de ENTRADA (o\n"
"entrada estándar), escribiendo en SALIDA (o en la salida estándar).\n"
"\n"
"  -c, --count           precede a las líneas con el número de ocurrencias\n"
"  -d, --repeated        muestra sólo las líneas duplicadas\n"
"  -D, --all-repeated    muestra todas las líneas duplicadas\n"
"  -f, --skip-fields=N   pasa por alto la comparación de los primeros N "
"campos\n"
"  -i, --ignore-case     pasa por alto las diferencias entra mayúsculas y\n"
"                        minúsculas\n"
"  -s, --skip-chars=N    pasa por alto la comparación de los primeros N "
"caracteres\n"
"  -u, --unique          muestra sólo las líneas que son únicas\n"
"  -w, --check-chars=N   sólo compara los primeros N caracteres de la línea\n"
"  -N                    lo mismo que -f N\n"
"  +N                    lo mismo que -s N\n"
"      --help            muestra esta ayuda y finaliza\n"
"      --version         informa de la versión y finaliza\n"
"\n"
"Un campo es cada conjunto de caracteres separados por espacios.\n"
"Se pasan por alto los campos y después los caracteres.\n"

#: src/uniq.c:272
#, c-format
msgid "error reading %s"
msgstr "error al leer %s"

#: src/uniq.c:275
#, c-format
msgid "error writing %s"
msgstr "error al escribir en %s"

# "saltar" quedaría más bonito. sv+
#: src/uniq.c:337
#, c-format
msgid "invalid number of fields to skip: `%s'"
msgstr "el número de campos que se deben pasar por alto no es válido: `%s'"

# ídem sv+
#: src/uniq.c:353
#, c-format
msgid "invalid number of bytes to skip: `%s'"
msgstr "el número de bytes que se deben pasar por alto no es válido: `%s'"

# Me gustaba mucho más "el número de bytes que hay que comparar".
# Lo de "se han de comparar" me parece un poco pedante. sv
# Pero correcto em+
# es incorrecto ser pedante cuando no hay necesidad... sv+
#: src/uniq.c:369 src/uniq.c:395
#, c-format
msgid "invalid number of bytes to compare: `%s'"
msgstr "el número de bytes que se han de comparar no es válido: `%s'"

#: src/uniq.c:416
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""
"mostrar todas las líneas duplicadas y los contadores de repetición\n"
"no tiene sentido"

#: src/wc.c:89
msgid ""
"Print line, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes, --chars   print the byte counts\n"
"  -l, --lines            print the newline counts\n"
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
"      --help             display this help and exit\n"
"      --version          output version information and exit\n"
msgstr ""
"Muestra el número de líneas, palabras y bytes para cada FICHERO, y una "
"línea\n"
"con el total si se especifica más de un FICHERO. Si no se especifica ningún\n"
"FICHERO, o si FICHERO es -, lee la entrada estándar.\n"
"  -c, --bytes, --chars   muestra el número de bytes\n"
"  -l, --lines            muestra el número de líneas\n"
"  -L, --max-line-length  muestra la longitud de la línea más larga\n"
"  -w, --words            muestra el número de palabras\n"
"      --help             muestra esta ayuda y finaliza\n"
"      --version          informa de la versión y finaliza\n"
"\n"

#: src/wc.c:364
msgid "total"
msgstr "total"

#~ msgid "`%s' has reappeared"
#~ msgstr "`%s' ha reaparecido"

#~ msgid "`-w PAGE_WIDTH' invalid column number: `%s'"
#~ msgstr "`-w ANCHO_PÁGINA' el número de columna no es válido: `%s'"

# Suprimo el "virtual", con tu permiso. sv
#~ msgid "virtual memory exhausted"
#~ msgstr "memoria agotada"

#~ msgid "argument"
#~ msgstr "argumento"

#~ msgid "`+' requires a numeric argument"
#~ msgstr "`+' requiere un argumento numérico"

#~ msgid "%s: extra characters in the argument to the `-%c' option: `%s'\n"
#~ msgstr "%s: sobran caracteres en el argumento de la opción `-%c' : `%s'\n"
