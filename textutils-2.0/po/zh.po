# Chinese translation for GNU textutils messages.
# Copyright (C) 1998 Free Software Foundation, Inc.
# Yuan-Chung Cheng <platin@ms.ccafps.khc.edu.tw>, 1998.
#
msgid ""
msgstr ""
"Project-Id-Version: textutils 1.22\n"
"POT-Creation-Date: 1999-08-06 02:10+0200\n"
"PO-Revision-Date: 1998-04-23 16:27+06:00\n"
"Last-Translator: Yuan-Chung Cheng <platin@ms.ccafps.khc.edu.tw>\n"
"Language-Team: Chinese <zh@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=big5\n"
"Content-Transfer-Encoding: 8-bit\n"

#: src/cat.c:84 src/cksum.c:265 src/comm.c:70 src/csplit.c:1502 src/cut.c:193
#: src/expand.c:104 src/fmt.c:268 src/fold.c:61 src/head.c:79 src/join.c:141
#: src/md5sum.c:100 src/nl.c:171 src/od.c:262 src/paste.c:405 src/pr.c:2772
#: src/ptx.c:1854 src/sort.c:251 src/split.c:83 src/sum.c:57 src/tac.c:124
#: src/tail.c:208 src/tr.c:321 src/tsort.c:89 src/unexpand.c:357 src/uniq.c:96
#: src/wc.c:81
#, c-format
msgid "Try `%s --help' for more information.\n"
msgstr "請用 `%s --help' 來顯示本指令的用法\n"

#: src/cat.c:88
#, c-format
msgid "Usage: %s [OPTION] [FILE]...\n"
msgstr "用法：%s [OPTION] [FILE]...\n"

#: src/cat.c:92
msgid ""
"Concatenate FILE(s), or standard input, to standard output.\n"
"\n"
"  -A, --show-all           equivalent to -vET\n"
"  -b, --number-nonblank    number nonblank output lines\n"
"  -e                       equivalent to -vE\n"
"  -E, --show-ends          display $ at end of each line\n"
"  -n, --number             number all output lines\n"
"  -s, --squeeze-blank      never more than one single blank line\n"
"  -t                       equivalent to -vT\n"
"  -T, --show-tabs          display TAB characters as ^I\n"
"  -u                       (ignored)\n"
"  -v, --show-nonprinting   use ^ and M- notation, except for LFD and TAB\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"把由 FILE(s) 或標準輸入讀取的資料連結起來，輸出到標準輸出。\n"
"\n"
"  -A, --show-all           跟 -vET 相同\n"
"  -b, --number-nonblank    輸出時標出非空白行的行號\n"
"  -e                       跟 -vE 相同\n"
"  -E, --show-ends          在每一行的最後顯示 `$' 記號 \n"
"  -n, --number             輸出時標出行號\n"
"  -s, --squeeze-blank      不輸出超過一行的空白行\n"
"  -t                       跟 -vT 相同\n"
"  -T, --show-tabs          將跳格字元 (TAB) 顯示為  ^I\n"
"  -u                       (這選項不被處理)\n"
"  -v, --show-nonprinting   除了跳格及換行字元外，使用 ^ 及 M- "
"表示法顯示字元\n"
"      --help               顯示這段說明訊息\n"
"      --version            顯示版本資訊\n"
"\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"

#: src/cat.c:111
msgid ""
"\n"
"  -B, --binary             use binary writes to the console device.\n"
"\n"
msgstr ""

#: src/cat.c:116 src/cksum.c:279 src/comm.c:87 src/csplit.c:1533 src/cut.c:225
#: src/expand.c:124 src/fmt.c:289 src/fold.c:79 src/head.c:103 src/join.c:175
#: src/md5sum.c:126 src/nl.c:213 src/od.c:327 src/paste.c:424 src/pr.c:2859
#: src/sort.c:298 src/split.c:106 src/sum.c:75 src/tac.c:142 src/tail.c:261
#: src/tr.c:383 src/unexpand.c:377 src/uniq.c:124 src/wc.c:100
#, fuzzy
msgid ""
"\n"
"Report bugs to <bug-textutils@gnu.org>."
msgstr ""
"\n"
"發現錯誤, 請報告到 textutils-bugs@gnu.ai.mit.edu"

#: src/cat.c:176 src/cat.c:257 src/cat.c:310 src/cat.c:820 src/comm.c:220
#: src/csplit.c:1493 src/cut.c:799 src/expand.c:392 src/fmt.c:416
#: src/fold.c:225 src/fold.c:306 src/head.c:139 src/head.c:169 src/head.c:387
#: src/join.c:871 src/md5sum.c:629 src/nl.c:608 src/od.c:1940 src/paste.c:485
#: src/pr.c:1158 src/tac.c:715 src/tail.c:285 src/tail.c:1518 src/tr.c:1670
#: src/tr.c:1916 src/tr.c:2024 src/tr.c:2031 src/tsort.c:490
#: src/unexpand.c:454
msgid "write error"
msgstr "寫入時發生錯誤"

#: src/cat.c:298
#, c-format
msgid "cannot do ioctl on `%s'"
msgstr "沒辦法對 `%s' 執行輸出入控制 (ioctl)"

#: src/cat.c:630 src/od.c:1152
msgid "standard output"
msgstr "標準輸出"

#: src/cat.c:761
#, c-format
msgid "%s: input file is output file"
msgstr "%s: 輸出和輸入檔案是相同的"

#: src/cksum.c:269 src/cut.c:197 src/expand.c:108 src/fold.c:65 src/head.c:83
#: src/nl.c:175 src/paste.c:409 src/pr.c:2776 src/sort.c:255 src/sum.c:61
#: src/tac.c:128 src/tail.c:212 src/unexpand.c:361 src/wc.c:85
#, c-format
msgid "Usage: %s [OPTION]... [FILE]...\n"
msgstr "用法：%s [選項]... [FILE]...\n"

#: src/cksum.c:273
msgid ""
"Print CRC checksum and byte counts of each FILE.\n"
"\n"
"  --help      display this help and exit\n"
"  --version   output version information and exit\n"
msgstr ""
"印出每個檔案的 CRC 總和檢查以及總位元組數目\n"
"\n"
"  --help               顯示這段說明訊息\n"
"  --version            顯示版本資訊\n"

#: src/comm.c:74
#, c-format
msgid "Usage: %s [OPTION]... LEFT_FILE RIGHT_FILE\n"
msgstr "用法：%s [選項]... LEFT_FILE RIGHT_FILE\n"

#: src/comm.c:78
msgid ""
"Compare sorted files LEFT_FILE and RIGHT_FILE line by line.\n"
"\n"
"  -1              suppress lines unique to left file\n"
"  -2              suppress lines unique to right file\n"
"  -3              suppress lines unique to both files\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
msgstr ""
"一行一行的比較 LEFT_FILE 及 RIGHT_FILE 這兩個排序過的檔案。\n"
"\n"
"  -1              不顯示只在第一個檔案 LEFT_FILE 出現過的行\n"
"  -2              不顯示只在第二個檔案 RIGHT_FILE 出現過的行\n"
"  -3              不顯示在兩個檔案中同時出現過的行\n"
"      --help      顯示這段說明訊息\n"
"      --version   顯示版本資訊\n"

#: src/csplit.c:295 src/csplit.c:1488 src/sort.c:561 src/tac-pipe.c:57
#: src/tr.c:1619 src/tr.c:1716 src/tr.c:1760
msgid "read error"
msgstr "讀取發生錯誤"

#: src/csplit.c:589
msgid "input disappeared"
msgstr "輸入消失了"

#: src/csplit.c:711 src/csplit.c:722
#, c-format
msgid "%s: line number out of range"
msgstr "%s: 行號超出範圍"

#: src/csplit.c:749
#, fuzzy, c-format
msgid "%s: `%s': line number out of range"
msgstr "%s: `%d': 行號超出範圍"

#: src/csplit.c:752 src/csplit.c:804
#, c-format
msgid " on repetition %d\n"
msgstr "在第 %d 次重覆時\n"

#: src/csplit.c:800
#, c-format
msgid "%s: `%s': match not found"
msgstr "%s: `%s': 找不到符合的字串"

#: src/csplit.c:861 src/csplit.c:901 src/tac.c:258
msgid "error in regular expression search"
msgstr "在正規運算式搜尋時發生錯誤"

#: src/csplit.c:1004
#, c-format
msgid "write error for `%s'"
msgstr "寫入 `%s' 時發生錯誤"

#: src/csplit.c:1076
#, c-format
msgid "%s: `+' or `-' expected after delimeter"
msgstr "%s: 在劃界符號後面應該有 `+' 或 `-' 字元"

#: src/csplit.c:1080
#, c-format
msgid "%s: integer expected after `%c'"
msgstr "%s: 在 `%c' 後面應該有一個整數引數"

#: src/csplit.c:1100
#, c-format
msgid "%s: `}' is required in repeat count"
msgstr "%s: 在重覆計數之後應該有 `}' 字元"

#: src/csplit.c:1110
#, c-format
msgid "%s}: integer required between `{' and `}'"
msgstr "%s}: 在 `{' 和 `}' 之間應該含有整數"

#: src/csplit.c:1137
#, c-format
msgid "%s: closing delimeter `%c' missing"
msgstr "%s: 找不到封閉劃界符號 `%c' "

#: src/csplit.c:1153
#, c-format
msgid "%s: invalid regular expression: %s"
msgstr "%s: 無效的正規運算式：%s"

#: src/csplit.c:1186
#, c-format
msgid "%s: invalid pattern"
msgstr "%s: 無效的樣式"

#: src/csplit.c:1189
#, c-format
msgid "%s: line number must be greater than zero"
msgstr "%s: 行號必須大於零"

#: src/csplit.c:1195
#, fuzzy, c-format
msgid "line number `%s' is smaller than preceding line number, %s"
msgstr "行號 `%s' 比前導行號還要小，%lu"

#: src/csplit.c:1201
#, c-format
msgid "warning: line number `%s' is the same as preceding line number"
msgstr "警告：行號 `%s' 跟前導行號一樣大"

#: src/csplit.c:1323
msgid "missing conversion specifier in suffix"
msgstr "在字尾裡找不到轉換說明符"

#: src/csplit.c:1329
#, c-format
msgid "invalid conversion specifier in suffix: %c"
msgstr "在字尾裡的轉換說明符無效：%c"

#: src/csplit.c:1332
#, c-format
msgid "invalid conversion specifier in suffix: \\%.3o"
msgstr "在字尾裡的轉換說明符無效：\\%.3o"

#: src/csplit.c:1364
msgid "missing %% conversion specification in suffix"
msgstr "在字尾裡找不到 %% 轉換規格"

#: src/csplit.c:1367
msgid "too many %% conversion specifications in suffix"
msgstr "在字尾裡有太多 %% 轉換規格"

#: src/csplit.c:1448
#, c-format
msgid "%s: invalid number"
msgstr "%s: 無效的號碼"

#: src/csplit.c:1471
msgid "too few arguments"
msgstr "引數太少了"

#: src/csplit.c:1506
#, c-format
msgid "Usage: %s [OPTION]... FILE PATTERN...\n"
msgstr "用法：%s [選項]... FILE PATTERN...\n"

#: src/csplit.c:1510
msgid ""
"Output pieces of FILE separated by PATTERN(s) to files `xx01', `xx02', ...,\n"
"and output byte counts of each piece to standard output.\n"
"\n"
"  -b, --suffix-format=FORMAT use sprintf FORMAT instead of %%d\n"
"  -f, --prefix=PREFIX        use PREFIX instead of `xx'\n"
"  -k, --keep-files           do not remove output files on errors\n"
"  -n, --digits=DIGITS        use specified number of digits instead of 2\n"
"  -s, --quiet, --silent      do not print counts of output file sizes\n"
"  -z, --elide-empty-files    remove empty output files\n"
"      --help                 display this help and exit\n"
"      --version              output version information and exit\n"
"\n"
"Read standard input if FILE is -.  Each PATTERN may be:\n"
"\n"
"  INTEGER            copy up to but not including specified line number\n"
"  /REGEXP/[OFFSET]   copy up to but not including a matching line\n"
"  %%REGEXP%%[OFFSET]   skip to, but not including a matching line\n"
"  {INTEGER}          repeat the previous pattern specified number of times\n"
"  {*}                repeat the previous pattern as many times as possible\n"
"\n"
"A line OFFSET is a required `+' or `-' followed by a positive integer.\n"
msgstr ""
"把檔案 FILE 依照樣式 PATTERN(s) 分割成數個小檔案 `xx01'，`xx02'，...，\n"
"並且將每個小檔案的大小輸出到標準輸出去。\n"
"\n"
"  -b, --suffix-format=FORMAT 用輸出格式 FORMAT 代替 %%d (sprintf 的格式)\n"
"  -f, --prefix=PREFIX        用字首 PREFIX 代替 `xx'\n"
"  -k, --keep-files           發生錯誤時不要移除已輸出的檔案\n"
"  -n, --digits=DIGITS        輸出檔名裡用 DIGITS 個數字標示 (預設值為 2)\n"
"  -s, --quiet, --silent      不要列印輸出檔案的大小\n"
"  -z, --elide-empty-files    移除空的輸出檔案\n"
"      --help                 顯示這段說明訊息\n"
"      --version              顯示版本資訊\n"
"\n"
"給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。使用的樣式 (PATTERN) "
"可以是：\n"
"\n"
"  INTEGER            行號；會把這些行號之前的部份分割出來\n"
"  /REGEXP/[OFFSET]   正規運算式；會把符合的那一行之前的部份分割出來\n"
"  %%REGEXP%%[OFFSET]   正規運算式；不過只輸出符合之後的部份\n"
"  {INTEGER}          重覆前一個樣式 INTEGER 次\n"
"  {*}                一直重覆前一個樣式\n"
"\n"
"行偏移量 OFFSET 是以加號或減號後面緊跟著一個正整數來表示 (如 `+3')。\n"

#: src/cut.c:201
#, fuzzy
msgid ""
"Print selected parts of lines from each FILE to standard output.\n"
"\n"
"  -b, --bytes=LIST        output only these bytes\n"
"  -c, --characters=LIST   output only these characters\n"
"  -d, --delimiter=DELIM   use DELIM instead of TAB for field delimiter\n"
"  -f, --fields=LIST       output only these fields\n"
"  -n                      (ignored)\n"
"  -s, --only-delimited    do not print lines not containing delimiters\n"
"      --output-delimiter=STRING  use STRING as the output delimiter\n"
"                            the default is to use the input delimiter\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"Use one, and only one of -b, -c or -f.  Each LIST is made up of one\n"
"range, or many ranges separated by commas.  Each range is one of:\n"
"\n"
"  N     N'th byte, character or field, counted from 1\n"
"  N-    from N'th byte, character or field, to end of line\n"
"  N-M   from N'th to M'th (included) byte, character or field\n"
"  -M    from first to M'th (included) byte, character or field\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"從檔案 FILE 中，每一行選出一部分輸出到標準輸出。\n"
"\n"
"  -b, --bytes=LIST        只輸出串列 LIST 中指定的位元組\n"
"  -c, --characters=LIST   只輸出串列 LIST 中指定的字元組\n"
"  -d, --delimiter=DELIM   用 DELIM 做為劃界符號 (預設是用欄標 TAB)\n"
"  -f, --fields=LIST       只輸出串列 LIST 中指定的欄位\n"
"  -n                      (這選項不被處理)\n"
"  -s, --only-delimited    不輸出沒有劃界符號的行\n"
"      --help              顯示這段說明訊息\n"
"      --version           顯示版本資訊\n"
"\n"
"使用 -b、-c、-f 來選擇輸出的部份，而且每次只能用一種選取方式。\n"
" LIST 是一個或多個用逗號 `,' 分隔的範圍。範圍的形式為：\n"
"\n"
"  N     第 N 個位元組、字元或欄位，由 1 算起\n"
"  N-    從第 N 個位元組、字元或欄位到這一行結束\n"
"  N-M   從第 N 個到第 M 個位元組、字元或欄位，包含 N、M\n"
"  -M    從這行的一開始到第 M 個位元組、字元或欄位，包含第 M 個\n"
"\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"

#: src/cut.c:363 src/cut.c:394 src/cut.c:454
msgid "invalid byte or field list"
msgstr "無效的位元組或欄位串列"

#: src/cut.c:717 src/cut.c:726
msgid "only one type of list may be specified"
msgstr "一次只能指定一種類型的串列"

#: src/cut.c:720
msgid "missing list of positions"
msgstr "找不到位置串列"

#: src/cut.c:729
msgid "missing list of fields"
msgstr "找不到欄位串列"

#: src/cut.c:736
msgid "the delimiter must be a single character"
msgstr "劃界符號必須是一個單一字元"

#: src/cut.c:766
msgid "you must specify a list of bytes, characters, or fields"
msgstr "你必須指定一個位元組、字元或欄位的串列"

#: src/cut.c:769
msgid "a delimiter may be specified only when operating on fields"
msgstr "只有在針對欄位作業時才能指定劃界符號"

#: src/cut.c:772
msgid ""
"suppressing non-delimited lines makes sense\n"
"\tonly when operating on fields"
msgstr ""
"只有在針對欄位作業時才能忽略\n"
"\t缺少劃界符號的行"

#: src/expand.c:112
msgid ""
"Convert tabs in each FILE to spaces, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -i, --initial       do not convert TABs after non whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart, not 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""
"把每個檔案 FILE 裡面的欄標轉換成空格字元，輸出到標準輸出。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -i, --initial       不要轉換在非空白字元後面的欄標\n"
"  -t, --tabs=NUMBER   把欄標轉換成 NUMBER 個字元 (預設是八個)\n"
"  -t, --tabs=LIST     用逗號分隔的串列 LIST 作為欄標的位置\n"
"      --help          顯示這段說明訊息\n"
"      --version       顯示版本資訊\n"
"\n"
"使用時可以用 -NUMBER 代替 -t NUMBER，用 -LIST 代替 -t LIST 。\n"

#: src/expand.c:166 src/unexpand.c:139
msgid "tab size contains an invalid character"
msgstr "指定的欄標大小裡含有無效的字元"

#: src/expand.c:184 src/unexpand.c:157
msgid "tab size cannot be 0"
msgstr "欄標大小不可為零"

#: src/expand.c:186 src/unexpand.c:159
msgid "tab sizes must be ascending"
msgstr "指定的欄標大小必須是升序的 (ascending)"

#: src/fmt.c:272
#, c-format
msgid "Usage: %s [-DIGITS] [OPTION]... [FILE]...\n"
msgstr "用法：%s [-阿拉伯數字] [選項]... [FILE]...\n"

#: src/fmt.c:273
msgid ""
"Reformat each paragraph in the FILE(s), writing to standard output.\n"
"If no FILE or if FILE is `-', read standard input.\n"
"\n"
"Mandatory arguments to long options are mandatory for short options too.\n"
"  -c, --crown-margin        preserve indentation of first two lines\n"
"  -p, --prefix=STRING       combine only lines having STRING as prefix\n"
"  -s, --split-only          split long lines, but do not refill\n"
"  -t, --tagged-paragraph    indentation of first line different from second\n"
"  -u, --uniform-spacing     one space between words, two after sentences\n"
"  -w, --width=NUMBER        maximum line width (default of 75 columns)\n"
"      --help                display this help and exit\n"
"      --version             output version information and exit\n"
"\n"
"In -wNUMBER, the letter `w' may be omitted.\n"
msgstr ""
"把檔案 FILE(s) 裡面的每一段重新格式化後，輸出到標準輸出。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
" (短選項用的參數和長選項用的是一樣的) \n"
"  -c, --crown-margin        保留最開頭兩行的縮排\n"
"  -p, --prefix=STRING       只合併用 STRING 開頭的行\n"
"  -s, --split-only          只把太長的行拆開，不把太短的行補滿\n"
"  -t, --tagged-paragraph    標示出每一段，每一段的第一行和第二行的縮排不同\n"
"  -u, --uniform-spacing     字與字之間用一個空格分開，句子之間則用兩個\n"
"  -w, --width=NUMBER        最大行寬 (預設為 75 格)\n"
"      --help                顯示這段說明訊息\n"
"      --version             顯示版本資訊\n"
"選項 -wNUMBER 裡面的 `w' 可以忽略不寫。\n"

#: src/fmt.c:372 src/nl.c:494
#, c-format
msgid "invalid line number increment: `%s'"
msgstr "無效的行號增量：`%s'"

#: src/fold.c:69
#, fuzzy
msgid ""
"Wrap input lines in each FILE (standard input by default), writing to\n"
"standard output.\n"
"\n"
"  -b, --bytes         count bytes rather than columns\n"
"  -s, --spaces        break at spaces\n"
"  -w, --width=WIDTH   use WIDTH columns instead of 80\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
msgstr ""
"在檔案 FILE 裡面太長的行中加入換行字元，使所有行都在一定長度以下。\n"
"預設是從標準輸入讀取資料，把結果輸出到標準輸出去。\n"
"\n"
"  -b, --bytes         依位元組數目計算，而非欄位數目\n"
"  -s, --spaces        在空格字元處斷行\n"
"  -w, --width=WIDTH   設定寬度為 WIDTH (預設是 80)\n"

#: src/fold.c:283
#, c-format
msgid "invalid number of columns: `%s'"
msgstr "無效的欄位數目：`%s'"

#: src/head.c:87
msgid ""
"Print first 10 lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -c, --bytes=SIZE         print first SIZE bytes\n"
"  -n, --lines=NUMBER       print first NUMBER lines instead of first 10\n"
"  -q, --quiet, --silent    never print headers giving file names\n"
"  -v, --verbose            always print headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
"If -VALUE is used as first OPTION, read -c VALUE when one of\n"
"multipliers bkm follows concatenated, else read -n VALUE.\n"
msgstr ""
"把每一個檔案 FILE 最前面的 10 行輸出到標準輸出。\n"
"所給的引數 FILE 超過一個時，會在每一個檔案內容之前標示出檔名。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -c, --bytes=SIZE         印出最前面的 SIZE 個位元組\n"
"  -n, --lines=NUMBER       印出最前面的 NUMBER 行 (預設值是 10 行)\n"
"  -q, --quiet, --silent    不要在檔案內容之前標示出檔名\n"
"  -v, --verbose            總是在檔案內容之前標示出檔名\n"
"      --help               顯示這段說明訊息\n"
"      --version            顯示版本資訊\n"
"\n"
"指定的 SIZE 可以是一個乘數字尾： b 表示 512，k 表示 1K，m 表示 1 Meg。\n"
"可以用一個數目字 -VALUE 當第一個選項，假如 VALUE 中含有乘數字尾 [bkm] "
"的話，\n"
"程式會把它解釋為 -c VALUE，否則就當成 -n VALUE 處理。 \n"

#: src/head.c:191 src/md5sum.c:302 src/md5sum.c:632 src/od.c:941 src/od.c:1200
#: src/od.c:1273 src/od.c:1937 src/pr.c:1156 src/pr.c:1365 src/pr.c:1487
#: src/tac.c:485 src/tac.c:491 src/tr.c:2034 src/tsort.c:493
msgid "standard input"
msgstr "標準輸出"

#: src/head.c:232 src/tail.c:1338
msgid "invalid number of lines"
msgstr "無效的行數"

#: src/head.c:233 src/tail.c:1339
msgid "invalid number of bytes"
msgstr "無效的位元組數目"

#: src/head.c:239 src/tail.c:1261 src/tail.c:1344
#, fuzzy, c-format
msgid "%s: %s is so large that it is not representable"
msgstr "%s: `%s' 太大了以致於無法被表示出來"

#: src/head.c:240 src/tail.c:1263 src/tail.c:1346
msgid "number of lines"
msgstr "行數"

#: src/head.c:240 src/tail.c:1264 src/tail.c:1346
msgid "number of bytes"
msgstr "位元組數目"

#: src/head.c:317
#, c-format
msgid "unrecognized option `-%c'"
msgstr "無法辨識的選項 `-%c'"

#: src/join.c:145
#, c-format
msgid "Usage: %s [OPTION]... FILE1 FILE2\n"
msgstr "用法：%s [選項]... FILE1 FILE2\n"

#: src/join.c:149
msgid ""
"For each pair of input lines with identical join fields, write a line to\n"
"standard output.  The default join field is the first, delimited\n"
"by whitespace.  When FILE1 or FILE2 (not both) is -, read standard input.\n"
"\n"
"  -a SIDE           print unpairable lines coming from file SIDE\n"
"  -e EMPTY          replace missing input fields with EMPTY\n"
"  -i, --ignore-case ignore differences in case when comparing fields\n"
"  -j FIELD          (obsolescent) equivalent to `-1 FIELD -2 FIELD'\n"
"  -j1 FIELD         (obsolescent) equivalent to `-1 FIELD'\n"
"  -j2 FIELD         (obsolescent) equivalent to `-2 FIELD'\n"
"  -o FORMAT         obey FORMAT while constructing output line\n"
"  -t CHAR           use CHAR as input and output field separator\n"
"  -v SIDE           like -a SIDE, but suppress joined output lines\n"
"  -1 FIELD          join on this FIELD of file 1\n"
"  -2 FIELD          join on this FIELD of file 2\n"
"      --help        display this help and exit\n"
"      --version     output version information and exit\n"
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"
msgstr ""
"把檔案 FILE1、FILE2 裡面某個欄位內容相同的行連結成一行，輸出到標準輸出。\n"
"預設值是兩個檔案的第一個欄位，用空白字元當劃界符號。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -a SIDE           把檔案 SIDE 中不成對的行也印出來 (SIDE = 1 或 2)\n"
"  -e EMPTY          把找不到欄位的行用 EMPTY 代換\n"
"  -i, --ignore-case 比較欄位內容時，忽略大小寫的不同\n"
"  -j FIELD          (即將廢棄) 與 `-1 FIELD -2 FIELD' 相同\n"
"  -j1 FIELD         (即將廢棄) 與 `-1 FIELD' 相同\n"
"  -j2 FIELD         (即將廢棄) 與 `-2 FIELD' 相同\n"
"  -o FORMAT         遵循格式 FORMAT 來輸出結果\n"
"  -t CHAR           用字元 CHAR 當輸入輸出的劃界符號\n"
"  -v SIDE           跟 -a SIDE 相似，但是不把相同的行印出來\n"
"  -1 FIELD          採用第一個檔案的第 FIELD 個欄位\n"
"  -2 FIELD          採用第二個檔案的第 FIELD 個欄位\n"
"      --help        顯示這段說明訊息\n"
"      --version     顯示版本資訊\n"
"\n"
"Unless -t CHAR is given, leading blanks separate fields and are ignored,\n"
"else fields are separated by CHAR.  Any FIELD is a field number counted\n"
"from 1.  FORMAT is one or more comma or blank separated specifications,\n"
"each being `SIDE.FIELD' or `0'.  Default FORMAT outputs the join field,\n"
"the remaining fields from FILE1, the remaining fields from FILE2, all\n"
"separated by CHAR.\n"

#. `0' must be all alone -- no `.FIELD'.
#: src/join.c:640
#, c-format
msgid "invalid field specifier: `%s'"
msgstr "無效的欄位說明符：`%s'"

#: src/join.c:654 src/join.c:767 src/join.c:803
#, c-format
msgid "invalid field number: `%s'"
msgstr "無效的欄位號碼：`%s'"

#: src/join.c:667
#, c-format
msgid "invalid file number in field spec: `%s'"
msgstr "在欄位中指定了無效的檔案編號：`%s'"

#: src/join.c:787
#, c-format
msgid "invalid field number for file 1: `%s'"
msgstr "針對 1 號檔案的欄位號碼是無效的：`%s'"

#: src/join.c:796
#, c-format
msgid "invalid field number for file 2: `%s'"
msgstr "針對 2 號檔案的欄位號碼是無效的：`%s'"

#: src/join.c:828
msgid "too many non-option arguments"
msgstr "非選項的引數太多了"

#: src/join.c:850
msgid "too few non-option arguments"
msgstr "非選項的引數太少了"

#: src/join.c:861
msgid "both files cannot be standard input"
msgstr "指定的兩個檔案不能都是標準輸入"

#: src/md5sum.c:104
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] [FILE]...\n"
"  or:  %s [OPTION] --check [FILE]\n"
"Print or check MD5 checksums.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --binary            read files in binary mode (default on "
"DOS/Windows)\n"
"  -c, --check             check MD5 sums against given list\n"
"  -t, --text              read files in text mode (default)\n"
"\n"
"The following two options are useful only when verifying checksums:\n"
"      --status            don't output anything, status code shows success\n"
"  -w, --warn              warn about improperly formated MD5 checksum lines\n"
"\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"The sums are computed as described in RFC 1321.  When checking, the input\n"
"should be a former output of this program.  The default mode is to print\n"
"a line with checksum, a character indicating type (`*' for binary, ` ' for\n"
"text), and name for each FILE.\n"
msgstr ""
"用法：%s [選項] [FILE]...\n"
"  或：%s [選項] --check [FILE]\n"
"印出檔案 FILE 的 MD5 總和檢查值，或對檔案進行 MD5 總和檢查。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -b, --binary            用二進制模式讀取檔案\n"
"  -c, --check             真對與定的檔案進行 MD5 總和檢查\n"
"  -t, --text              用文字模式讀取檔案 (預設值)\n"
"\n"
"底下這兩個選項只有在進行 MD5 總和檢查時才有效：\n"
"      --status            不要顯示訊息，以狀態碼告知成功\與否\n"
"  -w, --warn              對未經適當格式化的 MD5 總和檢查行做出警告\n"
"\n"
"      --help              顯示這段說明訊息\n"
"      --version           顯示版本資訊\n"
"\n"
"總和檢查的計算方式可以在 RFC 1321 裡面找到。\n"
"用來檢查的輸入值必須是這個程式先前所產生的結果才行。程式預設模式是針對每個\n"
"給定的檔案印出一行結果，每一行的第一個欄位是 MD5 總和檢查值，接著用一個字元\n"
"來標示檢查的形式 (`*' 表示用二進制模式，` ' 表示用文字模式)，最後則為檔名。 "
"\n"

#: src/md5sum.c:346
#, c-format
msgid "%s: %lu: improperly formatted MD5 checksum line"
msgstr "%s: %lu: 這一行不是經過適當格式化的 MD5 總和檢查行"

#: src/md5sum.c:367
#, c-format
msgid "%s: FAILED open or read\n"
msgstr "%s: 在開啟或讀取時發生嚴重錯誤\n"

#: src/md5sum.c:389
msgid "FAILED"
msgstr "嚴重錯誤"

#: src/md5sum.c:389
msgid "OK"
msgstr "OK"

#: src/md5sum.c:402
#, c-format
msgid "%s: read error"
msgstr "%s: 讀取時發生錯誤"

#. Warn if no tests are found.
#: src/md5sum.c:415
#, c-format
msgid "%s: no properly formatted MD5 checksum lines found"
msgstr "%s: 找到未經適當格式化的 MD5 總和檢查行"

#: src/md5sum.c:428
#, c-format
msgid "WARNING: %d of %d listed %s could not be read\n"
msgstr "警告：無法讀取 %d 之 %d 列出的 %s \n"

#: src/md5sum.c:431
msgid "file"
msgstr "檔案"

#: src/md5sum.c:431
msgid "files"
msgstr "檔案"

#: src/md5sum.c:437
#, c-format
msgid "WARNING: %d of %d computed %s did NOT match"
msgstr "警告：%d 之 %d 計算出來的 %s 並 `不' 匹配"

#: src/md5sum.c:440
msgid "checksum"
msgstr "總和檢查"

#: src/md5sum.c:440
msgid "checksums"
msgstr "總和檢查"

#: src/md5sum.c:517
msgid ""
"the --binary and --text options are meaningless when verifying checksums"
msgstr "當執行總和檢查驗証時，選項 --binary 及 --text 是沒有意義的"

#: src/md5sum.c:525
msgid "the --string and --check options are mutually exclusive"
msgstr "不能同時使用 --string 和 --check 這兩個選項"

#: src/md5sum.c:532
msgid "the --status option is meaningful only when verifying checksums"
msgstr "選項 --status 只有在執行總和檢查驗証時才有意義"

#: src/md5sum.c:539
msgid "the --warn option is meaningful only when verifying checksums"
msgstr "選項 --warn 只有在執行總和檢查驗証時才有意義"

#: src/md5sum.c:549
msgid "no files may be specified when using --string"
msgstr "使用選項 --string 時就不能再指定檔案了"

#: src/md5sum.c:568
msgid "only one argument may be specified when using --check"
msgstr "使用選項 --check 時只能指定一個引數"

#: src/nl.c:179
msgid ""
"Write each FILE to standard output, with line numbers added.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\n"
"  -d, --section-delimiter=CC      use CC for separating logical pages\n"
"  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\n"
"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\n"
"  -i, --page-increment=NUMBER     line number increment at each line\n"
"  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as "
"one\n"
"  -n, --number-format=FORMAT      insert line numbers according to FORMAT\n"
"  -p, --no-renumber               do not reset line numbers at logical "
"pages\n"
"  -s, --number-separator=STRING   add STRING after (possible) line number\n"
"  -v, --first-page=NUMBER         first line number on each logical page\n"
"  -w, --number-width=NUMBER       use NUMBER columns for line numbers\n"
"      --help                      display this help and exit\n"
"      --version                   output version information and exit\n"
"\n"
"By default, selects -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn.  CC are\n"
"two delimiter characters for separating logical pages, a missing\n"
"second character implies :.  Type \\\\ for \\.  STYLE is one of:\n"
"\n"
"  a         number all lines\n"
"  t         number only nonempty lines\n"
"  n         number no lines\n"
"  pREGEXP   number only lines that contain a match for REGEXP\n"
"\n"
"FORMAT is one of:\n"
"\n"
"  ln   left justified, no leading zeros\n"
"  rn   right justified, no leading zeros\n"
"  rz   right justified, leading zeros\n"
"\n"
msgstr ""
"把每個檔案的內容都標上行號，輸出到標準輸出去。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -b, --body-numbering=STYLE      使用樣式 STYLE 來標示內文的行號\n"
"  -d, --section-delimiter=CC      使用 CC 來區分邏輯頁 (logical pages)\n"
"  -f, --footer-numbering=STYLE    使用 STYLE 來標示註腳的行號\n"
"  -h, --header-numbering=STYLE    使用 STYLE 來標示標頭的行號\n"
"  -i, --page-increment=NUMBER     行與行之間，行號的增加量\n"
"  -l, --join-blank-lines=NUMBER   把 NUMBER 個空白行算成一行\n"
"  -n, --number-format=FORMAT      依據 FORMAT 插入行號\n"
"  -p, --no-renumber               在跨越邏輯頁時，不要把行號大小歸零\n"
"  -s, --number-separator=STRING   輸出時，把字串 STRING 加在行號之後\n"
"  -v, --first-page=NUMBER         每個邏輯頁第一行的行號大小\n"
"  -w, --number-width=NUMBER       用 NUMBER 個字元來標示行號\n"
"      --help                      顯示這段說明訊息\n"
"      --version                   顯示版本資訊\n"
"\n"
"程式執行時，預設會使用選項 -v1 -i1 -l1 -sTAB -w6 -nrn -hn -bt -fn。\n"
" CC 是兩個定界字符 (delimiter characters)，用來區分邏輯頁；假如只給一個\n"
" 定界字符，會自動把第二個設成 `:'。\n"
"要打兩個倒斜線 `\\\\' 來輸入倒斜線 `\\'。STYLE 是指：\n"
"\n"
"  a         把所有的行都標上行號\n"
"  t         只標非空白行\n"
"  n         不標行號\n"
"  pREGEXP   只把符合正規運算式 REGEXP 的行標上行號\n"
"\n"
"FORMAT 可以是：\n"
"\n"
"  ln   行號靠左對齊，開頭沒有零\n"
"  rn   行號靠右對齊，開頭沒有零\n"
"  rz   行號靠右對齊，開頭有零\n"
"\n"

#: src/nl.c:484
#, c-format
msgid "invalid starting line number: `%s'"
msgstr "無效的開始行號：`%s'"

#: src/nl.c:507
#, c-format
msgid "invalid number of blank lines: `%s'"
msgstr "無效的空白行數目：`%s'"

#: src/nl.c:521
#, c-format
msgid "invalid line number field width: `%s'"
msgstr "無效的行號欄位寬度：`%s'"

#: src/od.c:266
#, c-format
msgid ""
"Usage: %s [OPTION]... [FILE]...\n"
"  or:  %s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"
msgstr ""
"用法：%s [選項]... [FILE]...\n"
"  或：%s --traditional [FILE] [[+]OFFSET [[+]LABEL]]\n"

#: src/od.c:271
msgid ""
"Write an unambiguous representation, octal bytes by default, of FILE\n"
"to standard output.  With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -A, --address-radix=RADIX   decide how file offsets are printed\n"
"  -j, --skip-bytes=BYTES      skip BYTES input bytes first on each file\n"
"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes per file\n"
"  -s, --strings[=BYTES]       output strings of at least BYTES graphic "
"chars\n"
"  -t, --format=TYPE           select output format or formats\n"
"  -v, --output-duplicates     do not use * to mark line suppression\n"
"  -w, --width[=BYTES]         output BYTES bytes per output line\n"
"      --traditional           accept arguments in pre-POSIX form\n"
"      --help                  display this help and exit\n"
"      --version               output version information and exit\n"
"\n"
"Pre-POSIX format specifications may be intermixed, they accumulate:\n"
"  -a   same as -t a,  select named characters\n"
"  -b   same as -t oC, select octal bytes\n"
"  -c   same as -t c,  select ASCII characters or backslash escapes\n"
"  -d   same as -t u2, select unsigned decimal shorts\n"
"  -f   same as -t fF, select floats\n"
"  -h   same as -t x2, select hexadecimal shorts\n"
"  -i   same as -t d2, select decimal shorts\n"
"  -l   same as -t d4, select decimal longs\n"
"  -o   same as -t o2, select octal shorts\n"
"  -x   same as -t x2, select hexadecimal shorts\n"
msgstr ""
"把檔案內容用八進位、十進位或十六進位顯示出來 (預設是八進位)。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -A, --address-radix=RADIX   選擇檔案偏移量印出的方式\n"
"  -j, --skip-bytes=BYTES      跳過每個輸入檔最開頭的 BYTES 個位元組\n"
"  -N, --read-bytes=BYTES      每個檔案最多印出 BYTES 個位元組\n"
"  -s, --strings[=BYTES]       輸出至少含有 BYTES 個繪圖字元的字串\n"
"  -t, --format=TYPE           選擇輸出的格式\n"
"  -v, --output-duplicates     不要用星號 `*' 標示忽略掉的行\n"
"  -w, --width[=BYTES]         輸出時每一行印出 BYTES 個位元組\n"
"      --traditional           接受 \"前-POSIX\" 形式的引數\n"
"      --help                  顯示這段說明訊息\n"
"      --version               顯示版本資訊\n"
"\n"
"前-POSIX 形式的引數可以被混在一起用，包含了：\n"
"  -a   跟 -t a  相同，印出字元名稱\n"
"  -b   跟 -t oC 相同，用八進位顯示位元組\n"
"  -c   跟 -t c  相同，顯示 ASCII 字元或倒斜線逸出字元\n"
"  -d   跟 -t u2 相同，顯示十進位的無符號短整數 (unsigned short)\n"
"  -f   跟 -t fF 相同，顯示浮點數\n"
"  -h   跟 -t x2 相同，顯示十六進位的短整數\n"
"  -i   跟 -t d2 相同，顯示十進位的短整數\n"
"  -l   跟 -t d4 相同，顯示十進位的長整數\n"
"  -o   跟 -t o2 相同，顯示八進位短整數\n"
"  -x   跟 -t x2 相同，顯示十六進位的短整數\n"

#: src/od.c:298
#, fuzzy
msgid ""
"\n"
"For older syntax (second call format), OFFSET means -j OFFSET.  LABEL\n"
"is the pseudo-address at first byte printed, incremented when dump is\n"
"progressing.  For OFFSET and LABEL, a 0x or 0X prefix indicates\n"
"hexadecimal, suffixes maybe . for octal and b multiply by 512.\n"
"\n"
"TYPE is made up of one or more of these specifications:\n"
"\n"
"  a          named character\n"
"  c          ASCII character or backslash escape\n"
"  d[SIZE]    signed decimal, SIZE bytes per integer\n"
"  f[SIZE]    floating point, SIZE bytes per integer\n"
"  o[SIZE]    octal, SIZE bytes per integer\n"
"  u[SIZE]    unsigned decimal, SIZE bytes per integer\n"
"  x[SIZE]    hexadecimal, SIZE bytes per integer\n"
"\n"
"SIZE is a number.  For TYPE in doux, SIZE may also be C for\n"
"sizeof(char), S for sizeof(short), I for sizeof(int) or L for\n"
"sizeof(long).  If TYPE is f, SIZE may also be F for sizeof(float), D\n"
"for sizeof(double) or L for sizeof(long double).\n"
"\n"
"RADIX is d for decimal, o for octal, x for hexadecimal or n for none.\n"
"BYTES is hexadecimal with 0x or 0X prefix, it is multiplied by 512\n"
"with b suffix, by 1024 with k and by 1048576 with m.  Adding a z suffix to\n"
"any type adds a display of printable characters to the end of each line\n"
"of output.  -s without a number implies 3.  -w without a number implies 32.\n"
"By default, od uses -A o -t d2 -w 16.\n"
msgstr ""
"\n"
"用舊式的語法時 (第二種呼叫方法)，引數 OFFSET 意義跟 -j OFFSET 相同。\n"
"而 LABEL 就是在印出位址的時候，第一個位元組起算的基數。\n"
" OFFSET 與 LABEL 這兩個引數，都可以用字首 `0x' 或 `0X' 來表示十六進位\n"
"的數字，用字尾 `.' 表示八進位數字，`b' 表示乘以 512。\n"
"\n"
"輸出的格式 TYPE 可以用一個或多個的下列字元來指定：\n"
"\n"
"  a          用字元名稱來顯示字元\n"
"  c          用 ASCII 字元或倒斜線逸出字元來顯示\n"
"  d[SIZE]    有號的十進位整數，每 SIZE 個位元組當成一個整數\n"
"  f[SIZE]    浮點數，每 SIZE 個位元組當成一個浮點數\n"
"  o[SIZE]    八進位表示法，每 SIZE 個位元組當成一個整數\n"
"  u[SIZE]    無號的十進位整數，每 SIZE 個位元組當成一個整數\n"
"  x[SIZE]    十六進位表示法，每 SIZE 個位元組當成一個整數\n"
"\n"
"引數 SIZE 是一個數字；不過在用格式 [doux] 時，可以用 `C' 代表 "
"sizeof(char)、\n"
"用 `S' 代表 sizeof(short)、用 `I' 代表 sizeof(int)、`L' 代表 sizeof(long)。\n"
"當格式為 `f' 時，SIZE 可以是 `F'，代表 sizeof(float)、`D' 代表 "
"sizeof(double)、\n"
" `L' 代表 sizeof(long double)。\n"
"\n"
"引數 RADIX 是 `d' 就代表十進位、`o' 是八進位、`x' 是十六進位，`n' "
"則是沒有。\n"
"引數 BYTES 假如有字首 `0x' 或 `0X' ，表示十六進位。\n"
" BYTES 假如有字尾 `b' 表示乘以 512、`k' 表示乘以 1024、`m' 表示乘以 "
"1048576。\n"
"選項 -s 後面沒有指定數目字的話，程式預設值是 3 。\n"
"選項 -w 後面沒有指定數目字的話，程式預設值是 32 。\n"
" od 預設會使用 -A o -t d2 -w 16 這些參數。\n"

#. The integer at P in S would overflow an unsigned long.
#. A digit string that long is sufficiently odd looking
#. that the following diagnostic is sufficient.
#: src/od.c:676 src/od.c:789
#, c-format
msgid "invalid type string `%s'"
msgstr "`%s' 是無效的型別字串"

#: src/od.c:686
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte integral type"
msgstr ""
"`%s' 是無效的型別字串；\n"
"這個系統並沒有 %lu-位元的整數型別"

#: src/od.c:799
#, c-format
msgid ""
"invalid type string `%s';\n"
"this system doesn't provide a %lu-byte floating point type"
msgstr ""
"`%s' 是無效的型別字串；\n"
"這個系統並沒有 %lu-位元的浮點數型別\""

#: src/od.c:862
#, c-format
msgid "invalid character `%c' in type string `%s'"
msgstr "`%c' 是無效的字元 (在型別字串 `%s' 裡面)。"

#: src/od.c:1029
msgid "cannot skip past end of combined input"
msgstr "無法跳過合併輸入先前的結束符號"

#: src/od.c:1341
msgid "old-style offset"
msgstr "舊樣式的偏移量"

#: src/od.c:1660
#, c-format
msgid "invalid output address radix `%c'; it must be one character from [doxn]"
msgstr "輸出位址的基數 `%c' 是無效的；基數必須是 [doxn] 其中之一"

#: src/od.c:1671
msgid "skip argument"
msgstr "跳過引數"

#: src/od.c:1682
msgid "limit argument"
msgstr "限制引數"

#: src/od.c:1686
#, c-format
msgid ""
"specified number of bytes `%s' is larger than the maximum\n"
"representable value of type `long'"
msgstr ""
"指定的位元數目 `%s' 大於型別 `long' 的\n"
"最大可表示數值。"

#: src/od.c:1697
msgid "minimum string length"
msgstr "最小字串長度"

#: src/od.c:1751
msgid "width specification"
msgstr "寬度規格"

#: src/od.c:1770
msgid "no type may be specified when dumping strings"
msgstr "在傾印字串的時候不能指定型別"

#: src/od.c:1815
#, c-format
msgid "invalid second operand in compatibility mode `%s'"
msgstr "在相容性模式 `%s' 下，第二個運算數是無效的"

#: src/od.c:1836
#, fuzzy
msgid "in compatibility mode, the last two arguments must be offsets"
msgstr "在相容性模式下，最後的兩個引數必須是偏移量"

#: src/od.c:1843
#, fuzzy
msgid "compatibility mode supports at most three arguments"
msgstr "在相容性模式下，不能有超過三個引數"

#: src/od.c:1911
#, c-format
msgid "warning: invalid width %lu; using %d instead"
msgstr "警告：寬度 %lu 是無效的；用 %d 代替"

#: src/od.c:1927
#, c-format
msgid "%d: fmt=\"%s\" width=%d\n"
msgstr "%d: 格式=\"%s\" 寬度=%d\n"

#: src/paste.c:214
msgid "standard input is closed"
msgstr "標準輸入被關閉了"

#: src/paste.c:413
msgid ""
"Write lines consisting of the sequentially corresponding lines from\n"
"each FILE, separated by TABs, to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -d, --delimiters=LIST   reuse characters from LIST instead of TABs\n"
"  -s, --serial            paste one file at a time instead of in parallel\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
msgstr ""
"把所有檔案 FILE 合併在一起，每個檔案佔一個欄位，不同檔案的資料之間\n"
"以欄標 (TAB) 相隔，輸出到標準輸出。\n"
"印出每個檔案 FILE 裡面的行數、字數及位元數，指定多個檔案的話\n"
"\n"
"  -d, --delimiters=LIST   用串列 LIST 裡面的字元代替欄標來當作輸出的間隔\n"
"  -s, --serial            "
"以串列方式，同一檔案的內容先併成一行，再接下一個檔案\n"
"      --help              顯示這段說明訊息\n"
"      --version           顯示版本資訊\n"
"\n"

#: src/pr.c:788
#, fuzzy, c-format
msgid "`--pages' invalid range of page numbers: `%s'"
msgstr "頁碼範圍無效：`%s'"

#: src/pr.c:800
#, fuzzy, c-format
msgid "`--pages' invalid starting page number: `%s'"
msgstr "開始的頁碼無效：`%s'"

#: src/pr.c:812
#, fuzzy, c-format
msgid "`--pages' invalid ending page number: `%s'"
msgstr "結束的頁碼無效：`%s'"

#: src/pr.c:819
#, fuzzy
msgid "`--pages' starting page number is larger than ending page number"
msgstr "開始頁碼比結束頁碼還要大"

#: src/pr.c:910
msgid "`--pages=FIRST_PAGE[:LAST_PAGE]' missing argument"
msgstr ""

#: src/pr.c:921
#, fuzzy, c-format
msgid "`--columns=COLUMN' invalid number of columns: `%s'"
msgstr "無效的欄位數目：`%s'"

#: src/pr.c:973
#, c-format
msgid "`-l PAGE_LENGTH' invalid number of lines: `%s'"
msgstr "`-l PAGE_LENGTH' 無效的行數：`%s'"

#: src/pr.c:997
#, c-format
msgid "`-N NUMBER' invalid starting line number: `%s'"
msgstr "`-N NUMBER' 無效的開始行號：`%s'"

#: src/pr.c:1009
#, c-format
msgid "`-o MARGIN' invalid line offset: `%s'"
msgstr "`-o MARGIN' 無效的行偏移量：`%s'"

#: src/pr.c:1050
#, fuzzy, c-format
msgid "`-w PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-l PAGE_LENGTH' 無效的行數：`%s'"

#: src/pr.c:1062
#, fuzzy, c-format
msgid "`-W PAGE_WIDTH' invalid number of characters: `%s'"
msgstr "`-l PAGE_LENGTH' 無效的行數：`%s'"

#: src/pr.c:1080
msgid "Cannot specify number of columns when printing in parallel."
msgstr "當平行列印時，不能指定欄位數目"

#: src/pr.c:1084
msgid "Cannot specify both printing across and printing in parallel."
msgstr "不能同時指定平行列印與交錯列印"

#: src/pr.c:1182
#, c-format
msgid "`-%c' extra characters or invalid number in the argument: `%s'"
msgstr "`-%c' 有多餘的字元或無效的數字在引數 `%s' 裡面"

#: src/pr.c:1293
msgid "page width too narrow"
msgstr "頁寬太窄了"

#: src/pr.c:1706
#, c-format
msgid "%s%*s%s%*sPage"
msgstr "%s%*s%s%*s頁"

#: src/pr.c:2389
#, fuzzy, c-format
msgid "starting page number larger than total number of pages: `%d'"
msgstr "開始頁碼比結束頁碼還要大"

#: src/pr.c:2781
#, fuzzy
msgid ""
"Paginate or columnate FILE(s) for printing.\n"
"\n"
"  +FIRST_PAGE[:LAST_PAGE], --pages=FIRST_PAGE[:LAST_PAGE]\n"
"                    begin [stop] printing with page FIRST_[LAST_]PAGE\n"
"  -COLUMN, --columns=COLUMN\n"
"                    produce COLUMN-column output and print columns down,\n"
"                    unless -a is used. Balance number of lines in the\n"
"                    columns on each page.\n"
"  -a, --across      print columns across rather than down, used together\n"
"                    with -COLUMN\n"
"  -c, --show-control-chars\n"
"                    use hat notation (^G) and octal backslash notation\n"
"  -d, --double-space\n"
"                    double space the output\n"
"  -e[CHAR[WIDTH]], --expand-tabs[=CHAR[WIDTH]]\n"
"                    expand input CHARs (TABs) to tab WIDTH (8)\n"
"  -F, -f, --form-feed\n"
"                    use form feeds instead of newlines to separate pages\n"
"                    (by a 3-line page header with -F or a 5-line header\n"
"                    and trailer without -F)\n"
msgstr ""
"把檔案標上頁數或分欄，輸出到標準輸出，以作為列印之用。\n"
"\n"
"  +FIRST_PAGE[:LAST_PAGE]\n"
"                    由第 FIRST_PAGE[LAST_PAGE] 頁開始 [結束] 列印\n"
"  -COLUMN           製造 COLUMN 欄的輸出結果，將檔案內容由上到下的印出。\n"
"                    除非同時有指定選項 -a，否則程式會自動的平均每頁裡面\n"
"                    各欄的行數。\n"
"  -a                在分欄時將檔案內容交錯的印出，第一行在第一欄、第二行\n"
"                    在第二欄... 與選項 -COLUMN 一起使用。\n"
"  -c                使用 `^' 表示法 (^G) 以及八進位反斜線表示法來輸出\n"
"  -d                把輸出的間隔加倍\n"
"  -e[CHAR[WIDTH]]   把輸入資料裡面所有的字元 CHAR 換成寬度為 WIDTH "
"的欄標(TAB)\n"
"  -F, -f            使用換頁符號 (form feeds) 代替空白行來分頁\n"
"                    (用了選項 -f "
"的話，頁首會變成三行的格式，預設是五行的頁首\n"
"                    以及頁尾。)\n"
"  -h HEADER         用字串 HEADER 當每頁的標題 (預設是檔名當標題)\n"
"                    字串 HEADER 太長的話，左邊會被截掉。\n"
"                    而 -h \"\" 會印出一行空白行；記得不要使用  -h\"\"\n"
"  -i[CHAR[WIDTH]]   輸出時將所有空格字元替代成 CHAR (TAB)，欄位寬度 WIDTH "
"(8)\n"
"  -j                "
"分欄時合併整行，不會把太長的行截斷，欄位之間也不必對齊。\n"
"                    可用選項 -s[STRING] 設定分隔字元\n"
"  -l PAGE_LENGTH    把一頁的長度定為 PAGE_LENGTH 行 (預設值是 66)\n"
"                    (預設內文的長度是 56 行，用選項 -f 時有 63 行)\n"

#: src/pr.c:2803
msgid ""
"  -h HEADER, --header=HEADER\n"
"                    use a centered HEADER instead of filename in page "
"header,\n"
"                    with long headers left-hand-side truncation may occur,\n"
"                    -h \"\" prints a blank line, don't use -h\"\"\n"
"  -i[CHAR[WIDTH]], --output-tabs[=CHAR[WIDTH]]\n"
"                    replace spaces with CHARs (TABs) to tab WIDTH (8)\n"
"  -J, --join-lines  merge full lines, turns off -W line truncation, no "
"column\n"
"                    alignment, -S[STRING] sets separators\n"
"  -l PAGE_LENGTH, --length=PAGE_LENGTH\n"
"                    set the page length to PAGE_LENGTH (66) lines\n"
"                    (default number of lines of text 56, and with -F 63)\n"
"  -m, --merge       print all files in parallel, one in each column,\n"
"                    truncate lines, but join lines of full length with -J\n"
"  -n[SEP[DIGITS]], --number-lines[=SEP[DIGITS]]\n"
"                    number lines, use DIGITS (5) digits, then SEP (TAB),\n"
"                    default counting starts with 1st line of input file\n"
"  -N NUMBER, --first-line-number=NUMBER\n"
"                    start counting with NUMBER at 1st line of first\n"
"                    page printed (see +FIRST_PAGE)\n"
"  -o MARGIN, --indent=MARGIN\n"
"                    offset each line with MARGIN (zero) spaces, do not\n"
"                    affect -w or -W, MARGIN will be added to PAGE_WIDTH\n"
"  -r, --no-file-warnings\n"
"                    omit warning when a file cannot be opened\n"
msgstr ""

#: src/pr.c:2829
#, fuzzy
msgid ""
"  -s[CHAR],--separator[=CHAR]\n"
"                    separate columns by a single character, default for "
"CHAR\n"
"                    is the <TAB> character without -w and 'no char' with -w\n"
"                    -s[CHAR] turns off line truncation of all 3 column\n"
"                    options (-COLUMN|-a -COLUMN|-m) except -w is set\n"
"  -S[STRING], --sep-string[=STRING]\n"
"                    separate columns by an optional STRING, don't use\n"
"                    -S \"STRING\", -S only: No separator used (same as "
"-S\"\"),\n"
"                    without -S: Default separator <TAB> with -J and <space>\n"
"                    otherwise (same as -S\" \"), no effect on column "
"options\n"
"  -t, --omit-header omit page headers and trailers\n"
"  -T, --omit-pagination\n"
"                    omit page headers and trailers, eliminate any "
"pagination\n"
"                    by form feeds set in input files\n"
"  -v, --show-nonprinting\n"
"                    use octal backslash notation\n"
"  -w PAGE_WIDTH, --width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters for\n"
"                    multiple text-column output only, -s[char] turns off "
"(72)\n"
"  -W PAGE_WIDTH, --page-width=PAGE_WIDTH\n"
"                    set page width to PAGE_WIDTH (72) characters always,\n"
"                    truncate lines, except -J option is set, no "
"interference\n"
"                    with -S or -s\n"
"  --help            display this help and exit\n"
"  --version         output version information and exit\n"
"\n"
"-T implied by -l nn when nn <= 10 or <= 3 with -F. With no FILE, or when\n"
"FILE is -, read standard input.\n"
msgstr ""
"  -m                "
"把所有檔案水平的合併在一起，每個檔案佔一個欄位，把太長的\n"
"                    行截斷。 (可以用選項 -j 讓每行都完整的合併)\n"
"  -n[SEP[DIGITS]]   標上行號，行號用 DIGITS 位整數標出，用 SEP "
"當行號與內文的\n"
"                    間隔 (預設為 5、TAB)。會從第一行、行號一開始計算行號。\n"
"  -N NUMBER         從印出的第一頁第一行當作行號 NUMBER，開始計算行號。\n"
"  -o MARGIN         每一行偏移 MARGIN 個空格當作邊界 (不影響選項 -w)\n"
"  -r                不要在檔案無法被開啟時，印出警告訊息\n"
"  -s[STRING]        在欄位中間插入一個字串 STRING\n"
"                    選項 -s 和字串中間是沒有空白的，不要打成 -s \"STRING\"\n"
"                    沒有指定 -s 時，是用空白字元分隔，跟 -s\" \" 相同\n"
"                    假如沒給 STRING，只給了 -s，則欄位之間沒有間隔 (-s\"\")\n"
"  -t                不印出頁首及頁尾\n"
"  -T                不印出頁首及頁尾；並且忽略輸入檔裡面原先用分頁\n"
"                    符號 (form feeds) 作的分頁設定\n"
"  -v                以八進位反斜線表示法來輸出\n"
"  -w PAGE_WIDTH     把每頁的寬度定為 PAGE_WIDTH (預設是 72 )。\n"
"                    會把太長的行右邊太長的部份截掉 (請同時參考選項 -j)\n"
"  --help            顯示這段說明訊息\n"
"  --version         顯示版本資訊\n"
"\n"
"用選項 -T 的同時也包含了選項 -l nn 的效力；這裡 nn <= 10 或者\n"
"當用到 -f 時， nn <= 3。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"

#: src/ptx.c:409
#, c-format
msgid "%s (for regexp `%s')"
msgstr ""

#: src/ptx.c:1858
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION]... [INPUT]...   (without -G)\n"
"  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [選項]... [INPUT [OUTPUT]]\n"

#: src/ptx.c:1862
msgid ""
"Mandatory arguments to long options are mandatory for short options too.\n"
"\n"
"  -A, --auto-reference           output automatically generated references\n"
"  -C, --copyright                display Copyright and copying conditions\n"
"  -G, --traditional              behave more like System V `ptx'\n"
"  -F, --flag-truncation=STRING   use STRING for flagging line truncations\n"
"  -M, --macro-name=STRING        macro name to use instead of `xx'\n"
"  -O, --format=roff              generate output as roff directives\n"
"  -R, --right-side-refs          put references at right, not counted in -w\n"
"  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n"
"  -T, --format=tex               generate output as TeX directives\n"
"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n"
"  -b, --break-file=FILE          word break characters in this FILE\n"
"  -f, --ignore-case              fold lower case to upper case for sorting\n"
"  -g, --gap-size=NUMBER          gap size in columns between output fields\n"
"  -i, --ignore-file=FILE         read ignore word list from FILE\n"
"  -o, --only-file=FILE           read only word list from this FILE\n"
"  -r, --references               first field of each line is a reference\n"
"  -t, --typeset-mode               - not implemented -\n"
"  -w, --width=NUMBER             output width in columns, reference "
"excluded\n"
"      --help                     display this help and exit\n"
"      --version                  output version information and exit\n"
"\n"
"With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
msgstr ""

#: src/ptx.c:1962
msgid ""
"This program is free software; you can redistribute it and/or modify\n"
"it under the terms of the GNU General Public License as published by\n"
"the Free Software Foundation; either version 2, or (at your option)\n"
"any later version.\n"
"\n"
"This program is distributed in the hope that it will be useful,\n"
"but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
"GNU General Public License for more details.\n"
"\n"
"You should have received a copy of the GNU General Public License\n"
"along with this program; if not, write to the Free Software Foundation,\n"
"Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n"
msgstr ""

#: src/sort.c:259
#, fuzzy, c-format
msgid ""
"Write sorted concatenation of all FILE(s) to standard output.\n"
"\n"
"  +POS1 [-POS2]    start a key at POS1, end it *before* POS2 (obsolescent)\n"
"\t\t     field numbers and character offsets are numbered\n"
"                     starting with zero (contrast with the -k option)\n"
"  -b               ignore leading blanks in sort fields or keys\n"
"  -c               check if given files already sorted, do not sort\n"
"  -d               consider only [a-zA-Z0-9 ] characters in keys\n"
"  -f               fold lower case to upper case characters in keys\n"
"  -g               compare according to general numerical value, imply -b\n"
"  -i               consider only [\\040-\\0176] characters in keys\n"
"  -k POS1[,POS2]   start a key at POS1, end it *at* POS2\n"
"\t\t     field numbers and character offsets are numbered\n"
"                     starting with one (contrast with zero-based +POS form)\n"
"  -m               merge already sorted files, do not sort\n"
"  -M               compare (unknown) < `JAN' < ... < `DEC', imply -b\n"
"  -n               compare according to string numerical value, imply -b\n"
"  -o FILE          write result on FILE instead of standard output\n"
"  -r               reverse the result of comparisons\n"
"  -s               stabilize sort by disabling last resort comparison\n"
"  -t SEP           use SEParator instead of non- to whitespace transition\n"
"  -T DIRECTORY     use DIRECTORY for temporary files, not $TMPDIR or %s\n"
"  -u               with -c, check for strict ordering;\n"
"                   with -m, only output the first of an equal sequence\n"
"  -z               end lines with 0 byte, not newline, for find -print0\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
"\n"
msgstr ""
"把所有檔案 FILE(s) 的內容經過排序後，輸出到標準輸出。\n"
"\n"
"  +POS1 [-POS2]    用 POS1 到 POS2 當鍵 (key) "
"進行排序(包含POS1，不包含POS2)。\n"
"  -b               在對欄位或鍵進行排序時，忽略開頭的空白\n"
"  -c               先檢查所給的檔案是否已經排序妥當，排序好的就不進行排序了\n"
"  -d               比較大小時，只考慮鍵 (key) 裡面 [a-zA-Z0-9 ] 這些字元\n"
"  -f               比較大小時，忽略大小寫的不同\n"
"  -g               依據字元編碼的數字大小來比較，同時忽略開頭的空白 (-b)\n"
"  -i               排序時只考慮 [\\040-\\0176] 這個範圍的字元\n"
"  -k POS1[,POS2]   跟 +POS1 [-POS2] 相同，但位置是從 1 起算\n"
"  -m               把已經排序妥當的檔案合併在一起，不進行排序\n"
"  -M               比較月份， (unknown)< `JAN' <...< `DEC'，忽略開頭的空白 "
"(-b)\n"
"  -n               依據字串的數字大小來比較，同時忽略開頭的空白 (-b)\n"
"  -o FILE          把結果寫到檔案 FILE 裡面去 (預設為標準輸出)\n"
"  -r               以相反的順序印出結果\n"
"  -s               "
"對所有鍵(keys)都相同的行，依輸入順序印出，不對其他欄位排序\n"
"  -t SEP           用字元 SEP 來當欄位間的劃界符號 (預設是空字元)\n"
"  -T DIRECT        用目錄 DIRECT 來存放暫存檔，而非 $TMPDIR 或 %s\n"
"  -u               跟選項 -c 一起用，嚴格的檢查排序順序\n"
"                   跟選項 -m 一起用，連續的資料內容一樣時，只輸出第一筆\n"
"  -z               不用換行字元，以位元組 0 當作行的結尾，在 find -print0 "
"使用\n"
"      --help       顯示這段說明訊息\n"
"      --version    顯示版本資訊\n"
"\n"
"POS 的格式為 F[.C][OPTS]，其中 F 是欄位號碼、C 是在欄位中的字元位置，兩者\n"
"都由零起算。OPTS 是由 [Mbdfinr] 這些字元所組成，用來讓全域的 -Mbdfinr 選項\n"
"在比較該欄位時失效。\n"
"假如沒有指定排序鍵 (key) 時，sort 會用整行的內容來比較、排序。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"

#: src/sort.c:290
msgid ""
"POS is F[.C][OPTS], where F is the field number and C the character "
"position\n"
"in the field, both counted from one with -k, from zero with the obsolescent\n"
"form.  OPTS is made up of one or more of Mbdfinr; this effectively disables\n"
"global -Mbdfinr settings for that key.  If no key is given, use the entire\n"
"line as the key.  With no FILE, or when FILE is -, read standard input.\n"
msgstr ""

#: src/sort.c:381
msgid "flushing file"
msgstr "正在將檔案排齊"

#: src/sort.c:390
msgid "error closing file"
msgstr "正在關閉檔案時發生錯誤"

#: src/sort.c:402 src/sort.c:2371 src/sort.c:2376
#, c-format
msgid "%s: write error"
msgstr "%s: 寫入時發生錯誤"

#: src/sort.c:1451
#, fuzzy, c-format
msgid "%s: %s:%d: disorder: "
msgstr "%s: %s 錯亂\n"

#: src/sort.c:1454
#, fuzzy
msgid "standard error"
msgstr "%s: 讀取時發生錯誤"

#: src/sort.c:1816
#, c-format
msgid "invalid field specification `%s'"
msgstr "`%s' 是無效的欄位說明符"

#. Provoke with `sort -9'.
#: src/sort.c:2024
msgid ""
"when using the old-style +POS and -POS key specifiers,\n"
"the +POS specifier must come first"
msgstr ""
"當使用舊式的 +POS 與 -POS 鍵 (key) 說明符時，\n"
" +POS 說明符必須放在前面 "

#: src/sort.c:2060
msgid "option `-k' requires an argument"
msgstr "選項 `-k' 需要有一個引數"

#. Provoke with `sort -k0'
#: src/sort.c:2077
msgid "the starting field number argument to the `-k' option must be positive"
msgstr "在選項 `-k' 裡指定的開始欄位號碼必須是正的"

#. Provoke with `sort -k1.'
#: src/sort.c:2088
msgid "starting field spec has `.' but lacks following character offset"
msgstr "在開始欄位說明符裡面含有 `.'，卻沒有跟隨的字元偏移量"

#. Provoke with `sort -k1.0'
#: src/sort.c:2097
msgid ""
"starting field character offset argument to the `-k' option\n"
"must be positive"
msgstr ""
"在選項 `-k' 裡指定的開始欄位字元偏移量\n"
"必須是正的"

#. Provoke with `sort -k1,'
#: src/sort.c:2125
msgid "field specification has `,' but lacks following field spec"
msgstr "所給的欄位規格裡面含有 `,'，卻沒有跟隨的欄位說明符"

#. Provoke with `sort -k1,0'
#: src/sort.c:2135
msgid "ending field number argument to the `-k' option must be positive"
msgstr "在選項 `-k' 裡指定的結束欄位號碼必須是正的"

#. Provoke with `sort -k1,1.'
#: src/sort.c:2146
msgid "ending field spec has `.' but lacks following character offset"
msgstr "在結束欄位說明符裡面含有 `.'，卻沒有跟隨的字元偏移量"

#: src/sort.c:2177
msgid "option `-o' requires an argument"
msgstr "選項 `-o' 需要有一個引數"

#: src/sort.c:2195
msgid "option `-t' requires an argument"
msgstr "選項 `-t' 需要有一個引數"

#: src/sort.c:2206
msgid "option `-T' requires an argument"
msgstr "選項 `-T' 需要有一個引數"

#: src/sort.c:2221
#, c-format
msgid "%s: unrecognized option `-%c'\n"
msgstr "%s: 無法辨識的選項 `-%c'\n"

#: src/split.c:87
#, c-format
msgid "Usage: %s [OPTION] [INPUT [PREFIX]]\n"
msgstr "用法：%s [選項] [INPUT [PREFIX]]\n"

#: src/split.c:91
#, fuzzy
msgid ""
"Output fixed-size pieces of INPUT to PREFIXaa, PREFIXab, ...; default\n"
"PREFIX is `x'.  With no INPUT, or when INPUT is -, read standard input.\n"
"\n"
"  -b, --bytes=SIZE        put SIZE bytes per output file\n"
"  -C, --line-bytes=SIZE   put at most SIZE bytes of lines per output file\n"
"  -l, --lines=NUMBER      put NUMBER lines per output file\n"
"  -NUMBER                 same as -l NUMBER\n"
"      --verbose           print a diagnostic to standard error just\n"
"                            before each output file is opened\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
"\n"
"SIZE may have a multiplier suffix: b for 512, k for 1K, m for 1 Meg.\n"
msgstr ""
"把輸入檔 INPUT 分割成固定大小、檔名為 PREFIXaa, PREFIXab,... 的小檔案；\n"
"預設的字首 PREFIX 為 `x'。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -b, --bytes=SIZE        每個輸出檔案的大小為 SIZE 個位元組\n"
"  -C, --line-bytes=SIZE   以行為單位輸出，每個輸出檔案最大為 SIZE 個位元組\n"
"  -l, --lines=NUMBER      每以行為單位輸出，個輸出檔案 NUMBER 行\n"
"  -NUMBER                 跟 -l NUMBER 相同\n"
"      --verbose           在開啟每一個輸出檔的同時，\n"
"\t\t\t  印出一份診斷訊息到標準錯誤輸出 (standard error)\n"
"      --help              顯示這段說明訊息顯示這段說明訊息\n"
"      --version           顯示版本資訊\n"
"\n"
"指定的 SIZE 可以是一個乘數字尾： b 表示 512，k 表示 1K，m 表示 1 Meg。\n"

#: src/split.c:157
#, c-format
msgid "creating file `%s'\n"
msgstr "正在建立檔案 `%s'\n"

#: src/split.c:374 src/split.c:390 src/split.c:406 src/split.c:432
msgid "cannot split in more than one way"
msgstr "不能用超過一種方式來進行分割工作"

#: src/split.c:381 src/split.c:414
#, c-format
msgid "%s: invalid number of bytes"
msgstr "%s: 無效的位元組數目"

#: src/split.c:397
#, c-format
msgid "%s: invalid number of lines"
msgstr "%s: 無效的行數"

#: src/split.c:464
msgid "invalid number"
msgstr "無效的數字"

#: src/split.c:479 src/tr.c:1852 src/uniq.c:409
msgid "too many arguments"
msgstr "太多引數了"

#: src/sum.c:65
msgid ""
"Print checksum and block counts for each FILE.\n"
"\n"
"  -r              defeat -s, use BSD sum algorithm, use 1K blocks\n"
"  -s, --sysv      use System V sum algorithm, use 512 bytes blocks\n"
"      --help      display this help and exit\n"
"      --version   output version information and exit\n"
"\n"
"With no FILE, or when FILE is -, read standard input.\n"
msgstr ""
"把每個檔案 FILE 的總合檢查結果以及區塊數目印出來。\n"
"\n"
"  -r              蓋\過 -s，使用 BSD 的演算法、用 1K 的區塊大小\n"
"  -s, --sysv      使用 System V 的演算法、用 512 個位元組的區塊大小\n"
"      --help      顯示這段說明訊息\n"
"      --version   顯示版本資訊\n"
"\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"

#: src/tac.c:132
msgid ""
"Write each FILE to standard output, last line first.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -b, --before             attach the separator before instead of after\n"
"  -r, --regex              interpret the separator as a regular expression\n"
"  -s, --separator=STRING   use STRING as the separator instead of newline\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
msgstr ""
"從最後一行開始，把每個檔案 FILE 的內容倒過來，輸出到標準輸出去。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -b, --before             把分隔符加在前面 (預設是加在後面)\n"
"  -r, --regex              把分隔符解釋為正規運算式\n"
"  -s, --separator=STRING   用字串 STRING 當分隔符 (預設是換行字元)\n"
"      --help               顯示這段說明訊息\n"
"      --version            顯示版本資訊\n"

#: src/tac.c:453 src/tac.c:594
#, fuzzy
msgid "stdin: read error"
msgstr "%s: 讀取時發生錯誤"

#: src/tac.c:638
msgid "separator cannot be empty"
msgstr "分隔符不可以是空的"

#: src/tail.c:216
#, fuzzy, c-format
msgid ""
"Print the last %d lines of each FILE to standard output.\n"
"With more than one FILE, precede each with a header giving the file name.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"      --retry              keep trying to open a file even if it is\n"
"                             inaccessible when tail starts or if it becomes\n"
"                             inaccessible later -- useful only with -f\n"
"  -c, --bytes=N            output the last N bytes\n"
"  -f, --follow[={name|descriptor}] output appended data as the file grows;\n"
"                             -f, --follow, and --follow=descriptor are\n"
"                             equivalent\n"
"  -n, --lines=N            output the last N lines, instead of the last %d\n"
"      --max-unchanged-stats=N see the texinfo documentation\n"
"                             (the default is %d)\n"
"      --max-consecutive-size-changes=N see the texinfo documentation\n"
"                             (the default is %d)\n"
"      --pid=PID            with -f, terminate after process ID, PID dies\n"
"  -q, --quiet, --silent    never output headers giving file names\n"
"  -s, --sleep-interval=S   with -f, sleep S seconds between iterations\n"
"  -v, --verbose            always output headers giving file names\n"
"      --help               display this help and exit\n"
"      --version            output version information and exit\n"
"\n"
"If the first character of N (the number of bytes or lines) is a `+',\n"
"print beginning with the Nth item from the start of each file, otherwise,\n"
"print the last N items in the file.  N may have a multiplier suffix:\n"
"b for 512, k for 1024, m for 1048576 (1 Meg).  A first OPTION of -VALUE\n"
"or +VALUE is treated like -n VALUE or -n +VALUE unless VALUE has one of\n"
"the [bkm] suffix multipliers, in which case it is treated like -c VALUE\n"
"or -c +VALUE.\n"
"\n"
"With --follow (-f), tail defaults to following the file descriptor, which\n"
"means that even if a tail'ed file is renamed, tail will continue to track\n"
"its end.  This default behavior is not desirable when you really want to\n"
"track the actual name of the file, not the file descriptor (e.g., log\n"
"rotation).  Use --follow=name in that case.  That causes tail to track the\n"
"named file by reopening it periodically to see if it has been removed and\n"
"recreated by some other program.\n"
"\n"
msgstr ""
"把每個檔案 FILE P的最後 10 行輸出到標準輸出。\n"
"指定了超過一個 FILE 時，會一一處理，然後在輸出結果之前加上對應的檔名。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -c, --bytes=N            輸出倒數 N 個位元組\n"
"  -f, --follow             當檔案變大時，跟著輸出加在檔案尾端的資料\n"
"  -n, --lines=N            輸出倒數 N 行 (預設是 10 行)\n"
"  -q, --quiet, --silent    不要在輸出結果之前加上對應的檔名\n"
"  -v, --verbose            在輸出結果之前加上對應的檔名\n"
"      --help               顯示這段說明訊息\n"
"      --version            顯示版本資訊\n"
"\n"
"假如數目字 N 之前有一個 `+' 的話，會從檔案開頭起算的第 N 行 (或位元組)\n"
"開始印出，否則就把從檔案最後算起的 N 行 (或位元組) 印出。\n"
"指定的 N 可以有一個乘數字尾： b 表示 512，k 表示 1K，m 表示 1 Meg。\n"
"\n"
"此外，可以用一個數目字 -VALUE 當第一個選項，假如 VALUE 中含有\n"
"乘數字尾 [bkm] 的話，程式會把它解釋為 -c VALUE，否則就當成 -n VALUE 處理。\n"

#: src/tail.c:293
#, c-format
msgid "closing %s (fd=%d)"
msgstr ""

#. FIXME-maybe: detect the case in which the file first becomes
#. unreadable (perms), and later becomes readable again and can
#. be seen to be the same file (dev/ino).  Otherwise, tail prints
#. the entire contents of the file when it becomes readable.
#: src/tail.c:720
#, c-format
msgid "`%s' has become inaccessible"
msgstr ""

#: src/tail.c:739
#, fuzzy, c-format
msgid ""
"`%s' has been replaced with a non-regular file;  cannot follow end of "
"non-regular file"
msgstr "標準輸入：不能跟隨非常規檔案結束"

#: src/tail.c:759
#, c-format
msgid "`%s' has become accessible"
msgstr ""

#: src/tail.c:767
#, fuzzy, c-format
msgid "`%s' has appeared;  following end of new file"
msgstr "%s: 不能跟隨非常規檔案結束"

#: src/tail.c:778
#, c-format
msgid "`%s' has been replaced;  following end of new file"
msgstr ""

#: src/tail.c:892
msgid "file truncated"
msgstr "檔案被截斷了"

#: src/tail.c:912
msgid "no files remaining"
msgstr ""

#: src/tail.c:1120
#, c-format
msgid "%s: cannot follow end of non-regular file"
msgstr "%s: 不能跟隨非常規檔案結束"

#: src/tail.c:1231
#, c-format
msgid "%c: invalid suffix character in obsolescent option"
msgstr "%c: 在即將廢棄的選項中含有無效的字尾字元"

#: src/tail.c:1280
#, c-format
msgid ""
"too many arguments;  When using tail's obsolescent option syntax (%s)\n"
"there may be no more than one file argument.  Use the equivalent -n or -c\n"
"option instead."
msgstr ""

#: src/tail.c:1289
#, c-format
msgid ""
"Warning: it is not portable to use two or more file arguments with\n"
"tail's obsolescent option syntax (%s).  Use the equivalent -n or -c\n"
"option instead."
msgstr ""

#: src/tail.c:1371
#, fuzzy, c-format
msgid "%s: invalid maximum number of unchanged stats between opens"
msgstr "%s: 無效的位元組數目"

#: src/tail.c:1383
#, fuzzy, c-format
msgid "%s: invalid maximum number of consecutive size changes"
msgstr "%s: 無效的位元組數目"

#: src/tail.c:1395
#, fuzzy, c-format
msgid "%s: invalid PID"
msgstr "%s: 無效的號碼"

#: src/tail.c:1413
#, fuzzy, c-format
msgid "%s: invalid number of seconds"
msgstr "%s: 無效的位元組數目"

#: src/tail.c:1433
msgid "warning: --retry is useful only when following by name"
msgstr ""

#: src/tail.c:1437
msgid "warning: PID ignored; --pid=PID is useful only when following"
msgstr ""

#: src/tr.c:325
#, c-format
msgid "Usage: %s [OPTION]... SET1 [SET2]\n"
msgstr "用法：%s [選項]... SET1 [SET2]\n"

#: src/tr.c:329
msgid ""
"Translate, squeeze, and/or delete characters from standard input,\n"
"writing to standard output.\n"
"\n"
"  -c, --complement        first complement SET1\n"
"  -d, --delete            delete characters in SET1, do not translate\n"
"  -s, --squeeze-repeats   replace sequence of characters with one\n"
"  -t, --truncate-set1     first truncate SET1 to length of SET2\n"
"      --help              display this help and exit\n"
"      --version           output version information and exit\n"
msgstr ""
"從標準輸入讀取資料，將資料替換、壓縮、刪除字元後，輸出到標準輸出。\n"
"\n"
"  -c, --complement        補數，用所有不在 SET1 裡的字元來當 SET1\n"
"  -d, --delete            不做替換，直接把在 SET1 裡面的字元都刪除\n"
"  -s, --squeeze-repeats   把連續重複的字元都刪成只剩一個\n"
"  -t, --truncate-set1     先把 SET1 的長度截成跟 SET2 一樣長\n"
"      --help              顯示這段說明訊息\n"
"      --version           顯示版本資訊\n"

#: src/tr.c:340
msgid ""
"\n"
"SETs are specified as strings of characters.  Most represent themselves.\n"
"Interpreted sequences are:\n"
"\n"
"  \\NNN            character with octal value NNN (1 to 3 octal digits)\n"
"  \\\\              backslash\n"
"  \\a              audible BEL\n"
"  \\b              backspace\n"
"  \\f              form feed\n"
"  \\n              new line\n"
"  \\r              return\n"
"  \\t              horizontal tab\n"
"  \\v              vertical tab\n"
"  CHAR1-CHAR2     all characters from CHAR1 to CHAR2 in ascending order\n"
"  [CHAR1-CHAR2]   same as CHAR1-CHAR2, if both SET1 and SET2 use this\n"
"  [CHAR*]         in SET2, copies of CHAR until length of SET1\n"
"  [CHAR*REPEAT]   REPEAT copies of CHAR, REPEAT octal if starting with 0\n"
"  [:alnum:]       all letters and digits\n"
"  [:alpha:]       all letters\n"
"  [:blank:]       all horizontal whitespace\n"
"  [:cntrl:]       all control characters\n"
"  [:digit:]       all digits\n"
"  [:graph:]       all printable characters, not including space\n"
"  [:lower:]       all lower case letters\n"
"  [:print:]       all printable characters, including space\n"
"  [:punct:]       all punctuation characters\n"
"  [:space:]       all horizontal or vertical whitespace\n"
"  [:upper:]       all upper case letters\n"
"  [:xdigit:]      all hexadecimal digits\n"
"  [=CHAR=]        all characters which are equivalent to CHAR\n"
msgstr ""
"\n"
"字元集 SETs 是一個字串，表示出現在這個字串裡面所有字元所構成的集合。\n"
"另外，還有一些含有特殊意義的字串：\n"
"\n"
"  \\NNN            八進位編碼為 NNN 的字元 (1 到 3 個八進位阿拉伯數字)\n"
"  \\\\              反斜線\n"
"  \\a              喇叭聲 (BEL)\n"
"  \\b              退格字元 (backspace)\n"
"  \\f              換頁字元 (form feed)\n"
"  \\n              換行字元 (new line)\n"
"  \\r              轉回字元 (return)\n"
"  \\t              水平表號 (horizontal tab)\n"
"  \\v              垂直表號 (vertical tab)\n"
"  CHAR1-CHAR2     所有編碼在 CHAR1 到 CHAR2 之間的字元，依升序排列\n"
"  [CHAR1-CHAR2]   在 SET1 與 SET2 都用 `[]' 的時候，跟 CHAR1-CHAR2 相同\n"
"  [CHAR*]         用在 SET2，重複字元 CHAR 直到與 SET1 長度相同\n"
"  [CHAR*REPEAT]   重複字元 CHAR，重複 REPEAT 次\n"
"  [:alnum:]       所有的字母與阿拉伯數字\n"
"  [:alpha:]       所有的字母\n"
"  [:blank:]       所有的水平空白字元 (space、tab... 等等)\n"
"  [:cntrl:]       所有的控制字元\n"
"  [:digit:]       所有阿拉伯數字\n"
"  [:graph:]       所有可列印字元，不包括空格字元\n"
"  [:lower:]       所有小寫字母\n"
"  [:print:]       所有可列印字元，包括空格字元\n"
"  [:punct:]       所有標點符號 (punctuation characters)\n"
"  [:space:]       所有的水平及垂直空白字元\n"
"  [:upper:]       所有大寫字母\n"
"  [:xdigit:]      所有十六進位數字 ([0-9A-Fa-f])\n"
"  [=CHAR=]        所有跟字元 CHAR 相等的字元\n"

#: src/tr.c:372
msgid ""
"\n"
"Translation occurs if -d is not given and both SET1 and SET2 appear.\n"
"-t may be used only when translating.  SET2 is extended to length of\n"
"SET1 by repeating its last character as necessary.  Excess characters\n"
"of SET2 are ignored.  Only [:lower:] and [:upper:] are guaranteed to\n"
"expand in ascending order; used in SET2 while translating, they may\n"
"only be used in pairs to specify case conversion.  -s uses SET1 if not\n"
"translating nor deleting; else squeezing uses SET2 and occurs after\n"
"translation or deletion.\n"
msgstr ""
"\n"
"當 SET1 與 SET2 都有給，而且沒有指定選項 -d 時，程式就進行替換的工作；選項 "
"-t\n"
"只能在進行替換時使用。SET2 比 SET1 短時，程式會自動使用 SET2 的最後一個字元\n"
"補滿 SET2，讓 SET1 與 SET2 長度相等。SET2 比 SET1 長時，多的字元會被忽略。\n"
"這些字元集裡面，只有 [:lower:] 與 [:upper:] 用在 SET2 "
"時會保証依遞增的順序展\n"
"開，而 [:lower:] 與 [:upper:] 一定要成對的出現，用來作大小寫的轉換。\n"
"使用選項 -s ，且不作替換或刪除時，會使用 SET1 當壓縮的標的。\n"
"當需要壓縮並同時作替換或刪除時，會使用 SET2 "
"當壓縮的標的，並且在替換或刪除後\n"
"再作壓縮的動作。\n"

#. Any octal number larger than 0377 won't
#. fit in 8 bits.  So we stop when adding the
#. next digit would put us over the limit and
#. give a warning about the ambiguity.  POSIX
#. isn't clear on this, but one person has said
#. that in his interpretation, POSIX says tr
#. can't even give a warning.
#: src/tr.c:544
#, c-format
msgid ""
"warning: the ambiguous octal escape \\%c%c%c is being\n"
"\tinterpreted as the 2-byte sequence \\0%c%c, `%c'"
msgstr ""
"警告：將岐義的八進位逸出序列 \\%c%c%c \n"
"\t解釋為兩個位元組的序列 \\0%c%c, `%c'"

#: src/tr.c:553
msgid "invalid backslash escape at end of string"
msgstr "在字串的結尾有無效的反斜線逸出"

#: src/tr.c:559
#, c-format
msgid "invalid backslash escape `\\%c'"
msgstr "無效的反斜線逸出序列 `\\%c'"

#: src/tr.c:712
#, c-format
msgid "range-endpoints of `%s-%s' are in reverse collating sequence order"
msgstr "`%s-%s' 的範圍結束點在相反的排列序向"

#: src/tr.c:927
#, c-format
msgid "invalid repeat count `%s' in [c*n] construct"
msgstr "在 [c*n] 結構中有無效的重覆次數 `%s' "

#: src/tr.c:1033
#, c-format
msgid "invalid character class `%s'"
msgstr "無效的字元類別 `%s'"

#: src/tr.c:1058
#, c-format
msgid "%s: equivalence class operand must be a single character"
msgstr "%s: 等價類別運算數 (equivalence class operand) 必須是一個單一字元"

#: src/tr.c:1530
msgid "the [c*] repeat construct may not appear in string1"
msgstr "第一個字串裡不能有 [c*] 這種重複結構"

#: src/tr.c:1540
msgid "only one [c*] repeat construct may appear in string2"
msgstr "第二個字串裡只能出現一個 [c*] 這種重複結構"

#: src/tr.c:1548
msgid "[=c=] expressions may not appear in string2 when translating"
msgstr "進行替換時，[=c=] 表示式不能在第二個字串裡出現"

#: src/tr.c:1561
msgid "when not truncating set1, string2 must be non-empty"
msgstr "在不消除第一個字元集 (set1) 時，第二個字串不能是空的"

#: src/tr.c:1570
msgid ""
"when translating with complemented character classes,\n"
"string2 must map all characters in the domain to one"
msgstr ""
"在以互補的字元種類作替換時，第二個字串的範圍\n"
"必須包含第一個字串裡所有的字元"

#: src/tr.c:1577
msgid ""
"when translating, the only character classes that may appear in\n"
"string2 are `upper' and `lower'"
msgstr ""
"在替換時，唯一可能出現在第二個字串的字元種類\n"
"只有 `upper' 或 `lower'"

#: src/tr.c:1586
msgid "the [c*] construct may appear in string2 only when translating"
msgstr " [c*] 結構只有在替換時才能出現在第二個字串裡面"

#: src/tr.c:1857
msgid "two strings must be given when translating"
msgstr "在替換時必須給定兩個字串"

#: src/tr.c:1860
msgid "two strings must be given when both deleting and squeezing repeats"
msgstr "在同時刪除、壓擠重覆字 (squeezing repeats) 時必須給定兩個字串"

#: src/tr.c:1874
msgid "only one string may be given when deleting without squeezing repeats"
msgstr "刪除但是不壓擠重覆字 (squeezing repeats) 時只能給定一個字串"

#: src/tr.c:1880
msgid "at least one string must be given when squeezing repeats"
msgstr "在壓擠重覆字 (squeezing repeats) 時至少需給定一個字串"

#: src/tr.c:1971
msgid "misaligned [:upper:] and/or [:lower:] construct"
msgstr "沒有對齊的 [:upper:]、[:lower:] 結構"

#: src/tr.c:1994
msgid ""
"invalid identity mapping;  when translating, any [:lower:] or [:upper:]\n"
"construct in string1 must be aligned with a corresponding construct\n"
"([:upper:] or [:lower:], respectively) in string2"
msgstr ""
"無效的恆等映射 (identity mapping)；進行替換時，字串 1 的任何\n"
" [:lower:]、[:upper:] 結構，在字串 2 裡都必須有一個相對應的結構才可以。\n"
" (分別為 [:upper:]、[:lower:]) "

#: src/tsort.c:93
#, fuzzy, c-format
msgid ""
"Usage: %s [OPTION] [FILE]\n"
"Write totally ordered list consistent with the partial ordering in FILE.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"      --help       display this help and exit\n"
"      --version    output version information and exit\n"
msgstr ""
"印出每個檔案的 CRC 總和檢查以及總位元組數目\n"
"\n"
"  --help               顯示這段說明訊息\n"
"  --version            顯示版本資訊\n"

#: src/tsort.c:101
#, fuzzy
msgid ""
"\n"
"Report bugs to <textutils-bugs@gnu.org>."
msgstr ""
"\n"
"發現錯誤, 請報告到 textutils-bugs@gnu.ai.mit.edu"

#: src/tsort.c:443
#, c-format
msgid "%s: input contains a loop:\n"
msgstr ""

#. Should not happen.
#: src/tsort.c:450
msgid "could not find loop"
msgstr ""

#: src/tsort.c:480
#, fuzzy
msgid "only one argument may be specified"
msgstr "使用選項 --check 時只能指定一個引數"

#: src/unexpand.c:365
msgid ""
"Convert spaces in each FILE to tabs, writing to standard output.\n"
"With no FILE, or when FILE is -, read standard input.\n"
"\n"
"  -a, --all           convert all whitespace, instead of initial whitespace\n"
"  -t, --tabs=NUMBER   have tabs NUMBER characters apart instead of 8\n"
"  -t, --tabs=LIST     use comma separated list of explicit tab positions\n"
"      --help          display this help and exit\n"
"      --version       output version information and exit\n"
"\n"
"Instead of -t NUMBER or -t LIST, -NUMBER or -LIST may be used.\n"
msgstr ""
"把每個檔案 FILE 裡面的空格字元替換成欄標 (TAB)，輸出到標準輸出。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"\n"
"  -a, --all           除了檔案開頭的空白字元外，替換所有的空白字元\n"
"  -t, --tabs=NUMBER   把欄標定成間隔 NUMBER 個字元 (預設值為 8)\n"
"  -t, --tabs=LIST     用 LIST 當欄標的位置，LIST 是用逗號分隔的串列\n"
"      --help          顯示這段說明訊息\n"
"      --version       顯示版本資訊\n"
"\n"
"可以用比較簡單的 -NUMBER、 -LIST 來代替 -t NUMBER、 -t LIST。\n"

#: src/uniq.c:100
#, c-format
msgid "Usage: %s [OPTION]... [INPUT [OUTPUT]]\n"
msgstr "用法：%s [選項]... [INPUT [OUTPUT]]\n"

#: src/uniq.c:104
#, fuzzy
msgid ""
"Discard all but one of successive identical lines from INPUT (or\n"
"standard input), writing to OUTPUT (or standard output).\n"
"\n"
"  -c, --count           prefix lines by the number of occurrences\n"
"  -d, --repeated        only print duplicate lines\n"
"  -D, --all-repeated    print all duplicate lines\n"
"  -f, --skip-fields=N   avoid comparing the first N fields\n"
"  -i, --ignore-case     ignore differences in case when comparing\n"
"  -s, --skip-chars=N    avoid comparing the first N characters\n"
"  -u, --unique          only print unique lines\n"
"  -w, --check-chars=N   compare no more than N characters in lines\n"
"  -N                    same as -f N\n"
"  +N                    same as -s N\n"
"      --help            display this help and exit\n"
"      --version         output version information and exit\n"
"\n"
"A field is a run of whitespace, then non-whitespace characters.\n"
"Fields are skipped before chars.\n"
msgstr ""
"把由輸入檔 INPUT 讀取的資料裡，有內容重複相連的行都縮成一行，寫入\n"
"檔案 OUTPUT 中 (或輸出到標準輸出)。\n"
"\n"
"  -c, --count           在每行的開頭印出此行出現的次數\n"
"  -d, --repeated        只印出有重複相連的行\n"
"  -f, --skip-fields=N   跳過欄位，不比較每行最前面的 N 個欄位\n"
"  -i, --ignore-case     比較內容時，忽略大小寫的不同\n"
"  -s, --skip-chars=N    跳過字元，不比較每行最前面的 N 個字元\n"
"  -u, --unique          只印出沒有重複過的行\n"
"  -w, --check-chars=N   比較時，每行不超過 N 個字元\n"
"  -N                    與 -f N 相同\n"
"  +N                    與 -s N 相同\n"
"      --help            顯示這段說明訊息\n"
"      --version         顯示版本資訊\n"
"\n"
"這邊所謂的一個欄位，指的是一群用任意個空白字元相隔的非空白字元。\n"
"同時指定選項 -f 與 -s 時，會先跳過欄位、再跳過字元。\n"

#: src/uniq.c:272
#, c-format
msgid "error reading %s"
msgstr "正在讀取 %s 時發生錯誤"

#: src/uniq.c:275
#, c-format
msgid "error writing %s"
msgstr "正在寫入 %s 時發生錯誤"

#: src/uniq.c:337
#, c-format
msgid "invalid number of fields to skip: `%s'"
msgstr "要跳過的欄位數目無效：`%s'"

#: src/uniq.c:353
#, c-format
msgid "invalid number of bytes to skip: `%s'"
msgstr "要跳過的位元組數目無效：`%s'"

#: src/uniq.c:369 src/uniq.c:395
#, c-format
msgid "invalid number of bytes to compare: `%s'"
msgstr "要比較的位元組數目無效：`%s'"

#: src/uniq.c:416
msgid "printing all duplicated lines and repeat counts is meaningless"
msgstr ""

#: src/wc.c:89
#, fuzzy
msgid ""
"Print line, word, and byte counts for each FILE, and a total line if\n"
"more than one FILE is specified.  With no FILE, or when FILE is -,\n"
"read standard input.\n"
"  -c, --bytes, --chars   print the byte counts\n"
"  -l, --lines            print the newline counts\n"
"  -L, --max-line-length  print the length of the longest line\n"
"  -w, --words            print the word counts\n"
"      --help             display this help and exit\n"
"      --version          output version information and exit\n"
msgstr ""
"印出每個檔案 FILE 裡面的行數、字數及位元組數目，指定多個檔案的話\n"
"還會把總計印出來。\n"
"假如沒有給引數 FILE、或給定的 FILE 為 `-' 的話，則從標準輸入讀取資料。\n"
"  -c, --bytes, --chars   印出位元組數目\n"
"  -l, --lines            印出行數\n"
"  -w, --words            印出字數\n"
"      --help             顯示這段說明訊息\n"
"      --version          顯示版本資訊\n"

#: src/wc.c:364
msgid "total"
msgstr "總計"

#~ msgid "`-w PAGE_WIDTH' invalid column number: `%s'"
#~ msgstr "`-w PAGE_WIDTH' 無效的欄位號碼：`%s'"

#~ msgid "virtual memory exhausted"
#~ msgstr "虛擬記憶體耗盡"

#~ msgid "invalid number `%s'"
#~ msgstr "無效的號碼 `%s'"
