diff -urN shadow-20000902.orig/src/su.c shadow-20000902/src/su.c
--- shadow-20000902.orig/src/su.c	Mon Oct 23 18:18:12 2000
+++ shadow-20000902/src/su.c	Mon Oct 23 18:21:47 2000
@@ -52,6 +52,7 @@
 #include <grp.h>
 #include <signal.h>
 #include <pwd.h>
+#include <getopt.h>
 #include "pwauth.h"
 #include "getdef.h"
 
@@ -82,6 +83,18 @@
 
 /* local function prototypes */
 
+/* If nonzero, change some environment vars to indicate the user su'd to.  */
+static int change_environment;
+
+static struct option const longopts[] =
+{
+  {"command", required_argument, 0, 'c'},
+  {"preserve-environment", no_argument, 0, 'p'},
+  {"shell", required_argument, 0, 's'},
+  {"help", no_argument, 0, 'h'},
+  {0, 0, 0, 0}
+};
+
 #ifndef USE_PAM
 
 static RETSIGTYPE die(int);
@@ -124,6 +137,96 @@
 }
 #endif /* !USE_PAM */
 
+/* borrowed from GNU sh-utils' "su.c" */
+static int
+restricted_shell (const char *shell)
+{
+       char *line;
+
+       setusershell ();
+       while ((line = getusershell ()) != NULL) {
+               if (*line != '#' && strcmp (line, shell) == 0) {
+                       endusershell ();
+                       return 0;
+               }
+       }
+       endusershell ();
+       return 1;
+}
+
+/* borrowed from GNU sh-utils' "su.c" */
+static int
+elements (char **arr)
+{
+  int n = 0;
+
+  for (n = 0; *arr; ++arr)
+    ++n;
+  return n;
+}
+
+/* borrowed from GNU sh-utils' "su.c" */
+static void
+run_shell (char *shell, const char *command, char **additional_args, int login)
+{
+  const char **args;
+  int argno = 1;
+  char cmd[BUFSIZ];
+  int cmd_len_left = sizeof(cmd) - 1;
+
+  cmd[0] = '\0';
+
+  if (additional_args)
+    args = (const char **) xmalloc (sizeof (char *)
+                                    * (10 + elements (additional_args)));
+  else
+    args = (const char **) xmalloc (sizeof (char *) * 10);
+
+  if (login)
+    {
+      char *arg0;
+      char *shell_basename;
+
+      shell_basename = getdef_str("SU_NAME");
+      if (!shell_basename)
+       shell_basename = Basename(shell);
+
+      arg0 = xmalloc (strlen (shell_basename) + 2);
+      arg0[0] = '-';
+      strcpy (arg0 + 1, shell_basename);
+      args[0] = arg0;
+    }
+  else
+    args[0] = Basename(shell);
+  if (command || additional_args)
+    args[argno++] = "-c";
+  if (command) {
+    if (strlen(command) > cmd_len_left) {
+      fprintf(stderr, _("Command line args too long\n"));
+      exit(1);
+    }
+    strcat(cmd, command);
+    cmd_len_left -= strlen(command);
+  }
+  if (additional_args)
+    for (; *additional_args; ++additional_args) {
+      if ((strlen(*additional_args) + 1) > cmd_len_left) {
+	fprintf(stderr, _("Command line args too long\n"));
+	exit(1);
+      }
+      if (cmd[0]) {
+	strcat(cmd, " ");
+	cmd_len_left--;
+      }
+      strcat(cmd, *additional_args);
+      cmd_len_left -= strlen(*additional_args);
+    }
+  if (cmd[0]) args[argno++] = cmd;
+  args[argno] = NULL;
+  execv (shell, (char **) args);
+  fprintf (stderr, _("No shell\n"));
+  SYSLOG((LOG_WARN, "Cannot execute %s\n", shell));
+}
 
 static void
 su_failure(const char *tty)
@@ -161,12 +264,14 @@
 {
 	char	*cp;
 	const char *tty = 0;		/* Name of tty SU is run from        */
-	int	doshell = 0;
 	int	fakelogin = 0;
 	int	amroot = 0;
 	uid_t my_uid;
 	struct	passwd	*pw = 0;
 	char	**envp = environ;
+	char    *command = 0, *shell = 0, **additional_args = 0;
+	int     optc;
+	char	*tmp_name;
 #ifdef USE_PAM
 	int ret;
 #else  /* !USE_PAM */
@@ -180,12 +285,14 @@
 #endif
 #endif /* !USE_PAM */
 
-	sanitize_env();
+	/* sanitize_env(); */
 
 	setlocale(LC_ALL, "");
 	bindtextdomain(PACKAGE, LOCALEDIR);
 	textdomain(PACKAGE);
 
+	change_environment = 1;
+
 	/*
 	 * Get the program name.  The program name is used as a
 	 * prefix to most error messages.
@@ -230,12 +337,60 @@
 	 * Process the command line arguments. 
 	 */
 
-	argc--; argv++;			/* shift out command name */
+	while ((optc = getopt_long (argc, argv, "c:mps:h", longopts, NULL)) != -1) {
+		switch (optc) {
+		    case 0:
+			break;
+		    case 'c':
+			command = optarg;
+			break;
+		    case 'm':
+		    case 'p':
+			change_environment = 0;
+			break;
+		    case 's':
+			shell = optarg;
+			break;
+		    default:
+			fprintf(stderr, _("\
+Usage: su [OPTS] [-] [username [ARGS]]\n\
+	-	make this a login shell\n\
+	-c, --command=<command>\n\
+		pass command to the invoked shell using its -c\n\
+		option\n\
+       -m, -p, --preserve-environment\n\
+		do not reset environment variables, and keep the\n\
+		same shell\n\
+       -s, --shell=<shell>\n\
+		use shell instead of the default in /etc/passwd\n"));
+			exit(1);
+		}
+	}
 
-	if (argc > 0 && strcmp(argv[0], "-") == 0) {
+	if (optind < argc && !strcmp (argv[optind], "-")) {
 		fakelogin = 1;
-		argc--; argv++;		/* shift ... */
+		++optind;
+	}
+
+	if (optind < argc)
+		strncpy(name, argv[optind++], sizeof(name) - 1);
+	else
+		strcpy(name, "root");
+
+	if (optind < argc)
+		additional_args = argv + optind;
+
+	/*
+	 * Get the user's real name.  The current UID is used to determine
+	 * who has executed su.  That user ID must exist.
+	 */
+
+	pw = get_my_pwent();
+	if (!pw) {
+		SYSLOG((LOG_CRIT, "Unknown UID: %d\n", (int) my_uid));
+		su_failure(tty);
 	}
+	STRFCPY(oldname, pw->pw_name);
 
 	/*
 	 * If a new login is being set up, the old environment will
@@ -261,35 +416,6 @@
 			addenv(*envp++, NULL);
 	}
 
-	/*
-	 * The next argument must be either a user ID, or some flag to
-	 * a subshell.  Pretty sticky since you can't have an argument
-	 * which doesn't start with a "-" unless you specify the new user
-	 * name.  Any remaining arguments will be passed to the user's
-	 * login shell.
-	 */
-
-	if (argc > 0 && argv[0][0] != '-') {
-		STRFCPY(name, argv[0]);	/* use this login id */
-		argc--; argv++;		/* shift ... */
-	}
-	if (! name[0]) 			/* use default user ID */
-		(void) strcpy (name, "root");
-
-	doshell = argc == 0;		/* any arguments remaining? */
-
-	/*
-	 * Get the user's real name.  The current UID is used to determine
-	 * who has executed su.  That user ID must exist.
-	 */
-
-	pw = get_my_pwent();
-	if (!pw) {
-		SYSLOG((LOG_CRIT, "Unknown UID: %d\n", (int) my_uid));
-		su_failure(tty);
-	}
-	STRFCPY(oldname, pw->pw_name);
-
 #ifndef USE_PAM
 #ifdef SU_ACCESS
 	/*
@@ -302,9 +428,7 @@
 #endif
 	oldpass = xstrdup(pw->pw_passwd);
 #endif  /* SU_ACCESS */
-#endif  /* !USE_PAM */
-
-#ifdef USE_PAM
+#else /* USE_PAM */
 	ret = pam_start("su", name, &conv, &pamh);
 	if (ret != PAM_SUCCESS) {
 		SYSLOG((LOG_ERR, "pam_start: error %d\n", ret);
@@ -394,24 +518,18 @@
 	/*
 	 * Set the default shell.
 	 */
-#if 0
-	/*
-	 * XXX - GNU and *BSD versions of su support the -m option.
-	 * Need to add some option parsing code.
-	 */
-	if (mflg) {
-		if (!amroot && !check_shell(pwent.pw_shell)) {
-			fprintf(stderr, _("%s: permission denied (shell).\n"), Prog);
-			exit(1);
-		}
-		if ((cp = getenv("SHELL")))
-			pwent.pw_shell = cp;
-	}
-#endif
 
-	if (pwent.pw_shell[0] == '\0')
-		pwent.pw_shell = "/bin/sh";  /* XXX warning: const */
+	if (pwent.pw_shell == NULL || pwent.pw_shell[0] == '\0')
+		pwent.pw_shell = (char *) "/bin/sh";
 
+	if (shell == 0 && change_environment == 0)
+		shell = getenv ("SHELL");
+	if (shell != 0 && getuid () && restricted_shell (pwent.pw_shell))
+		shell = 0;
+	if (shell == 0)
+	shell = (char *) strdup (pwent.pw_shell);
+
+	signal(SIGINT, SIG_IGN);
 #ifdef USE_PAM
 	ret = pam_authenticate(pamh, 0);
 	if (ret != PAM_SUCCESS) {
@@ -434,6 +552,14 @@
 			su_failure(tty);
 		}
 	}
+	ret = pam_get_item(pamh, PAM_USER, (const void **) &tmp_name);
+	if (ret != PAM_SUCCESS) {
+		SYSLOG((LOG_ERR, "pam_get_item: internal PAM error\n"));
+		fprintf(stderr, "%s: Internal PAM error retrieving username\n", Prog);
+		pam_end(pamh, ret);
+		su_failure(tty);
+	}
+	strncpy(name, tmp_name, sizeof(name) - 1);
 #else  /* !USE_PAM */
 	/*
 	 * Set up a signal handler in case the user types QUIT.
@@ -500,6 +626,7 @@
 	}
 #endif  /* !USE_PAM */
 
+	signal(SIGINT, SIG_DFL);
 	cp = getdef_str((pwent.pw_uid == 0) ? "ENV_SUPATH" : "ENV_PATH");
 #if 0
 	addenv(cp ? cp : "PATH=/bin:/usr/bin", NULL);
@@ -514,10 +641,14 @@
 	}
 #endif
 
-	environ = newenvp;		/* make new environment active */
-
-	if (getenv ("IFS"))		/* don't export user IFS ... */
-		addenv("IFS= \t\n", NULL);	/* ... instead, set a safe IFS */
+	if (change_environment || restricted_shell(pwent.pw_shell)) {
+		environ = newenvp;			/* make new environment active */
+		if (getenv ("IFS"))			/* don't export user IFS ... */
+			addenv("IFS= \t\n", NULL);	/* ... instead, set a safe IFS */
+	} else {
+		if (getenv ("IFS"))
+			putenv("IFS= \t\n");
+	}
 
 	if (pwent.pw_shell[0] == '*') { /* subsystem root required */
 		subsystem (&pwent);	/* figure out what to execute */
@@ -555,17 +686,56 @@
 		pam_end(pamh, ret);
 		exit(1);
 	}
+	ret = pam_open_session(pamh, 0);
+	if (ret != PAM_SUCCESS) {
+		SYSLOG((LOG_ERR, "pam_open_session: %s\n", PAM_STRERROR(pamh, ret)));
+		fprintf(stderr, "%s: %s\n", Prog, PAM_STRERROR(pamh, ret));
+		pam_setcred(pamh, PAM_DELETE_CRED);
+		pam_end(pamh, ret);
+		exit(1);
+	}
+	/* We must fork before setuid() because we need to call
+	 * pam_close_session() as root.
+	 */
+
+	/* We let the admin configure whether they need to keep login
+	   around to close sessions */
+	if (getdef_bool("CLOSE_SESSIONS")) {
+		pid_t pid;
+		int status;
+
+		signal(SIGINT, SIG_IGN);
+		pid = fork();
+
+		switch(pid) {
+		case -1:
+			SYSLOG((LOG_ERR, "su: fork failure: %m"));
+			perror("su: fork failure");
+			pam_setcred(pamh, PAM_DELETE_CRED);
+			pam_close_session(pamh, 0);
+			pam_end(pamh, PAM_ABORT);
+			exit(1);
+		case 0: /* child */
+			signal(SIGINT, SIG_DFL);
+			break;
+		default: /* parent */
+			waitpid(pid, &status, 0);
+			/* now we are done using PAM */
+			pam_setcred(pamh, PAM_DELETE_CRED);
+			ret = pam_close_session(pamh, 0);
+			pam_end(pamh, ret);
+			exit(WEXITSTATUS(status));
+		}
+	}
 
 	/* become the new user */
 	if (change_uid(&pwent)) {
+		pam_close_session(pamh, 0);
 		pam_setcred(pamh, PAM_DELETE_CRED);
 		pam_end(pamh, PAM_ABORT);
 		exit(1);
 	}
 
-	/* now we are done using PAM */
-	pam_end(pamh, PAM_SUCCESS);
-
 #else  /* !USE_PAM */
 	if (!amroot)  /* no limits if su from root */
 		setup_limits(&pwent);
@@ -574,11 +744,13 @@
 		exit(1);
 #endif  /* !USE_PAM */
 
-	if (fakelogin)
+	if (fakelogin && (change_environment || restricted_shell(pwent.pw_shell)))
 		setup_env(&pwent);
 #if 1  /* Suggested by Joey Hess.  XXX - is this right?  */
-	else
+	else if (change_environment || restricted_shell(pwent.pw_shell)) {
 		addenv("HOME", pwent.pw_dir);
+		addenv("SHELL", shell);
+	}
 #endif
 
 	/*
@@ -590,48 +762,7 @@
 	 */
 	closelog();
 
-	/*
-	 * See if the user has extra arguments on the command line.  In
-	 * that case they will be provided to the new user's shell as
-	 * arguments.
-	 */
-
-	if (fakelogin) {
-		char *arg0;
-
-#if 0  /* XXX - GNU su doesn't do this.  --marekm */
-		if (! hushed (&pwent)) {
-			motd ();
-			mailcheck ();
-		}
-#endif
-		cp = getdef_str("SU_NAME");
-		if (!cp)
-			cp = Basename(pwent.pw_shell);
-
-		arg0 = xmalloc(strlen(cp) + 2);
-		arg0[0] = '-';
-		strcpy(arg0 + 1, cp);
-		cp = arg0;
-	} else
-		cp = Basename(pwent.pw_shell);
-
-	if (! doshell) {
-
-		/*
-		 * Use new user's shell from /etc/passwd and create an
-		 * argv with the rest of the command line included.
-		 */
-
-		argv[-1] = pwent.pw_shell;
-		(void) execv (pwent.pw_shell, &argv[-1]);
-		(void) fprintf (stderr, _("No shell\n"));
-		SYSLOG((LOG_WARN, "Cannot execute %s\n", pwent.pw_shell));
-		closelog();
-		exit (1);
-	}
-
-	shell(pwent.pw_shell, cp);
+	run_shell (shell, command, additional_args, fakelogin);
 	/*NOTREACHED*/
 	exit(1);
 }
