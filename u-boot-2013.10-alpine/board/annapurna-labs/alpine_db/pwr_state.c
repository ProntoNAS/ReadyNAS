
#include <errno.h>
#include <common.h>
#include <libfdt_env.h>
#include <fdt_support.h>
#include <libfdt.h>
#include <fdtdec.h>
#include <linux/compiler.h>
#include <asm/io.h>
#include <asm/global_data.h>
#include <spi.h>
#include <scsi.h>
#include <asm/arch/timer.h>
#include <malloc.h>
#include <spi_flash.h>
#include <i2c.h>
#include <miiphy.h>

#include <al_globals.h>
#include <al_board.h>
#include <shared_params.h>
#include <al_eth.h>
#include <al_hal_pbs_regs.h>
#include <al_hal_nb_regs.h>
#include <al_hal_cmos_regs.h>
#include <al_hal_unit_adapter_regs.h>
#include <al_hal_ddr.h>
#include <iodma.h>

#include "dev_info_layout.h"
#include "early_init_layout.h"
#include "generated/version_autogenerated.h"
#include "lcd.h"
#include "board_cfg.h"
#include "eeprom_per_device.h"

#include "bcd.h"

extern int set_power_switch(int status);

enum {
    PWR_ST_DOWN = 0,
    PWR_ST_UP   = 1,
};

extern int power_button_pressed;
extern int ac_adapter_plug_in;

struct isl12057_time
{
    unsigned char sc;
    unsigned char mn;
    unsigned char hr;
    unsigned char dt;
};
#define RTC_I2C_ADDR    0x68

static int rtc_alarm_get (int index, struct isl12057_time *time, int *indicate)
{
    unsigned int sc_a, mn_a, hr_a, dt_a;
    unsigned char status;

    sc_a = mn_a = hr_a = dt_a = 0;
    
    if (index == 1) {
        sc_a = 0x07;
        mn_a = 0x08;
        hr_a = 0x09;
        dt_a = 0x0a;
    } else if (index == 2) {
        mn_a = 0x0b;
        hr_a = 0x0c;
        dt_a = 0x0d;
    } else {
        return -1;
    }

    memset (time, 0, sizeof(*time));

    if (sc_a)
    i2c_read (RTC_I2C_ADDR, sc_a, 1, &time->sc, sizeof(time->sc));
    i2c_read (RTC_I2C_ADDR, mn_a, 1, &time->mn, sizeof(time->mn));
    i2c_read (RTC_I2C_ADDR, hr_a, 1, &time->hr, sizeof(time->hr));
    i2c_read (RTC_I2C_ADDR, dt_a, 1, &time->dt, sizeof(time->dt));

    time->sc = bcd2bin (time->sc);
    time->mn = bcd2bin (time->mn);
    time->hr = bcd2bin (time->hr);
    time->dt = bcd2bin (time->dt);

    *indicate = 0;
    status = 0;
    i2c_read (RTC_I2C_ADDR, 0x0f, 1, &status, sizeof(status));
    if ((status & 0x01) && (index == 1)) *indicate = 1;
    if ((status & 0x02) && (index == 2)) *indicate = 1;

    return 0;
}

static int rtc_alarm_set (int index, struct isl12057_time *time, int indicate)
{
    unsigned int sc_a, mn_a, hr_a, dt_a;
    unsigned char status;
    unsigned char control;

    sc_a = mn_a = hr_a = dt_a = 0;
    
    if (index == 1) {
        sc_a = 0x07;
        mn_a = 0x08;
        hr_a = 0x09;
        dt_a = 0x0a;
    } else if (index == 2) {
        mn_a = 0x0b;
        hr_a = 0x0c;
        dt_a = 0x0d;
    } else {
        return -1;
    }

    time->sc = bin2bcd (time->sc);
    time->mn = bin2bcd (time->mn);
    time->hr = bin2bcd (time->hr);
    time->dt = bin2bcd (time->dt);

    if (sc_a) 
    i2c_write (RTC_I2C_ADDR, sc_a, 1, &time->sc, sizeof(time->sc));
    i2c_write (RTC_I2C_ADDR, mn_a, 1, &time->mn, sizeof(time->mn));
    i2c_write (RTC_I2C_ADDR, hr_a, 1, &time->hr, sizeof(time->hr));
    i2c_write (RTC_I2C_ADDR, dt_a, 1, &time->dt, sizeof(time->dt));

    control = 0;
    i2c_read (RTC_I2C_ADDR, 0x0e, 1, &control, sizeof(control));
    control &= 0x03;
    if (indicate)
        control |= (1 << (index -1));
    else
        control &= ~(1 << (index -1));

    i2c_read (RTC_I2C_ADDR, 0x0f, 1, &status, sizeof(status));
    status &= ~(1 << (index -1));
    i2c_write (RTC_I2C_ADDR, 0x0f, 1, &status, sizeof(status));

    /* enable / disable */
    i2c_write (RTC_I2C_ADDR, 0x0e, 1, &control, sizeof(control));

    return 0;
}

static void rtc_alarm_clr (int index)
{
    unsigned char status;
    i2c_read (RTC_I2C_ADDR, 0x0f, 1, &status, sizeof(status));
    status &= ~(1 << (index -1));
    i2c_write (RTC_I2C_ADDR, 0x0f, 1, &status, sizeof(status));

}

#define AT803X_INTR_ENABLE                      0x12
#define AT803X_INTR_STATUS                      0x13
#define AT803X_WOL_ENABLE                       0x01
#define AT803X_DEVICE_ADDR                      0x03
#define AT803X_LOC_MAC_ADDR_0_15_OFFSET         0x804C
#define AT803X_LOC_MAC_ADDR_16_31_OFFSET        0x804B
#define AT803X_LOC_MAC_ADDR_32_47_OFFSET        0x804A
#define AT803X_MMD_ACCESS_CONTROL               0x0D
#define AT803X_MMD_ACCESS_CONTROL_DATA          0x0E
#define AT803X_FUNC_DATA                        0x4003

struct eth_phy
{
    char *bus;
    char  idx;
    unsigned char phy;
};
static struct eth_phy eth_phy_list[] = {
    [0] = {"al_eth1", 1, 4},
    [1] = {"al_eth3", 3, 5},
};

static void wol_wakeup_clear (void)
{
    /* the register is clear on read */
}

static void wol_set_statue (int index, unsigned char status)
{

    const u8 *mac;
    uchar env_enetaddr[6];
    int ret;
    unsigned short value;
    unsigned int i, offsets[] = {
            AT803X_LOC_MAC_ADDR_32_47_OFFSET,
            AT803X_LOC_MAC_ADDR_16_31_OFFSET,
            AT803X_LOC_MAC_ADDR_0_15_OFFSET,
    };

    

    if (status) {
        
        if (!eth_getenv_enetaddr_by_index("eth", eth_phy_list[index].idx, env_enetaddr)) return ;
        
            mac = env_enetaddr;

            if (!is_valid_ether_addr(mac))
                    return;
    
            for (i = 0; i < 3; i++) {
                    miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_MMD_ACCESS_CONTROL,
                              AT803X_DEVICE_ADDR);
                    miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_MMD_ACCESS_CONTROL_DATA,
                              offsets[i]);
                    miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_MMD_ACCESS_CONTROL,
                              AT803X_FUNC_DATA);
                    miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_MMD_ACCESS_CONTROL_DATA,
                              mac[(i * 2) + 1] | (mac[(i * 2)] << 8));
            }
    
            miiphy_read (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_ENABLE, &value);
            value |= AT803X_WOL_ENABLE;
            ret = miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_ENABLE, value);
            if (ret)
                    return ;
            miiphy_read (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_STATUS, &value);
    } else {
            miiphy_read (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_ENABLE, &value);
            value &= (~AT803X_WOL_ENABLE);
            ret = miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_ENABLE, value);
            if (ret)
                    return ;
            miiphy_read (eth_phy_list[index].bus, eth_phy_list[index].phy, AT803X_INTR_STATUS, &value);
    }

}

static void wol_set_isolate (int index, unsigned char status)
{
    unsigned short value = 0;
    miiphy_read (eth_phy_list[index].bus, eth_phy_list[index].phy, 0, &value);
    if (status)
        value |= 0x0400;
    else
        value &= (~0x0400);
    miiphy_write (eth_phy_list[index].bus, eth_phy_list[index].phy, 0, value);
}

static void wol_init (int sys_pwr, unsigned char wol_status)
{
    /* phy hardware state reset */
    gpio_direction_output(45, 0);
    mdelay (300);

    if (sys_pwr || wol_status)
    {
        gpio_direction_output(45, 0);
        mdelay (300);
        gpio_direction_output(46, 1);
        mdelay (300);
        gpio_direction_output(46, 0);
        mdelay (300);

        if (!sys_pwr) {
            printf (".\n");
            wol_set_isolate (0, 1);
            wol_set_isolate (1, 1);
        }
        wol_set_statue (0, wol_status);
        wol_set_statue (1, wol_status);
    } else {
    	gpio_direction_output(45, 1);
    }
}

static void rtc_wakeup_clear (void)
{
    rtc_alarm_clr (1);
}

/*this function use to wait for power button and wol*/
int power_up_seq (void)
{
    struct isl12057_time alarm_zero;
    struct isl12057_time alarm2;
    int indicate = 0;
    unsigned char ac_failure = 0;

    memset (&alarm2, 0, sizeof(alarm2));
    memset (&alarm_zero, 0, sizeof(alarm_zero));

    rtc_alarm_get (2, &alarm2, &indicate);

    printf ("mn=%02x, hr=%02x, dt=%02x\n", alarm2.mn, alarm2.hr, alarm2.dt);

    if (ac_adapter_plug_in)
    {
        if ((alarm2.mn & 0x0f) == PWR_ST_UP)
        {
            printf ("!!!!AC-failure!!!!\n");
            ac_failure = 1;

            goto go_on;
        }
        else
        {
            goto shutdown;
        }
    }

go_on:

    /* MAY BE POWER ON BY Button/RTC/WOL */
    wol_init (1, alarm2.dt);

    printf ("Power On!\n");
    alarm2.mn = PWR_ST_UP;

    if (ac_failure) {
        alarm2.mn |= 0x10;
    }
    //printf ("mn=%02x, hr=%02x, dt=%02x\n", alarm2.mn, alarm2.hr, alarm2.dt);
    rtc_alarm_set (2, &alarm2, 0);
    wol_wakeup_clear ();
    rtc_wakeup_clear ();
    
    return 0;
    
shutdown:
    wol_init (0, alarm2.dt);
	rtc_wakeup_clear ();
    
    printf ("shutdown\n");
    
    for (;;)set_power_switch (0);
    return 0;
}

int power_shutdown (void)
{
    struct isl12057_time alarm2;
    int dump;
    unsigned char wol_status;
    

    memset (&alarm2, 0, sizeof(alarm2));
    rtc_alarm_get (2, &alarm2, &dump);
    wol_status = alarm2.dt;

    //printf ("mn=%02x, hr=%02x, dt=%02x\n", alarm2.mn, alarm2.hr, alarm2.dt);

    alarm2.mn = PWR_ST_DOWN;
    rtc_alarm_set (2, &alarm2, 0);

    wol_init (0, wol_status);

    for (;;) set_power_switch (0);
}

int power_reset (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
    puts("reset...\n");
    
    do_reset(NULL, 0, 0, NULL);

    return 0;
}


