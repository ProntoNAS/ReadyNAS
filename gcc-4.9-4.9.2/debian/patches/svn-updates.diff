# DP: updates from the 4.9 branch upto 20141220 (r218987).

last_update()
{
	cat > ${dir}LAST_UPDATED <EOF
Sat Dec 20 07:41:06 CET 2014
Sat Dec 20 06:41:06 UTC 2014 (revision 218987)
EOF
}

LANG=C svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_9_2_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: libitm/configure.tgt
===================================================================
--- a/src/libitm/configure.tgt	(.../tags/gcc_4_9_2_release)
+++ b/src/libitm/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -102,7 +102,7 @@
   x86_64)
 	case " ${CC} ${CFLAGS} " in
 	  *" -m32 "*)
-	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=i686"
+	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=generic"
 	    XCFLAGS="${XCFLAGS} -fomit-frame-pointer"
 	    ;;
 	esac
Index: libitm/ChangeLog
===================================================================
--- a/src/libitm/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libitm/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-12-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* configure.tgt (x86_64): Tune -m32 multilib to generic.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: Makefile.in
===================================================================
--- a/src/Makefile.in	(.../tags/gcc_4_9_2_release)
+++ b/src/Makefile.in	(.../branches/gcc-4_9-branch)
@@ -46988,6 +46988,38 @@
 configure-stage4-gcc: maybe-all-stage4-gmp
 configure-stageprofile-gcc: maybe-all-stageprofile-gmp
 configure-stagefeedback-gcc: maybe-all-stagefeedback-gmp
+configure-gcc: maybe-all-mpfr
+
+configure-stage1-gcc: maybe-all-stage1-mpfr
+configure-stage2-gcc: maybe-all-stage2-mpfr
+configure-stage3-gcc: maybe-all-stage3-mpfr
+configure-stage4-gcc: maybe-all-stage4-mpfr
+configure-stageprofile-gcc: maybe-all-stageprofile-mpfr
+configure-stagefeedback-gcc: maybe-all-stagefeedback-mpfr
+configure-gcc: maybe-all-mpc
+
+configure-stage1-gcc: maybe-all-stage1-mpc
+configure-stage2-gcc: maybe-all-stage2-mpc
+configure-stage3-gcc: maybe-all-stage3-mpc
+configure-stage4-gcc: maybe-all-stage4-mpc
+configure-stageprofile-gcc: maybe-all-stageprofile-mpc
+configure-stagefeedback-gcc: maybe-all-stagefeedback-mpc
+configure-gcc: maybe-all-isl
+
+configure-stage1-gcc: maybe-all-stage1-isl
+configure-stage2-gcc: maybe-all-stage2-isl
+configure-stage3-gcc: maybe-all-stage3-isl
+configure-stage4-gcc: maybe-all-stage4-isl
+configure-stageprofile-gcc: maybe-all-stageprofile-isl
+configure-stagefeedback-gcc: maybe-all-stagefeedback-isl
+configure-gcc: maybe-all-cloog
+
+configure-stage1-gcc: maybe-all-stage1-cloog
+configure-stage2-gcc: maybe-all-stage2-cloog
+configure-stage3-gcc: maybe-all-stage3-cloog
+configure-stage4-gcc: maybe-all-stage4-cloog
+configure-stageprofile-gcc: maybe-all-stageprofile-cloog
+configure-stagefeedback-gcc: maybe-all-stagefeedback-cloog
 configure-gcc: maybe-all-lto-plugin
 
 configure-stage1-gcc: maybe-all-stage1-lto-plugin
Index: libgomp/configure.tgt
===================================================================
--- a/src/libgomp/configure.tgt	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/configure.tgt	(.../branches/gcc-4_9-branch)
@@ -82,7 +82,7 @@
 	config_path="linux/x86 linux posix"
 	case " ${CC} ${CFLAGS} " in
 	  *" -m32 "*)
-	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=i686"
+	    XCFLAGS="${XCFLAGS} -march=i486 -mtune=generic"
 	    ;;
 	esac
 	;;
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,16 @@
+2014-12-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* configure.tgt (x86_64-*-linux*): Tune -m32 multilib to generic.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/63938
+	* libgomp.fortran/pr63938-1.f90: New test.
+	* libgomp.fortran/pr63938-2.f90: New test.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libgomp/testsuite/libgomp.fortran/pr63938-1.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr63938-1.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr63938-1.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,14 @@
+! PR fortran/63938
+! { dg-do run }
+
+program pr63938_1
+  integer :: i, x(1)
+  x(1) = 0
+!$omp parallel do
+  do i = 1, 1000
+    !$omp atomic
+    x(1) = x(1) + 1
+  end do
+!$omp end parallel do
+  if (x(1) .ne. 1000) call abort
+end program pr63938_1
Index: libgomp/testsuite/libgomp.fortran/pr63938-2.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr63938-2.f90	(.../tags/gcc_4_9_2_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr63938-2.f90	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+! PR fortran/63938
+! { dg-do run }
+
+program pr63938_2
+  type t
+    integer :: x
+  end type
+  integer :: i
+  type(t) :: x
+  x%x = 0
+!$omp parallel do
+  do i = 1, 1000
+    !$omp atomic
+    x%x = x%x + 1
+  end do
+!$omp end parallel do
+  if (x%x .ne. 1000) call abort
+end program pr63938_2
Index: libstdc++-v3/configure.host
===================================================================
--- a/src/libstdc++-v3/configure.host	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/configure.host	(.../branches/gcc-4_9-branch)
@@ -219,7 +219,6 @@
     os_include_dir="os/aix"
     atomicity_dir="os/aix"
     atomic_word_dir="os/aix"
-    OPT_LDFLAGS="-Wl,-G"
     ;;
   aix4.*)
     os_include_dir="os/generic"
Index: libstdc++-v3/include/std/shared_mutex
===================================================================
--- a/src/libstdc++-v3/include/std/shared_mutex	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/shared_mutex	(.../branches/gcc-4_9-branch)
@@ -36,10 +36,8 @@
 #else
 
 #include <bits/c++config.h>
-#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
-# include <mutex>
-# include <condition_variable>
-#endif
+#include <mutex>
+#include <condition_variable>
 #include <bits/functexcept.h>
 
 namespace std _GLIBCXX_VISIBILITY(default)
@@ -51,7 +49,8 @@
    * @{
    */
 
-#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
+#ifdef _GLIBCXX_USE_C99_STDINT_TR1
+#ifdef _GLIBCXX_HAS_GTHREADS
 
 #define __cpp_lib_shared_timed_mutex 201402
 
@@ -254,7 +253,7 @@
 	}
     }
   };
-#endif // _GLIBCXX_HAS_GTHREADS && _GLIBCXX_USE_C99_STDINT_TR1
+#endif // _GLIBCXX_HAS_GTHREADS
 
   /// shared_lock
   template<typename _Mutex>
@@ -393,6 +392,8 @@
     swap(shared_lock<_Mutex>& __x, shared_lock<_Mutex>& __y) noexcept
     { __x.swap(__y); }
 
+#endif // _GLIBCXX_USE_C99_STDINT_TR1
+
   // @} group mutexes
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/include/std/tuple
===================================================================
--- a/src/libstdc++-v3/include/std/tuple	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/tuple	(.../branches/gcc-4_9-branch)
@@ -88,21 +88,22 @@
       constexpr _Head_base(const _Head& __h)
       : _Head(__h) { }
 
-      template<typename _UHead, typename = typename
-	       enable_if<!is_convertible<_UHead,
-	                                 __uses_alloc_base>::value>::type>
+      constexpr _Head_base(const _Head_base&) = default;
+      constexpr _Head_base(_Head_base&&) = default;
+
+      template<typename _UHead>
         constexpr _Head_base(_UHead&& __h)
 	: _Head(std::forward<_UHead>(__h)) { }
 
-      _Head_base(__uses_alloc0)
+      _Head_base(allocator_arg_t, __uses_alloc0)
       : _Head() { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc1<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _Head(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc2<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _Head(*__a._M_a) { }
 
       template<typename _UHead>
@@ -133,21 +134,22 @@
       constexpr _Head_base(const _Head& __h)
       : _M_head_impl(__h) { }
 
-      template<typename _UHead, typename = typename
-	       enable_if<!is_convertible<_UHead,
-	                                 __uses_alloc_base>::value>::type>
+      constexpr _Head_base(const _Head_base&) = default;
+      constexpr _Head_base(_Head_base&&) = default;
+
+      template<typename _UHead>
         constexpr _Head_base(_UHead&& __h)
 	: _M_head_impl(std::forward<_UHead>(__h)) { }
 
-      _Head_base(__uses_alloc0)
+      _Head_base(allocator_arg_t, __uses_alloc0)
       : _M_head_impl() { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc1<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 	: _M_head_impl(allocator_arg, *__a._M_a) { }
 
       template<typename _Alloc>
-	_Head_base(__uses_alloc2<_Alloc> __a)
+	_Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 	: _M_head_impl(*__a._M_a) { }
 
       template<typename _UHead>
@@ -285,7 +287,7 @@
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 	: _Inherited(__tag, __a),
-          _Base(__use_alloc<_Head>(__a)) { }
+          _Base(__tag, __use_alloc<_Head>(__a)) { }
 
       template<typename _Alloc>
 	_Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
Index: libstdc++-v3/include/std/functional
===================================================================
--- a/src/libstdc++-v3/include/std/functional	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/std/functional	(.../branches/gcc-4_9-branch)
@@ -2407,9 +2407,9 @@
     {
       if (static_cast<bool>(__x))
 	{
+	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	  _M_invoker = __x._M_invoker;
 	  _M_manager = __x._M_manager;
-	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	}
     }
 
Index: libstdc++-v3/include/parallel/numeric
===================================================================
--- a/src/libstdc++-v3/include/parallel/numeric	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/parallel/numeric	(.../branches/gcc-4_9-branch)
@@ -85,8 +85,7 @@
     __accumulate_switch(__RAIter __begin, __RAIter __end, 
                       _Tp __init, _BinaryOperation __binary_op, 
                       random_access_iterator_tag, 
-                      __gnu_parallel::_Parallelism __parallelism_tag  
-                      = __gnu_parallel::parallel_unbalanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -193,8 +192,7 @@
 			   _BinaryFunction2 __binary_op2,
 			   random_access_iterator_tag,
 			   random_access_iterator_tag,
-			   __gnu_parallel::_Parallelism __parallelism_tag
-			   = __gnu_parallel::parallel_unbalanced)
+			   __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION((__last1 - __first1)
                                       >= __gnu_parallel::_Settings::get().
@@ -419,8 +417,7 @@
 				 random_access_iterator_tag,
 				 random_access_iterator_tag,
 				 __gnu_parallel::_Parallelism
-				 __parallelism_tag
-				 = __gnu_parallel::parallel_balanced)
+				 __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
Index: libstdc++-v3/include/parallel/algo.h
===================================================================
--- a/src/libstdc++-v3/include/parallel/algo.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/parallel/algo.h	(.../branches/gcc-4_9-branch)
@@ -81,9 +81,8 @@
   template<typename _RAIter, typename _Function>
     _Function
     __for_each_switch(_RAIter __begin, _RAIter __end, 
-                    _Function __f, random_access_iterator_tag, 
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_balanced)
+                    _Function __f, random_access_iterator_tag,
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -896,8 +895,7 @@
     typename iterator_traits<_RAIter>::difference_type
     __count_switch(_RAIter __begin, _RAIter __end, 
                  const _Tp& __value, random_access_iterator_tag, 
-                 __gnu_parallel::_Parallelism __parallelism_tag 
-                 = __gnu_parallel::parallel_unbalanced)
+                 __gnu_parallel::_Parallelism __parallelism_tag)
     {
       typedef iterator_traits<_RAIter> _TraitsType;
       typedef typename _TraitsType::value_type _ValueType;
@@ -966,8 +964,7 @@
     typename iterator_traits<_RAIter>::difference_type
     __count_if_switch(_RAIter __begin, _RAIter __end, 
                     _Predicate __pred, random_access_iterator_tag,
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_unbalanced)
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       typedef iterator_traits<_RAIter> _TraitsType;
       typedef typename _TraitsType::value_type _ValueType;
@@ -1225,8 +1222,7 @@
     __transform1_switch(_RAIter1 __begin, _RAIter1 __end,
                       _RAIter2 __result, _UnaryOperation __unary_op,
                       random_access_iterator_tag, random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1315,8 +1311,7 @@
                       _RAIter3 __result, _BinaryOperation __binary_op,
                       random_access_iterator_tag, random_access_iterator_tag,
                       random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag 
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             (__end1 - __begin1) >=
@@ -1422,8 +1417,7 @@
     __replace_switch(_RAIter __begin, _RAIter __end, 
                    const _Tp& __old_value, const _Tp& __new_value, 
                    random_access_iterator_tag, 
-                   __gnu_parallel::_Parallelism __parallelism_tag
-                   = __gnu_parallel::parallel_balanced)
+                   __gnu_parallel::_Parallelism __parallelism_tag)
     {
       // XXX parallel version is where?
       replace(__begin, __end, __old_value, __new_value, 
@@ -1478,8 +1472,7 @@
     __replace_if_switch(_RAIter __begin, _RAIter __end,
                       _Predicate __pred, const _Tp& __new_value,
                       random_access_iterator_tag,
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1544,8 +1537,7 @@
     void
     __generate_switch(_RAIter __begin, _RAIter __end,
                     _Generator __gen, random_access_iterator_tag, 
-                    __gnu_parallel::_Parallelism __parallelism_tag
-                    = __gnu_parallel::parallel_balanced)
+                    __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -1608,8 +1600,7 @@
     inline _RAIter
     __generate_n_switch(_RAIter __begin, _Size __n, _Generator __gen, 
                       random_access_iterator_tag, 
-                      __gnu_parallel::_Parallelism __parallelism_tag
-                      = __gnu_parallel::parallel_balanced)
+                      __gnu_parallel::_Parallelism __parallelism_tag)
     {
       // XXX parallel version is where?
       return generate_n(__begin, __n, __gen, __gnu_parallel::sequential_tag());
@@ -2204,8 +2195,7 @@
     _RAIter
     __max_element_switch(_RAIter __begin, _RAIter __end, 
                        _Compare __comp, random_access_iterator_tag, 
-                       __gnu_parallel::_Parallelism __parallelism_tag
-                       = __gnu_parallel::parallel_balanced)
+			 __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
@@ -2296,8 +2286,7 @@
     _RAIter
     __min_element_switch(_RAIter __begin, _RAIter __end, 
                        _Compare __comp, random_access_iterator_tag, 
-                       __gnu_parallel::_Parallelism __parallelism_tag
-                       = __gnu_parallel::parallel_balanced)
+                       __gnu_parallel::_Parallelism __parallelism_tag)
     {
       if (_GLIBCXX_PARALLEL_CONDITION(
             static_cast<__gnu_parallel::_SequenceIndex>(__end - __begin)
Index: libstdc++-v3/include/bits/regex_executor.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex_executor.tcc	(.../branches/gcc-4_9-branch)
@@ -267,9 +267,11 @@
 	    _M_dfs<__match_mode>(__state._M_next);
 	  break;
 	case _S_opcode_match:
+	  if (_M_current == _M_end)
+	    break;
 	  if (__dfs_mode)
 	    {
-	      if (_M_current != _M_end && __state._M_matches(*_M_current))
+	      if (__state._M_matches(*_M_current))
 		{
 		  ++_M_current;
 		  _M_dfs<__match_mode>(__state._M_next);
@@ -350,23 +352,24 @@
     bool _Executor<_BiIter, _Alloc, _TraitsT, __dfs_mode>::
     _M_word_boundary(_State<_TraitsT> __state) const
     {
-      // By definition.
-      bool __ans = false;
-      auto __pre = _M_current;
-      --__pre;
-      if (!(_M_at_begin() && _M_at_end()))
+      bool __left_is_word = false;
+      if (_M_current != _M_begin
+	  || (_M_flags & regex_constants::match_prev_avail))
 	{
-	  if (_M_at_begin())
-	    __ans = _M_is_word(*_M_current)
-	      && !(_M_flags & regex_constants::match_not_bow);
-	  else if (_M_at_end())
-	    __ans = _M_is_word(*__pre)
-	      && !(_M_flags & regex_constants::match_not_eow);
-	  else
-	    __ans = _M_is_word(*_M_current)
-	      != _M_is_word(*__pre);
+	  auto __prev = _M_current;
+	  if (_M_is_word(*std::prev(__prev)))
+	    __left_is_word = true;
 	}
-      return __ans;
+      bool __right_is_word =
+	_M_current != _M_end && _M_is_word(*_M_current);
+
+      if (__left_is_word == __right_is_word)
+	return false;
+      if (__left_is_word && !(_M_flags & regex_constants::match_not_eow))
+	return true;
+      if (__right_is_word && !(_M_flags & regex_constants::match_not_bow))
+	return true;
+      return false;
     }
 
 _GLIBCXX_END_NAMESPACE_VERSION
Index: libstdc++-v3/include/bits/regex.tcc
===================================================================
--- a/src/libstdc++-v3/include/bits/regex.tcc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex.tcc	(.../branches/gcc-4_9-branch)
@@ -62,6 +62,7 @@
 	return false;
 
       typename match_results<_BiIter, _Alloc>::_Base_type& __res = __m;
+      __m._M_begin = __s;
       __res.resize(__re._M_automaton->_M_sub_count() + 2);
       for (auto& __it : __res)
 	__it.matched = false;
@@ -581,8 +582,10 @@
 				   | regex_constants::match_continuous))
 		    {
 		      _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);
-		      _M_match.at(_M_match.size()).first = __prefix_first;
-		      _M_match._M_in_iterator = true;
+		      auto& __prefix = _M_match.at(_M_match.size());
+		      __prefix.first = __prefix_first;
+		      __prefix.matched = __prefix.first != __prefix.second;
+		      // [28.12.1.4.5]
 		      _M_match._M_begin = _M_begin;
 		      return *this;
 		    }
@@ -594,8 +597,10 @@
 	  if (regex_search(__start, _M_end, _M_match, *_M_pregex, _M_flags))
 	    {
 	      _GLIBCXX_DEBUG_ASSERT(_M_match[0].matched);
-	      _M_match.at(_M_match.size()).first = __prefix_first;
-	      _M_match._M_in_iterator = true;
+	      auto& __prefix = _M_match.at(_M_match.size());
+	      __prefix.first = __prefix_first;
+	      __prefix.matched = __prefix.first != __prefix.second;
+	      // [28.12.1.4.5]
 	      _M_match._M_begin = _M_begin;
 	    }
 	  else
@@ -614,11 +619,9 @@
       _M_position = __rhs._M_position;
       _M_subs = __rhs._M_subs;
       _M_n = __rhs._M_n;
-      _M_result = __rhs._M_result;
       _M_suffix = __rhs._M_suffix;
       _M_has_m1 = __rhs._M_has_m1;
-      if (__rhs._M_result == &__rhs._M_suffix)
-	_M_result = &_M_suffix;
+      _M_normalize_result();
       return *this;
     }
 
Index: libstdc++-v3/include/bits/regex.h
===================================================================
--- a/src/libstdc++-v3/include/bits/regex.h	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/bits/regex.h	(.../branches/gcc-4_9-branch)
@@ -1568,42 +1568,30 @@
        */
       explicit
       match_results(const _Alloc& __a = _Alloc())
-      : _Base_type(__a), _M_in_iterator(false)
+      : _Base_type(__a)
       { }
 
       /**
        * @brief Copy constructs a %match_results.
        */
-      match_results(const match_results& __rhs)
-      : _Base_type(__rhs), _M_in_iterator(false)
-      { }
+      match_results(const match_results& __rhs) = default;
 
       /**
        * @brief Move constructs a %match_results.
        */
-      match_results(match_results&& __rhs) noexcept
-      : _Base_type(std::move(__rhs)), _M_in_iterator(false)
-      { }
+      match_results(match_results&& __rhs) noexcept = default;
 
       /**
        * @brief Assigns rhs to *this.
        */
       match_results&
-      operator=(const match_results& __rhs)
-      {
-	match_results(__rhs).swap(*this);
-	return *this;
-      }
+      operator=(const match_results& __rhs) = default;
 
       /**
        * @brief Move-assigns rhs to *this.
        */
       match_results&
-      operator=(match_results&& __rhs)
-      {
-	match_results(std::move(__rhs)).swap(*this);
-	return *this;
-      }
+      operator=(match_results&& __rhs) = default;
 
       /**
        * @brief Destroys a %match_results object.
@@ -1690,13 +1678,8 @@
       difference_type
       position(size_type __sub = 0) const
       {
-	// [28.12.1.4.5]
-	if (_M_in_iterator)
-	  return __sub < size() ? std::distance(_M_begin,
-						(*this)[__sub].first) : -1;
-	else
-	  return __sub < size() ? std::distance(this->prefix().first,
-						(*this)[__sub].first) : -1;
+	return __sub < size() ? std::distance(_M_begin,
+					      (*this)[__sub].first) : -1;
       }
 
       /**
@@ -1778,7 +1761,7 @@
        */
       const_iterator
       cbegin() const
-      { return _Base_type::cbegin() + 2; }
+      { return this->begin(); }
 
       /**
        * @brief Gets an iterator to one-past-the-end of the collection.
@@ -1792,7 +1775,7 @@
        */
       const_iterator
       cend() const
-      { return _Base_type::cend(); }
+      { return this->end(); }
 
       //@}
 
@@ -1881,7 +1864,10 @@
        */
       void
       swap(match_results& __that)
-      { _Base_type::swap(__that); }
+      {
+	_Base_type::swap(__that);
+	swap(_M_begin, __that._M_begin);
+      }
       //@}
 
     private:
@@ -2620,7 +2606,7 @@
 			     regex_constants::match_flag_type __m
 			     = regex_constants::match_default)
       : _M_position(__a, __b, __re, __m),
-      _M_subs(__submatches, *(&__submatches+1)), _M_n(0)
+      _M_subs(__submatches, __submatches + _Nm), _M_n(0)
       { _M_init(__a, __b); }
 
       /**
@@ -2629,12 +2615,8 @@
        */
       regex_token_iterator(const regex_token_iterator& __rhs)
       : _M_position(__rhs._M_position), _M_subs(__rhs._M_subs),
-      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_result(__rhs._M_result),
-      _M_has_m1(__rhs._M_has_m1)
-      {
-	if (__rhs._M_result == &__rhs._M_suffix)
-	  _M_result = &_M_suffix;
-      }
+      _M_suffix(__rhs._M_suffix), _M_n(__rhs._M_n), _M_has_m1(__rhs._M_has_m1)
+      { _M_normalize_result(); }
 
       /**
        * @brief Assigns a %regex_token_iterator to another.
@@ -2706,6 +2688,18 @@
       _M_end_of_seq() const
       { return _M_result == nullptr; }
 
+      // [28.12.2.2.4]
+      void
+      _M_normalize_result()
+      {
+	if (_M_position != _Position())
+	  _M_result = &_M_current_match();
+	else if (_M_has_m1)
+	  _M_result = &_M_suffix;
+	else
+	  _M_result = nullptr;
+      }
+
       _Position         _M_position;
       std::vector<int>  _M_subs;
       value_type        _M_suffix;
Index: libstdc++-v3/include/tr1/functional
===================================================================
--- a/src/libstdc++-v3/include/tr1/functional	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/include/tr1/functional	(.../branches/gcc-4_9-branch)
@@ -2112,9 +2112,9 @@
     {
       if (static_cast<bool>(__x))
 	{
+	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	  _M_invoker = __x._M_invoker;
 	  _M_manager = __x._M_manager;
-	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 	}
     }
 
@@ -2130,9 +2130,9 @@
 
 	if (_My_handler::_M_not_empty_function(__f))
 	  {
+	    _My_handler::_M_init_functor(_M_functor, __f);
 	    _M_invoker = &_My_handler::_M_invoke;
 	    _M_manager = &_My_handler::_M_manager;
-	    _My_handler::_M_init_functor(_M_functor, __f);
 	  }
       }
 
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,101 @@
+2014-12-17  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64302
+	PR libstdc++/64303
+	Backported form mainline
+	2014-12-17  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.h (match_results::cbegin, match_results::cend,
+	regex_token_iterator::regex_token_iterator,
+	regex_token_iterator::_M_normalize_result): Fix match_results cbegin
+	and cend and regex_token_iterator::_M_result invariant.
+	* include/bits/regex.tcc: Fix regex_token_iterator::_M_result invariant.
+	* testsuite/28_regex/iterators/regex_token_iterator/64303.cc: Testcase.
+
+2014-12-13  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64239
+	* include/bits/regex.h (match_results<>::match_results,
+	match_results<>::operator=, match_results<>::position,
+	match_results<>::swap): Fix ctor/assign/swap.
+	* include/bits/regex.tcc: (__regex_algo_impl<>,
+	regex_iterator<>::operator++): Set match_results::_M_begin as
+	"start position".
+	* testsuite/28_regex/iterators/regex_iterator/char/
+	string_position_01.cc: Test cases.
+
+2014-12-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/64203
+	* include/std/shared_mutex: Fix preprocessor conditions.
+	* testsuite/experimental/feat-cxx14.cc: Check conditions.
+
+2014-12-06  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/63840
+	* include/std/functional (function::function(const function&)): Set
+	_M_manager after operations that might throw.
+	* include/tr1/functional (function::function(const function&),
+	function::function(_Functor, _Useless)): Likewise.
+	* testsuite/20_util/function/63840.cc: New.
+	* testsuite/tr1/3_function_objects/function/63840.cc: New.
+
+	PR libstdc++/61947
+	* include/std/tuple (_Head_base): Use allocator_arg_t parameters to
+	disambiguate unary constructors.
+	(_Tuple_impl): Pass allocator_arg_t arguments.
+	* testsuite/20_util/tuple/61947.cc: New.
+	* testsuite/20_util/uses_allocator/cons_neg.cc: Adjust dg-error line.
+
+2014-12-06  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/64140
+	Backport form mainline
+	2014-12-04  Tim Shen  <timshen@google.com>
+
+	* include/bits/regex.tcc (regex_iterator<>::operator++): Update
+	prefix.matched after modifying prefix.first.
+	* testsuite/28_regex/iterators/regex_iterator/char/64140.cc: New
+	testcase.
+
+2014-12-02  Matthias Klose  <doko@ubuntu.com>
+
+	PR libstdc++/64103
+	Backport from mainline
+	2014-11-03  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	* include/parallel/algo.h: Do not use default arguments in function
+	template redeclarations (definitions).
+
+	2014-11-04  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/parallel/numeric.h: Do not use default arguments in function
+	template redeclarations (definitions).
+
+2014-11-28  Tim Shen  <timshen@google.com>
+
+	PR libstdc++/63497
+	* include/bits/regex_executor.tcc (_Executor::_M_dfs,
+	_Executor::_M_word_boundary): Avoid dereferecing _M_current at _M_end
+	or other invalid position.
+
+2014-11-13  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2014-09-10  Tony Wang  <tony.wang@arm.com>
+
+	PR target/56846
+	* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION):
+	Return with CONTINUE_UNWINDING when the state pattern
+	contains: _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
+
+2014-10-30  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backported from mainline.
+	2014-10-30  David Edelsohn  <dje.gcc@gmail.com>
+
+	* configure.host (aix4.3+, 5+): Do not use -G in link command.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libstdc++-v3/libsupc++/eh_personality.cc
===================================================================
--- a/src/libstdc++-v3/libsupc++/eh_personality.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/libsupc++/eh_personality.cc	(.../branches/gcc-4_9-branch)
@@ -378,6 +378,12 @@
   switch (state & _US_ACTION_MASK)
     {
     case _US_VIRTUAL_UNWIND_FRAME:
+      // If the unwind state pattern is
+      // _US_VIRTUAL_UNWIND_FRAME | _US_FORCE_UNWIND
+      // then we don't need to search for any handler as it is not a real
+      // exception. Just unwind the stack.
+      if (state & _US_FORCE_UNWIND)
+	CONTINUE_UNWINDING;
       actions = _UA_SEARCH_PHASE;
       break;
 
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/64140.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,53 @@
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// libstdc++/64140
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  const std::regex e("z*");
+  const std::string s("ab");
+
+  auto it = std::sregex_iterator(s.begin(), s.end(), e);
+  auto end = std::sregex_iterator();
+  VERIFY(it != end);
+  VERIFY(!it->prefix().matched);
+  ++it;
+  VERIFY(it != end);
+  VERIFY(it->prefix().matched);
+  ++it;
+  VERIFY(it != end);
+  VERIFY(it->prefix().matched);
+  ++it;
+  VERIFY(it == end);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_iterator/char/string_position_01.cc	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,7 @@
 // Tests iter->position() behavior
 
 #include <regex>
+#include <tuple>
 #include <testsuite_hooks.h>
 
 void
@@ -41,9 +42,53 @@
   }
 }
 
+// PR libstdc++/64239
+void
+test02()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::regex re("\\w+");
+  std::string s("-a-b-c-");
+
+  std::tuple<int, int, const char*> expected[] =
+  {
+    std::make_tuple(1, 1, "a"),
+    std::make_tuple(3, 1, "b"),
+    std::make_tuple(5, 1, "c"),
+  };
+
+  int i = 0;
+  for (auto it1 = std::sregex_iterator(s.begin(), s.end(), re),
+       end = std::sregex_iterator(); it1 != end; ++it1, i++)
+    {
+      auto it2 = it1;
+      VERIFY(it1->position() == std::get<0>(expected[i]));
+      VERIFY(it1->length() == std::get<1>(expected[i]));
+      VERIFY(it1->str() == std::get<2>(expected[i]));
+      VERIFY(it2->position() == std::get<0>(expected[i]));
+      VERIFY(it2->length() == std::get<1>(expected[i]));
+      VERIFY(it2->str() == std::get<2>(expected[i]));
+    }
+}
+
+void
+test03()
+{
+  bool test __attribute__((unused)) = true;
+
+  std::smatch m;
+  std::string s = "abcde";
+  std::regex_search(s, m, std::regex("bcd"));
+  VERIFY(m.position() == 1);
+  VERIFY(m.position() == m.prefix().length());
+}
+
 int
 main()
 {
   test01();
+  test02();
+  test03();
   return 0;
 }
Index: libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/28_regex/iterators/regex_token_iterator/64303.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,49 @@
+// { dg-do run }
+// { dg-options "-std=gnu++11" }
+
+//
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// 28.12.2 Class template regex_token_iterator
+
+#include <regex>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  bool test __attribute__((unused)) = true;
+
+  const std::string s("  111  222  ");
+  const std::regex re("\\w+");
+
+  std::sregex_token_iterator it1(s.begin(), s.end(), re), it2(it1), end;
+
+  for (; it1 != end; ++it1, ++it2) {
+    VERIFY(it1 == it2);
+    VERIFY(*it1 == *it2);
+  }
+  VERIFY(it2 == end);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/experimental/feat-cxx14.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/experimental/feat-cxx14.cc	(.../branches/gcc-4_9-branch)
@@ -106,10 +106,12 @@
 #  error "<shared_mutex>"
 #endif
 
-#ifndef  __cpp_lib_shared_timed_mutex
-#  error "__cpp_lib_shared_timed_mutex"
-#elif  __cpp_lib_shared_timed_mutex != 201402
-#  error "__cpp_lib_shared_timed_mutex != 201402"
+#if defined(_GLIBCXX_HAS_GTHREADS) && defined(_GLIBCXX_USE_C99_STDINT_TR1)
+#  ifndef  __cpp_lib_shared_timed_mutex
+#    error "__cpp_lib_shared_timed_mutex"
+#  elif  __cpp_lib_shared_timed_mutex != 201402
+#    error "__cpp_lib_shared_timed_mutex != 201402"
+#  endif
 #endif
 
 #ifndef  __cpp_lib_is_final
Index: libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/tr1/3_function_objects/function/63840.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tr1/functional>
+#include <stdexcept>
+#include <testsuite_hooks.h>
+
+struct functor
+{
+  functor() : copies(0) { }
+
+  functor(const functor& f)
+  : copies(f.copies + 1)
+  {
+    if (copies > 1)
+      throw std::runtime_error("functor");
+  }
+
+  void operator()() const { }
+
+  int copies;
+};
+
+
+void
+test01()
+{
+  std::tr1::function<void()> f = functor();
+  try {
+    std::tr1::function<void()> g = f;
+  } catch (const std::runtime_error& e) {
+    return;
+  }
+  VERIFY(false);
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/20_util/tuple/61947.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/tuple/61947.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/tuple/61947.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+// { dg-options "-std=gnu++11" }
+// { dg-do compile }
+
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <tuple>
+
+struct ConvertibleToAny {
+  template <class T> operator T() const { return T(); }
+};
+
+int main() {
+  std::tuple<ConvertibleToAny&&> t(ConvertibleToAny{});
+}
Index: libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/uses_allocator/cons_neg.cc	(.../branches/gcc-4_9-branch)
@@ -44,4 +44,4 @@
 
   tuple<Type> t(allocator_arg, a, 1);
 }
-// { dg-error "no matching function" "" { target *-*-* } 118 }
+// { dg-error "no matching function" "" { target *-*-* } 119 }
Index: libstdc++-v3/testsuite/20_util/function/63840.cc
===================================================================
--- a/src/libstdc++-v3/testsuite/20_util/function/63840.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/libstdc++-v3/testsuite/20_util/function/63840.cc	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,55 @@
+// Copyright (C) 2014 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++11" }
+
+#include <functional>
+#include <stdexcept>
+#include <testsuite_hooks.h>
+
+struct functor
+{
+  functor() = default;
+
+  functor(const functor&)
+  {
+    throw std::runtime_error("test");
+  }
+
+  functor(functor&& f) = default;
+
+  void operator()() const { }
+};
+
+
+void
+test01()
+{
+  std::function<void()> f = functor{};
+  try {
+    auto g = f;
+  } catch (const std::runtime_error& e) {
+    return;
+  }
+  VERIFY(false);
+}
+
+int
+main()
+{
+  test01();
+}
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/configure.ac	(.../branches/gcc-4_9-branch)
@@ -1658,6 +1658,9 @@
     ISL_CHECK_VERSION(0,11)
     if test "${gcc_cv_isl}" = no ; then
       ISL_CHECK_VERSION(0,12)
+      if test "${gcc_cv_isl}" = no ; then
+        ISL_CHECK_VERSION(0,14)
+      fi
     fi
   fi
   dnl Only execute fail-action, if ISL has been requested.
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,10 @@
+2014-12-04  Tobias Burnus  <burnus@net-b.de>
+
+	* configure.ac: Permit also ISL 0.14 with CLooG.
+	* Makefile.def: Make more dependent on mpfr, mpc, isl, and cloog.
+	* Makefile.in: Regenerate.
+	* configure: Regenerate.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/configure	(.../branches/gcc-4_9-branch)
@@ -6024,6 +6024,55 @@
   fi
 
 
+      if test "${gcc_cv_isl}" = no ; then
+
+  if test "${ENABLE_ISL_CHECK}" = yes ; then
+    _isl_saved_CFLAGS=$CFLAGS
+    _isl_saved_LDFLAGS=$LDFLAGS
+    _isl_saved_LIBS=$LIBS
+
+    CFLAGS="${_isl_saved_CFLAGS} ${islinc} ${gmpinc}"
+    LDFLAGS="${_isl_saved_LDFLAGS} ${isllibs}"
+    LIBS="${_isl_saved_LIBS} -lisl"
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for version 0.14 of ISL" >&5
+$as_echo_n "checking for version 0.14 of ISL... " >&6; }
+    if test "$cross_compiling" = yes; then :
+  gcc_cv_isl=yes
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/version.h>
+   #include <string.h>
+int
+main ()
+{
+if (strncmp (isl_version (), "isl-0.14", strlen ("isl-0.14")) != 0)
+     return 1;
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  gcc_cv_isl=yes
+else
+  gcc_cv_isl=no
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $gcc_cv_isl" >&5
+$as_echo "$gcc_cv_isl" >&6; }
+
+    CFLAGS=$_isl_saved_CFLAGS
+    LDFLAGS=$_isl_saved_LDFLAGS
+    LIBS=$_isl_saved_LIBS
+  fi
+
+
+      fi
     fi
   fi
 
Index: libgcc/ChangeLog
===================================================================
--- a/src/libgcc/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,35 @@
+2014-12-09  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-24  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (ABORT_INSTRUCTION): Use __builtin_trap()
+	instead.
+
+	2014-11-21  Guy Martin  <gmsoft@tuxicoman.be>
+	            John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/linux-atomic.c (__kernel_cmpxchg2): New.
+	(FETCH_AND_OP_2): New.  Use for subword and double word operations.
+	(OP_AND_FETCH_2): Likewise.
+	(COMPARE_AND_SWAP_2): Likewise.
+	(SYNC_LOCK_TEST_AND_SET_2): Likewise.
+	(SYNC_LOCK_RELEASE_2): Likewise.
+	(SUBWORD_SYNC_OP): Remove.
+	(SUBWORD_VAL_CAS): Likewise.
+	(SUBWORD_BOOL_CAS): Likewise.
+	(FETCH_AND_OP_WORD): Update.
+	Consistently use signed types.
+
+2014-12-09  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-30  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/55351
+	* config/sh/lib1funcs.S: Check value of __SHMEDIA__ instead of checking
+	whether it's defined.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libgcc/config/sh/lib1funcs.S
===================================================================
--- a/src/libgcc/config/sh/lib1funcs.S	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/sh/lib1funcs.S	(.../branches/gcc-4_9-branch)
@@ -1278,7 +1278,7 @@
 #endif
 	ENDFUNC(GLOBAL(sdivsi3_2))
 #endif
-#elif defined __SHMEDIA__
+#elif __SHMEDIA__
 /* m5compact-nofpu */
  // clobbered: r18,r19,r20,r21,r25,tr0,tr1,tr2
 	.mode	SHmedia
@@ -1683,7 +1683,7 @@
  add.l r18,r25,r0
  blink tr0,r63
 #endif
-#elif defined (__SHMEDIA__)
+#elif __SHMEDIA__
 /* m5compact-nofpu - more emphasis on code size than on speed, but don't
    ignore speed altogether - div1 needs 9 cycles, subc 7 and rotcl 4.
    So use a short shmedia loop.  */
@@ -1707,7 +1707,7 @@
  bnei r25,-32,tr1
  add.l r20,r63,r0
  blink tr2,r63
-#else /* ! defined (__SHMEDIA__) */
+#else /* ! __SHMEDIA__ */
 LOCAL(div8):
  div1 r5,r4
 LOCAL(div7):
@@ -1773,7 +1773,7 @@
 #endif /* L_udivsi3 */
 
 #ifdef L_udivdi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -1901,7 +1901,7 @@
 #endif /* L_udivdi3 */
 
 #ifdef L_divdi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -1925,7 +1925,7 @@
 #endif /* L_divdi3 */
 
 #ifdef L_umoddi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -2054,7 +2054,7 @@
 #endif /* L_umoddi3 */
 
 #ifdef L_moddi3
-#ifdef __SHMEDIA__
+#if __SHMEDIA__
 	.mode	SHmedia
 	.section	.text..SHmedia32,"ax"
 	.align	2
@@ -3142,7 +3142,7 @@
 
 #ifdef L_div_table
 #if __SH5__
-#if defined(__pic__) && defined(__SHMEDIA__)
+#if defined(__pic__) && __SHMEDIA__
 	.global	GLOBAL(sdivsi3)
 	FUNC(GLOBAL(sdivsi3))
 #if __SH5__ == 32
@@ -3215,7 +3215,7 @@
 #else /* ! __pic__ || ! __SHMEDIA__ */
 	.section	.rodata
 #endif /* __pic__ */
-#if defined(TEXT_DATA_BUG) && defined(__pic__) && defined(__SHMEDIA__)
+#if defined(TEXT_DATA_BUG) && defined(__pic__) && __SHMEDIA__
 	.balign 2
 	.type	Local_div_table,@object
 	.size	Local_div_table,128
Index: libgcc/config/pa/linux-atomic.c
===================================================================
--- a/src/libgcc/config/pa/linux-atomic.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libgcc/config/pa/linux-atomic.c	(.../branches/gcc-4_9-branch)
@@ -41,11 +41,8 @@
    using the kernel helper defined below.  There is no support for
    64-bit operations yet.  */
 
-/* A privileged instruction to crash a userspace program with SIGILL.  */
-#define ABORT_INSTRUCTION asm ("iitlbp %r0,(%sr0, %r0)")
-
 /* Determine kernel LWS function call (0=32-bit, 1=64-bit userspace).  */
-#define LWS_CAS (sizeof(unsigned long) == 4 ? 0 : 1)
+#define LWS_CAS (sizeof(long) == 4 ? 0 : 1)
 
 /* Kernel helper for compare-and-exchange a 32-bit value.  */
 static inline long
@@ -64,7 +61,7 @@
 	: "r1", "r20", "r22", "r23", "r29", "r31", "memory"
   );
   if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
-    ABORT_INSTRUCTION;
+    __builtin_trap ();
 
   /* If the kernel LWS call succeeded (lws_errno == 0), lws_ret contains
      the old value from memory.  If this value is equal to OLDVAL, the
@@ -75,6 +72,30 @@
   return lws_errno;
 }
 
+static inline long
+__kernel_cmpxchg2 (void * oldval, void * newval, void *mem, int val_size)
+{
+  register unsigned long lws_mem asm("r26") = (unsigned long) (mem);
+  register long lws_ret   asm("r28");
+  register long lws_errno asm("r21");
+  register unsigned long lws_old asm("r25") = (unsigned long) oldval;
+  register unsigned long lws_new asm("r24") = (unsigned long) newval;
+  register int lws_size asm("r23") = val_size;
+  asm volatile (	"ble	0xb0(%%sr2, %%r0)	\n\t"
+			"ldi	%2, %%r20		\n\t"
+	: "=r" (lws_ret), "=r" (lws_errno)
+	: "i" (2), "r" (lws_mem), "r" (lws_old), "r" (lws_new), "r" (lws_size)
+	: "r1", "r20", "r22", "r29", "r31", "fr4", "memory"
+  );
+  if (__builtin_expect (lws_errno == -EFAULT || lws_errno == -ENOSYS, 0))
+    __builtin_trap ();
+
+  /* If the kernel LWS call fails, retrun EBUSY */
+  if (!lws_errno && lws_ret)
+    lws_errno = -EBUSY;
+
+  return lws_errno;
+}
 #define HIDDEN __attribute__ ((visibility ("hidden")))
 
 /* Big endian masks  */
@@ -84,69 +105,101 @@
 #define MASK_1 0xffu
 #define MASK_2 0xffffu
 
-#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
-  int HIDDEN								\
-  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+#define FETCH_AND_OP_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
+  TYPE HIDDEN								\
+  __sync_fetch_and_##OP##_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
-    int failure, tmp;							\
+    TYPE tmp, newval;							\
+    int failure;							\
 									\
     do {								\
       tmp = *ptr;							\
-      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
+      newval = PFX_OP (tmp INF_OP val);					\
+      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
     } while (failure != 0);						\
 									\
     return tmp;								\
   }
 
-FETCH_AND_OP_WORD (add,   , +)
-FETCH_AND_OP_WORD (sub,   , -)
-FETCH_AND_OP_WORD (or,    , |)
-FETCH_AND_OP_WORD (and,   , &)
-FETCH_AND_OP_WORD (xor,   , ^)
-FETCH_AND_OP_WORD (nand, ~, &)
+FETCH_AND_OP_2 (add,   , +, long long, 8, 3)
+FETCH_AND_OP_2 (sub,   , -, long long, 8, 3)
+FETCH_AND_OP_2 (or,    , |, long long, 8, 3)
+FETCH_AND_OP_2 (and,   , &, long long, 8, 3)
+FETCH_AND_OP_2 (xor,   , ^, long long, 8, 3)
+FETCH_AND_OP_2 (nand, ~, &, long long, 8, 3)
 
-#define NAME_oldval(OP, WIDTH) __sync_fetch_and_##OP##_##WIDTH
-#define NAME_newval(OP, WIDTH) __sync_##OP##_and_fetch_##WIDTH
+FETCH_AND_OP_2 (add,   , +, short, 2, 1)
+FETCH_AND_OP_2 (sub,   , -, short, 2, 1)
+FETCH_AND_OP_2 (or,    , |, short, 2, 1)
+FETCH_AND_OP_2 (and,   , &, short, 2, 1)
+FETCH_AND_OP_2 (xor,   , ^, short, 2, 1)
+FETCH_AND_OP_2 (nand, ~, &, short, 2, 1)
 
-/* Implement both __sync_<op>_and_fetch and __sync_fetch_and_<op> for
-   subword-sized quantities.  */
+FETCH_AND_OP_2 (add,   , +, signed char, 1, 0)
+FETCH_AND_OP_2 (sub,   , -, signed char, 1, 0)
+FETCH_AND_OP_2 (or,    , |, signed char, 1, 0)
+FETCH_AND_OP_2 (and,   , &, signed char, 1, 0)
+FETCH_AND_OP_2 (xor,   , ^, signed char, 1, 0)
+FETCH_AND_OP_2 (nand, ~, &, signed char, 1, 0)
 
-#define SUBWORD_SYNC_OP(OP, PFX_OP, INF_OP, TYPE, WIDTH, RETURN)	\
+#define OP_AND_FETCH_2(OP, PFX_OP, INF_OP, TYPE, WIDTH, INDEX)		\
   TYPE HIDDEN								\
-  NAME##_##RETURN (OP, WIDTH) (TYPE *ptr, TYPE val)			\
+  __sync_##OP##_and_fetch_##WIDTH (TYPE *ptr, TYPE val)			\
   {									\
-    int *wordptr = (int *) ((unsigned long) ptr & ~3);			\
-    unsigned int mask, shift, oldval, newval;				\
+    TYPE tmp, newval;							\
     int failure;							\
 									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
+    do {								\
+      tmp = *ptr;							\
+      newval = PFX_OP (tmp INF_OP val);					\
+      failure = __kernel_cmpxchg2 (&tmp, &newval, ptr, INDEX);		\
+    } while (failure != 0);						\
 									\
+    return PFX_OP (tmp INF_OP val);					\
+  }
+
+OP_AND_FETCH_2 (add,   , +, long long, 8, 3)
+OP_AND_FETCH_2 (sub,   , -, long long, 8, 3)
+OP_AND_FETCH_2 (or,    , |, long long, 8, 3)
+OP_AND_FETCH_2 (and,   , &, long long, 8, 3)
+OP_AND_FETCH_2 (xor,   , ^, long long, 8, 3)
+OP_AND_FETCH_2 (nand, ~, &, long long, 8, 3)
+
+OP_AND_FETCH_2 (add,   , +, short, 2, 1)
+OP_AND_FETCH_2 (sub,   , -, short, 2, 1)
+OP_AND_FETCH_2 (or,    , |, short, 2, 1)
+OP_AND_FETCH_2 (and,   , &, short, 2, 1)
+OP_AND_FETCH_2 (xor,   , ^, short, 2, 1)
+OP_AND_FETCH_2 (nand, ~, &, short, 2, 1)
+
+OP_AND_FETCH_2 (add,   , +, signed char, 1, 0)
+OP_AND_FETCH_2 (sub,   , -, signed char, 1, 0)
+OP_AND_FETCH_2 (or,    , |, signed char, 1, 0)
+OP_AND_FETCH_2 (and,   , &, signed char, 1, 0)
+OP_AND_FETCH_2 (xor,   , ^, signed char, 1, 0)
+OP_AND_FETCH_2 (nand, ~, &, signed char, 1, 0)
+
+#define FETCH_AND_OP_WORD(OP, PFX_OP, INF_OP)				\
+  int HIDDEN								\
+  __sync_fetch_and_##OP##_4 (int *ptr, int val)				\
+  {									\
+    int failure, tmp;							\
+									\
     do {								\
-      oldval = *wordptr;						\
-      newval = ((PFX_OP (((oldval & mask) >> shift)			\
-                         INF_OP (unsigned int) val)) << shift) & mask;	\
-      newval |= oldval & ~mask;						\
-      failure = __kernel_cmpxchg (oldval, newval, wordptr);		\
+      tmp = *ptr;							\
+      failure = __kernel_cmpxchg (tmp, PFX_OP (tmp INF_OP val), ptr);	\
     } while (failure != 0);						\
 									\
-    return (RETURN & mask) >> shift;					\
+    return tmp;								\
   }
 
-SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, oldval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, oldval)
+FETCH_AND_OP_WORD (add,   , +)
+FETCH_AND_OP_WORD (sub,   , -)
+FETCH_AND_OP_WORD (or,    , |)
+FETCH_AND_OP_WORD (and,   , &)
+FETCH_AND_OP_WORD (xor,   , ^)
+FETCH_AND_OP_WORD (nand, ~, &)
 
-SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, oldval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, oldval)
-
 #define OP_AND_FETCH_WORD(OP, PFX_OP, INF_OP)				\
   int HIDDEN								\
   __sync_##OP##_and_fetch_4 (int *ptr, int val)				\
@@ -168,20 +221,42 @@
 OP_AND_FETCH_WORD (xor,   , ^)
 OP_AND_FETCH_WORD (nand, ~, &)
 
-SUBWORD_SYNC_OP (add,   , +, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (or,    , |, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (and,   , &, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned short, 2, newval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned short, 2, newval)
+typedef unsigned char bool;
 
-SUBWORD_SYNC_OP (add,   , +, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (sub,   , -, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (or,    , |, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (and,   , &, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (xor,   , ^, unsigned char, 1, newval)
-SUBWORD_SYNC_OP (nand, ~, &, unsigned char, 1, newval)
+#define COMPARE_AND_SWAP_2(TYPE, WIDTH, INDEX)				\
+  TYPE HIDDEN								\
+  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+				       TYPE newval)			\
+  {									\
+    TYPE actual_oldval;							\
+    int fail;								\
+									\
+    while (1)								\
+      {									\
+	actual_oldval = *ptr;						\
+									\
+	if (__builtin_expect (oldval != actual_oldval, 0))		\
+	  return actual_oldval;						\
+									\
+	fail = __kernel_cmpxchg2 (&actual_oldval, &newval, ptr, INDEX);	\
+									\
+	if (__builtin_expect (!fail, 1))				\
+	  return actual_oldval;						\
+    }									\
+  }									\
+									\
+  bool HIDDEN								\
+  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
+					TYPE newval)			\
+  {									\
+    int failure = __kernel_cmpxchg2 (&oldval, &newval, ptr, INDEX);	\
+    return (failure != 0);						\
+  }
 
+COMPARE_AND_SWAP_2 (long long, 8, 3)
+COMPARE_AND_SWAP_2 (short, 2, 1)
+COMPARE_AND_SWAP_2 (char, 1, 0)
+
 int HIDDEN
 __sync_val_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
@@ -201,41 +276,6 @@
     }
 }
 
-#define SUBWORD_VAL_CAS(TYPE, WIDTH)					\
-  TYPE HIDDEN								\
-  __sync_val_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-				       TYPE newval)			\
-  {									\
-    int *wordptr = (int *)((unsigned long) ptr & ~3), fail;		\
-    unsigned int mask, shift, actual_oldval, actual_newval;		\
-									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
-									\
-    while (1)								\
-      {									\
-	actual_oldval = *wordptr;					\
-									\
-	if (__builtin_expect (((actual_oldval & mask) >> shift)		\
-			      != (unsigned int) oldval, 0))		\
-	  return (actual_oldval & mask) >> shift;			\
-									\
-	actual_newval = (actual_oldval & ~mask)				\
-			| (((unsigned int) newval << shift) & mask);	\
-									\
-	fail = __kernel_cmpxchg (actual_oldval, actual_newval,		\
-				 wordptr);				\
-									\
-	if (__builtin_expect (!fail, 1))				\
-	  return (actual_oldval & mask) >> shift;			\
-      }									\
-  }
-
-SUBWORD_VAL_CAS (unsigned short, 2)
-SUBWORD_VAL_CAS (unsigned char,  1)
-
-typedef unsigned char bool;
-
 bool HIDDEN
 __sync_bool_compare_and_swap_4 (int *ptr, int oldval, int newval)
 {
@@ -243,18 +283,24 @@
   return (failure == 0);
 }
 
-#define SUBWORD_BOOL_CAS(TYPE, WIDTH)					\
-  bool HIDDEN								\
-  __sync_bool_compare_and_swap_##WIDTH (TYPE *ptr, TYPE oldval,		\
-					TYPE newval)			\
+#define SYNC_LOCK_TEST_AND_SET_2(TYPE, WIDTH, INDEX)			\
+TYPE HIDDEN								\
+  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
   {									\
-    TYPE actual_oldval							\
-      = __sync_val_compare_and_swap_##WIDTH (ptr, oldval, newval);	\
-    return (oldval == actual_oldval);					\
+    TYPE oldval;							\
+    int failure;							\
+									\
+    do {								\
+      oldval = *ptr;							\
+      failure = __kernel_cmpxchg2 (&oldval, &val, ptr, INDEX);		\
+    } while (failure != 0);						\
+									\
+    return oldval;							\
   }
 
-SUBWORD_BOOL_CAS (unsigned short, 2)
-SUBWORD_BOOL_CAS (unsigned char,  1)
+SYNC_LOCK_TEST_AND_SET_2 (long long, 8, 3)
+SYNC_LOCK_TEST_AND_SET_2 (short, 2, 1)
+SYNC_LOCK_TEST_AND_SET_2 (signed char, 1, 0)
 
 int HIDDEN
 __sync_lock_test_and_set_4 (int *ptr, int val)
@@ -269,37 +315,29 @@
   return oldval;
 }
 
-#define SUBWORD_TEST_AND_SET(TYPE, WIDTH)				\
-  TYPE HIDDEN								\
-  __sync_lock_test_and_set_##WIDTH (TYPE *ptr, TYPE val)		\
-  {									\
-    int failure;							\
-    unsigned int oldval, newval, shift, mask;				\
-    int *wordptr = (int *) ((unsigned long) ptr & ~3);			\
-									\
-    shift = (((unsigned long) ptr & 3) << 3) ^ INVERT_MASK_##WIDTH;	\
-    mask = MASK_##WIDTH << shift;					\
-									\
-    do {								\
-      oldval = *wordptr;						\
-      newval = (oldval & ~mask)						\
-	       | (((unsigned int) val << shift) & mask);		\
-      failure = __kernel_cmpxchg (oldval, newval, wordptr);		\
-    } while (failure != 0);						\
-									\
-    return (oldval & mask) >> shift;					\
+#define SYNC_LOCK_RELEASE_2(TYPE, WIDTH, INDEX)			\
+  void HIDDEN							\
+  __sync_lock_release_##WIDTH (TYPE *ptr)			\
+  {								\
+    TYPE failure, oldval, zero = 0;				\
+								\
+    do {							\
+      oldval = *ptr;						\
+      failure = __kernel_cmpxchg2 (&oldval, &zero, ptr, INDEX);	\
+    } while (failure != 0);					\
   }
 
-SUBWORD_TEST_AND_SET (unsigned short, 2)
-SUBWORD_TEST_AND_SET (unsigned char,  1)
+SYNC_LOCK_RELEASE_2 (long long, 8, 3)
+SYNC_LOCK_RELEASE_2 (short, 2, 1)
+SYNC_LOCK_RELEASE_2 (signed char, 1, 0)
 
-#define SYNC_LOCK_RELEASE(TYPE, WIDTH)					\
-  void HIDDEN								\
-  __sync_lock_release_##WIDTH (TYPE *ptr)				\
-  {									\
-    *ptr = 0;								\
-  }
+void HIDDEN
+__sync_lock_release_4 (int *ptr)
+{
+  int failure, oldval;
 
-SYNC_LOCK_RELEASE (int,   4)
-SYNC_LOCK_RELEASE (short, 2)
-SYNC_LOCK_RELEASE (char,  1)
+  do {
+    oldval = *ptr;
+    failure = __kernel_cmpxchg (oldval, 0, ptr);
+  } while (failure != 0);
+}
Index: gcc/tree-vrp.c
===================================================================
--- a/src/gcc/tree-vrp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vrp.c	(.../branches/gcc-4_9-branch)
@@ -9377,8 +9377,10 @@
     }
   else
     {
-      tree r1 = int_const_binop (subcode, vr0.min, vr1.min);
-      tree r2 = int_const_binop (subcode, vr0.max, vr1.max);
+      tree r1 = int_const_binop (subcode, vr0.min,
+				 subcode == MINUS_EXPR ? vr1.max : vr1.min);
+      tree r2 = int_const_binop (subcode, vr0.max,
+				 subcode == MINUS_EXPR ? vr1.min : vr1.max);
       if (r1 == NULL_TREE || TREE_OVERFLOW (r1)
 	  || r2 == NULL_TREE || TREE_OVERFLOW (r2))
 	return false;
Index: gcc/tree-ssa-tail-merge.c
===================================================================
--- a/src/gcc/tree-ssa-tail-merge.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-tail-merge.c	(.../branches/gcc-4_9-branch)
@@ -314,7 +314,8 @@
 
   if (gimple_vdef (stmt) != NULL_TREE
       || gimple_has_side_effects (stmt)
-      || gimple_could_trap_p_1 (stmt, false, false))
+      || gimple_could_trap_p_1 (stmt, false, false)
+      || gimple_vuse (stmt) != NULL_TREE)
     return false;
 
   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);
@@ -1164,7 +1165,8 @@
 						 gimple_assign_rhs1 (s2)));
       else if (TREE_CODE (lhs1) == SSA_NAME
 	       && TREE_CODE (lhs2) == SSA_NAME)
-	return vn_valueize (lhs1) == vn_valueize (lhs2);
+	return operand_equal_p (gimple_assign_rhs1 (s1),
+				gimple_assign_rhs1 (s2), 0);
       return false;
 
     case GIMPLE_COND:
Index: gcc/c-family/c-ubsan.c
===================================================================
--- a/src/gcc/c-family/c-ubsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/c-family/c-ubsan.c	(.../branches/gcc-4_9-branch)
@@ -98,19 +98,19 @@
   tree op1_utype = unsigned_type_for (type1);
   HOST_WIDE_INT op0_prec = TYPE_PRECISION (type0);
   tree uprecm1 = build_int_cst (op1_utype, op0_prec - 1);
-  tree precm1 = build_int_cst (type1, op0_prec - 1);
 
   t = fold_convert_loc (loc, op1_utype, op1);
   t = fold_build2 (GT_EXPR, boolean_type_node, t, uprecm1);
 
   /* For signed x << y, in C99/C11, the following:
-     (unsigned) x >> (precm1 - y)
+     (unsigned) x >> (uprecm1 - y)
      if non-zero, is undefined.  */
   if (code == LSHIFT_EXPR
       && !TYPE_UNSIGNED (type0)
       && flag_isoc99)
     {
-      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);
+      tree x = fold_build2 (MINUS_EXPR, unsigned_type_node, uprecm1,
+			    fold_convert (op1_utype, op1));
       tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);
       tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);
       tt = fold_build2 (NE_EXPR, boolean_type_node, tt,
@@ -118,13 +118,14 @@
     }
 
   /* For signed x << y, in C++11/C++14, the following:
-     x < 0 || ((unsigned) x >> (precm1 - y))
+     x < 0 || ((unsigned) x >> (uprecm1 - y))
      if > 1, is undefined.  */
   if (code == LSHIFT_EXPR
       && !TYPE_UNSIGNED (TREE_TYPE (op0))
       && (cxx_dialect == cxx11 || cxx_dialect == cxx1y))
     {
-      tree x = fold_build2 (MINUS_EXPR, integer_type_node, precm1, op1);
+      tree x = fold_build2 (MINUS_EXPR, unsigned_type_node, uprecm1,
+			    fold_convert (op1_utype, op1));
       tt = fold_convert_loc (loc, unsigned_type_for (type0), op0);
       tt = fold_build2 (RSHIFT_EXPR, TREE_TYPE (tt), tt, x);
       tt = fold_build2 (GT_EXPR, boolean_type_node, tt,
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_9-branch)
@@ -1 +1 @@
-20141030
+20141220
Index: gcc/tree-ssa-strlen.c
===================================================================
--- a/src/gcc/tree-ssa-strlen.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-strlen.c	(.../branches/gcc-4_9-branch)
@@ -1856,7 +1856,7 @@
 	    break;
 	  }
     }
-  else if (is_gimple_assign (stmt))
+  else if (is_gimple_assign (stmt) && !gimple_clobber_p (stmt))
     {
       tree lhs = gimple_assign_lhs (stmt);
 
Index: gcc/tree.c
===================================================================
--- a/src/gcc/tree.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree.c	(.../branches/gcc-4_9-branch)
@@ -1120,7 +1120,7 @@
   const_tree const t = (const_tree) x;
 
   return (TREE_INT_CST_HIGH (t) ^ TREE_INT_CST_LOW (t)
-	  ^ htab_hash_pointer (TREE_TYPE (t)));
+	  ^ TYPE_UID (TREE_TYPE (t)));
 }
 
 /* Return nonzero if the value represented by *X (an INTEGER_CST tree node)
Index: gcc/reload.c
===================================================================
--- a/src/gcc/reload.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/reload.c	(.../branches/gcc-4_9-branch)
@@ -1622,6 +1622,7 @@
 					       end_hard_regno (rel_mode,
 							       regno),
 					       PATTERN (this_insn), inloc)
+	    && ! find_reg_fusage (this_insn, USE, XEXP (note, 0))
 	    /* If this is also an output reload, IN cannot be used as
 	       the reload register if it is set in this insn unless IN
 	       is also OUT.  */
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/configure	(.../branches/gcc-4_9-branch)
@@ -27851,8 +27851,48 @@
 
 $as_echo "#define HAVE_cloog 1" >>confdefs.h
 
+
+  # Check whether isl_schedule_constraints_compute_schedule is available;
+  # it's new in ISL-0.13.
+  saved_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $ISLINC"
+  saved_LIBS="$LIBS"
+  LIBS="$LIBS $CLOOGLIBS $ISLLIBS $GMPLIBS"
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking Checking for isl_schedule_constraints_compute_schedule" >&5
+$as_echo_n "checking Checking for isl_schedule_constraints_compute_schedule... " >&6; }
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <isl/schedule.h>
+int
+main ()
+{
+isl_schedule_constraints_compute_schedule (NULL);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_has_isl_schedule_constraints_compute_schedule=yes
+else
+  ac_has_isl_schedule_constraints_compute_schedule=no
 fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_has_isl_schedule_constraints_compute_schedule" >&5
+$as_echo "$ac_has_isl_schedule_constraints_compute_schedule" >&6; }
 
+  LIBS="$saved_LIBS"
+  CFLAGS="$saved_CFLAGS"
+
+  if test x"$ac_has_isl_schedule_constraints_compute_schedule" = x"yes"; then
+
+$as_echo "#define HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE 1" >>confdefs.h
+
+  fi
+fi
+
+
 # Check for plugin support
 # Check whether --enable-plugin was given.
 if test "${enable_plugin+set}" = set; then :
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-4_9-branch)
@@ -9024,7 +9024,8 @@
       /* If the constant operation overflowed this can be
 	 simplified as a comparison against INT_MAX/INT_MIN.  */
       if (TREE_CODE (lhs) == INTEGER_CST
-	  && TREE_OVERFLOW (lhs))
+	  && TREE_OVERFLOW (lhs)
+	  && !TYPE_OVERFLOW_WRAPS (TREE_TYPE (arg0)))
 	{
 	  int const1_sgn = tree_int_cst_sgn (const1);
 	  enum tree_code code2 = code;
@@ -13295,7 +13296,7 @@
 	  tree itype = TREE_TYPE (arg00);
 	  if (TREE_INT_CST_HIGH (arg01) == 0
 	      && TREE_INT_CST_LOW (arg01)
-		 == (unsigned HOST_WIDE_INT) (TYPE_PRECISION (itype) - 1))
+		 == (unsigned HOST_WIDE_INT) (element_precision (itype) - 1))
 	    {
 	      if (TYPE_UNSIGNED (itype))
 		{
Index: gcc/omp-low.c
===================================================================
--- a/src/gcc/omp-low.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/omp-low.c	(.../branches/gcc-4_9-branch)
@@ -11181,24 +11181,24 @@
   if (orig_rettype == void_type_node)
     return NULL_TREE;
   TREE_TYPE (fndecl) = build_distinct_type_copy (TREE_TYPE (fndecl));
-  if (INTEGRAL_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl)))
-      || POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (fndecl))))
+  t = TREE_TYPE (TREE_TYPE (fndecl));
+  if (INTEGRAL_TYPE_P (t) || POINTER_TYPE_P (t))
     veclen = node->simdclone->vecsize_int;
   else
     veclen = node->simdclone->vecsize_float;
-  veclen /= GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (fndecl))));
+  veclen /= GET_MODE_BITSIZE (TYPE_MODE (t));
   if (veclen > node->simdclone->simdlen)
     veclen = node->simdclone->simdlen;
+  if (POINTER_TYPE_P (t))
+    t = pointer_sized_int_node;
   if (veclen == node->simdclone->simdlen)
-    TREE_TYPE (TREE_TYPE (fndecl))
-      = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)),
-			   node->simdclone->simdlen);
+    t = build_vector_type (t, node->simdclone->simdlen);
   else
     {
-      t = build_vector_type (TREE_TYPE (TREE_TYPE (fndecl)), veclen);
+      t = build_vector_type (t, veclen);
       t = build_array_type_nelts (t, node->simdclone->simdlen / veclen);
-      TREE_TYPE (TREE_TYPE (fndecl)) = t;
     }
+  TREE_TYPE (TREE_TYPE (fndecl)) = t;
   if (!node->definition)
     return NULL_TREE;
 
@@ -11287,7 +11287,10 @@
 	  if (veclen > node->simdclone->simdlen)
 	    veclen = node->simdclone->simdlen;
 	  adj.arg_prefix = "simd";
-	  adj.type = build_vector_type (parm_type, veclen);
+	  if (POINTER_TYPE_P (parm_type))
+	    adj.type = build_vector_type (pointer_sized_int_node, veclen);
+	  else
+	    adj.type = build_vector_type (parm_type, veclen);
 	  node->simdclone->args[i].vector_type = adj.type;
 	  for (j = veclen; j < node->simdclone->simdlen; j += veclen)
 	    {
@@ -11328,7 +11331,10 @@
       veclen /= GET_MODE_BITSIZE (TYPE_MODE (base_type));
       if (veclen > node->simdclone->simdlen)
 	veclen = node->simdclone->simdlen;
-      adj.type = build_vector_type (base_type, veclen);
+      if (POINTER_TYPE_P (base_type))
+	adj.type = build_vector_type (pointer_sized_int_node, veclen);
+      else
+	adj.type = build_vector_type (base_type, veclen);
       adjustments.safe_push (adj);
 
       for (j = veclen; j < node->simdclone->simdlen; j += veclen)
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,605 @@
+2014-12-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline
+	2014-12-03  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR rtl-optimization/64010
+	* reload.c (push_reload): Before reusing a register contained
+	in an operand as input reload register, ensure that it is not
+	used in CALL_INSN_FUNCTION_USAGE.
+
+2014-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/64265
+	* tsan.c (instrument_func_entry): Insert __tsan_func_entry
+	call on edge from entry block to single succ instead
+	of after labels of single succ of entry block.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64200
+	* config/i386/i386.c (decide_alg): Don't assert "alg != libcall"
+	for TARGET_INLINE_STRINGOPS_DYNAMICALLY.
+
+2014-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64269
+	* tree-ssa-forwprop.c (simplify_builtin_call): Bail out if
+	len2 or diff are too large.
+
+2014-12-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/md.texi (Insn Lengths): Fix description of (pc).
+
+2014-12-11  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2014-12-11  Renlin Li  <renlin.li@arm.com>
+
+	* config/aarch64/aarch64.c (aarch64_parse_cpu): Don't define
+	selected_tune.
+	(aarch64_override_options): Use selected_cpu's tuning.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-builtin.def (XVCVSXDDP_SCALE):  New
+	built-in definition.
+	(XVCVUXDDP_SCALE): Likewise.
+	(XVCVDPSXDS_SCALE): Likewise.
+	(XVCVDPUXDS_SCALE): Likewise.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins):  Add
+	entries for VSX_BUILTIN_XVCVSXDDP_SCALE,
+	VSX_BUILTIN_XVCVUXDDP_SCALE, VSX_BUILTIN_XVCVDPSXDS_SCALE, and
+	VSX_BUILTIN_XVCVDPUXDS_SCALE.
+	* config/rs6000/rs6000-protos.h (rs6000_scale_v2df): New
+	prototype.
+	* config/rs6000/rs6000.c (real.h): New include.
+	(rs6000_scale_v2df): New function.
+	* config/rs6000/vsx.md (UNSPEC_VSX_XVCVSXDDP): New unspec.
+	(UNSPEC_VSX_XVCVUXDDP): Likewise.
+	(UNSPEC_VSX_XVCVDPSXDS): Likewise.
+	(UNSPEC_VSX_XVCVDPUXDS): Likewise.
+	(vsx_xvcvsxddp_scale): New define_expand.
+	(vsx_xvcvsxddp): New define_insn.
+	(vsx_xvcvuxddp_scale): New define_expand.
+	(vsx_xvcvuxddp): New define_insn.
+	(vsx_xvcvdpsxds_scale): New define_expand.
+	(vsx_xvcvdpsxds): New define_insn.
+	(vsx_xvcvdpuxds_scale): New define_expand.
+	(vsx_xvcvdpuxds): New define_insn.
+	* doc/extend.texi (vec_ctf): Add new prototypes.
+	(vec_cts): Likewise.
+	(vec_ctu): Likewise.
+	(vec_splat): Likewise.
+	(vec_div): Likewise.
+	(vec_mul): Likewise.
+
+	Backport from mainline
+        2014-08-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_xl): New #define.
+	(vec_xst): Likewise.
+	* config/rs6000/rs6000-builtin.def (XXSPLTD_V2DF): New built-in.
+	(XXSPLTD_V2DI): Likewise.
+	(DIV_V2DI): Likewise.
+	(UDIV_V2DI): Likewise.
+	(MUL_V2DI): Likewise.
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add
+	entries for VSX_BUILTIN_XVRDPI, VSX_BUILTIN_DIV_V2DI,
+	VSX_BUILTIN_UDIV_V2DI, VSX_BUILTIN_MUL_V2DI,
+	VSX_BUILTIN_XXSPLTD_V2DF, and VSX_BUILTIN_XXSPLTD_V2DI).
+	* config/rs6000/vsx.md (UNSPEC_VSX_XXSPLTD): New unspec.
+	(UNSPEC_VSX_DIVSD): Likewise.
+	(UNSPEC_VSX_DIVUD): Likewise.
+	(UNSPEC_VSX_MULSD): Likewise.
+	(vsx_mul_v2di): New insn-and-split.
+	(vsx_div_v2di): Likewise.
+	(vsx_udiv_v2di): Likewise.
+	(vsx_xxspltd_<mode>): New insn.
+
+	Backport from mainline
+        2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.h (vec_cpsgn): New #define.
+	(vec_mergee): Likewise.
+	(vec_mergeo): Likewise.
+	(vec_cntlz): Likewise.
+	* config/rs600/rs6000-c.c (altivec_overloaded_builtins): Add new
+	entries for VEC_AND, VEC_ANDC, VEC_MERGEH, VEC_MERGEL, VEC_NOR,
+	VEC_OR, VEC_PACKSU, VEC_XOR, VEC_PERM, VEC_SEL, VEC_VCMPGT_P,
+	VMRGEW, and VMRGOW.
+	* doc/extend.texi: Document various forms of vec_cpsgn,
+	vec_splats, vec_and, vec_andc, vec_mergeh, vec_mergel, vec_nor,
+	vec_or, vec_perm, vec_sel, vec_sub, vec_xor, vec_all_eq,
+	vec_all_ge, vec_all_gt, vec_all_le, vec_all_lt, vec_all_ne,
+	vec_any_eq, vec_any_ge, vec_any_gt, vec_any_le, vec_any_lt,
+	vec_any_ne, vec_mergee, vec_mergeo, vec_packsu, and vec_cntlz.
+
+	Backport from mainline
+        2014-07-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/altivec.md (unspec enum):  Fix typo in UNSPEC_VSLDOI.
+	(altivec_vsldoi_<mode>): Likewise.
+
+
+2014-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/62021
+	* omp-low.c (simd_clone_adjust_return_type): Use
+	vector of pointer_sized_int_node types instead vector of pointer
+	types.
+	(simd_clone_adjust_argument_types): Likewise.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline:
+	2014-12-09  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR middle-end/64225
+	* tree-ssa-reassoc.c (acceptable_pow_call): Disable transformation
+	for BUILT_IN_POW when flag_errno_math is present.
+
+2014-12-10  Marek Polacek  <polacek@redhat.com>
+
+	Backport from mainline
+	2014-12-10  Marek Polacek  <polacek@redhat.com>
+
+	PR tree-optimization/61686
+	* tree-ssa-reassoc.c (range_entry_cmp): Use q->high instead of
+	p->high.
+
+2014-12-09  David Edelsohn  <dje.gcc@gmail.com>
+
+	Backport from mainline
+	2014-12-05  David Edelsohn  <dje.gcc@gmail.com>
+
+	* config/rs6000/xcoff.h (ASM_OUTPUT_ALIGNED_LOCAL): Append
+	alignment to section name. Increase default alignment to
+	word.
+
+2014-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR bootstrap/64213
+	Revert:
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/64191
+	* tree-vect-stmts.c (vect_stmt_relevant_p): Clobbers are
+	not relevant (nor are their uses).
+
+2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/50751
+	* config/sh/sh.md (extendqihi2): Allow only for TARGET_SH1.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-12-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64108
+	* config/i386/i386.c (decide_alg): Stop only if there aren't
+	any usable algorithms.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* combine.c (setup_incoming_promotions): Pass the argument
+	before any promotions happen to promote_function_mode.
+
+2014-12-04  Tobias Burnus  <burnus@net-b.de>
+
+	* configure.ac
+	(ac_has_isl_schedule_constraints_compute_schedule):
+	New check.
+	* graphite-clast-to-gimple.c: For ISL 0.14, include deprecate headers.
+	* graphite-interchange.c: Ditto.
+	* graphite-poly.c: Ditto.
+	* graphite-sese-to-poly.c: Ditto.
+	* graphite-optimize-isl.c (getScheduleForBandList): Ditto.
+	Conditionally use ISL 0.13+ functions.
+	* config.in: Regenerate.
+	* configure: Regenerate.
+
+2014-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/56493
+	* convert.c (convert_to_real, convert_to_expr, convert_to_complex):
+	Handle COMPOUND_EXPR.
+
+2014-12-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/59708
+	* expmed.c (expand_widening_mult): Return const0_rtx if
+	coeff is 0.
+
+2014-12-03  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/64153
+	* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Check
+	type sizes before view_converting.
+
+2014-12-03  Shanyao Chen  <chenshanyao@huawei.com>
+
+	Backport from mainline
+	2014-11-20  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	PR target/59593
+	* config/arm/arm.md (*movhi_insn): Use right formatting
+	for immediate.
+
+	2014-11-19  Felix Yang  <felix.yang@huawei.com>
+		    Shanyao Chen  <chenshanyao@huawei.com>
+
+	PR target/59593
+	* config/arm/arm.md (define_attr "arch"): Add v6t2.
+	(define_attr "arch_enabled"): Add test for the above.
+	(*movhi_insn_arch4): Add new alternative.
+
+2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	Backported from mainline
+	2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	PR middle-end/63762
+	PR target/63661
+	* ira.c (ira): Update preferred class.
+
+2014-12-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/64113
+	* config/alpha/alpha.md (call_value_osf_tlsgd): Do not split insn
+	using post-reload splitter.  Use peephole2 pass instead.
+	(call_value_osf_tlsldm): Ditto.
+	(TLS_CALL): New int iterator.
+	(tls): New int attribute.
+	(call_value_osf_<tls>): Merge insn pattern from call_value_osf_tlsgd
+	and call_value_tlsldm using TLS_CALL int iterator.
+
+2014-12-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR target/64115
+	* config/rs6000/rs6000.c (rs6000_delegitimize_address): Remove
+	invalid UNSPEC_TOCREL sanity check under ENABLE_CHECKING.
+
+2014-12-01  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/64111
+	* tree.c (int_cst_hash_hash): Use TYPE_UID instead of
+	htab_hash_pointer to not break PCH.
+
+2014-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/63551
+	* ipa-inline-analysis.c (evaluate_conditions_for_known_args): Convert
+	value of the argument to the type of the value in the condition.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64067
+	* expr.c (expand_expr_addr_expr_1) <case COMPOUND_LITERAL_EXPR>:
+	Handle it by returning address of COMPOUND_LITERAL_EXPR_DECL
+	not only if modifier is EXPAND_INITIALIZER, but whenever
+	COMPOUND_LITERAL_EXPR_DECL is non-NULL and TREE_STATIC.
+
+	2014-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63915
+	* tree-vect-stmts.c (vectorizable_simd_clone_call): Pass
+	true instead of false as last argument to gsi_replace.
+
+	PR sanitizer/63913
+	* ubsan.c: Include tree-eh.h.
+	(instrument_bool_enum_load): Handle loads that can throw.
+
+	2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63659
+	* ree.c (update_reg_equal_equiv_notes): New function.
+	(combine_set_extension, transform_ifelse): Use it.
+
+2014-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+
+	Backport from mainline.
+        2014-11-28  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>
+        * config/arm/t-aprofile (MULTILIB_MATCHES): New entry for
+        -march=armv8-a+crc.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63738
+	* tree-data-ref.c (split_constant_offset_1): Do not follow
+	SSA edges for SSA names with SSA_NAME_OCCURS_IN_ABNORMAL_PHI.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62238
+	* tree-predcom.c (ref_at_iteration): Unshare the expression
+	before gimplifying it.
+
+	2014-11-25  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61927
+	* tree-vect-loop.c (vect_analyze_loop_2): Revert ordering
+	of group and pattern analysis to the one in GCC 4.8.
+
+	2014-11-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63605
+	* fold-const.c (fold_binary_loc): Properly use element_precision
+	for types that may not be scalar.
+
+	2014-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63665
+	* fold-const.c (fold_comparison): Properly guard simplifying
+	against INT_MAX/INT_MIN with !TYPE_OVERFLOW_WRAPS.
+
+2014-11-25  Rohit  <rohitarulraj@freescale.com>
+
+	PR bootstrap/63703
+	* config/rs6000/darwin.h (REGISTER_NAMES): Update based on 32 newly
+	added GCC hard register numbers for SPE high registers.
+
+2014-11-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-23  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/53976
+	* config/sh/sh_optimize_sett_clrt.cc
+	(sh_optimize_sett_clrt::find_last_ccreg_values): Return bool instead
+	of void.  Abort at complex edges.
+	(sh_optimize_sett_clrt::execute): Do nothing if find_last_ccreg_values
+	returned false.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/63783
+	PR target/51244
+	* config/sh/sh_treg_combine.cc (sh_treg_combine::make_not_reg_insn):
+	Do not emit bitwise not insn.  Emit logical not insn sequence instead.
+	Adjust related comments throughout the file.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-20  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/60111
+	* config/sh/sh.c: Use signed char for signed field.
+
+2014-11-21  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/63673
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Allow
+	the base pointer of vec_vsx_ld and vec_vsx_st to take a pointer to
+	double.
+
+2014-11-21  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/61750
+	* tree-ssa-forwprop.c (simplify_vce): Verify type sizes
+	match for the resulting VIEW_CONVERT_EXPR.
+
+2014-11-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63947
+	* config/i386/i386.c (put_condition_code) <case LTU, case GEU>:
+	Output "b" and "nb" suffix for FP mode.
+
+2014-11-19  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline
+	PR tree-optimization/62167
+	* tree-ssa-tail-merge.c (stmt_local_def): Handle statements with vuse
+	conservatively.
+	(gimple_equal_p): Don't use vn_valueize to compare for lhs equality of
+	assigns.
+
+2014-11-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/tm.texi.in (TARGET_FLAGS_REGNUM): Move around.
+	* doc/tm.texi: Regenerate.
+
+2014-11-14  Felix Yang  <felix.yang@huawei.com>
+
+	Backport from mainline
+	2014-11-14  Felix Yang  <felix.yang@huawei.com>
+		    Jiji Jiang  <jiangjiji@huawei.com>
+
+	* config/aarch64/aarch64-simd.md (*aarch64_simd_ld1r<mode>): Use
+	VALL mode iterator instead of VALLDI.
+
+2014-11-13  Teresa Johnson  <tejohnson@google.com>
+
+	PR tree-optimization/63841
+	* tree-ssa-strlen.c (strlen_optimize_stmt): Ignore clobbers.
+
+2014-11-13  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	Backport from mainline
+	2014-11-02  Michael Collison  <michael.collison@linaro.org>
+
+	* config/arm/arm.h (CLZ_DEFINED_VALUE_AT_ZERO) : Update
+	to support vector modes.
+	(CTZ_DEFINED_VALUE_AT_ZERO): Ditto.
+
+2014-11-13  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* doc/tm.texi.in (SELECT_CC_MODE): Update example.
+	(REVERSIBLE_CC_MODE): Fix example.
+	(REVERSE_CONDITION): Fix typo.
+	* doc/tm.texi: Regenerate.
+
+2014-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/63838
+	* ipa-pure-const.c (propagate_nothrow): Walk w->indirect_calls
+	chain instead of node->indirect_calls.
+
+2014-11-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/61535
+	* config/sparc/sparc.c (function_arg_vector_value): Deal with vectors
+	smaller than 8 bytes.
+	(sparc_function_arg_1): Tweak.
+	(sparc_function_value_1): Tweak.
+
+2014-11-08  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* config/arm/arm.c (arm_set_return_address): Mark the store as frame
+	related, if any.
+	(thumb_set_return_address): Likewise.
+
+2014-11-07  Daniel Hellstrom  <daniel@gaisler.com>
+
+	* config.gcc (sparc-*-rtems*): Clean away unused t-elf.
+	* config/sparc/t-rtems: Add leon3v7 and muser-mode multilibs.
+
+2014-11-07  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2014-10-23  Marek Polacek  <polacek@redhat.com>
+
+	* c-ubsan.c (ubsan_instrument_shift): Perform the MINUS_EXPR
+	in unsigned type.
+
+2014-11-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.md (trap): New insn.  Add "trap" to attribute type.
+	Don't allow trap insn in in_branch_delay, in_nullified_branch_delay
+	or in_call_delay.
+
+2014-11-06  Daniel Hellstrom  <daniel@gaisler.com>
+
+	* config.gcc (sparc*-*-*): Accept mcpu=leon3v7 processor.
+	* doc/invoke.texi (SPARC options): Add mcpu=leon3v7 comment.
+	* config/sparc/leon.md (leon3_load, leon_store, leon_fp_*): Handle
+	leon3v7 as leon3.
+	* config/sparc/sparc-opts.h (enum processor_type): Add LEON3V7.
+	* config/sparc/sparc.c (sparc_option_override): Add leon3v7 support.
+	* config/sparc/sparc.h (TARGET_CPU_leon3v7): New define.
+	* config/sparc/sparc.md (cpu): Add leon3v7.
+	* config/sparc/sparc.opt (enum processor_type): Add leon3v7.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63538
+	* config/i386/i386.c (in_large_data_p): Reject automatic variables.
+	(ix86_encode_section_info): Do not check for non-automatic varibles
+	when setting SYMBOL_FLAG_FAR_ADDR flag.
+	(x86_64_elf_select_section): Do not check ix86_cmodel here.
+	(x86_64_elf_unique_section): Ditto.
+	(x86_elf_aligned_common): Emit tab before .largecomm.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline:
+	2014-10-20  Uros Bizjak  <ubizjak@gmail.com>
+
+	* varasm.c (const_alias_set): Remove.
+	(init_varasm_once): Remove initialization of const_alias_set.
+	(build_constant_desc): Do not set alias set to const_alias_set.
+
+	Backport from mainline:
+	2014-10-14  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/63475
+	* alias.c (true_dependence_1): Always use get_addr to extract
+	true address operands from x_addr and mem_addr.  Use extracted
+	address operands to check for references with alignment ANDs.
+	Use extracted address operands with find_base_term and
+	base_alias_check. For noncanonicalized operands call canon_rtx with
+	extracted address operand.
+	(write_dependence_1): Ditto.
+	(may_alias_p): Ditto.  Remove unused calls to canon_rtx.
+
+	Backport from mainline:
+	2014-10-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/63483
+	* alias.c (true_dependence_1): Do not exit early for MEM_READONLY_P
+	references when alignment ANDs are involved.
+	(write_dependence_p): Ditto.
+	(may_alias_p): Ditto.
+
+2014-10-31  DJ Delorie  <dj@redhat.com>
+
+	* expmed.c (strict_volatile_bitfield_p): Fix off-by-one error.
+
+2014-10-31  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	* config/aarch64/aarch64-elf-raw.h (CA53_ERR_835769_SPEC): Define.
+	(LINK_SPEC): Include CA53_ERR_835769_SPEC.
+	* config/aarch64/aarch64-linux.h (CA53_ERR_835769_SPEC): Define.
+	(LINK_SPEC): Include CA53_ERR_835769_SPEC.
+
+2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/63697
+	* tree-vrp.c (simplify_internal_call_using_ranges): For subcode ==
+	MINUS_EXPR, check overflow on vr0.min - vr1.max and vr0.max - vr1.min
+	instead of vr0.min - vr1.min and vr0.max - vr1.max.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* config/avr/avr-protos.h (regmask): New inline function.
+	(avr_fix_inputs, avr_emit3_fix_outputs): New protos.
+	* config/avr/avr.c (avr_fix_operands, avr_move_fixed_operands)
+	(avr_fix_inputs, avr_emit3_fix_outputs): New functions.
+	* config/avr/avr-fixed.md (mulqq3_nomul, muluqq3_nomul)
+	(mul<ALL2QA>3, mul<ALL4A>3, <usdiv><ALL1Q>3, <usdiv><ALL2QA>3)
+	(<usdiv><ALL4A>3, round<ALL124QA>3): Fix input operands.
+	* config/avr/avr-dimode.md (add<ALL8>3, sub<ALL8>3)
+	(<ss_addsub><ALL8S>3, <us_addsub><ALL8U>3, cbranch<ALL8>4)
+	(<di_shifts><ALL8>3, <any_extend>mulsidi3): Fix input operands.
+	* config/avr/avr.md (mulqi3_call, mulhi3_call, mulsi3, mulpsi3)
+	(mulu<QIHI>si3, muls<QIHI>si3, mulohisi3, <any_extend>mulhisi3)
+	(usmulhisi3, <any_extend>mulhi3_highpart, mulsqipsi3)
+	(fmul, fmuls, fmulsu): Fix operands.  Turn insn into expander as
+	needed.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
@@ -150,8 +757,8 @@
 	Backport from mainline
 	2014-06-24  Max Ostapenko  <m.ostapenko@partner.samsung.com>
 
-	* asan.c (instrument_strlen_call): Do not instrument first byte in strlen
-	if already instrumented.
+	* asan.c (instrument_strlen_call): Do not instrument first byte in
+	strlen if already instrumented.
 
 2014-10-16  Yury Gribov  <y.gribov@samsung.com>
 
@@ -1504,7 +2111,7 @@
 	* omp-low.c (create_omp_child_function): Don't set DECL_NAMELESS
 	on the FUNCTION_DECL.
 
-	* BASE-VER: Set to 4.9.1.
+	* BASE-VER: Set to 4.9.2.
 	* DEV-PHASE: Set to prerelease.
 
 2014-07-16  Release Manager
Index: gcc/testsuite/gcc.target/powerpc/builtins-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,166 @@
+/* { dg-do compile { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=power8 -O0" } */
+
+/* Test that a number of newly added builtin overloads are accepted
+   by the compiler.  */
+
+#include <altivec.h>
+
+vector double y = { 2.0, 4.0 };
+vector double z;
+
+int main ()
+{
+  vector float fa = {1.0, 2.0, 3.0, -4.0};
+  vector float fb = {-2.0, -3.0, -4.0, -5.0};
+  vector float fc = vec_cpsgn (fa, fb);
+
+  vector long long la = {5L, 14L};
+  vector long long lb = {3L, 86L};
+  vector long long lc = vec_and (la, lb);
+  vector bool long long ld = {0, -1};
+  vector long long le = vec_and (la, ld);
+  vector long long lf = vec_and (ld, lb);
+
+  vector unsigned long long ua = {5L, 14L};
+  vector unsigned long long ub = {3L, 86L};
+  vector unsigned long long uc = vec_and (ua, ub);
+  vector bool long long ud = {0, -1};
+  vector unsigned long long ue = vec_and (ua, ud);
+  vector unsigned long long uf = vec_and (ud, ub);
+
+  vector long long lg = vec_andc (la, lb);
+  vector long long lh = vec_andc (la, ld);
+  vector long long li = vec_andc (ld, lb);
+
+  vector unsigned long long ug = vec_andc (ua, ub);
+  vector unsigned long long uh = vec_andc (ua, ud);
+  vector unsigned long long ui = vec_andc (ud, ub);
+
+  vector double da = {1.0, -4.0};
+  vector double db = {-2.0, 5.0};
+  vector double dc = vec_cpsgn (da, db);
+
+  vector long long lj = vec_mergeh (la, lb);
+  vector long long lk = vec_mergeh (la, ld);
+  vector long long ll = vec_mergeh (ld, la);
+
+  vector unsigned long long uj = vec_mergeh (ua, ub);
+  vector unsigned long long uk = vec_mergeh (ua, ud);
+  vector unsigned long long ul = vec_mergeh (ud, ua);
+
+  vector long long lm = vec_mergel (la, lb);
+  vector long long ln = vec_mergel (la, ld);
+  vector long long lo = vec_mergel (ld, la);
+
+  vector unsigned long long um = vec_mergel (ua, ub);
+  vector unsigned long long un = vec_mergel (ua, ud);
+  vector unsigned long long uo = vec_mergel (ud, ua);
+
+  vector long long lp = vec_nor (la, lb);
+  vector long long lq = vec_nor (la, ld);
+  vector long long lr = vec_nor (ld, la);
+
+  vector unsigned long long up = vec_nor (ua, ub);
+  vector unsigned long long uq = vec_nor (ua, ud);
+  vector unsigned long long ur = vec_nor (ud, ua);
+
+  vector long long ls = vec_or (la, lb);
+  vector long long lt = vec_or (la, ld);
+  vector long long lu = vec_or (ld, la);
+
+  vector unsigned long long us = vec_or (ua, ub);
+  vector unsigned long long ut = vec_or (ua, ud);
+  vector unsigned long long uu = vec_or (ud, ua);
+
+  vector unsigned char ca = {0,4,8,1,5,9,2,6,10,3,7,11,15,12,14,13};
+  vector long long lv = vec_perm (la, lb, ca);
+  vector unsigned long long uv = vec_perm (ua, ub, ca);
+
+  vector long long lw = vec_sel (la, lb, lc);
+  vector long long lx = vec_sel (la, lb, uc);
+  vector long long ly = vec_sel (la, lb, ld);
+
+  vector unsigned long long uw = vec_sel (ua, ub, lc);
+  vector unsigned long long ux = vec_sel (ua, ub, uc);
+  vector unsigned long long uy = vec_sel (ua, ub, ld);
+
+  vector long long lz = vec_xor (la, lb);
+  vector long long l0 = vec_xor (la, ld);
+  vector long long l1 = vec_xor (ld, la);
+
+  vector unsigned long long uz = vec_xor (ua, ub);
+  vector unsigned long long u0 = vec_xor (ua, ud);
+  vector unsigned long long u1 = vec_xor (ud, ua);
+
+  int ia = vec_all_eq (ua, ub);
+  int ib = vec_all_ge (ua, ub);
+  int ic = vec_all_gt (ua, ub);
+  int id = vec_all_le (ua, ub);
+  int ie = vec_all_lt (ua, ub);
+  int ig = vec_all_ne (ua, ub);
+
+  int ih = vec_any_eq (ua, ub);
+  int ii = vec_any_ge (ua, ub);
+  int ij = vec_any_gt (ua, ub);
+  int ik = vec_any_le (ua, ub);
+  int il = vec_any_lt (ua, ub);
+  int im = vec_any_ne (ua, ub);
+
+  vector int sia = {9, 16, 25, 36};
+  vector int sib = {-8, -27, -64, -125};
+  vector int sic = vec_mergee (sia, sib);
+  vector int sid = vec_mergeo (sia, sib);
+
+  vector unsigned int uia = {9, 16, 25, 36};
+  vector unsigned int uib = {8, 27, 64, 125};
+  vector unsigned int uic = vec_mergee (uia, uib);
+  vector unsigned int uid = vec_mergeo (uia, uib);
+
+  vector bool int bia = {0, -1, -1, 0};
+  vector bool int bib = {-1, -1, 0, -1};
+  vector bool int bic = vec_mergee (bia, bib);
+  vector bool int bid = vec_mergeo (bia, bib);
+
+  vector unsigned int uie = vec_packsu (ua, ub);
+
+  vector long long l2 = vec_cntlz (la);
+  vector unsigned long long u2 = vec_cntlz (ua);
+  vector int sie = vec_cntlz (sia);
+  vector unsigned int uif = vec_cntlz (uia);
+  vector short ssa = {20, -40, -60, 80, 100, -120, -140, 160};
+  vector short ssb = vec_cntlz (ssa);
+  vector unsigned short usa = {81, 72, 63, 54, 45, 36, 27, 18};
+  vector unsigned short usb = vec_cntlz (usa);
+  vector signed char sca = {-4, 3, -9, 15, -31, 31, 0, 0,
+		            1, 117, -36, 99, 98, 97, 96, 95};
+  vector signed char scb = vec_cntlz (sca);
+  vector unsigned char cb = vec_cntlz (ca);
+
+  vector double dd = vec_xl (0, &y);
+  vec_xst (dd, 0, &z);
+
+  vector double de = vec_round (dd);
+
+  vector double df = vec_splat (de, 0);
+  vector double dg = vec_splat (de, 1);
+  vector long long l3 = vec_splat (l2, 0);
+  vector long long l4 = vec_splat (l2, 1);
+  vector unsigned long long u3 = vec_splat (u2, 0);
+  vector unsigned long long u4 = vec_splat (u2, 1);
+  vector bool long long l5 = vec_splat (ld, 0);
+  vector bool long long l6 = vec_splat (ld, 1);
+
+  vector long long l7 = vec_div (l3, l4);
+  vector unsigned long long u5 = vec_div (u3, u4);
+
+  vector long long l8 = vec_mul (l3, l4);
+  vector unsigned long long u6 = vec_mul (u3, u4);
+
+  vector double dh = vec_ctf (la, -2);
+  vector double di = vec_ctf (ua, 2);
+  vector long long l9 = vec_cts (dh, -2);
+  vector unsigned long long u7 = vec_ctu (di, 2);
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/powerpc/builtins-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-options "-mcpu=power8 " } */
+
+#include <altivec.h>
+
+void abort (void);
+
+int main ()
+{
+  vector long long sa = {27L, -14L};
+  vector long long sb = {-9L, -2L};
+
+  vector unsigned long long ua = {27L, 14L};
+  vector unsigned long long ub = {9L, 2L};
+
+  vector long long sc = vec_div (sa, sb);
+  vector unsigned long long uc = vec_div (ua, ub);
+
+  if (sc[0] != -3L || sc[1] != 7L || uc[0] != 3L || uc[1] != 7L)
+    abort ();
+
+  vector long long sd = vec_mul (sa, sb);
+  vector unsigned long long ud = vec_mul (ua, ub);
+
+  if (sd[0] != -243L || sd[1] != 28L || ud[0] != 243L || ud[1] != 28L)
+    abort ();
+
+  vector long long se = vec_splat (sa, 0);
+  vector long long sf = vec_splat (sa, 1);
+  vector unsigned long long ue = vec_splat (ua, 0);
+  vector unsigned long long uf = vec_splat (ua, 1);
+
+  if (se[0] != 27L || se[1] != 27L || sf[0] != -14L || sf[1] != -14L
+      || ue[0] != 27L || ue[1] != 27L || uf[0] != 14L || uf[1] != 14L)
+    abort ();
+
+  vector double da = vec_ctf (sa, -2);
+  vector double db = vec_ctf (ua, 2);
+  vector long long sg = vec_cts (da, -2);
+  vector unsigned long long ug = vec_ctu (db, 2);
+
+  if (da[0] != 108.0 || da[1] != -56.0 || db[0] != 6.75 || db[1] != 3.5
+      || sg[0] != 27L || sg[1] != -14L || ug[0] != 27L || ug[1] != 14L)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/avr/torture/pr63633-ice-mult.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,37 @@
+/* { dg-do compile } */
+
+void ice_mult32 (int x)
+{
+  register long reg __asm ("22");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_mult24 (int x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = 0x12345 * x));
+}
+
+void ice_sh24 (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 3));
+}
+
+void ice_sh24b (__int24 x)
+{
+  register __int24 reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = x << 22));
+}
+
+void ice_s16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*x));
+}
+
+void ice_u16s16 (int x)
+{
+  register long reg __asm ("20");
+  __asm volatile (" " :: "r" (reg = (long) x*0x1234u));
+}
Index: gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memcpy-strategy-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,21 @@
+/* PR target/64200 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=atom -mmemcpy-strategy=libcall:-1:align -minline-stringops-dynamically" } */
+
+#include <stdarg.h>
+
+extern void bar(char *x);
+
+void foo (int size, ...)
+{
+  struct
+  {
+    char x[size];
+  } d;
+
+  va_list ap;
+  va_start(ap, size);
+  d = va_arg(ap, typeof (d));
+  va_end(ap);
+  bar(d.x);
+}
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-store-7.c	(.../branches/gcc-4_9-branch)
@@ -29,13 +29,13 @@
   ap = ep;
   bp = fp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *ap++ = str;
       *bp++ = str;
     }
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       if (strcmp (*--ap, "STR") != 0)
 	abort ();
Index: gcc/testsuite/gcc.target/i386/pr63661.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63661.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63661.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,80 @@
+/* PR target/63661 */
+/* { dg-do run } */
+/* { dg-require-effective-target fpic } */
+/* { dg-options "-mtune=nehalem -fPIC -O2" } */
+
+static void __attribute__((noinline,noclone,hot))
+foo (double a, double q, double *ff, double *gx, int e, int ni)
+{
+  union
+    {
+      double n;
+      unsigned long long o;
+    } punner;
+  double d;
+
+  punner.n = q;
+   __builtin_printf("B: 0x%016llx ---- %g\n", punner.o, q);
+
+  d = q - 5;
+  if(d < 0)
+    d = -d;
+  if (d > 0.1)
+    __builtin_abort();
+}
+
+static int __attribute__((noinline,noclone,hot))
+bar (int order, double q, double c[])
+{
+  int ni, nn, i, e;
+  double g2, x2, de, s, ratio, ff;
+
+  nn = 0;
+  e = order & 1;
+  s = 0;
+  ratio = 0;
+  x2 = 0;
+  g2 = 0;
+
+  if(q == 0.0)
+    return 0;
+
+  if (order < 5)
+    {
+      ratio = 1.0 / q;
+      nn = order;
+    }
+
+  ni = -nn;
+
+  while(1)
+    {
+      de = ratio - g2 - x2;
+
+      foo (0, q, &ff, &g2, e, ni);
+
+      if((int)de == 0)
+        break;
+    }
+
+  s += 2 * nn * c[nn];
+
+  for (i = 0; i < 1; i++)
+    {
+      c[0] = nn;
+      for (; i < 10; i++)
+        c[i] = 0.0;
+      c[0] /= s;
+    }
+
+  return 0;
+}
+
+int
+main ()
+{
+  double c[1000];
+
+  bar (1, 5.0, c);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/pr63538.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63538.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,13 @@
+/* PR target/63538 */
+/* { dg-do compile } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-options "-O2 -mcmodel=medium -mlarge-data-threshold=0" } */
+
+static char *str = "Hello World";
+
+char *foo ()
+{
+  return str;
+}
+
+/* { dg-final { scan-assembler "movabs" } } */
Index: gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx256-unaligned-load-7.c	(.../branches/gcc-4_9-branch)
@@ -33,7 +33,7 @@
   cp = mp;
   dp = lp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *cp++ = str;
       *dp++ = str;
@@ -44,13 +44,13 @@
   cp = mp;
   dp = lp;
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       *ap++ = *cp++;
       *bp++ = *dp++;
     }
 
-  for (i = N; i >= 0; i--)
+  for (i = N; i > 0; i--)
     {
       if (strcmp (*--ap, "STR") != 0)
 	abort ();
Index: gcc/testsuite/gcc.target/i386/pr63947.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr63947.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr63947.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR target/63947 */
+/* { dg-do assemble } */
+/* { dg-options "-Os" } */
+/* { dg-additional-options "-march=i686" { target ia32 } } */
+
+long double foo (unsigned a, unsigned b)
+{
+  return a + b < a;
+}
Index: gcc/testsuite/gcc.target/i386/memset-strategy-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/memset-strategy-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/i386/memset-strategy-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR target/64108 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -march=atom -mmemset-strategy=libcall:-1:align -minline-all-stringops" } */
+
+char a[2048];
+void t (void)
+{
+  __builtin_memset (a, 1, 2048);
+}
+
Index: gcc/testsuite/gcc.target/h8300/pragma-isr.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/pragma-isr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/pragma-isr.c	(.../branches/gcc-4_9-branch)
@@ -18,23 +18,3 @@
 {
   foo ();
 }
-/* Check whether rte is generated for two ISRs.  */
-/* { dg-do compile { target h8300-*-* } }  */
-/* { dg-options "-O3" }  */
-/* { dg-final { scan-assembler-times "rte" 2} }  */
-
-extern void foo (void);
-
-#pragma interrupt
-void
-isr1 (void)
-{
-  foo ();
-}
-
-#pragma interrupt
-void
-isr2 (void)
-{
-  foo ();
-}
Index: gcc/testsuite/gcc.target/h8300/pragma-isr2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/pragma-isr2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/pragma-isr2.c	(.../branches/gcc-4_9-branch)
@@ -19,24 +19,3 @@
 {
   return 0;
 }
-/* Check whether rte is generated only for an ISR.  */
-/* { dg-do compile { target h8300-*-* } }  */
-/* { dg-options "-O" }  */
-/* { dg-final { scan-assembler-times "rte" 1 } }  */
-
-#pragma interrupt
-void
-isr (void)
-{
-}
-
-void
-delay (int a)
-{
-}
-
-int
-main (void)
-{
-  return 0;
-}
Index: gcc/testsuite/gcc.target/h8300/h8300.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/h8300/h8300.exp	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/h8300/h8300.exp	(.../branches/gcc-4_9-branch)
@@ -39,44 +39,3 @@
 
 # All done.
 dg-finish
-# Copyright (C) 2013-2014 Free Software Foundation, Inc.
-
-# This program is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
-# (at your option) any later version.
-# 
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-# 
-# You should have received a copy of the GNU General Public License
-# along with GCC; see the file COPYING3.  If not see
-# <http://www.gnu.org/licenses/>.
-
-# GCC testsuite that uses the `dg.exp' driver.
-
-# Exit immediately if this isn't a h8300 target.
-if ![istarget h8300*-*-*] then {
-  return
-}
-
-# Load support procs.
-load_lib gcc-dg.exp
-
-# If a testcase doesn't have special options, use these.
-global DEFAULT_CFLAGS
-if ![info exists DEFAULT_CFLAGS] then {
-    set DEFAULT_CFLAGS " -ansi -pedantic-errors"
-}
-
-# Initialize `dg'.
-dg-init
-
-# Main loop.
-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]] \
-	"" $DEFAULT_CFLAGS
-
-# All done.
-dg-finish
Index: gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr51244-20-sh2a.c	(.../branches/gcc-4_9-branch)
@@ -3,12 +3,12 @@
 /* { dg-do compile }  */
 /* { dg-options "-O2" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "*" } { "-m2a*" } } */
-/* { dg-final { scan-assembler-times "tst" 5 } } */
-/* { dg-final { scan-assembler-times "movt" 0 } } */
+/* { dg-final { scan-assembler-times "tst" 6 } } */
+/* { dg-final { scan-assembler-times "movt" 1 } } */
 /* { dg-final { scan-assembler-times "nott" 1 } } */
 /* { dg-final { scan-assembler-times "cmp/eq" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/hi" 4 } } */
 /* { dg-final { scan-assembler-times "cmp/gt" 3 } } */
-/* { dg-final { scan-assembler-times "not\t" 1 } } */
+/* { dg-final { scan-assembler-not "not\t" } } */
 
 #include "pr51244-20.c"
Index: gcc/testsuite/gcc.target/sh/pr51244-20.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/pr51244-20.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/pr51244-20.c	(.../branches/gcc-4_9-branch)
@@ -1,15 +1,15 @@
 /* Check that the SH specific sh_treg_combine RTL optimization pass works as
    expected.  On SH2A the expected insns are slightly different, see
-   pr51244-21.c.  */
+   pr51244-20-sh2a.c.  */
 /* { dg-do compile }  */
 /* { dg-options "-O2" } */
 /* { dg-skip-if "" { "sh*-*-*" } { "-m5*" "-m2a*" } { "" } } */
-/* { dg-final { scan-assembler-times "tst" 6 } } */
-/* { dg-final { scan-assembler-times "movt" 1 } } */
+/* { dg-final { scan-assembler-times "tst" 7 } } */
+/* { dg-final { scan-assembler-times "movt" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/eq" 2 } } */
 /* { dg-final { scan-assembler-times "cmp/hi" 4 } } */
 /* { dg-final { scan-assembler-times "cmp/gt" 2 } } */
-/* { dg-final { scan-assembler-times "not\t" 1 } } */
+/* { dg-final { scan-assembler-not "not\t" } } */
 
 
 /* non-SH2A: 2x tst, 1x movt, 2x cmp/eq, 1x cmp/hi
@@ -81,7 +81,7 @@
 }
 
 
-/* 2x tst, 1x cmp/hi, 1x not  */
+/* 3x tst, 1x movt, 1x cmp/hi, 1x not  */
 static inline int
 blk_oversized_queue_5 (int* q)
 {
Index: gcc/testsuite/gcc.target/sh/torture/pr63783-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/torture/pr63783-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/torture/pr63783-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* { dg-do run }  */
+/* { dg-additional-options "-std=c99" }  */
+
+#include <assert.h>
+
+int decision_result;
+int val;
+int truecount = 0;
+
+static void __attribute__((noinline))
+buggy (int flag)
+{
+  int condition;
+  if(flag == 0)
+    condition = val != 0;
+  else
+    condition = !decision_result;
+  if (condition)
+     truecount++;
+}
+
+int
+main (void)
+{
+  decision_result = 1;
+  buggy(1);
+  assert (truecount == 0);
+  return 0;
+}
Index: gcc/testsuite/gcc.target/sh/torture/pr63783-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/sh/torture/pr63783-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.target/sh/torture/pr63783-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* { dg-do run }  */
+/* { dg-additional-options "-std=c99" }  */
+
+#include <assert.h>
+
+long long decision_result;
+long long val;
+int truecount = 0;
+
+static void __attribute__((noinline))
+buggy (int flag)
+{
+  int condition;
+  if(flag == 0)
+    condition = val != 0;
+  else
+    condition = !decision_result;
+  if (condition)
+     truecount++;
+}
+
+int
+main (void)
+{
+  decision_result = 1;
+  buggy(1);
+  assert (truecount == 0);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr63659.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr63659.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr63659.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,29 @@
+/* PR rtl-optimization/63659 */
+
+int a, b, c, *d = &b, g, h, i;
+unsigned char e;
+char f;
+
+int
+main ()
+{
+  while (a)
+    {
+      for (a = 0; a; a++)
+	for (; c; c++)
+	  ;
+      if (i)
+	break;
+    }
+
+  char j = c, k = -1, l;
+  l = g = j >> h;
+  f = l == 0 ? k : k % l;
+  e = 0 ? 0 : f;
+  *d = e;
+
+  if (b != 255)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr64067.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr64067.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr64067.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,10 @@
+/* PR middle-end/64067 */
+
+struct S { int s; };
+int *const v[1] = { &((struct S) { .s = 42 }).s };
+
+int *
+foo (void)
+{
+  return v[0];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr64269.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr64269.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr64269.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+/* PR tree-optimization/64269 */
+
+void
+foo (char *p)
+{
+  __SIZE_TYPE__ s = ~(__SIZE_TYPE__)0;
+  *p = 0;
+  __builtin_memset (p + 1, 0, s);
+}
Index: gcc/testsuite/gnat.dg/opt45.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/opt45.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gnat.dg/opt45.adb	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,38 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+procedure Opt45 is
+
+  type Index_T is mod 2 ** 32;
+  for Index_T'Size use 32;
+  for Index_T'Alignment use 1;
+
+  type Array_T is array (Index_T range <>) of Natural;
+  type Array_Ptr_T is access all Array_T;
+
+  My_Array_1 : aliased Array_T := (1, 2);
+  My_Array_2 : aliased Array_T := (3, 4);
+
+  Array_Ptr : Array_Ptr_T := null;
+  Index : Index_T := Index_T'First;
+
+  My_Value : Natural := Natural'First;
+
+  procedure Proc (Selection : Positive) is
+  begin
+    if Selection = 1 then
+      Array_Ptr := My_Array_1'Access;
+      Index := My_Array_1'First;
+    else
+      Array_Ptr := My_Array_2'Access;
+      Index := My_Array_2'First;
+    end if;
+
+    if My_Value = Natural'First then
+      My_Value := Array_Ptr.all (Index);
+    end if;
+  end;
+
+begin
+  Proc (2);
+end;
Index: gcc/testsuite/gcc.dg/pr63762.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63762.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63762.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,77 @@
+/* PR middle-end/63762 */
+/* { dg-do assemble } */
+/* { dg-options "-O2" } */
+
+#include <stdlib.h>
+
+void *astFree ();
+void *astMalloc ();
+void astNegate (void *);
+int astGetNegated (void *);
+void astGetRegionBounds (void *, double *, double *);
+int astResampleF (void *, ...);
+
+extern int astOK;
+
+int
+MaskF (int inside, int ndim, const int lbnd[], const int ubnd[],
+       float in[], float val)
+{
+
+  void *used_region;
+  float *c, *d, *out, *tmp_out;
+  double *lbndgd, *ubndgd;
+  int *lbndg, *ubndg, idim, ipix, nax, nin, nout, npix, npixg, result = 0;
+  if (!astOK) return result;
+  lbndg = astMalloc (sizeof (int)*(size_t) ndim);
+  ubndg = astMalloc (sizeof (int)*(size_t) ndim);
+  lbndgd = astMalloc (sizeof (double)*(size_t) ndim);
+  ubndgd = astMalloc (sizeof (double)*(size_t) ndim);
+  if (astOK)
+    {
+      astGetRegionBounds (used_region, lbndgd, ubndgd);
+      npix = 1;
+      npixg = 1;
+      for (idim = 0; idim < ndim; idim++)
+        {
+          lbndg[ idim ] = lbnd[ idim ];
+          ubndg[ idim ] = ubnd[ idim ];
+          npix *= (ubnd[ idim ] - lbnd[ idim ] + 1);
+          if (npixg >= 0) npixg *= (ubndg[ idim ] - lbndg[ idim ] + 1);
+        }
+      if (npixg <= 0 && astOK)
+        {
+          if ((inside != 0) == (astGetNegated( used_region ) != 0))
+            {
+              c = in;
+              for (ipix = 0; ipix < npix; ipix++) *(c++) = val;
+              result = npix;
+            }
+        }
+      else if (npixg > 0 && astOK)
+        {
+          if ((inside != 0) == (astGetNegated (used_region) != 0))
+            {
+              tmp_out = astMalloc (sizeof (float)*(size_t) npix);
+              if (tmp_out)
+                {
+                  c = tmp_out;
+                  for (ipix = 0; ipix < npix; ipix++) *(c++) = val;
+                  result = npix - npixg;
+                }
+              out = tmp_out;
+            }
+          else
+            {
+              tmp_out = NULL;
+              out = in;
+            }
+          if (inside) astNegate (used_region);
+          result += astResampleF (used_region, ndim, lbnd, ubnd, in, NULL,
+                                  NULL, NULL, 0, 0.0, 100, val, ndim,
+                                  lbnd, ubnd, lbndg, ubndg, out, NULL);
+          if (inside) astNegate (used_region);
+        }
+    }
+  return result;
+}
Index: gcc/testsuite/gcc.dg/pr51879-12.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr51879-12.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr51879-12.c	(.../branches/gcc-4_9-branch)
@@ -24,6 +24,6 @@
   baz (a);
 }
 
-/* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre"} } */
-/* { dg-final { scan-tree-dump-times "bar2 \\(" 1 "pre"} } */
+/* { dg-final { scan-tree-dump-times "bar \\(" 1 "pre" { xfail *-*-* } } } */
+/* { dg-final { scan-tree-dump-times "bar2 \\(" 1 "pre" { xfail *-*-* } } } */
 /* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/pr63665.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr63665.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr63665.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-require-effective-target int32plus } */
+/* { dg-options "-O -fno-tree-ccp -fno-tree-fre -fno-tree-copy-prop -fwrapv" } */
+
+static inline int
+test5 (int x)
+{
+  int y = 0x80000000;
+  return x + y;
+}
+
+int
+main ()
+{
+  if (test5 (0x80000000) != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr62167-run.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62167-run.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62167-run.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,47 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
Index: gcc/testsuite/gcc.dg/pr52769.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr52769.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr52769.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,24 @@
+/* PR c/52769 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+typedef struct
+{
+  int should_be_zero;
+  char s[6];
+  int x;
+} foo_t;
+
+int
+main (void)
+{
+  volatile foo_t foo = {
+    .s = "123456",
+    .x = 2
+  };
+
+  if (foo.should_be_zero != 0)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr62167.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr62167.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/pr62167.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,50 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -ftree-tail-merge -fdump-tree-pre" } */
+
+struct node
+{
+  struct node *next;
+  struct node *prev;
+};
+
+struct node node;
+
+struct head
+{
+  struct node *first;
+};
+
+struct head heads[5];
+
+int k = 2;
+
+struct head *head = &heads[2];
+
+int
+main ()
+{
+  struct node *p;
+
+  node.next = (void*)0;
+
+  node.prev = (void *)head;
+
+  head->first = &node;
+
+  struct node *n = head->first;
+
+  struct head *h = &heads[k];
+
+  heads[2].first = n->next;
+
+  if ((void*)n->prev == (void *)h)
+    p = h->first;
+  else
+    /* Dead tbaa-unsafe load from ((struct node *)&heads[2])->next.  */
+    p = n->prev->next;
+
+  return !(p == (void*)0);
+}
+
+/* { dg-final { scan-tree-dump-not "Removing basic block" "pre"} } */
+/* { dg-final { cleanup-tree-dump "pre" } } */
Index: gcc/testsuite/gcc.dg/torture/pr63738.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr63738.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr63738.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+/*  { dg-do compile } */
+
+#include <setjmp.h>
+
+struct longjmp_buffer {
+  jmp_buf buf;
+};
+
+void plouf();
+
+extern long interprete()
+{
+  long * sp;
+  int i;
+  long *args;
+  int n;
+
+  struct longjmp_buffer raise_buf;
+  setjmp (raise_buf.buf);
+
+  plouf();
+  sp -= 4;
+  for (i = 0; i < n; i++)
+    args[i] = sp[10-i];
+  plouf();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr62238.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr62238.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr62238.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-do run } */
+
+int a[4], b, c, d; 
+
+int
+fn1 (int p)
+{
+  for (; d; d++)
+    {
+      unsigned int h;
+      for (h = 0; h < 3; h++)
+	{
+	  if (a[c+c+h])
+	    {
+	      if (p)
+		break;
+	      return 0;
+	    }
+	  b = 0;
+	}
+    }
+  return 0;
+}
+
+int
+main ()
+{
+  fn1 (0);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/pr64041.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr64041.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr64041.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,64 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+int printf (const char *, ...);
+
+int a, b = 1, d;
+
+union U1
+{
+  unsigned int f0;
+  int f1;
+};
+
+union U2
+{
+  int f2;
+  int f3;
+} c;
+
+int
+fn1 (int p)
+{
+  int t = p && a || p && a && p; 
+  return t ? t : a;
+}
+
+unsigned
+fn2 (union U1 p1, union U2 p2)
+{
+  if (p1.f1 <= 0)
+    {
+      for (; p2.f2;)
+	c.f2 = 0;
+      p2.f2 = fn1 (d);
+    }
+  return p2.f3;
+}
+
+int g = 0;
+
+int
+foo ()
+{
+  if (b)
+    {
+      union U1 f = { 0xFFFFFFFFU }; 
+
+      fn2 (f, c);
+    }
+  g = 1;
+  return 0; 
+}
+
+
+int
+main ()
+{
+  foo ();
+
+  if (g == 0)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/ipa/pr63551.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/ipa/pr63551.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/ipa/pr63551.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-options "-Os" } */
+
+union U
+{
+  unsigned int f0;
+  int f1;
+};
+
+int a, d;
+
+void
+fn1 (union U p)
+{
+  if (p.f1 <= 0)
+    if (a)
+      d = 0;
+}
+
+void
+fn2 ()
+{
+  d = 0;
+  union U b = { 4294967286U };
+  fn1 (b);
+}
+
+int
+main ()
+{
+  fn2 ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr63605.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr63605.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr63605.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+extern void abort (void);
+
+int a, b[8] = { 2, 0, 0, 0, 0, 0, 0, 0 }, c[8];
+
+int
+main ()
+{
+  int d;
+  check_vect ();
+  for (; a < 8; a++)
+    {
+      d = b[a] >> 1;
+      c[a] = d != 0;
+    }
+  if (c[0] != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr62021.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr62021.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr62021.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,30 @@
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-additional-options "-fopenmp-simd" } */
+/* { dg-additional-options "-mavx" { target avx_runtime } } */
+
+#pragma omp declare simd linear(y)
+__attribute__((noinline)) int *
+foo (int *x, int y)
+{
+  return x + y;
+}
+
+int a[1024];
+int *b[1024] = { &a[0] };
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    b[i] = &a[1023 - i];
+  #pragma omp simd
+  for (i = 0; i < 1024; i++)
+    b[i] = foo (b[i], i);
+  for (i = 0; i < 1024; i++)
+    if (b[i] != &a[1023])
+      __builtin_abort ();
+  return 0;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/20141029-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/20141029-1.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/gcc.dg/20141029-1.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-options "-fstrict-volatile-bitfields -fdump-rtl-final" } */
+
+#define PERIPH (*(volatile struct system_periph *)0x81234)
+
+struct system_periph {
+  union {
+    unsigned short WORD;
+    struct {
+      unsigned short a:1;
+      unsigned short b:1;
+      unsigned short  :5;
+      unsigned short c:1;
+      unsigned short  :8;
+    } BIT;
+  } ALL;
+};
+
+void
+foo()
+{
+  while (1)
+    {
+      PERIPH.ALL.BIT.a = 1;
+    }
+}
+/* { dg-final { scan-rtl-dump-times "mem/v(/.)*:HI" 4 "final" } } */
+/* { dg-final { cleanup-rtl-dump "final" } } */
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,251 @@
+2014-12-19  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/60955
+	* g++.dg/warn/register-parm-1.C: New.
+
+2014-12-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63551
+	* gcc.dg/ipa/pr63551.c (fn2): Use 4294967286U instead of
+	4294967286 to avoid warnings.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-14  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-12-06  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64200
+	* gcc.target/i386/memcpy-strategy-4.c: New test.
+
+2014-12-13  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-12-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/64269
+	* gcc.c-torture/compile/pr64269.c: New test.
+
+2014-12-10  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2014-09-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/builtins-1.c: Add tests for vec_ctf,
+	vec_cts, and vec_ctu.
+	* gcc.target/powerpc/builtins-2.c: Likewise.
+
+	Backport from mainline
+	2014-08-28  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/builtins-1.c: Add tests for vec_xl, vec_xst,
+	vec_round, vec_splat, vec_div, and vec_mul.
+	* gcc.target/powerpc/builtins-2.c: New test.
+
+	Backport from mainline
+	2014-08-20  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* testsuite/gcc.target/powerpc/builtins-1.c: New test.
+
+2014-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/62021
+	* gcc.dg/vect/pr62021.c: New test.
+
+2014-12-09  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR bootstrap/64213
+	Revert:
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-12-07  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	* gcc.target/h8300/h8300.exp: Fix duplicated text.
+	* gcc.target/h8300/pragma-isr.c: Likewise.
+	* gcc.target/h8300/pragma-isr2.c: Likewise.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-12-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/64108
+	* gcc.target/i386/memset-strategy-2.c: New test.
+
+2014-12-05  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2014-11-28  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR rtl-optimization/64037
+	* g++.dg/pr64037.C: New test.
+
+2014-12-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/56493
+	* c-c++-common/pr56493.c: New test.
+
+2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+
+	Backported from mainline
+	2014-12-03  Renlin Li  <Renlin.Li@arm.com>
+		    H.J. Lu  <hongjiu.lu@intel.com>
+
+	 PR middle-end/63762
+	 PR target/63661
+	 * gcc.dg/pr63762.c: New test.
+	 * gcc.target/i386/pr63661.c: New test.
+
+2014-12-01  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/63551
+	* gcc.dg/ipa/pr63551.c: New test.
+	* gcc.dg/ipa/pr64041.c: Likewise.
+
+2014-12-01  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63738
+	* gcc.dg/torture/pr63738.c: Fix call to setjmp.
+
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/64067
+	* gcc.c-torture/compile/pr64067.c: New test.
+
+	2014-11-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/63915
+	* c-c++-common/gomp/pr60823-4.c: New test.
+
+	PR sanitizer/63913
+	* g++.dg/ubsan/pr63913.C: New test.
+
+	2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/63659
+	* gcc.c-torture/execute/pr63659.c: New test.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63738
+	* gcc.dg/torture/pr63738.c: New testcase.
+
+2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2014-11-26  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/62238
+	* gcc.dg/torture/pr62238.c: New testcase.
+
+	2014-11-07  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/63605
+	* gcc.dg/vect/pr63605.c: New testcase.
+
+	2014-10-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/63665
+	* gcc.dg/pr63665.c: New testcase.
+
+2014-11-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/opt45.adb: New test.
+
+2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	Backport from mainline
+	2014-11-22  Oleg Endo  <olegendo@gcc.gnu.org>
+
+	PR target/63783
+	PR target/51244
+	* gcc.target/sh/torture/pr63783-1.c: New.
+	* gcc.target/sh/torture/pr63783-2.c: New.
+	* gcc.target/sh/pr51244-20.c: Adjust.
+	* gcc.target/sh/pr51244-20-sh2a.c: Adjust.
+
+2014-11-19  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63947
+	* gcc.target/i386/pr63947.c: New test.
+
+2014-11-19  Tom de Vries  <tom@codesourcery.com>
+
+	Backport from mainline
+	PR tree-optimization/62167
+	* gcc.dg/pr51879-12.c: Add xfails.
+	* gcc.dg/pr62167-run.c: New test.
+	* gcc.dg/pr62167.c: New test.
+
+2014-11-13  Teresa Johnson  <tejohnson@google.com>
+
+	PR tree-optimization/63841
+	* g++.dg/tree-ssa/pr63841.C: New test.
+
+2014-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/63838
+	* g++.dg/ipa/pr63838.C: New test.
+
+2014-11-11  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/63265
+	* g++.dg/cpp0x/constexpr-63265.C: New.
+
+2014-11-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backported from mainline
+	2014-11-09  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR testsuite/63305
+	* gcc.target/i386/avx256-unaligned-load-7.c (avx_test): Fix
+	buffer overflow.
+	* gcc.target/i386/avx256-unaligned-store-7.c (avx_test): Likewise.
+
+2014-11-07  Marek Polacek  <polacek@redhat.com>
+
+	* c-c++-common/ubsan/undefined-2.c: New test.
+
+2014-11-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/63538
+	* gcc.target/i386/pr63538.c: New test.
+
+2014-11-03  Marek Polacek  <polacek@redhat.com>
+
+	PR c/52769
+	* gcc.dg/pr52769.c: New test.
+
+2014-10-31  DJ Delorie  <dj@redhat.com>
+
+	* gcc.dg/20141029-1.c: New.
+
+2014-10-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/63697
+	* c-c++-common/ubsan/overflow-sub-3.c: New test.
+
+2014-10-30  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR63633
+	* gcc.target/avr/torture/pr63633-ice-mult.c: New test.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/testsuite/g++.dg/pr64037.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr64037.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/pr64037.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,27 @@
+// { dg-do run { target i?86-*-* x86_64-*-* } }
+// { dg-options "-std=c++11 -Os" }
+
+enum class X : unsigned char {
+  V = 2,
+};
+
+static void
+__attribute__((noinline,noclone))
+foo(unsigned &out, unsigned a, X b)
+{
+  out = static_cast<unsigned>(b);
+}
+
+int main()
+{
+  unsigned deadbeef = 0xDEADBEEF;
+  asm volatile ("" : "+d" (deadbeef), "+c" (deadbeef));
+
+  unsigned out;
+  foo(out, 2, X::V);
+
+  if (out != 2)
+    __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ubsan/pr63913.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ubsan/pr63913.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ubsan/pr63913.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,12 @@
+// PR sanitizer/63913
+// { dg-do compile }
+// { dg-options "-fsanitize=bool -fnon-call-exceptions" }
+
+struct B { B (); ~B (); };
+
+double
+foo (bool *x)
+{
+  B b;
+  return *x;
+}
Index: gcc/testsuite/g++.dg/tree-ssa/pr63841.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/tree-ssa/pr63841.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/tree-ssa/pr63841.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,35 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include <string>
+
+std::string __attribute__ ((noinline)) comp_test_write() {
+  std::string data;
+
+  for (int i = 0; i < 2; ++i) {
+    char b = 1 >> (i * 8);
+    data.append(&b, 1);
+  }
+
+  return data;
+}
+
+std::string __attribute__ ((noinline)) comp_test_write_good() {
+  std::string data;
+
+  char b;
+  for (int i = 0; i < 2; ++i) {
+    b = 1 >> (i * 8);
+    data.append(&b, 1);
+  }
+
+  return data;
+}
+
+int main() {
+  std::string good = comp_test_write_good();
+  std::string bad = comp_test_write();
+
+  if (good != bad)
+    __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/warn/register-parm-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/register-parm-1.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/warn/register-parm-1.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,9 @@
+// PR c++/60955
+// { dg-options "-Wextra" }
+
+unsigned int erroneous_warning(register int a) {
+    if ((a) & 0xff) return 1; else return 0;
+}
+unsigned int no_erroneous_warning(register int a) {
+    if (a & 0xff) return 1; else return 0;
+}
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/constexpr-63265.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,19 @@
+// PR c++/63265
+// { dg-do compile { target c++11 } }
+
+#define LSHIFT (sizeof(unsigned int) * __CHAR_BIT__)
+
+template <int lshift>
+struct SpuriouslyWarns1 {
+    static constexpr unsigned int v = lshift < LSHIFT ? 1U << lshift : 0;
+};
+
+static_assert(SpuriouslyWarns1<LSHIFT>::v == 0, "Impossible occurred");
+
+template <int lshift>
+struct SpuriouslyWarns2 {
+    static constexpr bool okay = lshift < LSHIFT;
+    static constexpr unsigned int v = okay ? 1U << lshift : 0;
+};
+
+static_assert(SpuriouslyWarns2<LSHIFT>::v == 0, "Impossible occurred");
Index: gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/cpp0x/alias-decl-44.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,43 @@
+// PR c++/63849
+// { dg-do compile { target c++11 } }
+
+template <class _T, class...>
+using First = _T;            // we should not use this
+                             // alias with only
+                             // one pack parameter (?)
+
+template <template <class...> class _Successor,
+          int,
+          class... _Xs>
+struct Overlay
+{
+    using O = _Successor<_Xs...>;
+};
+
+template <class... _Pack>
+struct List
+{
+    template <int _s>
+    using O = typename Overlay<List, _s, _Pack...>::O;
+
+    template <template <class...> class _S>
+    using Pass = _S<_Pack...>;
+
+    template <int _i>
+    using At = typename O<_i>
+    ::template Pass<First>;
+};
+
+template <int _i>
+using At = typename List<int, char>
+::template At<_i>;
+
+template <int _i>
+void func_crash(At<_i>&) {}
+
+int main(int argc, char *argv[])
+{
+    char ccc;
+    int iii;
+    func_crash<0>(iii);
+}
Index: gcc/testsuite/g++.dg/ipa/pr63838.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/ipa/pr63838.C	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/g++.dg/ipa/pr63838.C	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,56 @@
+// PR ipa/63838
+// { dg-do run }
+// { dg-options "-O2 -fdump-ipa-pure-const" }
+// { dg-final { scan-ipa-dump-not "Function found to be nothrow: void foo" "pure-const" } }
+// { dg-final { scan-ipa-dump-not "Function found to be nothrow: void bar" "pure-const" } }
+// { dg-final { cleanup-ipa-dump "pure-const" } }
+
+__attribute__((noinline, noclone)) static void bar (int);
+volatile int v;
+void (*fn) ();
+struct S { S () { v++; } ~S () { v++; } };
+
+__attribute__((noinline, noclone)) static void
+foo (int x)
+{
+  v++;
+  if (x == 5)
+    bar (x);
+}
+
+__attribute__((noinline, noclone)) static void
+bar (int x)
+{
+  v++;
+  if (x == 6)
+    foo (x);
+  else if (x == 5)
+    fn ();
+}
+
+__attribute__((noinline, noclone)) int
+baz (int x)
+{
+  S s;
+  foo (x);
+}
+
+void
+throw0 ()
+{
+  throw 0;
+}
+
+int
+main ()
+{
+  fn = throw0;
+  asm volatile ("" : : : "memory");
+  try
+    {
+      baz (5);
+    }
+  catch (int)
+    {
+    }
+}
Index: gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/overflow-sub-3.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+/* { dg-options "-fsanitize=signed-integer-overflow" } */
+
+__attribute__((noinline, noclone)) int
+foo1 (int x, int y)
+{
+  return x - y;
+}
+
+__attribute__((noinline, noclone)) int
+foo2 (int x, int y)
+{
+  unsigned int xa = (unsigned int) x - (__INT_MAX__ - 3);
+  xa &= 3;
+  x = __INT_MAX__ - 3 + xa;
+  unsigned int ya = y + 1U;
+  ya &= 1;
+  y = ya - 1;
+  return x - y;
+}
+
+int
+main ()
+{
+  int xm1, y;
+  for (xm1 = __INT_MAX__ - 4; xm1 < __INT_MAX__; xm1++)
+    for (y = -1; y <= 0; y++)
+      if (foo1 (xm1 + 1, y) != (int) (xm1 + 1U - y)
+	  || foo2 (xm1 + 1, y) != (int) (xm1 + 1U - y))
+	__builtin_abort ();
+  return 0;
+}
+/* { dg-output ":7:\[0-9]\[^\n\r]*signed integer overflow: 2147483647 - -1 cannot be represented in type 'int'\[^\n\r]*(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*:19:\[0-9]\[^\n\r]*signed integer overflow: 2147483647 - -1 cannot be represented in type 'int'" } */
Index: gcc/testsuite/c-c++-common/ubsan/undefined-2.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/ubsan/undefined-2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/ubsan/undefined-2.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,26 @@
+/* { dg-do run } */
+/* { dg-options "-fsanitize=undefined" } */
+/* { dg-additional-options "-std=gnu11" { target c } } */
+/* { dg-additional-options "-std=c++11" { target c++ } } */
+
+#include <stdio.h>
+
+volatile int w, z;
+
+__attribute__ ((noinline, noclone)) int
+foo (int x, int y)
+{
+  z++;
+  return x << y;
+}
+
+int
+main ()
+{
+  fputs ("1st\n", stderr);
+  w = foo (0, -__INT_MAX__);
+  return 0;
+}
+
+/* { dg-output "1st(\n|\r\n|\r)" } */
+/* { dg-output "\[^\n\r]*shift exponent -\[^\n\r]* is negative\[^\n\r]*(\n|\r\n|\r)" } */
Index: gcc/testsuite/c-c++-common/pr56493.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr56493.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/pr56493.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,16 @@
+/* PR c++/56493 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-gimple" } */
+
+unsigned long long bar (void);
+int x;
+
+void
+foo (void)
+{
+  x += bar ();
+}
+
+/* Verify we narrow the addition from unsigned long long to unsigned int type.  */
+/* { dg-final { scan-tree-dump "  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.*  (\[a-zA-Z._0-9]*) = \\(unsigned int\\) \[^;\n\r]*;.* = \\1 \\+ \\2;" "gimple" { target { ilp32 || lp64 } } } } */
+/* { dg-final { cleanup-tree-dump "gimple" } } */
Index: gcc/testsuite/c-c++-common/gomp/pr60823-4.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/gomp/pr60823-4.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/testsuite/c-c++-common/gomp/pr60823-4.c	(.../branches/gcc-4_9-branch)
@@ -0,0 +1,7 @@
+/* PR tree-optimization/63915 */
+/* { dg-do run } */
+/* { dg-require-effective-target vect_simd_clones } */
+/* { dg-options "-O2 -fopenmp-simd" } */
+/* { dg-additional-options "-fpic" { target fpic } } */
+
+#include "pr60823-2.c"
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,21 @@
+2014-12-19  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/60955
+	* pt.c (struct warning_sentinel): Move it...
+	* cp-tree.h: ... here.
+	* semantics.c (force_paren_expr): Use it.
+
+2014-11-21  Jason Merrill  <jason@redhat.com>
+
+	PR c++/63849
+	* mangle.c (decl_mangling_context): Use template_type_parameter_p.
+
+2014-11-11  Paolo Carlini  <paolo.carlini@oracle.com>
+
+	PR c++/63265
+	* pt.c (tsubst_copy_and_build, case COND_EXPR): Maybe fold to
+	constant the condition.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/cp/pt.c
===================================================================
--- a/src/gcc/cp/pt.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/pt.c	(.../branches/gcc-4_9-branch)
@@ -14151,16 +14151,6 @@
   return t;
 }
 
-/* Sentinel to disable certain warnings during template substitution.  */
-
-struct warning_sentinel {
-  int &flag;
-  int val;
-  warning_sentinel(int& flag, bool suppress=true)
-    : flag(flag), val(flag) { if (suppress) flag = 0; }
-  ~warning_sentinel() { flag = val; }
-};
-
 /* Like tsubst but deals with expressions and performs semantic
    analysis.  FUNCTION_P is true if T is the "F" in "F (ARGS)".  */
 
@@ -14875,11 +14865,13 @@
     case COND_EXPR:
       {
 	tree cond = RECUR (TREE_OPERAND (t, 0));
+	tree folded_cond = (maybe_constant_value
+			    (fold_non_dependent_expr_sfinae (cond, tf_none)));
 	tree exp1, exp2;
 
-	if (TREE_CODE (cond) == INTEGER_CST)
+	if (TREE_CODE (folded_cond) == INTEGER_CST)
 	  {
-	    if (integer_zerop (cond))
+	    if (integer_zerop (folded_cond))
 	      {
 		++c_inhibit_evaluation_warnings;
 		exp1 = RECUR (TREE_OPERAND (t, 1));
@@ -14893,6 +14885,7 @@
 		exp2 = RECUR (TREE_OPERAND (t, 2));
 		--c_inhibit_evaluation_warnings;
 	      }
+	    cond = folded_cond;
 	  }
 	else
 	  {
Index: gcc/cp/semantics.c
===================================================================
--- a/src/gcc/cp/semantics.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/semantics.c	(.../branches/gcc-4_9-branch)
@@ -1629,6 +1629,9 @@
 	  tree type = unlowered_expr_type (expr);
 	  bool rval = !!(kind & clk_rvalueref);
 	  type = cp_build_reference_type (type, rval);
+	  /* This inhibits warnings in, eg, cxx_mark_addressable
+	     (c++/60955).  */
+	  warning_sentinel s (extra_warnings);
 	  expr = build_static_cast (type, expr, tf_error);
 	  if (expr != error_mark_node)
 	    REF_PARENTHESIZED_P (expr) = true;
Index: gcc/cp/mangle.c
===================================================================
--- a/src/gcc/cp/mangle.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/mangle.c	(.../branches/gcc-4_9-branch)
@@ -763,8 +763,7 @@
       if (extra)
 	return extra;
     }
-    else if (TREE_CODE (decl) == TYPE_DECL
-	     && TREE_CODE (TREE_TYPE (decl)) == TEMPLATE_TYPE_PARM)
+  else if (template_type_parameter_p (decl))
      /* template type parms have no mangling context.  */
       return NULL_TREE;
   return CP_DECL_CONTEXT (decl);
Index: gcc/cp/cp-tree.h
===================================================================
--- a/src/gcc/cp/cp-tree.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/cp/cp-tree.h	(.../branches/gcc-4_9-branch)
@@ -1098,6 +1098,18 @@
 #define processing_specialization scope_chain->x_processing_specialization
 #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation
 
+/* RAII sentinel to disable certain warnings during template substitution
+   and elsewhere.  */
+
+struct warning_sentinel
+{
+  int &flag;
+  int val;
+  warning_sentinel(int& flag, bool suppress=true)
+    : flag(flag), val(flag) { if (suppress) flag = 0; }
+  ~warning_sentinel() { flag = val; }
+};
+
 /* The cached class binding level, from the most recently exited
    class, or NULL if none.  */
 
Index: gcc/ipa-pure-const.c
===================================================================
--- a/src/gcc/ipa-pure-const.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa-pure-const.c	(.../branches/gcc-4_9-branch)
@@ -1434,7 +1434,7 @@
 	      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))
 	        can_throw = true;
 	    }
-          for (ie = node->indirect_calls; ie; ie = ie->next_callee)
+          for (ie = w->indirect_calls; ie; ie = ie->next_callee)
 	    if (ie->can_throw_external)
 	      {
 		can_throw = true;
Index: gcc/config.in
===================================================================
--- a/src/gcc/config.in	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config.in	(.../branches/gcc-4_9-branch)
@@ -1211,6 +1211,12 @@
 #endif
 
 
+/* Define if isl_schedule_constraints_compute_schedule exists. */
+#ifndef USED_FOR_TARGET
+#undef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#endif
+
+
 /* Define to 1 if you have the `kill' function. */
 #ifndef USED_FOR_TARGET
 #undef HAVE_KILL
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_9-branch)
@@ -7630,11 +7630,13 @@
       break;
 
     case COMPOUND_LITERAL_EXPR:
-      /* Allow COMPOUND_LITERAL_EXPR in initializers, if e.g.
-	 rtl_for_decl_init is called on DECL_INITIAL with
-	 COMPOUNT_LITERAL_EXPRs in it, they aren't gimplified.  */
-      if (modifier == EXPAND_INITIALIZER
-	  && COMPOUND_LITERAL_EXPR_DECL (exp))
+      /* Allow COMPOUND_LITERAL_EXPR in initializers or coming from
+	 initializers, if e.g. rtl_for_decl_init is called on DECL_INITIAL
+	 with COMPOUND_LITERAL_EXPRs in it, or ARRAY_REF on a const static
+	 array with address of COMPOUND_LITERAL_EXPR in DECL_INITIAL;
+	 the initializers aren't gimplified.  */
+      if (COMPOUND_LITERAL_EXPR_DECL (exp)
+	  && TREE_STATIC (COMPOUND_LITERAL_EXPR_DECL (exp)))
 	return expand_expr_addr_expr_1 (COMPOUND_LITERAL_EXPR_DECL (exp),
 					target, tmode, modifier, as);
       /* FALLTHRU */
Index: gcc/ada/mlib-utl.adb
===================================================================
--- a/src/gcc/ada/mlib-utl.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/mlib-utl.adb	(.../branches/gcc-4_9-branch)
@@ -282,6 +282,10 @@
          if not Opt.Quiet_Output then
             Write_Str  (Ranlib_Name.all);
             Write_Char (' ');
+            for J in Ranlib_Options'Range loop
+               Write_Str  (Ranlib_Options (J).all);
+               Write_Char (' ');
+            end loop;
             Write_Line (Arguments (Ar_Options'Length + 1).all);
          end if;
 
Index: gcc/ada/ChangeLog
===================================================================
--- a/src/gcc/ada/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,27 @@
+2014-11-24  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (push_range_check_info): Replace early test
+	with assertion.
+	(Raise_Error_to_gnu): Do not call push_range_check_info if the loop
+	stack is empty.
+	* gcc-interface/utils.c (convert_to_fat_pointer): Fix formatting.
+	* gcc-interface/utils2.c (gnat_invariant_expr): Deal with padded types
+	and revert latest change.
+
+2014-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2014-11-20  Vincent Celier  <celier@adacore.com>
+
+	PR ada/47500
+	* back_end.adb (Scan_Back_End_Switches): Skip switch -G and
+	its argument.
+
+2014-11-11  Simon Wright  <simon@pushface.org>
+
+	PR ada/42978
+	* mlib-utl.adb (ar): Output the options passed to ranlib.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/ada/back_end.adb
===================================================================
--- a/src/gcc/ada/back_end.adb	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/back_end.adb	(.../branches/gcc-4_9-branch)
@@ -210,9 +210,10 @@
          Last  : constant Natural  := Switch_Last (Switch_Chars);
 
       begin
-         --  Skip -o or internal GCC switches together with their argument
+         --  Skip -o, -G or internal GCC switches together with their argument.
 
          if Switch_Chars (First .. Last) = "o"
+           or else Switch_Chars (First .. Last) = "G"
            or else Is_Internal_GCC_Switch (Switch_Chars)
          then
             Next_Arg := Next_Arg + 1;
Index: gcc/ada/gcc-interface/utils.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/utils.c	(.../branches/gcc-4_9-branch)
@@ -4371,8 +4371,7 @@
 	{
 	  /* The template type can still be dummy at this point so we build an
 	     empty constructor.  The middle-end will fill it in with zeros.  */
-	  t = build_constructor (template_type,
-				 NULL);
+	  t = build_constructor (template_type, NULL);
 	  TREE_CONSTANT (t) = TREE_STATIC (t) = 1;
 	  null_bounds = build_unary_op (ADDR_EXPR, NULL_TREE, t);
 	  SET_TYPE_NULL_BOUNDS (ptr_template_type, null_bounds);
Index: gcc/ada/gcc-interface/utils2.c
===================================================================
--- a/src/gcc/ada/gcc-interface/utils2.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/utils2.c	(.../branches/gcc-4_9-branch)
@@ -2784,7 +2784,13 @@
 	  || (TREE_CODE (expr) == VAR_DECL && TREE_READONLY (expr)))
 	 && decl_function_context (expr) == current_function_decl
 	 && DECL_INITIAL (expr))
-    expr = remove_conversions (DECL_INITIAL (expr), false);
+    {
+      expr = DECL_INITIAL (expr);
+      /* Look into CONSTRUCTORs built to initialize padded types.  */
+      if (TYPE_IS_PADDING_P (TREE_TYPE (expr)))
+	expr = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (expr))), expr);
+      expr = remove_conversions (expr, false);
+    }
 
   if (TREE_CONSTANT (expr))
     return fold_convert (type, expr);
@@ -2840,7 +2846,7 @@
   if (!TREE_READONLY (t))
     return NULL_TREE;
 
-  if (TREE_CODE (t) == CONSTRUCTOR || TREE_CODE (t) == PARM_DECL)
+  if (TREE_CODE (t) == PARM_DECL)
     return fold_convert (type, expr);
 
   if (TREE_CODE (t) == VAR_DECL
Index: gcc/ada/gcc-interface/trans.c
===================================================================
--- a/src/gcc/ada/gcc-interface/trans.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ada/gcc-interface/trans.c	(.../branches/gcc-4_9-branch)
@@ -2424,9 +2424,6 @@
   struct loop_info_d *iter = NULL;
   unsigned int i;
 
-  if (vec_safe_is_empty (gnu_loop_stack))
-    return NULL;
-
   var = remove_conversions (var, false);
 
   if (TREE_CODE (var) != VAR_DECL)
@@ -2435,6 +2432,8 @@
   if (decl_function_context (var) != current_function_decl)
     return NULL;
 
+  gcc_assert (vec_safe_length (gnu_loop_stack) > 0);
+
   for (i = vec_safe_length (gnu_loop_stack) - 1;
        vec_safe_iterate (gnu_loop_stack, i, &iter);
        i--)
@@ -5165,6 +5164,7 @@
 	     the original checks reinstated, and a run time selection.
 	     The former loop will be suitable for vectorization.  */
 	  if (flag_unswitch_loops
+	      && !vec_safe_is_empty (gnu_loop_stack)
 	      && (!gnu_low_bound
 		  || (gnu_low_bound = gnat_invariant_expr (gnu_low_bound)))
 	      && (!gnu_high_bound
Index: gcc/tsan.c
===================================================================
--- a/src/gcc/tsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tsan.c	(.../branches/gcc-4_9-branch)
@@ -651,25 +651,24 @@
 static void
 instrument_func_entry (void)
 {
-  basic_block succ_bb;
-  gimple_stmt_iterator gsi;
   tree ret_addr, builtin_decl;
   gimple g;
+  gimple_seq seq = NULL;
 
-  succ_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));
-  gsi = gsi_after_labels (succ_bb);
-
   builtin_decl = builtin_decl_implicit (BUILT_IN_RETURN_ADDRESS);
   g = gimple_build_call (builtin_decl, 1, integer_zero_node);
   ret_addr = make_ssa_name (ptr_type_node, NULL);
   gimple_call_set_lhs (g, ret_addr);
   gimple_set_location (g, cfun->function_start_locus);
-  gsi_insert_before (&gsi, g, GSI_SAME_STMT);
+  gimple_seq_add_stmt_without_update (&seq, g);
 
-  builtin_decl =  builtin_decl_implicit (BUILT_IN_TSAN_FUNC_ENTRY);
+  builtin_decl = builtin_decl_implicit (BUILT_IN_TSAN_FUNC_ENTRY);
   g = gimple_build_call (builtin_decl, 1, ret_addr);
   gimple_set_location (g, cfun->function_start_locus);
-  gsi_insert_before (&gsi, g, GSI_SAME_STMT);
+  gimple_seq_add_stmt_without_update (&seq, g);
+
+  edge e = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun));
+  gsi_insert_seq_on_edge_immediate (e, seq);
 }
 
 /* Instruments function exits.  */
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_9-branch)
@@ -2683,6 +2683,18 @@
     }
 
   lhsaddr = save_expr (lhsaddr);
+  if (TREE_CODE (lhsaddr) != SAVE_EXPR
+      && (TREE_CODE (lhsaddr) != ADDR_EXPR
+	  || TREE_CODE (TREE_OPERAND (lhsaddr, 0)) != VAR_DECL))
+    {
+      /* Make sure LHS is simple enough so that goa_lhs_expr_p can recognize
+	 it even after unsharing function body.  */
+      tree var = create_tmp_var_raw (TREE_TYPE (lhsaddr), NULL);
+      DECL_CONTEXT (var) = current_function_decl;
+      lhsaddr = build4 (TARGET_EXPR, TREE_TYPE (lhsaddr), var, lhsaddr,
+			NULL_TREE, NULL_TREE);
+    }
+
   rhs = gfc_evaluate_now (rse.expr, &block);
 
   if (((atomic_code->ext.omp_atomic & GFC_OMP_ATOMIC_MASK)
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,12 @@
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/63938
+	* trans-openmp.c (gfc_trans_omp_atomic): Make sure lhsaddr is
+	simple enough for goa_lhs_expr_p.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-4_9-branch)
@@ -5495,8 +5495,31 @@
 AC_ARG_VAR(CLOOGINC,[How to find CLOOG include files])
 if test "x${CLOOGLIBS}" != "x" ; then 
    AC_DEFINE(HAVE_cloog, 1, [Define if cloog is in use.])
+
+  # Check whether isl_schedule_constraints_compute_schedule is available;
+  # it's new in ISL-0.13.
+  saved_CFLAGS="$CFLAGS"
+  CFLAGS="$CFLAGS $ISLINC"
+  saved_LIBS="$LIBS"
+  LIBS="$LIBS $CLOOGLIBS $ISLLIBS $GMPLIBS"
+
+  AC_MSG_CHECKING([Checking for isl_schedule_constraints_compute_schedule])
+  AC_TRY_LINK([#include <isl/schedule.h>],
+              [isl_schedule_constraints_compute_schedule (NULL);],
+              [ac_has_isl_schedule_constraints_compute_schedule=yes],
+              [ac_has_isl_schedule_constraints_compute_schedule=no])
+  AC_MSG_RESULT($ac_has_isl_schedule_constraints_compute_schedule)
+
+  LIBS="$saved_LIBS"
+  CFLAGS="$saved_CFLAGS"
+
+  if test x"$ac_has_isl_schedule_constraints_compute_schedule" = x"yes"; then
+     AC_DEFINE(HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE, 1,
+               [Define if isl_schedule_constraints_compute_schedule exists.])
+  fi
 fi
 
+
 # Check for plugin support
 AC_ARG_ENABLE(plugin,
 [AS_HELP_STRING([--enable-plugin], [enable plugin support])],
Index: gcc/alias.c
===================================================================
--- a/src/gcc/alias.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/alias.c	(.../branches/gcc-4_9-branch)
@@ -2517,6 +2517,7 @@
 true_dependence_1 (const_rtx mem, enum machine_mode mem_mode, rtx mem_addr,
 		   const_rtx x, rtx x_addr, bool mem_canonicalized)
 {
+  rtx true_mem_addr;
   rtx base;
   int ret;
 
@@ -2536,10 +2537,26 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
+  if (! x_addr)
+    x_addr = XEXP (x, 0);
+  x_addr = get_addr (x_addr);
+
+  if (! mem_addr)
+    {
+      mem_addr = XEXP (mem, 0);
+      if (mem_mode == VOIDmode)
+	mem_mode = GET_MODE (mem);
+    }
+  true_mem_addr = get_addr (mem_addr);
+
   /* Read-only memory is by definition never modified, and therefore can't
-     conflict with anything.  We don't expect to find read-only set on MEM,
-     but stupid user tricks can produce them, so don't die.  */
-  if (MEM_READONLY_P (x))
+     conflict with anything.  However, don't assume anything when AND
+     addresses are involved and leave to the code below to determine
+     dependence.  We don't expect to find read-only set on MEM, but
+     stupid user tricks can produce them, so don't die.  */
+  if (MEM_READONLY_P (x)
+      && GET_CODE (x_addr) != AND
+      && GET_CODE (true_mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2548,29 +2565,6 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  if (! mem_addr)
-    {
-      mem_addr = XEXP (mem, 0);
-      if (mem_mode == VOIDmode)
-	mem_mode = GET_MODE (mem);
-    }
-
-  if (! x_addr)
-    {
-      x_addr = XEXP (x, 0);
-      if (!((GET_CODE (x_addr) == VALUE
-	     && GET_CODE (mem_addr) != VALUE
-	     && reg_mentioned_p (x_addr, mem_addr))
-	    || (GET_CODE (x_addr) != VALUE
-		&& GET_CODE (mem_addr) == VALUE
-		&& reg_mentioned_p (mem_addr, x_addr))))
-	{
-	  x_addr = get_addr (x_addr);
-	  if (! mem_canonicalized)
-	    mem_addr = get_addr (mem_addr);
-	}
-    }
-
   base = find_base_term (x_addr);
   if (base && (GET_CODE (base) == LABEL_REF
 	       || (GET_CODE (base) == SYMBOL_REF
@@ -2577,14 +2571,14 @@
 		   && CONSTANT_POOL_ADDRESS_P (base))))
     return 0;
 
-  rtx mem_base = find_base_term (mem_addr);
-  if (! base_alias_check (x_addr, base, mem_addr, mem_base,
+  rtx mem_base = find_base_term (true_mem_addr);
+  if (! base_alias_check (x_addr, base, true_mem_addr, mem_base,
 			  GET_MODE (x), mem_mode))
     return 0;
 
   x_addr = canon_rtx (x_addr);
   if (!mem_canonicalized)
-    mem_addr = canon_rtx (mem_addr);
+    mem_addr = canon_rtx (true_mem_addr);
 
   if ((ret = memrefs_conflict_p (GET_MODE_SIZE (mem_mode), mem_addr,
 				 SIZE_FOR_MODE (x), x_addr, 0)) != -1)
@@ -2637,6 +2631,7 @@
 		    bool mem_canonicalized, bool x_canonicalized, bool writep)
 {
   rtx mem_addr;
+  rtx true_mem_addr, true_x_addr;
   rtx base;
   int ret;
 
@@ -2657,8 +2652,20 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
-  /* A read from read-only memory can't conflict with read-write memory.  */
-  if (!writep && MEM_READONLY_P (mem))
+  if (!x_addr)
+    x_addr = XEXP (x, 0);
+  true_x_addr = get_addr (x_addr);
+
+  mem_addr = XEXP (mem, 0);
+  true_mem_addr = get_addr (mem_addr);
+
+  /* A read from read-only memory can't conflict with read-write memory.
+     Don't assume anything when AND addresses are involved and leave to
+     the code below to determine dependence.  */
+  if (!writep
+      && MEM_READONLY_P (mem)
+      && GET_CODE (true_x_addr) != AND
+      && GET_CODE (true_mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2667,24 +2674,7 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  mem_addr = XEXP (mem, 0);
-  if (!x_addr)
-    {
-      x_addr = XEXP (x, 0);
-      if (!((GET_CODE (x_addr) == VALUE
-	     && GET_CODE (mem_addr) != VALUE
-	     && reg_mentioned_p (x_addr, mem_addr))
-	    || (GET_CODE (x_addr) != VALUE
-		&& GET_CODE (mem_addr) == VALUE
-		&& reg_mentioned_p (mem_addr, x_addr))))
-	{
-	  x_addr = get_addr (x_addr);
-	  if (!mem_canonicalized)
-	    mem_addr = get_addr (mem_addr);
-	}
-    }
-
-  base = find_base_term (mem_addr);
+  base = find_base_term (true_mem_addr);
   if (! writep
       && base
       && (GET_CODE (base) == LABEL_REF
@@ -2692,18 +2682,18 @@
 	      && CONSTANT_POOL_ADDRESS_P (base))))
     return 0;
 
-  rtx x_base = find_base_term (x_addr);
-  if (! base_alias_check (x_addr, x_base, mem_addr, base, GET_MODE (x),
-			  GET_MODE (mem)))
+  rtx x_base = find_base_term (true_x_addr);
+  if (! base_alias_check (true_x_addr, x_base, true_mem_addr, base,
+			  GET_MODE (x), GET_MODE (mem)))
     return 0;
 
   if (!x_canonicalized)
     {
-      x_addr = canon_rtx (x_addr);
+      x_addr = canon_rtx (true_x_addr);
       x_mode = GET_MODE (x);
     }
   if (!mem_canonicalized)
-    mem_addr = canon_rtx (mem_addr);
+    mem_addr = canon_rtx (true_mem_addr);
 
   if ((ret = memrefs_conflict_p (SIZE_FOR_MODE (mem), mem_addr,
 				 GET_MODE_SIZE (x_mode), x_addr, 0)) != -1)
@@ -2771,10 +2761,20 @@
       || MEM_ALIAS_SET (mem) == ALIAS_SET_MEMORY_BARRIER)
     return 1;
 
+  x_addr = XEXP (x, 0);
+  x_addr = get_addr (x_addr);
+
+  mem_addr = XEXP (mem, 0);
+  mem_addr = get_addr (mem_addr);
+
   /* Read-only memory is by definition never modified, and therefore can't
-     conflict with anything.  We don't expect to find read-only set on MEM,
-     but stupid user tricks can produce them, so don't die.  */
-  if (MEM_READONLY_P (x))
+     conflict with anything.  However, don't assume anything when AND
+     addresses are involved and leave to the code below to determine
+     dependence.  We don't expect to find read-only set on MEM, but
+     stupid user tricks can produce them, so don't die.  */
+  if (MEM_READONLY_P (x)
+      && GET_CODE (x_addr) != AND
+      && GET_CODE (mem_addr) != AND)
     return 0;
 
   /* If we have MEMs referring to different address spaces (which can
@@ -2783,19 +2783,6 @@
   if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
     return 1;
 
-  x_addr = XEXP (x, 0);
-  mem_addr = XEXP (mem, 0);
-  if (!((GET_CODE (x_addr) == VALUE
-	 && GET_CODE (mem_addr) != VALUE
-	 && reg_mentioned_p (x_addr, mem_addr))
-	|| (GET_CODE (x_addr) != VALUE
-	    && GET_CODE (mem_addr) == VALUE
-	    && reg_mentioned_p (mem_addr, x_addr))))
-    {
-      x_addr = get_addr (x_addr);
-      mem_addr = get_addr (mem_addr);
-    }
-
   rtx x_base = find_base_term (x_addr);
   rtx mem_base = find_base_term (mem_addr);
   if (! base_alias_check (x_addr, x_base, mem_addr, mem_base,
@@ -2802,9 +2789,6 @@
 			  GET_MODE (x), GET_MODE (mem_addr)))
     return 0;
 
-  x_addr = canon_rtx (x_addr);
-  mem_addr = canon_rtx (mem_addr);
-
   if (nonoverlapping_memrefs_p (mem, x, true))
     return 0;
 
Index: gcc/tree-vect-loop.c
===================================================================
--- a/src/gcc/tree-vect-loop.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-loop.c	(.../branches/gcc-4_9-branch)
@@ -1647,6 +1647,13 @@
       return false;
     }
 
+  /* Classify all cross-iteration scalar data-flow cycles.
+     Cross-iteration cycles caused by virtual phis are analyzed separately.  */
+
+  vect_analyze_scalar_cycles (loop_vinfo);
+
+  vect_pattern_recog (loop_vinfo, NULL);
+
   /* Analyze the access patterns of the data-refs in the loop (consecutive,
      complex, etc.). FORNOW: Only handle consecutive access pattern.  */
 
@@ -1659,13 +1666,6 @@
       return false;
     }
 
-  /* Classify all cross-iteration scalar data-flow cycles.
-     Cross-iteration cycles caused by virtual phis are analyzed separately.  */
-
-  vect_analyze_scalar_cycles (loop_vinfo);
-
-  vect_pattern_recog (loop_vinfo, NULL);
-
   /* Data-flow analysis to detect stmts that do not need to be vectorized.  */
 
   ok = vect_mark_stmts_to_be_vectorized (loop_vinfo);
Index: gcc/tree-data-ref.c
===================================================================
--- a/src/gcc/tree-data-ref.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-data-ref.c	(.../branches/gcc-4_9-branch)
@@ -663,6 +663,9 @@
 
     case SSA_NAME:
       {
+	if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op0))
+	  return false;
+
 	gimple def_stmt = SSA_NAME_DEF_STMT (op0);
 	enum tree_code subcode;
 
Index: gcc/ipa-inline-analysis.c
===================================================================
--- a/src/gcc/ipa-inline-analysis.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ipa-inline-analysis.c	(.../branches/gcc-4_9-branch)
@@ -861,9 +861,19 @@
 	}
       if (c->code == IS_NOT_CONSTANT || c->code == CHANGED)
 	continue;
-      res = fold_binary_to_constant (c->code, boolean_type_node, val, c->val);
-      if (res && integer_zerop (res))
-	continue;
+
+      if (operand_equal_p (TYPE_SIZE (TREE_TYPE (c->val)),
+			   TYPE_SIZE (TREE_TYPE (val)), 0))
+	{
+	  val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (c->val), val);
+
+	  res = val
+	    ? fold_binary_to_constant (c->code, boolean_type_node, val, c->val)
+	    : NULL;
+
+	  if (res && integer_zerop (res))
+	    continue;
+	}
       clause |= 1 << (i + predicate_first_dynamic_condition);
     }
   return clause;
Index: gcc/expmed.c
===================================================================
--- a/src/gcc/expmed.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/expmed.c	(.../branches/gcc-4_9-branch)
@@ -463,7 +463,7 @@
   /* Check for cases where the C++ memory model applies.  */
   if (bitregion_end != 0
       && (bitnum - bitnum % modesize < bitregion_start
-	  || bitnum - bitnum % modesize + modesize > bitregion_end))
+	  || bitnum - bitnum % modesize + modesize - 1 > bitregion_end))
     return false;
 
   return true;
@@ -3321,6 +3321,9 @@
       enum mult_variant variant;
       struct algorithm algorithm;
 
+      if (coeff == 0)
+	return CONST0_RTX (mode);
+
       /* Special case powers of two.  */
       if (EXACT_POWER_OF_2_OR_ZERO_P (coeff))
 	{
Index: gcc/tree-predcom.c
===================================================================
--- a/src/gcc/tree-predcom.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-predcom.c	(.../branches/gcc-4_9-branch)
@@ -1391,8 +1391,8 @@
     off = size_binop (PLUS_EXPR, off,
 		      size_binop (MULT_EXPR, DR_STEP (dr), ssize_int (iter)));
   tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);
-  addr = force_gimple_operand_1 (addr, stmts, is_gimple_mem_ref_addr,
-				 NULL_TREE);
+  addr = force_gimple_operand_1 (unshare_expr (addr), stmts,
+				 is_gimple_mem_ref_addr, NULL_TREE);
   tree alias_ptr = fold_convert (reference_alias_ptr_type (DR_REF (dr)), coff);
   /* While data-ref analysis punts on bit offsets it still handles
      bitfield accesses at byte boundaries.  Cope with that.  Note that
Index: gcc/ubsan.c
===================================================================
--- a/src/gcc/ubsan.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ubsan.c	(.../branches/gcc-4_9-branch)
@@ -47,6 +47,7 @@
 #include "asan.h"
 #include "gimplify-me.h"
 #include "intl.h"
+#include "tree-eh.h"
 
 /* Map from a tree to a VAR_DECL tree.  */
 
@@ -807,7 +808,9 @@
       || TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)
     return;
 
+  bool can_throw = stmt_could_throw_p (stmt);
   location_t loc = gimple_location (stmt);
+  tree lhs = gimple_assign_lhs (stmt);
   tree ptype = build_pointer_type (TREE_TYPE (rhs));
   tree atype = reference_alias_ptr_type (rhs);
   gimple g = gimple_build_assign (make_ssa_name (ptype, NULL),
@@ -817,9 +820,24 @@
   tree mem = build2 (MEM_REF, utype, gimple_assign_lhs (g),
 		     build_int_cst (atype, 0));
   tree urhs = make_ssa_name (utype, NULL);
-  g = gimple_build_assign (urhs, mem);
-  gimple_set_location (g, loc);
-  gsi_insert_before (gsi, g, GSI_SAME_STMT);
+  if (can_throw)
+    {
+      gimple_assign_set_lhs (stmt, urhs);
+      g = gimple_build_assign_with_ops (NOP_EXPR, lhs, urhs, NULL_TREE);
+      gimple_set_location (g, loc);
+      edge e = find_fallthru_edge (gimple_bb (stmt)->succs);
+      gsi_insert_on_edge_immediate (e, g);
+      gimple_assign_set_rhs_from_tree (gsi, mem);
+      update_stmt (stmt);
+      *gsi = gsi_for_stmt (g);
+      g = stmt;
+    }
+  else
+    {
+      g = gimple_build_assign (urhs, mem);
+      gimple_set_location (g, loc);
+      gsi_insert_before (gsi, g, GSI_SAME_STMT);
+    }
   minv = fold_convert (utype, minv);
   maxv = fold_convert (utype, maxv);
   if (!integer_zerop (minv))
@@ -841,8 +859,11 @@
   gimple_set_location (g, loc);
   gsi_insert_after (gsi, g, GSI_NEW_STMT);
 
-  gimple_assign_set_rhs_with_ops (&gsi2, NOP_EXPR, urhs, NULL_TREE);
-  update_stmt (stmt);
+  if (!can_throw)
+    {
+      gimple_assign_set_rhs_with_ops (&gsi2, NOP_EXPR, urhs, NULL_TREE);
+      update_stmt (stmt);
+    }
 
   tree data = ubsan_create_data ("__ubsan_invalid_value_data",
 				 &loc, NULL,
Index: gcc/tree-ssa-forwprop.c
===================================================================
--- a/src/gcc/tree-ssa-forwprop.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-forwprop.c	(.../branches/gcc-4_9-branch)
@@ -1534,7 +1534,8 @@
 	  use_operand_p use_p;
 
 	  if (!tree_fits_shwi_p (val2)
-	      || !tree_fits_uhwi_p (len2))
+	      || !tree_fits_uhwi_p (len2)
+	      || compare_tree_int (len2, 1024) == 1)
 	    break;
 	  if (is_gimple_call (stmt1))
 	    {
@@ -1600,7 +1601,8 @@
 	     is not constant, or is bigger than memcpy length, bail out.  */
 	  if (diff == NULL
 	      || !tree_fits_uhwi_p (diff)
-	      || tree_int_cst_lt (len1, diff))
+	      || tree_int_cst_lt (len1, diff)
+	      || compare_tree_int (diff, 1024) == 1)
 	    break;
 
 	  /* Use maximum of difference plus memset length and memcpy length
@@ -3178,7 +3180,9 @@
 	  && (INTEGRAL_TYPE_P (TREE_TYPE (def_op))
 	      || POINTER_TYPE_P (TREE_TYPE (def_op)))
 	  && (TYPE_PRECISION (TREE_TYPE (op))
-	      == TYPE_PRECISION (TREE_TYPE (def_op))))
+	      == TYPE_PRECISION (TREE_TYPE (def_op)))
+	  && (TYPE_SIZE (TREE_TYPE (op))
+	      == TYPE_SIZE (TREE_TYPE (def_op))))
 	{
 	  TREE_OPERAND (gimple_assign_rhs1 (stmt), 0) = def_op;
 	  update_stmt (stmt);
Index: gcc/graphite-clast-to-gimple.c
===================================================================
--- a/src/gcc/graphite-clast-to-gimple.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-clast-to-gimple.c	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,12 @@
 #include <isl/aff.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/lp.h>
+#include <isl/deprecated/ilp_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/graphite-optimize-isl.c
===================================================================
--- a/src/gcc/graphite-optimize-isl.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-optimize-isl.c	(.../branches/gcc-4_9-branch)
@@ -28,7 +28,11 @@
 #include <isl/band.h>
 #include <isl/aff.h>
 #include <isl/options.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
@@ -373,7 +377,11 @@
 	{
 	  for (i = ScheduleDimensions - 1 ;  i >= 0 ; i--)
 	    {
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+	      if (isl_band_member_is_coincident (Band, i))
+#else
 	      if (isl_band_member_is_zero_distance (Band, i))
+#endif
 		{
 		  isl_map *TileMap;
 		  isl_union_map *TileUMap;
Index: gcc/varasm.c
===================================================================
--- a/src/gcc/varasm.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/varasm.c	(.../branches/gcc-4_9-branch)
@@ -95,11 +95,6 @@
 
 bool first_function_block_is_cold;
 
-/* We give all constants their own alias set.  Perhaps redundant with
-   MEM_READONLY_P, but pre-dates it.  */
-
-static alias_set_type const_alias_set;
-
 /* Whether we saw any functions with no_split_stack.  */
 
 static bool saw_no_split_stack;
@@ -3250,7 +3245,6 @@
   rtl = gen_const_mem (TYPE_MODE (TREE_TYPE (exp)), symbol);
   set_mem_attributes (rtl, exp, 1);
   set_mem_alias_set (rtl, 0);
-  set_mem_alias_set (rtl, const_alias_set);
 
   /* We cannot share RTX'es in pool entries.
      Mark this piece of RTL as required for unsharing.  */
@@ -5957,7 +5951,6 @@
   const_desc_htab = htab_create_ggc (1009, const_desc_hash,
 				     const_desc_eq, NULL);
 
-  const_alias_set = new_alias_set ();
   shared_constant_pool = create_constant_pool ();
 
 #ifdef TEXT_SECTION_ASM_OP
Index: gcc/ira.c
===================================================================
--- a/src/gcc/ira.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ira.c	(.../branches/gcc-4_9-branch)
@@ -5347,7 +5347,18 @@
 	      ira_allocno_iterator ai;
 
 	      FOR_EACH_ALLOCNO (a, ai)
-		ALLOCNO_REGNO (a) = REGNO (ALLOCNO_EMIT_DATA (a)->reg);
+		{
+		  int old_regno = ALLOCNO_REGNO (a);
+		  int new_regno = REGNO (ALLOCNO_EMIT_DATA (a)->reg);
+
+		  ALLOCNO_REGNO (a) = new_regno;
+
+		  if (old_regno != new_regno)
+		    setup_reg_classes (new_regno, reg_preferred_class (old_regno),
+		                       reg_alternate_class (old_regno),
+		                       reg_allocno_class (old_regno));
+		}
+
 	    }
 	  else
 	    {
Index: gcc/graphite-poly.c
===================================================================
--- a/src/gcc/graphite-poly.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-poly.c	(.../branches/gcc-4_9-branch)
@@ -30,7 +30,11 @@
 #include <isl/aff.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/ilp_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/tree-vect-stmts.c
===================================================================
--- a/src/gcc/tree-vect-stmts.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-vect-stmts.c	(.../branches/gcc-4_9-branch)
@@ -325,7 +325,8 @@
 
   /* changing memory.  */
   if (gimple_code (stmt) != GIMPLE_PHI)
-    if (gimple_vdef (stmt))
+    if (gimple_vdef (stmt)
+	&& !gimple_clobber_p (stmt))
       {
 	if (dump_enabled_p ())
 	  dump_printf_loc (MSG_NOTE, vect_location,
@@ -3184,7 +3185,7 @@
   set_vinfo_for_stmt (new_stmt, stmt_info);
   set_vinfo_for_stmt (stmt, NULL);
   STMT_VINFO_STMT (stmt_info) = new_stmt;
-  gsi_replace (gsi, new_stmt, false);
+  gsi_replace (gsi, new_stmt, true);
   unlink_stmt_vdef (stmt);
 
   return true;
Index: gcc/graphite-sese-to-poly.c
===================================================================
--- a/src/gcc/graphite-sese-to-poly.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-sese-to-poly.c	(.../branches/gcc-4_9-branch)
@@ -29,7 +29,12 @@
 #include <cloog/cloog.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
+#include <isl/deprecated/constraint_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: gcc/combine.c
===================================================================
--- a/src/gcc/combine.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/combine.c	(.../branches/gcc-4_9-branch)
@@ -1529,8 +1529,8 @@
       uns3 = TYPE_UNSIGNED (DECL_ARG_TYPE (arg));
 
       /* The mode and signedness of the argument as it is actually passed,
-         after any TARGET_PROMOTE_FUNCTION_ARGS-driven ABI promotions.  */
-      mode3 = promote_function_mode (DECL_ARG_TYPE (arg), mode2, &uns3,
+         see assign_parm_setup_reg in function.c.  */
+      mode3 = promote_function_mode (TREE_TYPE (arg), mode1, &uns3,
 				     TREE_TYPE (cfun->decl), 0);
 
       /* The mode of the register in which the argument is being passed.  */
Index: gcc/config.gcc
===================================================================
--- a/src/gcc/config.gcc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config.gcc	(.../branches/gcc-4_9-branch)
@@ -2662,7 +2662,7 @@
 	;;
 sparc-*-rtems*)
 	tm_file="${tm_file} dbxelf.h elfos.h sparc/sysv4.h sparc/sp-elf.h sparc/rtemself.h rtems.h newlib-stdint.h"
-	tmake_file="${tmake_file} sparc/t-sparc sparc/t-elf sparc/t-rtems"
+	tmake_file="${tmake_file} sparc/t-sparc sparc/t-rtems"
 	;;
 sparc-*-linux*)
 	tm_file="${tm_file} dbxelf.h elfos.h sparc/sysv4.h gnu-user.h linux.h glibc-stdint.h sparc/tso.h"
@@ -3205,6 +3205,9 @@
 	*-leon[3-9]*)
 	  with_cpu=leon3
 	  ;;
+	*-leon[3-9]v7*)
+	  with_cpu=leon3v7
+	  ;;
 	*)
 	  with_cpu="`echo ${target} | sed 's/-.*$//'`"
 	  ;;
@@ -3993,7 +3996,7 @@
 			case ${val} in
 			"" | sparc | sparcv9 | sparc64 \
 			| v7 | cypress \
-			| v8 | supersparc | hypersparc | leon | leon3 \
+			| v8 | supersparc | hypersparc | leon | leon3 | leon3v7 \
 			| sparclite | f930 | f934 | sparclite86x \
 			| sparclet | tsc701 \
 			| v9 | ultrasparc | ultrasparc3 | niagara | niagara2 \
Index: gcc/ree.c
===================================================================
--- a/src/gcc/ree.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/ree.c	(.../branches/gcc-4_9-branch)
@@ -261,6 +261,50 @@
 
 static int max_insn_uid;
 
+/* Update or remove REG_EQUAL or REG_EQUIV notes for INSN.  */
+
+static bool
+update_reg_equal_equiv_notes (rtx insn, enum machine_mode new_mode,
+			      enum machine_mode old_mode, enum rtx_code code)
+{
+  rtx *loc = &REG_NOTES (insn);
+  while (*loc)
+    {
+      enum reg_note kind = REG_NOTE_KIND (*loc);
+      if (kind == REG_EQUAL || kind == REG_EQUIV)
+	{
+	  rtx orig_src = XEXP (*loc, 0);
+	  /* Update equivalency constants.  Recall that RTL constants are
+	     sign-extended.  */
+	  if (GET_CODE (orig_src) == CONST_INT
+	      && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (new_mode))
+	    {
+	      if (INTVAL (orig_src) >= 0 || code == SIGN_EXTEND)
+		/* Nothing needed.  */;
+	      else
+		{
+		  /* Zero-extend the negative constant by masking out the
+		     bits outside the source mode.  */
+		  rtx new_const_int
+		    = gen_int_mode (INTVAL (orig_src)
+				    & GET_MODE_MASK (old_mode),
+				    new_mode);
+		  if (!validate_change (insn, &XEXP (*loc, 0),
+					new_const_int, true))
+		    return false;
+		}
+	      loc = &XEXP (*loc, 1);
+	    }
+	  /* Drop all other notes, they assume a wrong mode.  */
+	  else if (!validate_change (insn, loc, XEXP (*loc, 1), true))
+	    return false;
+	}
+      else
+	loc = &XEXP (*loc, 1);
+    }
+  return true;
+}
+
 /* Given a insn (CURR_INSN), an extension candidate for removal (CAND)
    and a pointer to the SET rtx (ORIG_SET) that needs to be modified,
    this code modifies the SET rtx to a new SET rtx that extends the
@@ -282,6 +326,7 @@
 combine_set_extension (ext_cand *cand, rtx curr_insn, rtx *orig_set)
 {
   rtx orig_src = SET_SRC (*orig_set);
+  enum machine_mode orig_mode = GET_MODE (SET_DEST (*orig_set));
   rtx new_set;
   rtx cand_pat = PATTERN (cand->insn);
 
@@ -318,9 +363,8 @@
 	{
 	  /* Zero-extend the negative constant by masking out the bits outside
 	     the source mode.  */
-	  enum machine_mode src_mode = GET_MODE (SET_DEST (*orig_set));
 	  rtx new_const_int
-	    = gen_int_mode (INTVAL (orig_src) & GET_MODE_MASK (src_mode),
+	    = gen_int_mode (INTVAL (orig_src) & GET_MODE_MASK (orig_mode),
 			    GET_MODE (new_reg));
 	  new_set = gen_rtx_SET (VOIDmode, new_reg, new_const_int);
 	}
@@ -359,7 +403,9 @@
 
   /* This change is a part of a group of changes.  Hence,
      validate_change will not try to commit the change.  */
-  if (validate_change (curr_insn, orig_set, new_set, true))
+  if (validate_change (curr_insn, orig_set, new_set, true)
+      && update_reg_equal_equiv_notes (curr_insn, cand->mode, orig_mode,
+				       cand->code))
     {
       if (dump_file)
         {
@@ -409,7 +455,9 @@
   ifexpr = gen_rtx_IF_THEN_ELSE (cand->mode, cond, map_srcreg, map_srcreg2);
   new_set = gen_rtx_SET (VOIDmode, map_dstreg, ifexpr);
 
-  if (validate_change (def_insn, &PATTERN (def_insn), new_set, true))
+  if (validate_change (def_insn, &PATTERN (def_insn), new_set, true)
+      && update_reg_equal_equiv_notes (def_insn, cand->mode, GET_MODE (dstreg),
+				       cand->code))
     {
       if (dump_file)
         {
Index: gcc/tree-ssa-reassoc.c
===================================================================
--- a/src/gcc/tree-ssa-reassoc.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/tree-ssa-reassoc.c	(.../branches/gcc-4_9-branch)
@@ -2047,7 +2047,7 @@
 	      else
 		return -1;
 	    }
-	  else if (p->high != NULL_TREE)
+	  else if (q->high != NULL_TREE)
 	    return 1;
 	  /* If both ranges are the same, sort below by ascending idx.  */
 	}
@@ -3692,6 +3692,9 @@
   switch (DECL_FUNCTION_CODE (fndecl))
     {
     CASE_FLT_FN (BUILT_IN_POW):
+      if (flag_errno_math)
+	return false;
+
       *base = gimple_call_arg (stmt, 0);
       arg1 = gimple_call_arg (stmt, 1);
 
Index: gcc/config/alpha/alpha.md
===================================================================
--- a/src/gcc/config/alpha/alpha.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/alpha/alpha.md	(.../branches/gcc-4_9-branch)
@@ -5984,16 +5984,38 @@
   [(set_attr "type" "jsr")
    (set_attr "length" "*,*,8")])
 
-(define_insn_and_split "call_value_osf_tlsgd"
+(define_int_iterator TLS_CALL
+	[UNSPEC_TLSGD_CALL
+	 UNSPEC_TLSLDM_CALL])
+
+(define_int_attr tls
+	[(UNSPEC_TLSGD_CALL "tlsgd")
+	 (UNSPEC_TLSLDM_CALL "tlsldm")])
+
+(define_insn "call_value_osf_<tls>"
   [(set (match_operand 0)
 	(call (mem:DI (match_operand:DI 1 "symbolic_operand"))
 	      (const_int 0)))
-   (unspec [(match_operand:DI 2 "const_int_operand")] UNSPEC_TLSGD_CALL)
+   (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
    (use (reg:DI 29))
    (clobber (reg:DI 26))]
   "HAVE_AS_TLS"
-  "#"
-  "&& reload_completed"
+  "ldq $27,%1($29)\t\t!literal!%2\;jsr $26,($27),%1\t\t!lituse_<tls>!%2\;ldah $29,0($26)\t\t!gpdisp!%*\;lda $29,0($29)\t\t!gpdisp!%*"
+  [(set_attr "type" "jsr")
+   (set_attr "length" "16")])
+
+;; We must use peep2 instead of a split because we need accurate life
+;; information for $gp.
+(define_peephole2
+  [(parallel
+    [(set (match_operand 0)
+	  (call (mem:DI (match_operand:DI 1 "symbolic_operand"))
+		(const_int 0)))
+     (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
+     (use (reg:DI 29))
+     (clobber (reg:DI 26))])]
+  "HAVE_AS_TLS && reload_completed
+   && peep2_regno_dead_p (1, 29)"
   [(set (match_dup 3)
 	(unspec:DI [(match_dup 5)
 		    (match_dup 1)
@@ -6001,10 +6023,9 @@
    (parallel [(set (match_dup 0)
 		   (call (mem:DI (match_dup 3))
 			 (const_int 0)))
-	      (set (match_dup 5)
-		   (unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP1))
+	      (use (match_dup 5))
 	      (use (match_dup 1))
-	      (use (unspec [(match_dup 2)] UNSPEC_TLSGD_CALL))
+	      (use (unspec [(match_dup 2)] TLS_CALL))
 	      (clobber (reg:DI 26))])
    (set (match_dup 5)
 	(unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP2))]
@@ -6012,19 +6033,18 @@
   operands[3] = gen_rtx_REG (Pmode, 27);
   operands[4] = GEN_INT (alpha_next_sequence_number++);
   operands[5] = pic_offset_table_rtx;
-}
-  [(set_attr "type" "multi")])
+})
 
-(define_insn_and_split "call_value_osf_tlsldm"
-  [(set (match_operand 0)
-	(call (mem:DI (match_operand:DI 1 "symbolic_operand"))
-	      (const_int 0)))
-   (unspec [(match_operand:DI 2 "const_int_operand")] UNSPEC_TLSLDM_CALL)
-   (use (reg:DI 29))
-   (clobber (reg:DI 26))]
-  "HAVE_AS_TLS"
-  "#"
-  "&& reload_completed"
+(define_peephole2
+  [(parallel
+    [(set (match_operand 0)
+	  (call (mem:DI (match_operand:DI 1 "symbolic_operand"))
+		(const_int 0)))
+     (unspec [(match_operand:DI 2 "const_int_operand")] TLS_CALL)
+     (use (reg:DI 29))
+     (clobber (reg:DI 26))])]
+  "HAVE_AS_TLS && reload_completed
+   && !peep2_regno_dead_p (1, 29)"
   [(set (match_dup 3)
 	(unspec:DI [(match_dup 5)
 		    (match_dup 1)
@@ -6035,7 +6055,7 @@
 	      (set (match_dup 5)
 		   (unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP1))
 	      (use (match_dup 1))
-	      (use (unspec [(match_dup 2)] UNSPEC_TLSLDM_CALL))
+	      (use (unspec [(match_dup 2)] TLS_CALL))
 	      (clobber (reg:DI 26))])
    (set (match_dup 5)
 	(unspec:DI [(match_dup 5) (match_dup 4)] UNSPEC_LDGP2))]
@@ -6043,8 +6063,7 @@
   operands[3] = gen_rtx_REG (Pmode, 27);
   operands[4] = GEN_INT (alpha_next_sequence_number++);
   operands[5] = pic_offset_table_rtx;
-}
-  [(set_attr "type" "multi")])
+})
 
 (define_insn "*call_value_osf_1"
   [(set (match_operand 0)
Index: gcc/config/sparc/t-rtems
===================================================================
--- a/src/gcc/config/sparc/t-rtems	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/t-rtems	(.../branches/gcc-4_9-branch)
@@ -17,6 +17,15 @@
 # <http://www.gnu.org/licenses/>.
 #
 
-MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3
-MULTILIB_DIRNAMES = soft v8 leon3
+MULTILIB_OPTIONS = msoft-float mcpu=v8/mcpu=leon3/mcpu=leon3v7 muser-mode
+MULTILIB_DIRNAMES = soft v8 leon3 leon3v7 user-mode
 MULTILIB_MATCHES = msoft-float=mno-fpu
+
+MULTILIB_EXCEPTIONS = muser-mode
+MULTILIB_EXCEPTIONS += mcpu=leon3
+MULTILIB_EXCEPTIONS += mcpu=leon3v7
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=leon3v7
+MULTILIB_EXCEPTIONS += msoft-float/muser-mode
+MULTILIB_EXCEPTIONS += msoft-float/mcpu=v8/muser-mode
+MULTILIB_EXCEPTIONS += mcpu=v8/muser-mode
Index: gcc/config/sparc/sparc.md
===================================================================
--- a/src/gcc/config/sparc/sparc.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.md	(.../branches/gcc-4_9-branch)
@@ -221,6 +221,7 @@
    hypersparc,
    leon,
    leon3,
+   leon3v7,
    sparclite,
    f930,
    f934,
Index: gcc/config/sparc/sparc.opt
===================================================================
--- a/src/gcc/config/sparc/sparc.opt	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.opt	(.../branches/gcc-4_9-branch)
@@ -153,6 +153,9 @@
 Enum(sparc_processor_type) String(leon3) Value(PROCESSOR_LEON3)
 
 EnumValue
+Enum(sparc_processor_type) String(leon3v7) Value(PROCESSOR_LEON3V7)
+
+EnumValue
 Enum(sparc_processor_type) String(sparclite) Value(PROCESSOR_SPARCLITE)
 
 EnumValue
Index: gcc/config/sparc/sparc-opts.h
===================================================================
--- a/src/gcc/config/sparc/sparc-opts.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc-opts.h	(.../branches/gcc-4_9-branch)
@@ -31,6 +31,7 @@
   PROCESSOR_HYPERSPARC,
   PROCESSOR_LEON,
   PROCESSOR_LEON3,
+  PROCESSOR_LEON3V7,
   PROCESSOR_SPARCLITE,
   PROCESSOR_F930,
   PROCESSOR_F934,
Index: gcc/config/sparc/sparc.c
===================================================================
--- a/src/gcc/config/sparc/sparc.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.c	(.../branches/gcc-4_9-branch)
@@ -1246,6 +1246,7 @@
     { TARGET_CPU_hypersparc, PROCESSOR_HYPERSPARC },
     { TARGET_CPU_leon, PROCESSOR_LEON },
     { TARGET_CPU_leon3, PROCESSOR_LEON3 },
+    { TARGET_CPU_leon3v7, PROCESSOR_LEON3V7 },
     { TARGET_CPU_sparclite, PROCESSOR_F930 },
     { TARGET_CPU_sparclite86x, PROCESSOR_SPARCLITE86X },
     { TARGET_CPU_sparclet, PROCESSOR_TSC701 },
@@ -1274,6 +1275,7 @@
     { "hypersparc",	MASK_ISA, MASK_V8|MASK_FPU },
     { "leon",		MASK_ISA, MASK_V8|MASK_LEON|MASK_FPU },
     { "leon3",		MASK_ISA, MASK_V8|MASK_LEON3|MASK_FPU },
+    { "leon3v7",	MASK_ISA, MASK_LEON3|MASK_FPU },
     { "sparclite",	MASK_ISA, MASK_SPARCLITE },
     /* The Fujitsu MB86930 is the original sparclite chip, with no FPU.  */
     { "f930",		MASK_ISA|MASK_FPU, MASK_SPARCLITE },
@@ -1526,6 +1528,7 @@
       sparc_costs = &leon_costs;
       break;
     case PROCESSOR_LEON3:
+    case PROCESSOR_LEON3V7:
       sparc_costs = &leon3_costs;
       break;
     case PROCESSOR_SPARCLET:
@@ -6801,28 +6804,30 @@
 }
 
 /* Used by function_arg and sparc_function_value_1 to implement the conventions
-   for passing and returning large (BLKmode) vectors.
+   for passing and returning BLKmode vectors.
    Return an expression valid as a return value for the FUNCTION_ARG
    and TARGET_FUNCTION_VALUE.
 
-   SIZE is the size in bytes of the vector (at least 8 bytes).
+   SIZE is the size in bytes of the vector.
    REGNO is the FP hard register the vector will be passed in.  */
 
 static rtx
 function_arg_vector_value (int size, int regno)
 {
-  int i, nregs = size / 8;
-  rtx regs;
+  const int nregs = MAX (1, size / 8);
+  rtx regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));
 
-  regs = gen_rtx_PARALLEL (BLKmode, rtvec_alloc (nregs));
-
-  for (i = 0; i < nregs; i++)
-    {
+  if (size < 8)
+    XVECEXP (regs, 0, 0)
+      = gen_rtx_EXPR_LIST (VOIDmode,
+			   gen_rtx_REG (SImode, regno),
+			   const0_rtx);
+  else
+    for (int i = 0; i < nregs; i++)
       XVECEXP (regs, 0, i)
 	= gen_rtx_EXPR_LIST (VOIDmode,
 			     gen_rtx_REG (DImode, regno + 2*i),
 			     GEN_INT (i*8));
-    }
 
   return regs;
 }
@@ -6868,10 +6873,9 @@
 		  || (TARGET_ARCH64 && size <= 16));
 
       if (mode == BLKmode)
-	return function_arg_vector_value (size,
-					  SPARC_FP_ARG_FIRST + 2*slotno);
-      else
-	mclass = MODE_FLOAT;
+	return function_arg_vector_value (size, SPARC_FP_ARG_FIRST + 2*slotno);
+
+      mclass = MODE_FLOAT;
     }
 
   if (TARGET_ARCH32)
@@ -7315,10 +7319,9 @@
 		  || (TARGET_ARCH64 && size <= 32));
 
       if (mode == BLKmode)
-	return function_arg_vector_value (size,
-					  SPARC_FP_ARG_FIRST);
-      else
-	mclass = MODE_FLOAT;
+	return function_arg_vector_value (size, SPARC_FP_ARG_FIRST);
+
+      mclass = MODE_FLOAT;
     }
 
   if (TARGET_ARCH64 && type)
Index: gcc/config/sparc/leon.md
===================================================================
--- a/src/gcc/config/sparc/leon.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/leon.md	(.../branches/gcc-4_9-branch)
@@ -29,11 +29,11 @@
 
 ;; Use a double reservation to work around the load pipeline hazard on UT699.
 (define_insn_reservation "leon3_load" 1
-  (and (eq_attr "cpu" "leon3") (eq_attr "type" "load,sload"))
+  (and (eq_attr "cpu" "leon3,leon3v7") (eq_attr "type" "load,sload"))
   "leon_memory*2")
 
 (define_insn_reservation "leon_store" 2
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "store"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "store"))
   "leon_memory*2")
 
 ;; This describes Gaisler Research's FPU
@@ -44,21 +44,21 @@
 (define_cpu_unit "grfpu_ds" "grfpu")
 
 (define_insn_reservation "leon_fp_alu" 4
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fp,fpcmp,fpmul"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fp,fpcmp,fpmul"))
   "grfpu_alu, nothing*3")
 
 (define_insn_reservation "leon_fp_divs" 16
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpdivs"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpdivs"))
   "grfpu_ds*14, nothing*2")
 
 (define_insn_reservation "leon_fp_divd" 17
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpdivd"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpdivd"))
   "grfpu_ds*15, nothing*2")
 
 (define_insn_reservation "leon_fp_sqrts" 24
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpsqrts"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpsqrts"))
   "grfpu_ds*22, nothing*2")
 
 (define_insn_reservation "leon_fp_sqrtd" 25
-  (and (eq_attr "cpu" "leon,leon3") (eq_attr "type" "fpsqrtd"))
+  (and (eq_attr "cpu" "leon,leon3,leon3v7") (eq_attr "type" "fpsqrtd"))
   "grfpu_ds*23, nothing*2")
Index: gcc/config/sparc/sparc.h
===================================================================
--- a/src/gcc/config/sparc/sparc.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sparc/sparc.h	(.../branches/gcc-4_9-branch)
@@ -137,21 +137,22 @@
 #define TARGET_CPU_hypersparc	3
 #define TARGET_CPU_leon		4
 #define TARGET_CPU_leon3	5
-#define TARGET_CPU_sparclite	6
-#define TARGET_CPU_f930		6       /* alias */
-#define TARGET_CPU_f934		6       /* alias */
-#define TARGET_CPU_sparclite86x	7
-#define TARGET_CPU_sparclet	8
-#define TARGET_CPU_tsc701	8       /* alias */
-#define TARGET_CPU_v9		9	/* generic v9 implementation */
-#define TARGET_CPU_sparcv9	9	/* alias */
-#define TARGET_CPU_sparc64	9	/* alias */
-#define TARGET_CPU_ultrasparc	10
-#define TARGET_CPU_ultrasparc3	11
-#define TARGET_CPU_niagara	12
-#define TARGET_CPU_niagara2	13
-#define TARGET_CPU_niagara3	14
-#define TARGET_CPU_niagara4	15
+#define TARGET_CPU_leon3v7	6
+#define TARGET_CPU_sparclite	7
+#define TARGET_CPU_f930		7       /* alias */
+#define TARGET_CPU_f934		7       /* alias */
+#define TARGET_CPU_sparclite86x	8
+#define TARGET_CPU_sparclet	9
+#define TARGET_CPU_tsc701	9       /* alias */
+#define TARGET_CPU_v9		10	/* generic v9 implementation */
+#define TARGET_CPU_sparcv9	10	/* alias */
+#define TARGET_CPU_sparc64	10	/* alias */
+#define TARGET_CPU_ultrasparc	11
+#define TARGET_CPU_ultrasparc3	12
+#define TARGET_CPU_niagara	13
+#define TARGET_CPU_niagara2	14
+#define TARGET_CPU_niagara3	15
+#define TARGET_CPU_niagara4	16
 
 #if TARGET_CPU_DEFAULT == TARGET_CPU_v9 \
  || TARGET_CPU_DEFAULT == TARGET_CPU_ultrasparc \
@@ -239,8 +240,13 @@
 #define ASM_CPU32_DEFAULT_SPEC AS_LEON_FLAG
 #endif
 
+#if TARGET_CPU_DEFAULT == TARGET_CPU_leon3v7
+#define CPP_CPU32_DEFAULT_SPEC "-D__leon__"
+#define ASM_CPU32_DEFAULT_SPEC AS_LEONV7_FLAG
 #endif
 
+#endif
+
 #if !defined(CPP_CPU32_DEFAULT_SPEC) || !defined(CPP_CPU64_DEFAULT_SPEC)
  #error Unrecognized value in TARGET_CPU_DEFAULT.
 #endif
@@ -285,6 +291,7 @@
 %{mcpu=hypersparc:-D__hypersparc__ -D__sparc_v8__} \
 %{mcpu=leon:-D__leon__ -D__sparc_v8__} \
 %{mcpu=leon3:-D__leon__ -D__sparc_v8__} \
+%{mcpu=leon3v7:-D__leon__} \
 %{mcpu=v9:-D__sparc_v9__} \
 %{mcpu=ultrasparc:-D__sparc_v9__} \
 %{mcpu=ultrasparc3:-D__sparc_v9__} \
@@ -334,6 +341,7 @@
 %{mcpu=hypersparc:-Av8} \
 %{mcpu=leon:" AS_LEON_FLAG "} \
 %{mcpu=leon3:" AS_LEON_FLAG "} \
+%{mcpu=leon3v7:" AS_LEONV7_FLAG "} \
 %{mv8plus:-Av8plus} \
 %{mcpu=v9:-Av9} \
 %{mcpu=ultrasparc:%{!mv8plus:-Av9a}} \
@@ -1760,8 +1768,10 @@
 
 #ifdef HAVE_AS_LEON
 #define AS_LEON_FLAG "-Aleon"
+#define AS_LEONV7_FLAG "-Aleon"
 #else
 #define AS_LEON_FLAG "-Av8"
+#define AS_LEONV7_FLAG "-Av7"
 #endif
 
 /* We use gcc _mcount for profiling.  */
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_9-branch)
@@ -5006,6 +5006,10 @@
   if (TREE_CODE (exp) == FUNCTION_DECL)
     return false;
 
+  /* Automatic variables are never large data.  */
+  if (TREE_CODE (exp) == VAR_DECL && !is_global_var (exp))
+    return false;
+
   if (TREE_CODE (exp) == VAR_DECL && DECL_SECTION_NAME (exp))
     {
       const char *section = TREE_STRING_POINTER (DECL_SECTION_NAME (exp));
@@ -5036,8 +5040,7 @@
 x86_64_elf_select_section (tree decl, int reloc,
 			   unsigned HOST_WIDE_INT align)
 {
-  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     {
       const char *sname = NULL;
       unsigned int flags = SECTION_WRITE;
@@ -5123,8 +5126,7 @@
 static void ATTRIBUTE_UNUSED
 x86_64_elf_unique_section (tree decl, int reloc)
 {
-  if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     {
       const char *prefix = NULL;
       /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */
@@ -5193,7 +5195,7 @@
 {
   if ((ix86_cmodel == CM_MEDIUM || ix86_cmodel == CM_MEDIUM_PIC)
       && size > (unsigned int)ix86_section_threshold)
-    fputs (".largecomm\t", file);
+    fputs ("\t.largecomm\t", file);
   else
     fputs (COMMON_ASM_OP, file);
   assemble_name (file, name);
@@ -14503,7 +14505,7 @@
       if (mode == CCmode)
 	suffix = "b";
       else if (mode == CCCmode)
-	suffix = "c";
+	suffix = fp ? "b" : "c";
       else
 	gcc_unreachable ();
       break;
@@ -14526,9 +14528,9 @@
       break;
     case GEU:
       if (mode == CCmode)
-	suffix = fp ? "nb" : "ae";
+	suffix = "nb";
       else if (mode == CCCmode)
-	suffix = "nc";
+	suffix = fp ? "nb" : "nc";
       else
 	gcc_unreachable ();
       break;
@@ -23890,7 +23892,8 @@
 		      *noalign = alg_noalign;
 		      return alg;
 		    }
-		  break;
+		  else if (!any_alg_usable_p)
+		    break;
 		}
 	      else if (alg_usable_p (candidate, memset))
 		{
@@ -23928,9 +23931,10 @@
       alg = decide_alg (count, max / 2, min_size, max_size, memset,
 			zero_memset, dynamic_check, noalign);
       gcc_assert (*dynamic_check == -1);
-      gcc_assert (alg != libcall);
       if (TARGET_INLINE_STRINGOPS_DYNAMICALLY)
 	*dynamic_check = max;
+      else
+	gcc_assert (alg != libcall);
       return alg;
     }
   return (alg_usable_p (algs->unknown_size, memset)
@@ -41076,9 +41080,7 @@
 {
   default_encode_section_info (decl, rtl, first);
 
-  if (TREE_CODE (decl) == VAR_DECL
-      && (TREE_STATIC (decl) || DECL_EXTERNAL (decl))
-      && ix86_in_large_data_p (decl))
+  if (ix86_in_large_data_p (decl))
     SYMBOL_REF_FLAGS (XEXP (rtl, 0)) |= SYMBOL_FLAG_FAR_ADDR;
 }
 
Index: gcc/config/sh/sh.c
===================================================================
--- a/src/gcc/config/sh/sh.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh.c	(.../branches/gcc-4_9-branch)
@@ -2957,7 +2957,7 @@
 struct ashl_lshr_sequence
 {
   char insn_count;
-  char amount[6];
+  signed char amount[6];
   char clobbers_t;
 };
 
Index: gcc/config/sh/sh_optimize_sett_clrt.cc
===================================================================
--- a/src/gcc/config/sh/sh_optimize_sett_clrt.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh_optimize_sett_clrt.cc	(.../branches/gcc-4_9-branch)
@@ -111,7 +111,7 @@
   // Given a start insn and its basic block, recursively determine all
   // possible ccreg values in all basic block paths that can lead to the
   // start insn.
-  void find_last_ccreg_values (rtx start_insn, basic_block bb,
+  bool find_last_ccreg_values (rtx start_insn, basic_block bb,
 			       std::vector<ccreg_value>& values_out,
 			       std::vector<basic_block>& prev_visited_bb) const;
 
@@ -226,8 +226,8 @@
 
 	    ccreg_values.clear ();
 	    visited_bbs.clear ();
-	    find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values,
-				    visited_bbs);
+	    bool ok = find_last_ccreg_values (PREV_INSN (i), bb, ccreg_values,
+					      visited_bbs);
 
 	    log_msg ("number of ccreg values collected: %u\n",
 		     (unsigned int)ccreg_values.size ());
@@ -235,7 +235,7 @@
 	    // If all the collected values are equal and are equal to the
 	    // constant value of the setcc insn, the setcc insn can be
 	    // removed.
-	    if (all_ccreg_values_equal (ccreg_values)
+	    if (ok && all_ccreg_values_equal (ccreg_values)
 		&& rtx_equal_p (ccreg_values.front ().value, setcc_val))
 	      {
 		log_msg ("all values are ");
@@ -309,7 +309,7 @@
     gcc_unreachable ();
 }
 
-void
+bool
 sh_optimize_sett_clrt
 ::find_last_ccreg_values (rtx start_insn, basic_block bb,
 			  std::vector<ccreg_value>& values_out,
@@ -348,7 +348,7 @@
 	  log_msg ("\n");
 
 	  values_out.push_back (v);
-	  return;
+	  return true;
 	}
 
       if (any_condjump_p (i) && onlyjump_p (i) && !prev_visited_bb.empty ())
@@ -372,7 +372,7 @@
 	  log_msg ("\n");
 
 	  values_out.push_back (v);
-	  return;
+	  return true;
 	}
     }
 
@@ -393,10 +393,14 @@
       for (edge_iterator ei = ei_start (bb->preds); !ei_end_p (ei);
 	   ei_next (&ei))
 	{
+	  if (ei_edge (ei)->flags & EDGE_COMPLEX)
+	    log_return (false, "aborting due to complex edge\n");
+
 	  basic_block pred_bb = ei_edge (ei)->src;
 	  pred_bb_count += 1;
-	  find_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out,
-				  prev_visited_bb);
+	  if (!find_last_ccreg_values (BB_END (pred_bb), pred_bb, values_out,
+				       prev_visited_bb))
+	    return false;
 	}
 
       prev_visited_bb.pop_back ();
@@ -419,6 +423,8 @@
 
     values_out.push_back (v);
   }
+
+  return true;
 }
 
 bool
Index: gcc/config/sh/sh_treg_combine.cc
===================================================================
--- a/src/gcc/config/sh/sh_treg_combine.cc	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh_treg_combine.cc	(.../branches/gcc-4_9-branch)
@@ -78,7 +78,9 @@
 
 In [bb 4] elimination of the comparison would require inversion of the branch
 condition and compensation of other BBs.
-Instead an inverting reg-move can be used:
+Instead the comparison in [bb 3] can be replaced with the comparison in [bb 5]
+by using a reg-reg move.  In [bb 4] a logical not is used to compensate the
+inverted condition.
 
 [bb 3]
 (set (reg:SI 167) (reg:SI 173))
@@ -85,7 +87,8 @@
 -> bb 5
 
 [BB 4]
-(set (reg:SI 167) (not:SI (reg:SI 177)))
+(set (reg:SI 147 t) (eq:SI (reg:SI 177) (const_int 0)))
+(set (reg:SI 167) (reg:SI 147 t))
 -> bb 5
 
 [bb 5]
@@ -214,9 +217,9 @@
       and replace the comparisons in the BBs with reg-reg copies to get the
       operands in place (create new pseudo regs).
 
-    - If the cstores differ, try to apply the special case
-        (eq (reg) (const_int 0)) -> inverted = (not (reg)).
-      for the subordinate cstore types and eliminate the dominating ones.
+    - If the cstores differ and the comparison is a test against zero,
+      use reg-reg copies for the dominating cstores and logical not cstores
+      for the subordinate cstores.
 
 - If the comparison types in the BBs are not the same, or the first approach
   doesn't work out for some reason, try to eliminate the comparison before the
@@ -558,7 +561,8 @@
   bool can_extend_ccreg_usage (const bb_entry& e,
 			       const cbranch_trace& trace) const;
 
-  // Create an insn rtx that is a negating reg move (not operation).
+  // Create an insn rtx that performs a logical not (test != 0) on the src_reg
+  // and stores the result in dst_reg.
   rtx make_not_reg_insn (rtx dst_reg, rtx src_reg) const;
 
   // Create an insn rtx that inverts the ccreg.
@@ -892,12 +896,32 @@
 rtx
 sh_treg_combine::make_not_reg_insn (rtx dst_reg, rtx src_reg) const
 {
-  // This will to go through expanders and may output multiple insns
-  // for multi-word regs.
+  // On SH we can do only SImode and DImode comparisons.
+  if (! (GET_MODE (src_reg) == SImode || GET_MODE (src_reg) == DImode))
+    return NULL;
+
+  // On SH we can store the ccreg into an SImode or DImode reg only.
+  if (! (GET_MODE (dst_reg) == SImode || GET_MODE (dst_reg) == DImode))
+    return NULL;
+
   start_sequence ();
-  expand_simple_unop (GET_MODE (dst_reg), NOT, src_reg, dst_reg, 0);
+
+  emit_insn (gen_rtx_SET (VOIDmode, m_ccreg,
+			  gen_rtx_fmt_ee (EQ, SImode, src_reg, const0_rtx)));
+
+  if (GET_MODE (dst_reg) == SImode)
+    emit_move_insn (dst_reg, m_ccreg);
+  else if (GET_MODE (dst_reg) == DImode)
+    {
+      emit_move_insn (gen_lowpart (SImode, dst_reg), m_ccreg);
+      emit_move_insn (gen_highpart (SImode, dst_reg), const0_rtx);
+    }
+  else
+    gcc_unreachable ();
+
   rtx i = get_insns ();
   end_sequence ();
+
   return i;
 }
 
@@ -1080,7 +1104,12 @@
   // There is one special case though, where an integer comparison
   //     (eq (reg) (const_int 0))
   // can be inverted with a sequence
-  //     (eq (not (reg)) (const_int 0))
+  //     (set (t) (eq (reg) (const_int 0))
+  //     (set (reg) (t))
+  //     (eq (reg) (const_int 0))
+  //
+  // FIXME: On SH2A it might be better to use the nott insn in this case,
+  // i.e. do the try_eliminate_cstores approach instead.
   if (inv_cstore_count != 0 && cstore_count != 0)
     {
       if (make_not_reg_insn (comp_op0, comp_op0) == NULL_RTX)
Index: gcc/config/sh/sh.md
===================================================================
--- a/src/gcc/config/sh/sh.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/sh/sh.md	(.../branches/gcc-4_9-branch)
@@ -6331,10 +6331,9 @@
 })
 
 (define_expand "extendqihi2"
-  [(set (match_operand:HI 0 "arith_reg_dest" "")
-	(sign_extend:HI (match_operand:QI 1 "arith_reg_operand" "")))]
-  ""
-  "")
+  [(set (match_operand:HI 0 "arith_reg_dest")
+	(sign_extend:HI (match_operand:QI 1 "arith_reg_operand")))]
+  "TARGET_SH1")
 
 (define_insn "*extendqihi2_compact_reg"
   [(set (match_operand:HI 0 "arith_reg_dest" "=r")
Index: gcc/config/avr/avr-fixed.md
===================================================================
--- a/src/gcc/config/avr/avr-fixed.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-fixed.md	(.../branches/gcc-4_9-branch)
@@ -231,8 +231,12 @@
               (clobber (reg:HI 24))])
    (set (match_operand:QQ 0 "register_operand" "")
         (reg:QQ 23))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QQmode, 24));
+  })
 
+
 (define_expand "muluqq3_nomul"
   [(set (reg:UQQ 22)
         (match_operand:UQQ 1 "register_operand" ""))
@@ -246,7 +250,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:UQQ 0 "register_operand" "")
         (reg:UQQ 25))]
-  "!AVR_HAVE_MUL")
+  "!AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (UQQmode, 22));
+  })
 
 (define_insn "*mulqq3.call"
   [(set (reg:QQ 23)
@@ -274,7 +281,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
         (reg:ALL2QA 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 18));
+  })
 
 ;; "*mulhq3.call"  "*muluhq3.call"
 ;; "*mulha3.call"  "*muluha3.call"
@@ -302,7 +312,10 @@
                     (reg:ALL4A 20)))
    (set (match_operand:ALL4A 0 "register_operand" "")
         (reg:ALL4A 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 16));
+  })
 
 ;; "*mulsa3.call" "*mulusa3.call"
 (define_insn "*mul<mode>3.call"
@@ -330,8 +343,13 @@
                                 (reg:ALL1Q 22)))
               (clobber (reg:QI 25))])
    (set (match_operand:ALL1Q 0 "register_operand" "")
-        (reg:ALL1Q 24))])
+        (reg:ALL1Q 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 25));
+  })
 
+
 ;; "*divqq3.call" "*udivuqq3.call"
 (define_insn "*<code><mode>3.call"
   [(set (reg:ALL1Q 24)
@@ -356,7 +374,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:QI 21))])
    (set (match_operand:ALL2QA 0 "register_operand" "")
-        (reg:ALL2QA 24))])
+        (reg:ALL2QA 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 26));
+  })
 
 ;; "*divhq3.call" "*udivuhq3.call"
 ;; "*divha3.call" "*udivuha3.call"
@@ -385,7 +407,11 @@
               (clobber (reg:HI 26))
               (clobber (reg:HI 30))])
    (set (match_operand:ALL4A 0 "register_operand" "")
-        (reg:ALL4A 22))])
+        (reg:ALL4A 22))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, 24));
+  })
 
 ;; "*divsa3.call" "*udivusa3.call"
 (define_insn "*<code><mode>3.call"
@@ -435,6 +461,7 @@
 
     operands[3] = gen_rtx_REG (<MODE>mode, regno_out[(size_t) GET_MODE_SIZE (<MODE>mode)]);
     operands[4] = gen_rtx_REG (<MODE>mode,  regno_in[(size_t) GET_MODE_SIZE (<MODE>mode)]);
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, REGNO (operands[4])));
     operands[5] = simplify_gen_subreg (QImode, force_reg (HImode, operands[2]), HImode, 0);
     // $2 is no more needed, but is referenced for expand.
     operands[2] = const0_rtx;
Index: gcc/config/avr/avr-dimode.md
===================================================================
--- a/src/gcc/config/avr/avr-dimode.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-dimode.md	(.../branches/gcc-4_9-branch)
@@ -68,6 +68,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (DImode == <MODE>mode
@@ -145,6 +146,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -201,6 +203,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -249,6 +252,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (const_operand (operands[2], GET_MODE (operands[2])))
@@ -338,6 +342,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
 
     if (s8_operand (operands[2], VOIDmode))
@@ -424,6 +429,7 @@
   {
     rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);
 
+    avr_fix_inputs (operands, 1 << 2, regmask (<MODE>mode, ACC_A));
     emit_move_insn (acc_a, operands[1]);
     emit_move_insn (gen_rtx_REG (QImode, 16), operands[2]);
     emit_insn (gen_<code_stdname><mode>3_insn ());
@@ -457,6 +463,7 @@
               (clobber (any_extend:SI (match_dup 1)))])]
   "avr_have_dimode"
   {
+    avr_fix_inputs (operands, 1 << 2, regmask (SImode, 22));
     emit_move_insn (gen_rtx_REG (SImode, 22), operands[1]);
     emit_move_insn (gen_rtx_REG (SImode, 18), operands[2]);
     emit_insn (gen_<extend_u>mulsidi3_insn());
Index: gcc/config/avr/avr.md
===================================================================
--- a/src/gcc/config/avr/avr.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr.md	(.../branches/gcc-4_9-branch)
@@ -1482,7 +1482,11 @@
    (set (reg:QI 22) (match_operand:QI 2 "register_operand" ""))
    (parallel [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
               (clobber (reg:QI 22))])
-   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))])
+   (set (match_operand:QI 0 "register_operand" "") (reg:QI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
+  })
 
 (define_insn "*mulqi3_call"
   [(set (reg:QI 24) (mult:QI (reg:QI 24) (reg:QI 22)))
@@ -2210,8 +2214,14 @@
    (parallel [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
               (clobber (reg:HI 22))
               (clobber (reg:QI 21))])
-   (set (match_operand:HI 0 "register_operand" "") (reg:HI 24))])
+   (set (match_operand:HI 0 "register_operand" "")
+        (reg:HI 24))]
+  ""
+  {
+    avr_fix_inputs (operands, (1 << 2), regmask (HImode, 24));
+  })
 
+
 (define_insn "*mulhi3_call"
   [(set (reg:HI 24) (mult:HI (reg:HI 24) (reg:HI 22)))
    (clobber (reg:HI 22))
@@ -2248,6 +2258,10 @@
         emit_insn (gen_mulohisi3 (operands[0], operands[2], operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn_and_split "*mulsi3"
@@ -2287,7 +2301,23 @@
 
 ;; "muluqisi3"
 ;; "muluhisi3"
-(define_insn_and_split "mulu<mode>si3"
+(define_expand "mulu<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulu<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*muluqisi3"
+;; "*muluhisi3"
+(define_insn_and_split "*mulu<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (zero_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2323,7 +2353,23 @@
 
 ;; "mulsqisi3"
 ;; "mulshisi3"
-(define_insn_and_split "muls<mode>si3"
+(define_expand "muls<mode>si3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" ""))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_muls<mode>si3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+;; "*mulsqisi3"
+;; "*mulshisi3"
+(define_insn_and_split "*muls<mode>si3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                           "=r")
         (mult:SI (sign_extend:SI (match_operand:QIHI 1 "pseudo_register_operand" "r"))
                  (match_operand:SI 2 "pseudo_register_or_const_int_operand"      "rn")))
@@ -2366,7 +2412,22 @@
 
 ;; One-extend operand 1
 
-(define_insn_and_split "mulohisi3"
+(define_expand "mulohisi3"
+  [(parallel [(set (match_operand:SI 0 "pseudo_register_operand" "")
+                   (mult:SI (not:SI (zero_extend:SI
+                                     (not:HI (match_operand:HI 1 "pseudo_register_operand" ""))))
+                            (match_operand:SI 2 "pseudo_register_or_const_int_operand" "")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulohisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulohisi3"
   [(set (match_operand:SI 0 "pseudo_register_operand"                          "=r")
         (mult:SI (not:SI (zero_extend:SI
                           (not:HI (match_operand:HI 1 "pseudo_register_operand" "r"))))
@@ -2394,7 +2455,12 @@
                             (any_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_<extend_u>mulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 (define_expand "usmulhisi3"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
@@ -2402,7 +2468,12 @@
                             (sign_extend:SI (match_operand:HI 2 "register_operand" ""))))
               (clobber (reg:HI 26))
               (clobber (reg:DI 18))])]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    if (avr_emit3_fix_outputs (gen_usmulhisi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
 
 ;; "*uumulqihisi3" "*uumulhiqisi3" "*uumulhihisi3" "*uumulqiqisi3"
 ;; "*usmulqihisi3" "*usmulhiqisi3" "*usmulhihisi3" "*usmulqiqisi3"
@@ -2474,7 +2545,10 @@
               (clobber (reg:HI 22))])
    (set (match_operand:HI 0 "register_operand" "")
         (reg:HI 24))]
-  "AVR_HAVE_MUL")
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, 1 << 2, regmask (HImode, 18));
+  })
 
 
 (define_insn "*mulsi3_call"
@@ -2697,6 +2771,10 @@
         emit_insn (gen_mulsqipsi3 (operands[0], reg, operands[1]));
         DONE;
       }
+
+    if (avr_emit3_fix_outputs (gen_mulpsi3, operands, 1u << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
   })
 
 (define_insn "*umulqihipsi3"
@@ -2729,7 +2807,21 @@
   [(set_attr "length" "7")
    (set_attr "cc" "clobber")])
 
-(define_insn_and_split "mulsqipsi3"
+(define_expand "mulsqipsi3"
+  [(parallel [(set (match_operand:PSI 0 "pseudo_register_operand" "")
+                   (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" ""))
+                             (match_operand:PSI 2 "pseudo_register_or_const_int_operand""")))
+              (clobber (reg:HI 26))
+              (clobber (reg:DI 18))])]
+  "AVR_HAVE_MUL"
+  {
+    avr_fix_inputs (operands, (1 << 1) | (1 << 2), -1u);
+    if (avr_emit3_fix_outputs (gen_mulsqipsi3, operands, 1 << 0,
+                               regmask (DImode, 18) | regmask (HImode, 26)))
+      DONE;
+  })
+
+(define_insn_and_split "*mulsqipsi3"
   [(set (match_operand:PSI 0 "pseudo_register_operand"                          "=r")
         (mult:PSI (sign_extend:PSI (match_operand:QI 1 "pseudo_register_operand" "r"))
                   (match_operand:PSI 2 "pseudo_register_or_const_int_operand"    "rn")))
@@ -6064,6 +6156,7 @@
         emit_insn (gen_fmul_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmul_insn"
@@ -6107,6 +6200,7 @@
         emit_insn (gen_fmuls_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmuls_insn"
@@ -6150,6 +6244,7 @@
         emit_insn (gen_fmulsu_insn (operand0, operand1, operand2));
         DONE;
       }
+    avr_fix_inputs (operands, 1 << 2, regmask (QImode, 24));
   })
 
 (define_insn "fmulsu_insn"
Index: gcc/config/avr/avr-protos.h
===================================================================
--- a/src/gcc/config/avr/avr-protos.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr-protos.h	(.../branches/gcc-4_9-branch)
@@ -124,6 +124,15 @@
 extern bool avr_load_libgcc_p (rtx);
 extern bool avr_xload_libgcc_p (enum machine_mode);
 
+static inline unsigned
+regmask (enum machine_mode mode, unsigned regno)
+{
+  return ((1u << GET_MODE_SIZE (mode)) - 1) << regno;
+}
+
+extern void avr_fix_inputs (rtx*, unsigned, unsigned);
+extern bool avr_emit3_fix_outputs (rtx (*)(rtx,rtx,rtx), rtx*, unsigned, unsigned);
+
 extern rtx lpm_reg_rtx;
 extern rtx lpm_addr_reg_rtx;
 extern rtx tmp_reg_rtx;
Index: gcc/config/avr/avr.c
===================================================================
--- a/src/gcc/config/avr/avr.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/avr/avr.c	(.../branches/gcc-4_9-branch)
@@ -11118,6 +11118,115 @@
 }
 
 
+/* PR63633: The middle-end might come up with hard regs as input operands.
+
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   For each element of OPMASK which is a hard register overlapping RMASK,
+   replace OP[n] with a newly created pseudo register
+
+   HREG == 0:  Also emit a move insn that copies the contents of that
+               hard register into the new pseudo.
+
+   HREG != 0:  Also set HREG[n] to the hard register.  */
+
+static void
+avr_fix_operands (rtx *op, rtx *hreg, unsigned opmask, unsigned rmask)
+{
+  for (; opmask; opmask >>= 1, op++)
+    {
+      rtx reg = *op;
+
+      if (hreg)
+        *hreg = NULL_RTX;
+
+      if ((opmask & 1)
+          && REG_P (reg)
+          && REGNO (reg) < FIRST_PSEUDO_REGISTER
+          // This hard-reg overlaps other prohibited hard regs?
+          && (rmask & regmask (GET_MODE (reg), REGNO (reg))))
+        {
+          *op = gen_reg_rtx (GET_MODE (reg));
+          if (hreg == NULL)
+            emit_move_insn (*op, reg);
+          else
+            *hreg = reg;
+        }
+
+      if (hreg)
+        hreg++;
+    }
+}
+
+
+void
+avr_fix_inputs (rtx *op, unsigned opmask, unsigned rmask)
+{
+  avr_fix_operands (op, NULL, opmask, rmask);
+}
+
+
+/* Helper for the function below:  If bit n of MASK is set and
+   HREG[n] != NULL, then emit a move insn to copy OP[n] to HREG[n].
+   Otherwise do nothing for that n.  Return TRUE.  */
+
+static bool
+avr_move_fixed_operands (rtx *op, rtx *hreg, unsigned mask)
+{
+  for (; mask; mask >>= 1, op++, hreg++)
+    if ((mask & 1)
+        && *hreg)
+      emit_move_insn (*hreg, *op);
+
+  return true;
+}
+
+
+/* PR63633: The middle-end might come up with hard regs as output operands.
+
+   GEN is a sequence generating function like gen_mulsi3 with 3 operands OP[].
+   RMASK is a bit mask representing a subset of hard registers R0...R31:
+   Rn is an element of that set iff bit n of RMASK is set.
+   OPMASK describes a subset of OP[]:  If bit n of OPMASK is 1 then
+   OP[n] has to be fixed; otherwise OP[n] is left alone.
+
+   Emit the insn sequence as generated by GEN() with all elements of OPMASK
+   which are hard registers overlapping RMASK replaced by newly created
+   pseudo registers.  After the sequence has been emitted, emit insns that
+   move the contents of respective pseudos to their hard regs.  */
+
+bool
+avr_emit3_fix_outputs (rtx (*gen)(rtx,rtx,rtx), rtx *op,
+                       unsigned opmask, unsigned rmask)
+{
+  const int n = 3;
+  rtx hreg[n];
+
+  /* It is legitimate for GEN to call this function, and in order not to
+     get self-recursive we use the following static kludge.  This is the
+     only way not to duplicate all expanders and to avoid ugly and
+     hard-to-maintain C-code instead of the much more appreciated RTL
+     representation as supplied by define_expand.  */
+  static bool lock = false;
+
+  gcc_assert (opmask < (1u << n));
+
+  if (lock)
+    return false;
+
+  avr_fix_operands (op, hreg, opmask, rmask);
+
+  lock = true;
+  emit_insn (gen (op[0], op[1], op[2]));
+  lock = false;
+
+  return avr_move_fixed_operands (op, hreg, opmask);
+}
+
+
 /* Worker function for movmemhi expander.
    XOP[0]  Destination as MEM:BLK
    XOP[1]  Source      "     "
Index: gcc/config/aarch64/aarch64-simd.md
===================================================================
--- a/src/gcc/config/aarch64/aarch64-simd.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-simd.md	(.../branches/gcc-4_9-branch)
@@ -4565,8 +4565,8 @@
 })
 
 (define_insn "*aarch64_simd_ld1r<mode>"
-  [(set (match_operand:VALLDI 0 "register_operand" "=w")
-	(vec_duplicate:VALLDI
+  [(set (match_operand:VALL 0 "register_operand" "=w")
+	(vec_duplicate:VALL
 	  (match_operand:<VEL> 1 "aarch64_simd_struct_operand" "Utv")))]
   "TARGET_SIMD"
   "ld1r\\t{%0.<Vtype>}, %1"
Index: gcc/config/aarch64/aarch64.c
===================================================================
--- a/src/gcc/config/aarch64/aarch64.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64.c	(.../branches/gcc-4_9-branch)
@@ -5152,7 +5152,6 @@
       if (strlen (cpu->name) == len && strncmp (cpu->name, str, len) == 0)
 	{
 	  selected_cpu = cpu;
-	  selected_tune = cpu;
 	  aarch64_isa_flags = selected_cpu->flags;
 
 	  if (ext != NULL)
@@ -5248,9 +5247,8 @@
 
   gcc_assert (selected_cpu);
 
-  /* The selected cpu may be an architecture, so lookup tuning by core ID.  */
   if (!selected_tune)
-    selected_tune = &all_cores[selected_cpu->core];
+    selected_tune = selected_cpu;
 
   aarch64_tune_flags = selected_tune->flags;
   aarch64_tune = selected_tune->core;
Index: gcc/config/aarch64/aarch64-elf-raw.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-elf-raw.h	(.../branches/gcc-4_9-branch)
@@ -25,9 +25,18 @@
 #define STARTFILE_SPEC " crti%O%s crtbegin%O%s crt0%O%s"
 #define ENDFILE_SPEC " crtend%O%s crtn%O%s"
 
+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define CA53_ERR_835769_SPEC \
+  " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#else
+#define CA53_ERR_835769_SPEC \
+  " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#endif
+
 #ifndef LINK_SPEC
 #define LINK_SPEC "%{mbig-endian:-EB} %{mlittle-endian:-EL} -X \
-  -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}"
+  -maarch64elf%{mabi=ilp32*:32}%{mbig-endian:b}" \
+  CA53_ERR_835769_SPEC
 #endif
 
 #endif /* GCC_AARCH64_ELF_RAW_H */
Index: gcc/config/aarch64/aarch64-linux.h
===================================================================
--- a/src/gcc/config/aarch64/aarch64-linux.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/aarch64/aarch64-linux.h	(.../branches/gcc-4_9-branch)
@@ -35,8 +35,17 @@
    %{mbig-endian:-EB} %{mlittle-endian:-EL}     \
    -maarch64linux%{mbig-endian:b}"
 
-#define LINK_SPEC LINUX_TARGET_LINK_SPEC
+#ifdef TARGET_FIX_ERR_A53_835769_DEFAULT
+#define CA53_ERR_835769_SPEC \
+  " %{!mno-fix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#else
+#define CA53_ERR_835769_SPEC \
+  " %{mfix-cortex-a53-835769:--fix-cortex-a53-835769}"
+#endif
 
+#define LINK_SPEC LINUX_TARGET_LINK_SPEC \
+                  CA53_ERR_835769_SPEC
+
 #define TARGET_OS_CPP_BUILTINS()		\
   do						\
     {						\
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
--- a/src/gcc/config/rs6000/rs6000-protos.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-protos.h	(.../branches/gcc-4_9-branch)
@@ -65,6 +65,7 @@
 extern void altivec_expand_stvex_be (rtx, rtx, enum machine_mode, unsigned);
 extern void rs6000_expand_extract_even (rtx, rtx, rtx);
 extern void rs6000_expand_interleave (rtx, rtx, rtx, bool);
+extern void rs6000_scale_v2df (rtx, rtx, int);
 extern void build_mask64_2_operands (rtx, rtx *);
 extern int expand_block_clear (rtx[]);
 extern int expand_block_move (rtx[]);
Index: gcc/config/rs6000/xcoff.h
===================================================================
--- a/src/gcc/config/rs6000/xcoff.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/xcoff.h	(.../branches/gcc-4_9-branch)
@@ -304,14 +304,15 @@
   do { fputs (LOCAL_COMMON_ASM_OP, (FILE));			\
        RS6000_OUTPUT_BASENAME ((FILE), (NAME));			\
        if ((ALIGN) > 32)					\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,%u\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s%u_,%u\n",	\
 		  (SIZE), xcoff_bss_section_name,			\
+		  floor_log2 ((ALIGN) / BITS_PER_UNIT),			\
 		  floor_log2 ((ALIGN) / BITS_PER_UNIT));		\
        else if ((SIZE) > 4)					\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,3\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s3_,3\n",	\
 		  (SIZE), xcoff_bss_section_name);		\
        else							\
-	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s\n",	\
+	 fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED",%s,2\n",	\
 		  (SIZE), xcoff_bss_section_name);		\
      } while (0)
 #endif
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
--- a/src/gcc/config/rs6000/rs6000-builtin.def	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-builtin.def	(.../branches/gcc-4_9-branch)
@@ -1258,7 +1258,17 @@
 BU_VSX_2 (VEC_MERGEL_V2DI,    "mergel_2di",	CONST,	vsx_mergel_v2di)
 BU_VSX_2 (VEC_MERGEH_V2DF,    "mergeh_2df",	CONST,	vsx_mergeh_v2df)
 BU_VSX_2 (VEC_MERGEH_V2DI,    "mergeh_2di",	CONST,	vsx_mergeh_v2di)
+BU_VSX_2 (XXSPLTD_V2DF,       "xxspltd_2df",    CONST,  vsx_xxspltd_v2df)
+BU_VSX_2 (XXSPLTD_V2DI,       "xxspltd_2di",    CONST,  vsx_xxspltd_v2di)
+BU_VSX_2 (DIV_V2DI,           "div_2di",        CONST,  vsx_div_v2di)
+BU_VSX_2 (UDIV_V2DI,          "udiv_2di",       CONST,  vsx_udiv_v2di)
+BU_VSX_2 (MUL_V2DI,           "mul_2di",        CONST,  vsx_mul_v2di)
 
+BU_VSX_2 (XVCVSXDDP_SCALE,    "xvcvsxddp_scale", CONST, vsx_xvcvsxddp_scale)
+BU_VSX_2 (XVCVUXDDP_SCALE,    "xvcvuxddp_scale", CONST, vsx_xvcvuxddp_scale)
+BU_VSX_2 (XVCVDPSXDS_SCALE,   "xvcvdpsxds_scale", CONST, vsx_xvcvdpsxds_scale)
+BU_VSX_2 (XVCVDPUXDS_SCALE,   "xvcvdpuxds_scale", CONST, vsx_xvcvdpuxds_scale)
+
 /* VSX abs builtin functions.  */
 BU_VSX_A (XVABSDP,	      "xvabsdp",	CONST,	absv2df2)
 BU_VSX_A (XVNABSDP,	      "xvnabsdp",	CONST,	vsx_nabsv2df2)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000-c.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000-c.c	(.../branches/gcc-4_9-branch)
@@ -597,6 +597,8 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_ROUND, ALTIVEC_BUILTIN_VRFIN,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0, 0 },
+  { ALTIVEC_BUILTIN_VEC_ROUND, VSX_BUILTIN_XVRDPI,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0, 0 },
   { ALTIVEC_BUILTIN_VEC_RECIP, ALTIVEC_BUILTIN_VRECIPFP,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_RECIP, VSX_BUILTIN_RECIP_V2DF,
@@ -877,6 +879,18 @@
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_AND, ALTIVEC_BUILTIN_VAND,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -931,6 +945,18 @@
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_ANDC, ALTIVEC_BUILTIN_VANDC,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1118,6 +1144,10 @@
     RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTF, ALTIVEC_BUILTIN_VCFSX,
     RS6000_BTI_V4SF, RS6000_BTI_V4SI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTF, VSX_BUILTIN_XVCVSXDDP_SCALE,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DI, RS6000_BTI_INTSI, 0},
+  { ALTIVEC_BUILTIN_VEC_CTF, VSX_BUILTIN_XVCVUXDDP_SCALE,
+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI, 0},
   { ALTIVEC_BUILTIN_VEC_VCFSX, ALTIVEC_BUILTIN_VCFSX,
     RS6000_BTI_V4SF, RS6000_BTI_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VCFUX, ALTIVEC_BUILTIN_VCFUX,
@@ -1124,12 +1154,20 @@
     RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTS, ALTIVEC_BUILTIN_VCTSXS,
     RS6000_BTI_V4SI, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTS, VSX_BUILTIN_XVCVDPSXDS_SCALE,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_CTU, ALTIVEC_BUILTIN_VCTUXS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_CTU, VSX_BUILTIN_XVCVDPUXDS_SCALE,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
   { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_XVDIVSP,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_XVDIVDP,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_DIV_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_DIV, VSX_BUILTIN_UDIV_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_LD, ALTIVEC_BUILTIN_LVX_V2DI,
@@ -1595,6 +1633,16 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEH, VSX_BUILTIN_VEC_MERGEH_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGHW, ALTIVEC_BUILTIN_VMRGHW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGHW, ALTIVEC_BUILTIN_VMRGHW,
@@ -1643,6 +1691,16 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_MERGEL, VSX_BUILTIN_VEC_MERGEL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGLW, ALTIVEC_BUILTIN_VMRGLW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { ALTIVEC_BUILTIN_VEC_VMRGLW, ALTIVEC_BUILTIN_VMRGLW,
@@ -1771,6 +1829,10 @@
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, 0 },
   { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_XVMULDP,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_MUL_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { VSX_BUILTIN_VEC_MUL, VSX_BUILTIN_MUL_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_MULE, ALTIVEC_BUILTIN_VMULEUB,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0 },
   { ALTIVEC_BUILTIN_VEC_MULE, ALTIVEC_BUILTIN_VMULESB,
@@ -1812,6 +1874,18 @@
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_NOR, ALTIVEC_BUILTIN_VNOR,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },
@@ -1842,6 +1916,18 @@
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_OR, ALTIVEC_BUILTIN_VOR,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -1945,6 +2031,8 @@
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
+    RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSWUS, ALTIVEC_BUILTIN_VPKSWUS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSHUS, ALTIVEC_BUILTIN_VPKSHUS,
@@ -2127,6 +2215,14 @@
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_SPLAT, ALTIVEC_BUILTIN_VSPLTW,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_INTSI, 0 },
+  { ALTIVEC_BUILTIN_VEC_SPLAT, VSX_BUILTIN_XXSPLTD_V2DI,
+    RS6000_BTI_bool_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VSPLTW, ALTIVEC_BUILTIN_VSPLTW,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_INTSI, 0 },
   { ALTIVEC_BUILTIN_VEC_VSPLTW, ALTIVEC_BUILTIN_VSPLTW,
@@ -2519,6 +2615,18 @@
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_V2DF, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DF, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
+  { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_XOR, ALTIVEC_BUILTIN_VXOR,
     RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_V4SI, 0 },
@@ -2778,6 +2886,8 @@
     RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_V2DF, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V16QI },
+  { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_unsigned_V16QI },
   { ALTIVEC_BUILTIN_VEC_PERM, ALTIVEC_BUILTIN_VPERM_4SI,
@@ -2818,6 +2928,12 @@
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_unsigned_V2DI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
     RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_2DI,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_4SF,
     RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_V4SF, RS6000_BTI_bool_V4SI },
   { ALTIVEC_BUILTIN_VEC_SEL, ALTIVEC_BUILTIN_VSEL_4SF,
@@ -3267,6 +3383,8 @@
 
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DF,
     RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF, 0 },
+  { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DF,
+    RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double, 0 },
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
     RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI, 0 },
   { VSX_BUILTIN_VEC_LD, VSX_BUILTIN_LXVD2X_V2DI,
@@ -3321,6 +3439,8 @@
 
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DF,
     RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_V2DF },
+  { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DF,
+    RS6000_BTI_void, RS6000_BTI_V2DF, RS6000_BTI_INTSI, ~RS6000_BTI_double },
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
     RS6000_BTI_void, RS6000_BTI_V2DI, RS6000_BTI_INTSI, ~RS6000_BTI_V2DI },
   { VSX_BUILTIN_VEC_ST, VSX_BUILTIN_STXVD2X_V2DI,
@@ -3431,6 +3551,18 @@
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SI, RS6000_BTI_bool_V4SI },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTSW_P,
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SI, RS6000_BTI_V4SI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTUD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_bool_V2DI, RS6000_BTI_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_bool_V2DI },
+  { ALTIVEC_BUILTIN_VEC_VCMPGT_P, P8V_BUILTIN_VCMPGTSD_P,
+    RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V2DI, RS6000_BTI_V2DI },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, ALTIVEC_BUILTIN_VCMPGTFP_P,
     RS6000_BTI_INTSI, RS6000_BTI_INTSI, RS6000_BTI_V4SF, RS6000_BTI_V4SF },
   { ALTIVEC_BUILTIN_VEC_VCMPGT_P, VSX_BUILTIN_XVCMPGTDP_P,
@@ -3889,6 +4021,8 @@
   { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
+  { P8V_BUILTIN_VEC_VMRGEW, P8V_BUILTIN_VMRGEW,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
 
   { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
     RS6000_BTI_V4SI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
@@ -3895,6 +4029,8 @@
   { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,
     RS6000_BTI_unsigned_V4SI, 0 },
+  { P8V_BUILTIN_VEC_VMRGOW, P8V_BUILTIN_VMRGOW,
+    RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, RS6000_BTI_bool_V4SI, 0 },
 
   { P8V_BUILTIN_VEC_VPOPCNT, P8V_BUILTIN_VPOPCNTB,
     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },
Index: gcc/config/rs6000/darwin.h
===================================================================
--- a/src/gcc/config/rs6000/darwin.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/darwin.h	(.../branches/gcc-4_9-branch)
@@ -206,7 +206,11 @@
     "vrsave", "vscr",							\
     "spe_acc", "spefscr",                                               \
     "sfp",								\
-    "tfhar", "tfiar", "texasr"						\
+    "tfhar", "tfiar", "texasr",						\
+    "rh0",  "rh1",  "rh2",  "rh3",  "rh4",  "rh5",  "rh6",  "rh7",	\
+    "rh8",  "rh9",  "rh10", "rh11", "rh12", "rh13", "rh14", "rh15",	\
+    "rh16", "rh17", "rh18", "rh19", "rh20", "rh21", "rh22", "rh23",	\
+    "rh24", "rh25", "rh26", "rh27", "rh28", "rh29", "rh30", "rh31"	\
 }
 
 /* This outputs NAME to FILE.  */
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_9-branch)
@@ -79,6 +79,7 @@
 #include "dumpfile.h"
 #include "cgraph.h"
 #include "target-globals.h"
+#include "real.h"
 #if TARGET_XCOFF
 #include "xcoffout.h"  /* get declarations of xcoff_*_section_name */
 #endif
@@ -6896,24 +6897,6 @@
   if (GET_CODE (y) == UNSPEC
       && XINT (y, 1) == UNSPEC_TOCREL)
     {
-#ifdef ENABLE_CHECKING
-      if (REG_P (XVECEXP (y, 0, 1))
-	  && REGNO (XVECEXP (y, 0, 1)) == TOC_REGISTER)
-	{
-	  /* All good.  */
-	}
-      else if (GET_CODE (XVECEXP (y, 0, 1)) == DEBUG_EXPR)
-	{
-	  /* Weirdness alert.  df_note_compute can replace r2 with a
-	     debug_expr when this unspec is in a debug_insn.
-	     Seen in gcc.dg/pr51957-1.c  */
-	}
-      else
-	{
-	  debug_rtx (orig_x);
-	  abort ();
-	}
-#endif
       y = XVECEXP (y, 0, 0);
 
 #ifdef HAVE_AS_TLS
@@ -30922,6 +30905,23 @@
   rs6000_do_expand_vec_perm (target, op0, op1, vmode, nelt, perm);
 }
 
+/* Scale a V2DF vector SRC by two to the SCALE and place in TGT.  */
+void
+rs6000_scale_v2df (rtx tgt, rtx src, int scale)
+{
+  HOST_WIDE_INT hwi_scale (scale);
+  REAL_VALUE_TYPE r_pow;
+  rtvec v = rtvec_alloc (2);
+  rtx elt;
+  rtx scale_vec = gen_reg_rtx (V2DFmode);
+  (void)real_powi (&r_pow, DFmode, &dconst2, hwi_scale);
+  elt = CONST_DOUBLE_FROM_REAL_VALUE (r_pow, DFmode);
+  RTVEC_ELT (v, 0) = elt;
+  RTVEC_ELT (v, 1) = elt;
+  rs6000_expand_vector_init (scale_vec, gen_rtx_PARALLEL (V2DFmode, v));
+  emit_insn (gen_mulv2df3 (tgt, src, scale_vec));
+}
+
 /* Return an RTX representing where to find the function value of a
    function returning MODE.  */
 static rtx
Index: gcc/config/rs6000/vsx.md
===================================================================
--- a/src/gcc/config/rs6000/vsx.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/vsx.md	(.../branches/gcc-4_9-branch)
@@ -260,6 +260,14 @@
    UNSPEC_VSX_ROUND_IC
    UNSPEC_VSX_SLDWI
    UNSPEC_VSX_XXSPLTW
+   UNSPEC_VSX_XXSPLTD
+   UNSPEC_VSX_DIVSD
+   UNSPEC_VSX_DIVUD
+   UNSPEC_VSX_MULSD
+   UNSPEC_VSX_XVCVSXDDP
+   UNSPEC_VSX_XVCVUXDDP
+   UNSPEC_VSX_XVCVDPSXDS
+   UNSPEC_VSX_XVCVDPUXDS
   ])
 
 ;; VSX moves
@@ -746,6 +754,34 @@
   [(set_attr "type" "<VStype_simple>")
    (set_attr "fp_type" "<VSfptype_mul>")])
 
+; Emulate vector with scalar for vec_mul in V2DImode
+(define_insn_and_split "vsx_mul_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_MULSD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_muldi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_muldi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdouble")])
+
 (define_insn "*vsx_div<mode>3"
   [(set (match_operand:VSX_F 0 "vsx_register_operand" "=<VSr>,?<VSa>")
         (div:VSX_F (match_operand:VSX_F 1 "vsx_register_operand" "<VSr>,<VSa>")
@@ -755,6 +791,61 @@
   [(set_attr "type" "<VStype_div>")
    (set_attr "fp_type" "<VSfptype_div>")])
 
+; Emulate vector with scalar for vec_div in V2DImode
+(define_insn_and_split "vsx_div_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_DIVSD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_divdi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_divdi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdiv")])
+
+(define_insn_and_split "vsx_udiv_v2di"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DI 1 "vsx_register_operand" "wa")
+                      (match_operand:V2DI 2 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_DIVUD))]
+  "VECTOR_MEM_VSX_P (V2DImode)"
+  "#"
+  "VECTOR_MEM_VSX_P (V2DImode) && !reload_completed && !reload_in_progress"
+  [(const_int 0)]
+  "
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op3 = gen_reg_rtx (DImode);
+  rtx op4 = gen_reg_rtx (DImode);
+  rtx op5 = gen_reg_rtx (DImode);
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (0)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (0)));
+  emit_insn (gen_udivdi3 (op5, op3, op4));
+  emit_insn (gen_vsx_extract_v2di (op3, op1, GEN_INT (1)));
+  emit_insn (gen_vsx_extract_v2di (op4, op2, GEN_INT (1)));
+  emit_insn (gen_udivdi3 (op3, op3, op4));
+  emit_insn (gen_vsx_concat_v2di (op0, op5, op3));
+}"
+  [(set_attr "type" "vecdiv")])
+
 ;; *tdiv* instruction returning the FG flag
 (define_expand "vsx_tdiv<mode>3_fg"
   [(set (match_dup 3)
@@ -1268,6 +1359,102 @@
   "xscvspdpn %x0,%x1"
   [(set_attr "type" "fp")])
 
+;; Convert and scale (used by vec_ctf, vec_cts, vec_ctu for double/long long)
+
+(define_expand "vsx_xvcvsxddp_scale"
+  [(match_operand:V2DF 0 "vsx_register_operand" "")
+   (match_operand:V2DI 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  int scale = INTVAL(operands[2]);
+  emit_insn (gen_vsx_xvcvsxddp (op0, op1));
+  if (scale != 0)
+    rs6000_scale_v2df (op0, op0, -scale);
+  DONE;
+})
+
+(define_insn "vsx_xvcvsxddp"
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wa")
+        (unspec:V2DF [(match_operand:V2DI 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVSXDDP))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvsxddp %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvuxddp_scale"
+  [(match_operand:V2DF 0 "vsx_register_operand" "")
+   (match_operand:V2DI 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  int scale = INTVAL(operands[2]);
+  emit_insn (gen_vsx_xvcvuxddp (op0, op1));
+  if (scale != 0)
+    rs6000_scale_v2df (op0, op0, -scale);
+  DONE;
+})
+
+(define_insn "vsx_xvcvuxddp"
+  [(set (match_operand:V2DF 0 "vsx_register_operand" "=wa")
+        (unspec:V2DF [(match_operand:V2DI 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVUXDDP))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvuxddp %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvdpsxds_scale"
+  [(match_operand:V2DI 0 "vsx_register_operand" "")
+   (match_operand:V2DF 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx tmp = gen_reg_rtx (V2DFmode);
+  int scale = INTVAL(operands[2]);
+  if (scale != 0)
+    rs6000_scale_v2df (tmp, op1, scale);
+  emit_insn (gen_vsx_xvcvdpsxds (op0, tmp));
+  DONE;
+})
+
+(define_insn "vsx_xvcvdpsxds"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DF 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVDPSXDS))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvdpsxds %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
+(define_expand "vsx_xvcvdpuxds_scale"
+  [(match_operand:V2DI 0 "vsx_register_operand" "")
+   (match_operand:V2DF 1 "vsx_register_operand" "")
+   (match_operand:QI 2 "immediate_operand" "")]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx tmp = gen_reg_rtx (V2DFmode);
+  int scale = INTVAL(operands[2]);
+  if (scale != 0)
+    rs6000_scale_v2df (tmp, op1, scale);
+  emit_insn (gen_vsx_xvcvdpuxds (op0, tmp));
+  DONE;
+})
+
+(define_insn "vsx_xvcvdpuxds"
+  [(set (match_operand:V2DI 0 "vsx_register_operand" "=wa")
+        (unspec:V2DI [(match_operand:V2DF 1 "vsx_register_operand" "wa")]
+                     UNSPEC_VSX_XVCVDPUXDS))]
+  "VECTOR_UNIT_VSX_P (V2DFmode)"
+  "xvcvdpuxds %x0,%x1"
+  [(set_attr "type" "vecdouble")])
+
 ;; Convert from 64-bit to 32-bit types
 ;; Note, favor the Altivec registers since the usual use of these instructions
 ;; is in vector converts and we need to use the Altivec vperm instruction.
@@ -1921,6 +2108,22 @@
   "xxspltw %x0,%x1,%2"
   [(set_attr "type" "vecperm")])
 
+;; V2DF/V2DI splat for use by vec_splat builtin
+(define_insn "vsx_xxspltd_<mode>"
+  [(set (match_operand:VSX_D 0 "vsx_register_operand" "=wa")
+        (unspec:VSX_D [(match_operand:VSX_D 1 "vsx_register_operand" "wa")
+	               (match_operand:QI 2 "u5bit_cint_operand" "i")]
+                      UNSPEC_VSX_XXSPLTD))]
+  "VECTOR_MEM_VSX_P (<MODE>mode)"
+{
+  if ((VECTOR_ELT_ORDER_BIG && INTVAL (operands[2]) == 0)
+      || (!VECTOR_ELT_ORDER_BIG && INTVAL (operands[2]) == 1))
+    return "xxpermdi %x0,%x1,%x1,0";
+  else
+    return "xxpermdi %x0,%x1,%x1,3";
+}
+  [(set_attr "type" "vecperm")])
+
 ;; V4SF/V4SI interleave
 (define_insn "vsx_xxmrghw_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=wf,?<VSa>")
Index: gcc/config/rs6000/altivec.md
===================================================================
--- a/src/gcc/config/rs6000/altivec.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/altivec.md	(.../branches/gcc-4_9-branch)
@@ -67,7 +67,7 @@
    UNSPEC_VCTSXS
    UNSPEC_VLOGEFP
    UNSPEC_VEXPTEFP
-   UNSPEC_VLSDOI
+   UNSPEC_VSLDOI
    UNSPEC_VUNPACK_HI_SIGN
    UNSPEC_VUNPACK_LO_SIGN
    UNSPEC_VUNPACK_HI_SIGN_DIRECT
@@ -2077,7 +2077,7 @@
         (unspec:VM [(match_operand:VM 1 "register_operand" "v")
 		    (match_operand:VM 2 "register_operand" "v")
 		    (match_operand:QI 3 "immediate_operand" "i")]
-		  UNSPEC_VLSDOI))]
+		  UNSPEC_VSLDOI))]
   "TARGET_ALTIVEC"
   "vsldoi %0,%1,%2,%3"
   [(set_attr "type" "vecperm")])
Index: gcc/config/rs6000/altivec.h
===================================================================
--- a/src/gcc/config/rs6000/altivec.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/rs6000/altivec.h	(.../branches/gcc-4_9-branch)
@@ -124,6 +124,7 @@
 #define vec_vcfux __builtin_vec_vcfux
 #define vec_cts __builtin_vec_cts
 #define vec_ctu __builtin_vec_ctu
+#define vec_cpsgn __builtin_vec_copysign
 #define vec_expte __builtin_vec_expte
 #define vec_floor __builtin_vec_floor
 #define vec_loge __builtin_vec_loge
@@ -214,8 +215,10 @@
 #define vec_lvsl __builtin_vec_lvsl
 #define vec_lvsr __builtin_vec_lvsr
 #define vec_max __builtin_vec_max
+#define vec_mergee __builtin_vec_vmrgew
 #define vec_mergeh __builtin_vec_mergeh
 #define vec_mergel __builtin_vec_mergel
+#define vec_mergeo __builtin_vec_vmrgow
 #define vec_min __builtin_vec_min
 #define vec_mladd __builtin_vec_mladd
 #define vec_msum __builtin_vec_msum
@@ -319,6 +322,8 @@
 #define vec_sqrt __builtin_vec_sqrt
 #define vec_vsx_ld __builtin_vec_vsx_ld
 #define vec_vsx_st __builtin_vec_vsx_st
+#define vec_xl __builtin_vec_vsx_ld
+#define vec_xst __builtin_vec_vsx_st
 
 /* Note, xxsldi and xxpermdi were added as __builtin_vsx_<xxx> functions
    instead of __builtin_vec_<xxx>  */
@@ -336,6 +341,7 @@
 #define vec_vadduqm __builtin_vec_vadduqm
 #define vec_vbpermq __builtin_vec_vbpermq
 #define vec_vclz __builtin_vec_vclz
+#define vec_cntlz __builtin_vec_vclz
 #define vec_vclzb __builtin_vec_vclzb
 #define vec_vclzd __builtin_vec_vclzd
 #define vec_vclzh __builtin_vec_vclzh
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_9-branch)
@@ -28492,7 +28492,11 @@
 
 	  addr = plus_constant (Pmode, addr, delta);
 	}
-      emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      /* The store needs to be marked as frame related in order to prevent
+	 DSE from deleting it as dead if it is based on fp.  */
+      rtx insn = emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (Pmode, LR_REGNUM));
     }
 }
 
@@ -28544,7 +28548,11 @@
       else
 	addr = plus_constant (Pmode, addr, delta);
 
-      emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      /* The store needs to be marked as frame related in order to prevent
+	 DSE from deleting it as dead if it is based on fp.  */
+      rtx insn = emit_move_insn (gen_frame_mem (Pmode, addr), source);
+      RTX_FRAME_RELATED_P (insn) = 1;
+      add_reg_note (insn, REG_CFA_RESTORE, gen_rtx_REG (Pmode, LR_REGNUM));
     }
   else
     emit_move_insn (gen_rtx_REG (Pmode, LR_REGNUM), source);
Index: gcc/config/arm/t-aprofile
===================================================================
--- a/src/gcc/config/arm/t-aprofile	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/t-aprofile	(.../branches/gcc-4_9-branch)
@@ -88,6 +88,9 @@
 MULTILIB_MATCHES       += march?armv8-a=mcpu?cortex-a57
 MULTILIB_MATCHES       += march?armv8-a=mcpu?cortex-a57.cortex-a53
 
+# Arch Matches
+MULTILIB_MATCHES       += march?armv8-a=march?armv8-a+crc
+
 # FPU matches
 MULTILIB_MATCHES       += mfpu?vfpv3-d16=mfpu?vfpv3
 MULTILIB_MATCHES       += mfpu?vfpv3-d16=mfpu?vfpv3-fp16
Index: gcc/config/arm/arm.h
===================================================================
--- a/src/gcc/config/arm/arm.h	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.h	(.../branches/gcc-4_9-branch)
@@ -2138,9 +2138,10 @@
    ? reverse_condition_maybe_unordered (code) \
    : reverse_condition (code))
 
-/* The arm5 clz instruction returns 32.  */
-#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
-#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE)  ((VALUE) = 32, 1)
+#define CLZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE))
+#define CTZ_DEFINED_VALUE_AT_ZERO(MODE, VALUE) \
+  ((VALUE) = GET_MODE_UNIT_BITSIZE (MODE))
 
 #define CC_STATUS_INIT \
   do { cfun->machine->thumb1_cc_insn = NULL_RTX; } while (0)
Index: gcc/config/arm/arm.md
===================================================================
--- a/src/gcc/config/arm/arm.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/arm/arm.md	(.../branches/gcc-4_9-branch)
@@ -125,9 +125,10 @@
 ; This can be "a" for ARM, "t" for either of the Thumbs, "32" for
 ; TARGET_32BIT, "t1" or "t2" to specify a specific Thumb mode.  "v6"
 ; for ARM or Thumb-2 with arm_arch6, and nov6 for ARM without
-; arm_arch6.  This attribute is used to compute attribute "enabled",
-; use type "any" to enable an alternative in all cases.
-(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,neon_for_64bits,avoid_neon_for_64bits,iwmmxt,iwmmxt2"
+; arm_arch6.  "v6t2" for Thumb-2 with arm_arch6.  This attribute is
+; used to compute attribute "enabled", use type "any" to enable an
+; alternative in all cases.
+(define_attr "arch" "any,a,t,32,t1,t2,v6,nov6,v6t2,neon_for_64bits,avoid_neon_for_64bits,iwmmxt,iwmmxt2"
   (const_string "any"))
 
 (define_attr "arch_enabled" "no,yes"
@@ -162,6 +163,10 @@
 	      (match_test "TARGET_32BIT && !arm_arch6"))
 	 (const_string "yes")
 
+	 (and (eq_attr "arch" "v6t2")
+	      (match_test "TARGET_32BIT && arm_arch6 && arm_arch_thumb2"))
+	 (const_string "yes")
+
 	 (and (eq_attr "arch" "avoid_neon_for_64bits")
 	      (match_test "TARGET_NEON")
 	      (not (match_test "TARGET_PREFER_NEON_64BITS")))
@@ -6961,8 +6966,8 @@
 
 ;; Pattern to recognize insn generated default case above
 (define_insn "*movhi_insn_arch4"
-  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,m,r")
-	(match_operand:HI 1 "general_operand"      "rI,K,r,mi"))]
+  [(set (match_operand:HI 0 "nonimmediate_operand" "=r,r,r,m,r")
+	(match_operand:HI 1 "general_operand"      "rI,K,n,r,mi"))]
   "TARGET_ARM
    && arm_arch4
    && (register_operand (operands[0], HImode)
@@ -6970,16 +6975,19 @@
   "@
    mov%?\\t%0, %1\\t%@ movhi
    mvn%?\\t%0, #%B1\\t%@ movhi
+   movw%?\\t%0, %L1\\t%@ movhi
    str%(h%)\\t%1, %0\\t%@ movhi
    ldr%(h%)\\t%0, %1\\t%@ movhi"
   [(set_attr "predicable" "yes")
-   (set_attr "pool_range" "*,*,*,256")
-   (set_attr "neg_pool_range" "*,*,*,244")
+   (set_attr "pool_range" "*,*,*,*,256")
+   (set_attr "neg_pool_range" "*,*,*,*,244")
+   (set_attr "arch" "*,*,v6t2,*,*")
    (set_attr_alternative "type"
                          [(if_then_else (match_operand 1 "const_int_operand" "")
                                         (const_string "mov_imm" )
                                         (const_string "mov_reg"))
                           (const_string "mvn_imm")
+                          (const_string "mov_imm")
                           (const_string "store1")
                           (const_string "load1")])]
 )
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_9-branch)
@@ -123,7 +123,7 @@
 ;; type "binary" insns have two input operands (1,2) and one output (0)
 
 (define_attr "type"
-  "move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,sh_func_adrs,parallel_branch,fpstore_load,store_fpload"
+  "move,unary,binary,shift,nullshift,compare,load,store,uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,fpload,fpstore,fpalu,fpcc,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,multi,milli,sh_func_adrs,parallel_branch,fpstore_load,store_fpload,trap"
   (const_string "binary"))
 
 (define_attr "pa_combine_type"
@@ -166,7 +166,7 @@
 ;; For conditional branches. Frame related instructions are not allowed
 ;; because they confuse the unwind support.
 (define_attr "in_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch")
+  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch,trap")
 		     (eq_attr "length" "4")
 		     (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 		(const_string "true")
@@ -175,7 +175,7 @@
 ;; Disallow instructions which use the FPU since they will tie up the FPU
 ;; even if the instruction is nullified.
 (define_attr "in_nullified_branch_delay" "false,true"
-  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch")
+  (if_then_else (and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,fpcc,fpalu,fpmulsgl,fpmuldbl,fpdivsgl,fpdivdbl,fpsqrtsgl,fpsqrtdbl,parallel_branch,trap")
 		     (eq_attr "length" "4")
 		     (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 		(const_string "true")
@@ -184,7 +184,7 @@
 ;; For calls and millicode calls.  Allow unconditional branches in the
 ;; delay slot.
 (define_attr "in_call_delay" "false,true"
-  (cond [(and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch")
+  (cond [(and (eq_attr "type" "!uncond_branch,branch,cbranch,fbranch,call,sibcall,dyncall,multi,milli,sh_func_adrs,parallel_branch,trap")
 	      (eq_attr "length" "4")
 	      (not (match_test "RTX_FRAME_RELATED_P (insn)")))
 	   (const_string "true")
@@ -5331,6 +5331,15 @@
   [(set_attr "type" "binary,binary")
    (set_attr "length" "4,4")])
 
+;; Trap instructions.
+
+(define_insn "trap"
+  [(trap_if (const_int 1) (const_int 0))]
+  ""
+  "{addit|addi,tc},<> 1,%%r0,%%r0"
+  [(set_attr "type" "trap")
+   (set_attr "length" "4")])
+
 ;; Clobbering a "register_operand" instead of a match_scratch
 ;; in operand3 of millicode calls avoids spilling %r1 and
 ;; produces better code.
Index: gcc/convert.c
===================================================================
--- a/src/gcc/convert.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/convert.c	(.../branches/gcc-4_9-branch)
@@ -97,6 +97,15 @@
   enum built_in_function fcode = builtin_mathfn_code (expr);
   tree itype = TREE_TYPE (expr);
 
+  if (TREE_CODE (expr) == COMPOUND_EXPR)
+    {
+      tree t = convert_to_real (type, TREE_OPERAND (expr, 1));
+      if (t == TREE_OPERAND (expr, 1))
+	return expr;
+      return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),
+			 TREE_OPERAND (expr, 0), t);
+    }    
+
   /* Disable until we figure out how to decide whether the functions are
      present in runtime.  */
   /* Convert (float)sqrt((double)x) where x is float into sqrtf(x) */
@@ -403,6 +412,15 @@
       return error_mark_node;
     }
 
+  if (ex_form == COMPOUND_EXPR)
+    {
+      tree t = convert_to_integer (type, TREE_OPERAND (expr, 1));
+      if (t == TREE_OPERAND (expr, 1))
+	return expr;
+      return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR, TREE_TYPE (t),
+			 TREE_OPERAND (expr, 0), t);
+    }    
+
   /* Convert e.g. (long)round(d) -> lround(d).  */
   /* If we're converting to char, we may encounter differing behavior
      between converting from double->char vs double->long->char.
@@ -891,6 +909,14 @@
 
 	if (TYPE_MAIN_VARIANT (elt_type) == TYPE_MAIN_VARIANT (subtype))
 	  return expr;
+	else if (TREE_CODE (expr) == COMPOUND_EXPR)
+	  {
+	    tree t = convert_to_complex (type, TREE_OPERAND (expr, 1));
+	    if (t == TREE_OPERAND (expr, 1))
+	      return expr;
+	    return build2_loc (EXPR_LOCATION (expr), COMPOUND_EXPR,
+			       TREE_TYPE (t), TREE_OPERAND (expr, 0), t);
+	  }    
 	else if (TREE_CODE (expr) == COMPLEX_EXPR)
 	  return fold_build2 (COMPLEX_EXPR, type,
 			      convert (subtype, TREE_OPERAND (expr, 0)),
Index: gcc/graphite-interchange.c
===================================================================
--- a/src/gcc/graphite-interchange.c	(.../tags/gcc_4_9_2_release)
+++ b/src/gcc/graphite-interchange.c	(.../branches/gcc-4_9-branch)
@@ -31,7 +31,13 @@
 #include <isl/ilp.h>
 #include <cloog/cloog.h>
 #include <cloog/isl/domain.h>
+#ifdef HAVE_ISL_SCHED_CONSTRAINTS_COMPUTE_SCHEDULE
+#include <isl/deprecated/int.h>
+#include <isl/deprecated/aff_int.h>
+#include <isl/deprecated/ilp_int.h>
+#include <isl/deprecated/constraint_int.h>
 #endif
+#endif
 
 #include "system.h"
 #include "coretypes.h"
Index: libgo/mksysinfo.sh
===================================================================
--- a/src/libgo/mksysinfo.sh	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/mksysinfo.sh	(.../branches/gcc-4_9-branch)
@@ -174,6 +174,9 @@
 #ifdef TIOCGWINSZ
   TIOCGWINSZ_val = TIOCGWINSZ,
 #endif
+#ifdef TIOCSWINSZ
+  TIOCSWINSZ_val = TIOCSWINSZ,
+#endif
 #ifdef TIOCNOTTY
   TIOCNOTTY_val = TIOCNOTTY,
 #endif
@@ -192,6 +195,12 @@
 #ifdef TIOCSIG
   TIOCSIG_val = TIOCSIG,
 #endif
+#ifdef TCGETS
+  TCGETS_val = TCGETS,
+#endif
+#ifdef TCSETS
+  TCSETS_val = TCSETS,
+#endif
 };
 EOF
 
@@ -780,6 +789,11 @@
     echo 'const TIOCGWINSZ = _TIOCGWINSZ_val' >> ${OUT}
   fi
 fi
+if ! grep '^const TIOCSWINSZ' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TIOCSWINSZ_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TIOCSWINSZ = _TIOCSWINSZ_val' >> ${OUT}
+  fi
+fi
 if ! grep '^const TIOCNOTTY' ${OUT} >/dev/null 2>&1; then
   if grep '^const _TIOCNOTTY_val' ${OUT} >/dev/null 2>&1; then
     echo 'const TIOCNOTTY = _TIOCNOTTY_val' >> ${OUT}
@@ -812,8 +826,18 @@
 fi
 
 # The ioctl flags for terminal control
-grep '^const _TC[GS]ET' gen-sysinfo.go | \
+grep '^const _TC[GS]ET' gen-sysinfo.go | grep -v _val | \
     sed -e 's/^\(const \)_\(TC[GS]ET[^= ]*\)\(.*\)$/\1\2 = _\2/' >> ${OUT}
+if ! grep '^const TCGETS' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TCGETS_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TCGETS = _TCGETS_val' >> ${OUT}
+  fi
+fi
+if ! grep '^const TCSETS' ${OUT} >/dev/null 2>&1; then
+  if grep '^const _TCSETS_val' ${OUT} >/dev/null 2>&1; then
+    echo 'const TCSETS = _TCSETS_val' >> ${OUT}
+  fi
+fi
 
 # ioctl constants.  Might fall back to 0 if TIOCNXCL is missing, too, but
 # needs handling in syscalls.exec.go.
Index: libgo/go/debug/elf/file_test.go
===================================================================
--- a/src/libgo/go/debug/elf/file_test.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/file_test.go	(.../branches/gcc-4_9-branch)
@@ -261,6 +261,12 @@
 		},
 	},
 	{
+		"testdata/go-relocation-test-gcc447-ppc64.obj",
+		[]relocationTestEntry{
+			{0, &dwarf.Entry{Offset: 0xb, Tag: dwarf.TagCompileUnit, Children: true, Field: []dwarf.Field{dwarf.Field{Attr: dwarf.AttrProducer, Val: "GNU C 4.4.7 20120313 (Red Hat 4.4.7-4)"}, dwarf.Field{Attr: dwarf.AttrLanguage, Val: int64(1)}, dwarf.Field{Attr: dwarf.AttrName, Val: "t.c"}, dwarf.Field{Attr: dwarf.AttrCompDir, Val: "/tmp"}, dwarf.Field{Attr: dwarf.AttrLowpc, Val: uint64(0x0)}, dwarf.Field{Attr: dwarf.AttrHighpc, Val: uint64(0x24)}, dwarf.Field{Attr: dwarf.AttrStmtList, Val: int64(0)}}}},
+		},
+	},
+	{
 		"testdata/gcc-amd64-openbsd-debug-with-rela.obj",
 		[]relocationTestEntry{
 			{203, &dwarf.Entry{Offset: 0xc62, Tag: dwarf.TagMember, Children: false, Field: []dwarf.Field{{Attr: dwarf.AttrName, Val: "it_interval"}, {Attr: dwarf.AttrDeclFile, Val: int64(7)}, {Attr: dwarf.AttrDeclLine, Val: int64(236)}, {Attr: dwarf.AttrType, Val: dwarf.Offset(0xb7f)}, {Attr: dwarf.AttrDataMemberLoc, Val: []byte{0x23, 0x0}}}}},
Index: libgo/go/debug/elf/file.go
===================================================================
--- a/src/libgo/go/debug/elf/file.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/file.go	(.../branches/gcc-4_9-branch)
@@ -519,6 +519,9 @@
 	if f.Class == ELFCLASS64 && f.Machine == EM_X86_64 {
 		return f.applyRelocationsAMD64(dst, rels)
 	}
+	if f.Class == ELFCLASS64 && f.Machine == EM_PPC64 {
+		return f.applyRelocationsPPC64(dst, rels)
+	}
 	if f.Class == ELFCLASS64 && f.Machine == EM_AARCH64 {
 		return f.applyRelocationsARM64(dst, rels)
 	}
@@ -615,6 +618,47 @@
 	return nil
 }
 
+func (f *File) applyRelocationsPPC64(dst []byte, rels []byte) error {
+	// 24 is the size of Rela64.
+	if len(rels)%24 != 0 {
+		return errors.New("length of relocation section is not a multiple of Sym64Size")
+	}
+
+	symbols, _, err := f.getSymbols(SHT_SYMTAB)
+	if err != nil {
+		return err
+	}
+
+	b := bytes.NewBuffer(rels)
+	var rela Rela64
+
+	for b.Len() > 0 {
+		binary.Read(b, f.ByteOrder, &rela)
+		symNo := rela.Info >> 32
+		t := R_PPC64(rela.Info & 0xffff)
+
+		if symNo == 0 || symNo > uint64(len(symbols)) {
+			continue
+		}
+		sym := &symbols[symNo-1]
+
+	switch t {
+		case R_PPC64_ADDR64:
+			if rela.Off+8 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint64(dst[rela.Off:rela.Off+8], uint64(rela.Addend) + uint64(sym.Value))
+		case R_PPC64_ADDR32:
+			if rela.Off+4 >= uint64(len(dst)) || rela.Addend < 0 {
+				continue
+			}
+			f.ByteOrder.PutUint32(dst[rela.Off:rela.Off+4], uint32(rela.Addend) + uint32(sym.Value))
+		}
+	}
+
+	return nil
+}
+
 func (f *File) DWARF() (*dwarf.Data, error) {
 	// There are many other DWARF sections, but these
 	// are the required ones, and the debug/dwarf package
Index: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
===================================================================
--- a/src/libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj	(.../branches/gcc-4_9-branch)

Property changes on: libgo/go/debug/elf/testdata/go-relocation-test-gcc447-ppc64.obj
___________________________________________________________________
Added: svn:mime-type
## -0,0 +1 ##
+application/octet-stream
\ No newline at end of property
Index: libgo/go/debug/elf/elf.go
===================================================================
--- a/src/libgo/go/debug/elf/elf.go	(.../tags/gcc_4_9_2_release)
+++ b/src/libgo/go/debug/elf/elf.go	(.../branches/gcc-4_9-branch)
@@ -1246,6 +1246,242 @@
 func (i R_386) String() string   { return stringName(uint32(i), r386Strings, false) }
 func (i R_386) GoString() string { return stringName(uint32(i), r386Strings, true) }
 
+// Relocation types for ppc64.
+type R_PPC64 int
+
+const (
+	R_PPC64_NONE                R_PPC64 = 0 /* No relocation. */
+	R_PPC64_ADDR32              R_PPC64 = 1
+	R_PPC64_ADDR24              R_PPC64 = 2
+	R_PPC64_ADDR16              R_PPC64 = 3
+	R_PPC64_ADDR16_LO           R_PPC64 = 4
+	R_PPC64_ADDR16_HI           R_PPC64 = 5
+	R_PPC64_ADDR16_HA           R_PPC64 = 6
+	R_PPC64_ADDR14              R_PPC64 = 7
+	R_PPC64_ADDR14_BRTAKEN      R_PPC64 = 8
+	R_PPC64_ADDR14_BRNTAKEN     R_PPC64 = 9
+	R_PPC64_REL24               R_PPC64 = 10
+	R_PPC64_REL14               R_PPC64 = 11
+	R_PPC64_REL14_BRTAKEN       R_PPC64 = 12
+	R_PPC64_REL14_BRNTAKEN      R_PPC64 = 13
+	R_PPC64_GOT16               R_PPC64 = 14
+	R_PPC64_GOT16_LO            R_PPC64 = 15
+	R_PPC64_GOT16_HI            R_PPC64 = 16
+	R_PPC64_GOT16_HA            R_PPC64 = 17
+				    
+	R_PPC64_COPY                R_PPC64 = 19
+	R_PPC64_GLOB_DAT            R_PPC64 = 20
+	R_PPC64_JMP_SLOT            R_PPC64 = 21
+	R_PPC64_RELATIVE            R_PPC64 = 22
+				    
+	R_PPC64_UADDR32             R_PPC64 = 24
+	R_PPC64_UADDR16             R_PPC64 = 25
+	R_PPC64_REL32               R_PPC64 = 26
+	R_PPC64_PLT32               R_PPC64 = 27
+	R_PPC64_PLTREL32            R_PPC64 = 28
+	R_PPC64_PLT16_LO            R_PPC64 = 29
+	R_PPC64_PLT16_HI            R_PPC64 = 30
+	R_PPC64_PLT16_HA            R_PPC64 = 31
+				    
+	R_PPC64_SECTOFF             R_PPC64 = 33
+	R_PPC64_SECTOFF_LO          R_PPC64 = 34
+	R_PPC64_SECTOFF_HI          R_PPC64 = 35
+	R_PPC64_SECTOFF_HA          R_PPC64 = 36
+	R_PPC64_REL30	            R_PPC64 = 37
+	R_PPC64_ADDR64		    R_PPC64 = 38
+	R_PPC64_ADDR16_HIGHER	    R_PPC64 = 39
+	R_PPC64_ADDR16_HIGHERA	    R_PPC64 = 40
+	R_PPC64_ADDR16_HIGHEST	    R_PPC64 = 41
+	R_PPC64_ADDR16_HIGHESTA     R_PPC64 = 42
+	R_PPC64_UADDR64		    R_PPC64 = 43
+	R_PPC64_REL64		    R_PPC64 = 44
+	R_PPC64_PLT64		    R_PPC64 = 45
+	R_PPC64_PLTREL64	    R_PPC64 = 46
+	R_PPC64_TOC16		    R_PPC64 = 47
+	R_PPC64_TOC16_LO	    R_PPC64 = 48
+	R_PPC64_TOC16_HI	    R_PPC64 = 49
+	R_PPC64_TOC16_HA	    R_PPC64 = 50
+	R_PPC64_TOC		    R_PPC64 = 51
+	R_PPC64_PLTGOT16	    R_PPC64 = 52
+	R_PPC64_PLTGOT16_LO	    R_PPC64 = 53
+	R_PPC64_PLTGOT16_HI	    R_PPC64 = 54
+	R_PPC64_PLTGOT16_HA	    R_PPC64 = 55
+				    
+	R_PPC64_ADDR16_DS	    R_PPC64 = 56
+	R_PPC64_ADDR16_LO_DS	    R_PPC64 = 57
+	R_PPC64_GOT16_DS	    R_PPC64 = 58
+	R_PPC64_GOT16_LO_DS	    R_PPC64 = 59
+	R_PPC64_PLT16_LO_DS	    R_PPC64 = 60
+	R_PPC64_SECTOFF_DS	    R_PPC64 = 61
+	R_PPC64_SECTOFF_LO_DS	    R_PPC64 = 62
+	R_PPC64_TOC16_DS	    R_PPC64 = 63
+	R_PPC64_TOC16_LO_DS	    R_PPC64 = 64
+	R_PPC64_PLTGOT16_DS	    R_PPC64 = 65
+	R_PPC64_PLTGOT16_LO_DS	    R_PPC64 = 66
+				    
+	R_PPC64_TLS		    R_PPC64 = 67
+	R_PPC64_DTPMOD64	    R_PPC64 = 68
+	R_PPC64_TPREL16		    R_PPC64 = 69
+	R_PPC64_TPREL16_LO 	    R_PPC64 = 70
+	R_PPC64_TPREL16_HI          R_PPC64 = 71
+	R_PPC64_TPREL16_HA          R_PPC64 = 72
+	R_PPC64_TPREL64       	    R_PPC64 = 73
+	R_PPC64_DTPREL16            R_PPC64 = 74
+	R_PPC64_DTPREL16_LO   	    R_PPC64 = 75
+	R_PPC64_DTPREL16_HI   	    R_PPC64 = 76
+	R_PPC64_DTPREL16_HA         R_PPC64 = 77
+	R_PPC64_DTPREL64            R_PPC64 = 78
+	R_PPC64_GOT_TLSGD16    	    R_PPC64 = 79
+	R_PPC64_GOT_TLSGD16_LO      R_PPC64 = 80
+	R_PPC64_GOT_TLSGD16_HI      R_PPC64 = 81
+	R_PPC64_GOT_TLSGD16_HA      R_PPC64 = 82
+	R_PPC64_GOT_TLSLD16         R_PPC64 = 83
+	R_PPC64_GOT_TLSLD16_LO      R_PPC64 = 84
+	R_PPC64_GOT_TLSLD16_HI      R_PPC64 = 85
+	R_PPC64_GOT_TLSLD16_HA      R_PPC64 = 86
+	R_PPC64_GOT_TPREL16_DS      R_PPC64 = 87
+	R_PPC64_GOT_TPREL16_LO_DS   R_PPC64 = 88
+	R_PPC64_GOT_TPREL16_HI	    R_PPC64 = 89
+	R_PPC64_GOT_TPREL16_HA      R_PPC64 = 90
+	R_PPC64_GOT_DTPREL16_DS     R_PPC64 = 91
+	R_PPC64_GOT_DTPREL16_LO_DS  R_PPC64 = 92
+	R_PPC64_GOT_DTPREL16_HI     R_PPC64 = 93
+	R_PPC64_GOT_DTPREL16_HA     R_PPC64 = 94
+	R_PPC64_TPREL16_DS	    R_PPC64 = 95
+	R_PPC64_TPREL16_LO_DS       R_PPC64 = 96
+	R_PPC64_TPREL16_HIGHER      R_PPC64 = 97
+	R_PPC64_TPREL16_HIGHERA     R_PPC64 = 98
+	R_PPC64_TPREL16_HIGHEST     R_PPC64 = 99
+	R_PPC64_TPREL16_HIGHESTA    R_PPC64 = 100
+	R_PPC64_DTPREL16_DS	    R_PPC64 = 101
+	R_PPC64_DTPREL16_LO_DS      R_PPC64 = 102
+	R_PPC64_DTPREL16_HIGHER     R_PPC64 = 103
+	R_PPC64_DTPREL16_HIGHERA    R_PPC64 = 104
+	R_PPC64_DTPREL16_HIGHEST    R_PPC64 = 105
+	R_PPC64_DTPREL16_HIGHESTA   R_PPC64 = 106
+
+	R_PPC64_GNU_VTINHERIT	    R_PPC64 = 253
+	R_PPC64_GNU_VTENTRY	    R_PPC64 = 254
+)
+
+var rppc64Strings = []intName{
+        {0, "R_PPC64_NONE"},
+	{1, "R_PPC64_ADDR32"},
+	{2, "R_PPC64_ADDR24"},
+	{3, "R_PPC64_ADDR16"},
+	{4, "R_PPC64_ADDR16_LO"},
+	{5, "R_PPC64_ADDR16_HI"},
+	{6, "R_PPC64_ADDR16_HA"},
+	{7, "R_PPC64_ADDR14"},
+	{8, "R_PPC64_ADDR14_BRTAKEN"},
+	{9, "R_PPC64_ADDR14_BRNTAKEN"},
+	{10, "R_PPC64_REL24"},
+	{11, "R_PPC64_REL14"},
+	{12, "R_PPC64_REL14_BRTAKEN"},
+	{13, "R_PPC64_REL14_BRNTAKEN"},
+	{14, "R_PPC64_GOT16"},
+	{15, "R_PPC64_GOT16_LO"},
+	{16, "R_PPC64_GOT16_HI"},
+	{17, "R_PPC64_GOT16_HA"},
+
+	{19, "R_PPC64_COPY"},
+	{20, "R_PPC64_GLOB_DAT"},
+	{21, "R_PPC64_JMP_SLOT"},
+	{22, "R_PPC64_RELATIVE"},
+
+	{24, "R_PPC64_UADDR32"},
+	{25, "R_PPC64_UADDR16"},
+	{26, "R_PPC64_REL32"},
+	{27, "R_PPC64_PLT32"},
+	{28, "R_PPC64_PLTREL32"},
+	{29, "R_PPC64_PLT16_LO"},
+	{30, "R_PPC64_PLT16_HI"},
+	{31, "R_PPC64_PLT16_HA"},
+
+	{33, "R_PPC64_SECTOFF"},
+	{34, "R_PPC64_SECTOFF_LO"},
+	{35, "R_PPC64_SECTOFF_HI"},
+	{36, "R_PPC64_SECTOFF_HA"},
+	{37, "R_PPC64_REL30"},
+	{38, "R_PPC64_ADDR64"},
+	{39, "R_PPC64_ADDR16_HIGHER"},
+	{40, "R_PPC64_ADDR16_HIGHERA"},
+	{41, "R_PPC64_ADDR16_HIGHEST"},
+	{42, "R_PPC64_ADDR16_HIGHESTA"},
+	{43, "R_PPC64_UADDR64"},
+	{44, "R_PPC64_REL64"},
+	{45, "R_PPC64_PLT64"},
+	{46, "R_PPC64_PLTREL64"},
+	{47, "R_PPC64_TOC16"},
+	{48, "R_PPC64_TOC16_LO"},
+	{49, "R_PPC64_TOC16_HI"},
+	{50, "R_PPC64_TOC16_HA"},
+	{51, "R_PPC64_TOC"},
+	{52, "R_PPC64_PLTGOT16"},
+	{53, "R_PPC64_PLTGOT16_LO"},
+	{54, "R_PPC64_PLTGOT16_HI"},
+	{55, "R_PPC64_PLTGOT16_HA"},
+
+	{56, "R_PPC64_ADDR16_DS"},
+	{57, "R_PPC64_ADDR16_LO_DS"},
+	{58, "R_PPC64_GOT16_DS"},
+	{59, "R_PPC64_GOT16_LO_DS"},
+	{60, "R_PPC64_PLT16_LO_DS"},
+	{61, "R_PPC64_SECTOFF_DS"},
+	{62, "R_PPC64_SECTOFF_LO_DS"},
+	{63, "R_PPC64_TOC16_DS"},
+	{64, "R_PPC64_TOC16_LO_DS"},
+	{65, "R_PPC64_PLTGOT16_DS"},
+	{66, "R_PPC64_PLTGOT16_LO_DS"},
+
+	{67, "R_PPC64_TLS"},
+	{68, "R_PPC64_DTPMOD64"},
+	{69, "R_PPC64_TPREL16"},
+	{70, "R_PPC64_TPREL16_LO"},
+	{71, "R_PPC64_TPREL16_HI"},
+	{72, "R_PPC64_TPREL16_HA"},
+	{73, "R_PPC64_TPREL64"},
+	{74, "R_PPC64_DTPREL16"},
+	{75, "R_PPC64_DTPREL16_LO"},
+	{76, "R_PPC64_DTPREL16_HI"},
+	{77, "R_PPC64_DTPREL16_HA"},
+	{78, "R_PPC64_DTPREL64"},
+	{79, "R_PPC64_GOT_TLSGD16"},
+	{80, "R_PPC64_GOT_TLSGD16_LO"},
+	{81, "R_PPC64_GOT_TLSGD16_HI"},
+	{82, "R_PPC64_GOT_TLSGD16_HA"},
+	{83, "R_PPC64_GOT_TLSLD16"},
+	{84, "R_PPC64_GOT_TLSLD16_LO"},
+	{85, "R_PPC64_GOT_TLSLD16_HI"},
+	{86, "R_PPC64_GOT_TLSLD16_HA"},
+	{87, "R_PPC64_GOT_TPREL16_DS"},
+	{88, "R_PPC64_GOT_TPREL16_LO_DS"},
+	{89, "R_PPC64_GOT_TPREL16_HI"},
+	{90, "R_PPC64_GOT_TPREL16_HA"},
+	{91, "R_PPC64_GOT_DTPREL16_DS"},
+	{92, "R_PPC64_GOT_DTPREL16_LO_DS"},
+	{93, "R_PPC64_GOT_DTPREL16_HI"},
+	{94, "R_PPC64_GOT_DTPREL16_HA"},
+	{95, "R_PPC64_TPREL16_DS"},
+	{96, "R_PPC64_TPREL16_LO_DS"},
+	{97, "R_PPC64_TPREL16_HIGHER"},
+	{98, "R_PPC64_TPREL16_HIGHERA"},
+	{99, "R_PPC64_TPREL16_HIGHEST"},
+	{100, "R_PPC64_TPREL16_HIGHESTA"},
+	{101, "R_PPC64_DTPREL16_DS"},
+	{102, "R_PPC64_DTPREL16_LO_DS"},
+	{103, "R_PPC64_DTPREL16_HIGHER"},
+	{104, "R_PPC64_DTPREL16_HIGHERA"},
+	{105, "R_PPC64_DTPREL16_HIGHEST"},
+	{106, "R_PPC64_DTPREL16_HIGHESTA"},
+
+	{253, "R_PPC64_GNU_VTINHERIT"},
+	{254, "R_PPC64_GNU_VTENTRY"},
+}
+
+func (i R_PPC64) String() string   { return stringName(uint32(i), rppc64Strings, false) }
+func (i R_PPC64) GoString() string { return stringName(uint32(i), rppc64Strings, true) }
+
 // Relocation types for PowerPC.
 type R_PPC int
 
Index: Makefile.def
===================================================================
--- a/src/Makefile.def	(.../tags/gcc_4_9_2_release)
+++ b/src/Makefile.def	(.../branches/gcc-4_9-branch)
@@ -296,6 +296,10 @@
 // Host modules specific to gcc.
 dependencies = { module=configure-gcc; on=configure-intl; };
 dependencies = { module=configure-gcc; on=all-gmp; };
+dependencies = { module=configure-gcc; on=all-mpfr; };
+dependencies = { module=configure-gcc; on=all-mpc; };
+dependencies = { module=configure-gcc; on=all-isl; };
+dependencies = { module=configure-gcc; on=all-cloog; };
 dependencies = { module=configure-gcc; on=all-lto-plugin; };
 dependencies = { module=configure-gcc; on=all-binutils; };
 dependencies = { module=configure-gcc; on=all-gas; };
Index: libcpp/line-map.c
===================================================================
--- a/src/libcpp/line-map.c	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/line-map.c	(.../branches/gcc-4_9-branch)
@@ -527,10 +527,10 @@
 	  && line_delta * ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) > 1000)
       || (max_column_hint >= (1U << ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map)))
       || (max_column_hint <= 80
-	  && ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) >= 10))
-    {
-      add_map = true;
-    }
+	  && ORDINARY_MAP_NUMBER_OF_COLUMN_BITS (map) >= 10)
+      || (highest > 0x60000000
+	  && (set->max_column_hint || highest > 0x70000000)))
+    add_map = true;
   else
     max_column_hint = set->max_column_hint;
   if (add_map)
@@ -541,7 +541,7 @@
 	  /* If the column number is ridiculous or we've allocated a huge
 	     number of source_locations, give up on column numbers. */
 	  max_column_hint = 0;
-	  if (highest >0x70000000)
+	  if (highest > 0x70000000)
 	    return 0;
 	  column_bits = 0;
 	}
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,13 @@
+2014-11-28  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2014-11-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/60436
+	* line-map.c (linemap_line_start): If highest is above 0x60000000
+	and we are still tracking columns or highest is above 0x70000000,
+	force add_map.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libcpp/po/ChangeLog
===================================================================
--- a/src/libcpp/po/ChangeLog	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/po/ChangeLog	(.../branches/gcc-4_9-branch)
@@ -1,3 +1,7 @@
+2014-11-07  Joseph Myers  <joseph@codesourcery.com>
+
+	* ja.po: Update.
+
 2014-10-30  Release Manager
 
 	* GCC 4.9.2 released.
Index: libcpp/po/ja.po
===================================================================
--- a/src/libcpp/po/ja.po	(.../tags/gcc_4_9_2_release)
+++ b/src/libcpp/po/ja.po	(.../branches/gcc-4_9-branch)
@@ -4,15 +4,15 @@
 # Daisuke Yamashita <yamad@mb.infoweb.ne.jp>, 1999-2001
 #    Masahito Yamaga <yamaga@ipc.chiba-u.ac.jp>, 1999.
 #    IIDA Yosiaki <iida@secom.ne.jp>, 1999.
-# Yasuaki Taniguchi <yasuakit@gmail.com>, 2010, 2011.
 # Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>, 2012, 2013
+# Yasuaki Taniguchi <yasuakit@gmail.com>, 2010, 2011, 2014.
 msgid ""
 msgstr ""
-"Project-Id-Version: cpplib 4.8-b20130224\n"
+"Project-Id-Version: cpplib 4.9-b20140202\n"
 "Report-Msgid-Bugs-To: http://gcc.gnu.org/bugs.html\n"
 "POT-Creation-Date: 2014-02-02 17:35+0000\n"
-"PO-Revision-Date: 2013-03-04 18:01+0900\n"
-"Last-Translator: Takeshi Hamasaki <hmatrjp@users.sourceforge.jp>\n"
+"PO-Revision-Date: 2014-11-07 08:19+0000\n"
+"Last-Translator: Yasuaki Taniguchi <yasuakit@gmail.com>\n"
 "Language-Team: Japanese <translation-team-ja@lists.sourceforge.net>\n"
 "Language: ja\n"
 "MIME-Version: 1.0\n"
@@ -19,7 +19,6 @@
 "Content-Type: text/plain; charset=UTF-8\n"
 "Content-Transfer-Encoding: 8bit\n"
 "Plural-Forms: nplurals=1; plural=0;\n"
-"X-Generator: Poedit 1.5.4\n"
 
 #: charset.c:673
 #, c-format
@@ -456,10 +455,8 @@
 msgstr " \"%.*s\" "
 
 #: expr.c:667
-#, fuzzy
-#| msgid "use of C++0x long long integer constant"
 msgid "use of C++11 long long integer constant"
-msgstr "C++0x  long long "
+msgstr "C++11  long long "
 
 #: expr.c:668
 msgid "use of C99 long long integer constant"
@@ -470,10 +467,8 @@
 msgstr " GCC "
 
 #: expr.c:690
-#, fuzzy
-#| msgid "binary constants are a GCC extension"
 msgid "binary constants are a C++1y feature or GCC extension"
-msgstr " GCC "
+msgstr " C++1y  GCC "
 
 #: expr.c:787
 msgid "integer constant is too large for its type"
@@ -703,10 +698,8 @@
 msgstr " 16 "
 
 #: lex.c:1558
-#, fuzzy
-#| msgid "invalid character '%c' in raw string delimiter"
 msgid "invalid new-line in raw string delimiter"
-msgstr " '%c' "
+msgstr ""
 
 #: lex.c:1562
 #, c-format
@@ -718,10 +711,8 @@
 msgstr ""
 
 #: lex.c:1654 lex.c:1783
-#, fuzzy
-#| msgid "invalid suffix on literal; C++11 requires a space between literal and identifier"
 msgid "invalid suffix on literal; C++11 requires a space between literal and string macro"
-msgstr "C++11 "
+msgstr "C++11 "
 
 #: lex.c:1765
 msgid "null character(s) preserved in literal"
@@ -762,7 +753,7 @@
 #: macro.c:236 macro.c:333
 #, c-format
 msgid "macro \"%s\" might prevent reproducible builds"
-msgstr ""
+msgstr " \"%s\" "
 
 #: macro.c:267
 msgid "could not determine file timestamp"
