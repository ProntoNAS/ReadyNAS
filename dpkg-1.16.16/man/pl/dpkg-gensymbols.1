.\" dpkg manual page - dpkg-gensymbols(1)
.\"
.\" Copyright Â© 2007-2011 RaphaÃ«l Hertzog <hertzog@debian.org>
.\" Copyright Â© 2009-2010 Modestas Vainius <modestas@vainius.eu>
.\"
.\" This is free software; you can redistribute it and/or modify
.\" it under the terms of the GNU General Public License as published by
.\" the Free Software Foundation; either version 2 of the License, or
.\" (at your option) any later version.
.\"
.\" This is distributed in the hope that it will be useful,
.\" but WITHOUT ANY WARRANTY; without even the implied warranty of
.\" MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.\" GNU General Public License for more details.
.\"
.\" You should have received a copy of the GNU General Public License
.\" along with this program.  If not, see <http://www.gnu.org/licenses/>.
.
.\"*******************************************************************
.\"
.\" This file was generated with po4a. Translate the source file.
.\"
.\"*******************************************************************
.TH dpkg\-gensymbols 1 2012\-04\-22 "Projekt Debian" "programy pomocnicze dpkg"
.SH NAZWA
dpkg\-gensymbols \- generuje pliki symboli (informacje o zale¿no¶ciach
bibliotek wspó³dzielonych)
.
.SH SK£ADNIA
\fBdpkg\-gensymbols\fP [\fIopcja\fP...]
.
.SH OPIS
\fBdpkg\-gensymbols\fP skanuje tymczasowe drzewo budowania (domy¶lnie
debian/tmp) w poszukiwaniu bibliotek i generuje opisuj±cy je plik
\fIsymbols\fP. Plik ten, je¶li nie jest pusty, jest nastêpnie instalowany do
podkatalogu DEBIAN drzewa budowania, tak wiêc na koñcu zawiera informacje
kontrolne pakietu.
.P
Podczas tworzenia wspomnianych plików, jako wej¶cie s± u¿ywane pliki symboli
dostarczone przez opiekuna. Szukane s± nastêpuj±ce pliki (u¿ywany jest
pierwszy ze znalezionych):
.IP \(bu 4
debian/\fIpakiet\fP.symbols.\fIarch\fP
.IP \(bu 4
debian/symbols.\fIarch\fP
.IP \(bu 4
debian/\fIpakiet\fP.symbols
.IP \(bu 4
debian/symbols
.P
G³ównym zastosowaniem tych plików jest udostêpnienie najmniejszej wersji
zwi±zanej z ka¿dym symbolem zapewnianym przez biblioteki. Najczê¶ciej
koresponduje to z pierwsz± wersj± pakietu, która udostêpnia dany symbol, ale
mo¿e zostaæ równie¿ zwiêkszona rêcznie przez opiekuna, je¶li ABI symbolu
zosta³o rozszerzone bez naruszenia kompatybilno¶ci
wstecznej. Odpowiedzialno¶ci± opiekuna jest utrzymywanie tych plików w
aktualno¶ci i dok³adno¶ci, \fBdpkg\-gensymbols\fP s³u¿y tu pomoc±.
.P
Gdy wygenerowane pliki symboli ró¿ni± siê od dostarczonych przez opiekuna,
\fBdpkg\-gensymbols\fP wypisze ró¿nicê pomiêdzy dwoma wersjami. Co wiêcej, je¶li
ró¿nica jest zbyt du¿a, zakoñczy siê niepowodzeniem (mo¿na dostosowaæ
wielko¶æ tolerowanej ró¿nicy, patrz opcja \fB\-c\fP).
.SH "ZARZ¡DZANIE PLIKAMI SYMBOLI"
Pliki symboli s± bardzo przydatne jedynie, gdy odpowiadaj± ewolucji pakietu
przez kilka wydañ. Opiekun musi zaktualizowaæ je za ka¿dym razem, gdy dodany
jest nowy symbol, dziêki czemu powi±zana najmniejsza wersja jest zgodna z
rzeczywisto¶ci±. Aby zrealizowaæ to poprawnie, mo¿na u¿yæ ró¿nic zawartych w
logach budowania. W wiêkszo¶ci przypadków, diff pasuje bezpo¶rednio do pliku
debian/\fIpakiet\fP.symbols. Niemniej, potrzebne s± z regu³y dalsze zmiany:
zaleca siê np. porzucaæ rewizjê Debiana z tej najmniejszej wersji, aby
backport z mniejsz± wersj± lecz z t± sam± wersj± projektu macierzystego móg³
spe³niæ wygenerowane zale¿no¶ci. Je¶li rewizja Debiana nie mo¿e zostaæ
porzucona, poniewa¿ symbol zosta³ dodany przez zmianê w samym Debianie,
nale¿y u¿yæ przyrostka wersji "~".
.P
Przed dodaniem jakiejkolwiek ³atki do pliku symboli, opiekun powinien dwa
razy sprawdziæ, czy jest ona poprawna. Publiczne symbole nie mog± znikaæ,
wiêc najlepiej je¶li jedynie dodaje ona nowe wiersze.
.P
Proszê zauwa¿yæ, ¿e mo¿na umieszczaæ komentarze w plikach symboli: ka¿dy
wiersz zaczynaj±cy siê od "#", z wyj±tkiem "#include" (patrz rozdzia³
\fBU¿ywanie include (do³±czeñ)\fP), jest komentarzem. Wiersze zaczynaj±ce siê
od "#MISSING:" s± specjalnymi komentarzami dokumentuj±cymi symbole które
zniknê³y.
.SS "U¿ywanie podstawieñ #PACKAGE#"
.P
W niektórych rzadkich przypadkach, nazwa biblioteki ró¿ni siê miêdzy
architekturami. Aby zapobiec kodowaniu nazwy pakietu na sztywno w pliku
symboli, mo¿na u¿yæ markera \fI#PACKAGE#\fP. Zostanie ona zast±piona prawdziw±
nazw± pakietu podczas instalacji tych plików symboli. W przeciwieñstwie do
markera \fI#MINVER#\fP, \fI#PACKAGE#\fP nigdy nie pojawi siê w pliku symboli
wewn±trz pakietu binarnego.
.SS "U¿ywanie znaczników symboli"
.P
Tagowanie symboli jest przydatne do oznaczania symboli, które s± w jaki¶
sposób specjalne. Ka¿dy symbol mo¿e mieæ dowoln± liczbê znaczników z nim
powi±zanych. Podczas gdy wszystkie znaczniki s± przetwarzane i
przechowywane, jedynie niektóre z nich s± rozumiane przez \fBdpkg\-gensymbols\fP
i wyzwalaj± specjaln± obs³ugê tych symboli. Patrz podsekcja \fBStandardowe
znaczniki symboli\fP, aby siê z nimi zapoznaæ.
.P
Okre¶lenie znacznika powinno znale¼æ siê zaraz przed nazw± symbolu (nie ma
pomiêdzy nimi spacji). Zawsze rozpoczyna siê nawiasem otwieraj±cym \fB(\fP,
koñczy nawiasem zamykaj±cym \fB)\fP i musi zawieraæ przynajmniej jeden
znacznik. Poszczególne znaczniki s± oddzielone znakiem \fB|\fP. Ka¿dy znacznik
mo¿e posiadaæ warto¶æ (opcjonalnie), która jest oddzielona od jego nazwy za
pomoc± znaku \fB=\fP. Nazwy i warto¶ci znaczników mog± zawieraæ dowolne znaki,
poza znakami specjalnymi \fB)\fP \fB|\fP \fB=\fP. Nazwy symboli, które znajduj± siê
za okre¶leniem znacznika, mog± zostaæ opcjonalnie ujête w znaki \fB'\fP lub
\fB"\fP. Jednak je¶li symbol nie okre¶la ¿adnych znaczników, cudzys³owy s±
traktowane jako czê¶æ nazwy symbolu, która koñczy siê na pierwszej spacji.
.P
 (tag1=i am marked|tag name with space)"tagged quoted symbol"@Base 1.0
 (optional)tagged_unquoted_symbol@Base 1.0 1
 untagged_symbol@Base 1.0
.P
Pierwszy symbol w przyk³adzie jest nazwany \fItagged quoted symbol\fP i posiada
dwa znaczniki \fItag1\fP z warto¶ci± \fIi am marked\fP i \fItag name with space\fP,
który nie posiada warto¶ci. Drugi symbol ma nazwê \fItagged_unquoted_symbol\fP
jest jego jedynym znacznikiem jest \fIoptional\fP. Ostatni symbol jest
przyk³adem zwyk³ego symbolu bez znacznika.
.P
Poniewa¿ znaczniki symboli s± rozszerzeniem formatu \fIdeb\-symbols(5)\fP, mog±
byæ jedynie czê¶ci± plików symboli u¿ytych w pakietach ¼ród³owych (pliki te
powinny byæ nastêpnie widziane jako szablony u¿ywane do zbudowania plików
symboli osadzonych w pakietach binarnych. Gdy \fBdkpg\-gensymbols\fP zostanie
wywo³ane bez opcji \fI\-t\fP, to wy¶wietli pliki symboli kompatybilne z formatem
\fIdeb\-symbols(5)\fP: w pe³ni przetworzy symbole zgodnie z wymaganiami ich
znaczników standardowych i wytnie wszystkie znaczniki z
wyniku. Przeciwieñstwem jest tryb szablonu (\fI\-t\fP), gdzie wszystkie symbole
i ich znaczniki (zarówno standardowe jak i nieznane) s± zachowane w wyniku i
wypisywane w takiej oryginalnej postaci, jak by³y za³adowane.
.SS "Standardowe znaczniki symboli"
.TP 
\fBoptional\fP
Symbol oznaczony jako opcjonalny mo¿e znikn±æ z biblioteki w dowolnym
momencie i nigdy nie spowoduje b³êdu \fBdpkg\-gensymbols\fP. Usuniête symbole
bêd± siê jednak w dalszym ci±gu pojawiaæ jako MISSING w ka¿dym diffie w
ka¿dej nowej wersji pakietu. To zachowanie jest przypomnieniem dla opiekuna,
¿e dany symbol musi byæ usuniêty z pliku symboli lub ponownie dodany do
biblioteki. Gdy opcjonalny symbol, zadeklarowany wcze¶niej jako MISSING,
nagle pojawi siê w nastêpnej wersji, zostanie uaktualniony z powrotem do
statusu "istniej±cego", gdy jego minimalna wersja nie zmieni³a siê.

Znacznik ten jest przydatny do symboli prywatnych, gdy ich znikniêcie nie
spowoduje z³amania ABI. Przyk³adowo, wiêkszo¶æ szablonów C++ nale¿y do tej
kategorii. Podobnie jak ka¿dy inny znacznik, mo¿e mieæ on równie¿ dowoln±
warto¶æ: mo¿na jej u¿yæ do okre¶lenia powodu, dla którego symbol jest
opcjonalny.
.TP 
\fBarch=\fP\fIlista\-architektur\fP
Znacznik ten pozwala na ograniczenie zestawu architektur, na którym ma
istnieæ. Gdy lista symboli jest aktualizowana za pomoc± symboli odkrytych w
bibliotece, wszystkie symbole specyficzne dla architektury, które nie
dotycz± architektury bie¿±cego komputera s± traktowane tak, jakby nie
istnia³y. Je¶li symbol specyficzny dla architektury, pasuj±cy do
architektury bie¿±cego komputera nie istnieje w bibliotece, stosowana jest
zwyk³a procedura dla brakuj±cych symboli i mo¿e to spowodowaæ b³±d
\fBdpkg\-gensymbols\fP. Z drugiej strony, je¶li symbol specyficzny dla
architektury zostanie znaleziony, podczas gdy nie powinien on istnieæ
(poniewa¿ architektura bie¿±cego komputera nie jest wypisana w znaczniku),
czyni siê go neutralnym architekturowo (znacznik architektury jest pomijany,
a symbol pojawia siê w ró¿nicy z powodu tej zmiany), ale nie jest traktowany
jako nowy.

Podczas dzia³ania w domy¶lnym trybie nieszablonowym, spo¶ród symboli
specyficznych dla architektury tylko te, które pasuj± do architektury
bie¿±cego komputera s± zapisywane do pliku symboli. Odwrotnie jest w trybie
szablonu: wszystkie symbole specyficzne dla architektury (³±cznie z tymi,
nale¿±cymi do obcych architektur) s± zawsze zapisywane do pliku symboli.

Format \fIlisty\-architektur\fP jest taki sam, jak ten u¿ywany w polu
\fIBuild\-Depends\fP pliku \fIdebian/control\fP (z wyj±tkiem otaczaj±cych nawiasów
kwadratowych []). Na przyk³ad, pierwszy symbol z poni¿szej listy bêdzie
brany pod uwagê jedynie na architekturach alpha, any\-amd64 i ia64, drugi
jedynie na architekturach linux, a trzeci wszêdzie, poza architektur± armel.

 (arch=alpha any\-amd64 ia64)a_64bit_specific_symbol@Base 1.0
 (arch=linux\-any)linux_specific_symbol@Base 1.0
 (arch=!armel)symbol_armel_does_not_have@Base 1.0
.TP 
\fBignore\-blacklist\fP
dpkg\-gensymbols posiada wewnêtrzn±, czarn± listê symboli, które nie powinny
pojawiæ siê w plikach symboli, poniewa¿ s± one z regu³y jedynie efektem
ubocznym detali implementacyjnych toolchainu. Je¶li z jakiego¶ powodu
naprawdê chce siê w³±czyæ jeden z tych symboli do pliku symboli, nale¿y
oznaczyæ ten symbol znacznikiem \fBignore\-blacklist\fP. Mo¿e byæ potrzebny do
niektórych niskopoziomowych bibliotek toolchainu, takich jak libgcc.
.TP 
\fBc++\fP
Oznacza wzorzec symbolu \fIc++\fP. Patrz podsekcja \fBU¿ywanie wzorców symboli\fP
poni¿ej.
.TP 
\fBsymver\fP
Oznacza wzorzec symbolu \fIsymver\fP (wersja symbolu). Patrz podsekcja
\fBU¿ywanie wzorców symboli\fP poni¿ej.
.TP 
\fBregex\fP
Oznacza wzorzec symbolu \fIregex\fP. Patrz podsekcja \fBU¿ywanie wzorców
symboli\fP poni¿ej.
.SS "U¿ywanie wzorców symboli"
.P
W przeciwieñstwie do standardowej specyfikacji symboli, wzorzec mo¿e
pokrywaæ wiele symboli rzeczywistych z biblioteki. \fBdpkg\-gensymbols\fP
postara siê dopasowaæ ka¿dy wzorzec do ka¿dego symbolu rzeczywistego, który
\fInie\fP posiada zdefiniowanego odpowiedniego symbolu specyficznego w pliku
symboli. Gdy tylko znaleziony zostanie pierwszy pasuj±cy wzorzec, to
wszystkie jego znaczniki i w³a¶ciwo¶ci bêd± u¿ywane jako podstawa okre¶lenia
symbolu. Je¶li ¿aden ze wzorców nie zostanie dopasowany, to symbol zostanie
uznany za nowy.

Wzorzec jest uwa¿any za porzucony, je¶li nie pasuje do ¿adnego symbolu w
bibliotece. Domy¶lnie, spowoduje to b³±d \fBdpkg\-gensymbols\fP na poziomie
\fI\-c1\fP lub wy¿szym. Je¶li jednak chce siê unikn±æ tego b³êdu, mo¿na oznaczyæ
wzorzec znacznikiem \fIoptional\fP. Wówczas, je¶li wzorzec do niczego nie
pasuje, pojawia siê jedynie w diffie jako MISSING. Co wiêcej, podobnie jak
ka¿dy symbol, wzorzec mo¿e byæ ograniczony do okre¶lonych architektur, za
pomoc± znacznika \fIarch\fP. Proszê zapoznaæ siê ze znajduj±c± siê wy¿ej
podsekcj± \fIStandardowe znaczniki symboli\fP, aby dowiedzieæ siê wiêcej.

Wzorce s± rozszerzeniem formatu \fIdeb\-symbols(5)\fP, poniewa¿ s± one
prawid³owe jedynie w szablonach pliku symboli. Sk³adnia wzorców nie ró¿ni
siê od tej symboli. Jednak czê¶æ nazwy symbolu specyfikacji s³u¿y jako
wyra¿enie, które ma byæ dopasowane do \fInazwa@wersja\fP w symbolu
rzeczywistym. Aby dokonaæ rozró¿nienia miêdzy ró¿nymi typami wzorców,
wzorzec jest z regu³y tagowany specjalnym znacznikiem.

Obecnie \fBdpkg\-gensymbols\fP obs³uguje trzy proste typy symboli:
.TP  3
\fBc++\fP
Ten wzorzec jest oznaczony znacznikiem \fIc++\fP. Dopasowuje on jedynie symbole
C++ za pomoc± ich odkodowanych nazw symboli (takich, jak wypisywanych przez
narzêdzie \fBc++filt\fP(1)). Wzorzec jest bardzo przydatny do dopasowania
symboli, których zakodowane nazwy mog± ró¿niæ siê miêdzy ró¿nymi
architekturami, podczas gdy odkodowane nazwy pozostaj± takie same. Jedn± z
grup takich symboli jest \fInon\-virtual thunks\fP, które posiadaj± przesuniêcia
(offsety) specyficzne dla architektury, do³±czone do zakodowanych
nazw. Czêstym przypadkiem tego przyk³adu jest wirtualny destruktor, który w
wirtualnym dziedziczeniu (ang. diamond inheritance) wymaga niewirtualnego
symbolu thunk. Na przyk³ad nawet je¶li _ZThn8_N3NSB6ClassDD1Ev@Base na
architekturze 32\-bitowej stanie siê prawdopodobnie
_ZThn16_N3NSB6ClassDD1Ev@Base na 64\-bitowej, mo¿e zostaæ dopasowany
pojedynczym wzorcem \fIc++\fP:
.RS
.PP
libdummy.so.1 libdummy1 #MINVER#
 [...]
 (c++)"non\-virtual thunk to NSB::ClassD::~ClassD()@Base" 1.0
 [...]
.P
Powy¿sz±, odkodowan± nazwê mo¿na uzyskaæ wykonuj±c nastêpuj±ce polecenie:
.PP
 $ echo '_ZThn8_N3NSB6ClassDD1Ev@Base' | c++filt
.P
Proszê zauwa¿yæ, ¿e o ile zakodowana nazwa jest, z definicji, unikatowa w
bibliotece, o tyle nie musi byæ to prawd± dla nazw odkodowanych. Kilka
ró¿ni±cych siê symboli rzeczywistych mo¿e mieæ tê sam± nazwê odkodowan±. Na
przyk³ad dzieje siê tak w przypadku niewirtualnych symboli thunk w z³o¿onych
konfiguracjach dziedziczenia lub w przypadku wiêkszo¶ci konstruktorów i
desktruktorów (poniewa¿ g++ tworzy dla nich z regu³y dwa symbole
rzeczywiste). Jednak, poniewa¿ konflikty zachodz± na poziomie ABI, nie
powinny one obni¿yæ jako¶ci pliku symboli.
.RE
.TP 
\fBsymver\fP
Wzorzec jest oznaczany znacznikiem \fIsymver\fP. Dobrze zarz±dzane biblioteki
posiadaj± wersjonowane symbole, a ka¿da wersja odpowiada wersji oryginalnej,
gdzie symbol zosta³ dodany. W takim przypadku mo¿na u¿yæ wzorca \fIsymver\fP,
aby dopasowaæ symbol zwi±zany z okre¶lon± wersj± np.:
.RS
.PP
libc.so.6 libc6 #MINVER#
 (symver)GLIBC_2.0 2.0
 [...]
 (symver)GLIBC_2.7 2.7
 access@GLIBC_2.0 2.2
.PP
Wszystkie symbole zwi±zane z wersjami GLIBC_2.0 i GLIBC_2.7 prowadz± do,
odpowiednio, minimalnej wersji 2.0 i 2.7 z wyj±tkiem symbolu
access@GLIBC_2.0. Ostatnie, prowadzi do minimalnej zale¿no¶ci na libc6 w
wersji 2.2 pomimo, ¿e znajduje siê w zakresie wzorca "(symver)GLIBC_2.0",
poniewa¿ specyficzne symbole maj± pierwszeñstwo przed wzorcami.
.P
Proszê zauwa¿yæ, ¿e o ile wzorca masek starego stylu (oznaczane przez
"*@version" w polu nazwy symbolu s± wci±¿ obs³ugiwane, to s± obecnie
zast±pione przez now± sk³adniê "(symver|optional)version". Na przyk³ad
"*@GLIBC_2.0 2.0" powinno byæ zapisane jako "(symver|optional)GLIBC_2.0
2.0", je¶li potrzebne jest takie samo znaczenie.
.RE
.TP 
\fBregex\fP
Wyra¿enia regularne s± oznaczane znacznikiem \fIregex\fP. S± dopasowane za
pomoc± wyra¿eñ regularnych perla, okre¶lonych w polu nazwy
symbolu. Wyra¿enie regularne jest dopasowane "jak jest", nie nale¿y jednak
zapominaæ rozpocz±æ go znakiem \fI^\fP, w przeciwnym wypadku dopasuje ono
dowoln± czê¶æ ³añcucha symbolu rzeczywistego \fInazwa@wersja\fP np.:
.RS
.PP
libdummy.so.1 libdummy1 #MINVER#
 (regex)"^mystack_.*@Base$" 1.0
 (regex|optional)"private" 1.0
.P
Symbole takie jak "mystack_new@Base", :mystack_push@Base",
"mystack_pop@Base" itd. zostan± dopasowane przez pierwszy wzorzec, natomiast
np. "ng_mystack_new@Base" \- nie. Drugi wzorzec dopasuje wszystkie symbole
posiadaj±ce ³añcuch "private" w swych nazwach, a dopasowania odziedzicz±
znacznik \fIoptional\fP z wzorca.
.RE
.P
Podane wy¿ej wzorce proste mog± byæ ³±czone tam, gdzie ma to sens. W takim
przypadku s± one przetwarzane w takiej kolejno¶ci, w jakiej podano znaczniki
np. oba
.PP
 (c++|regex)"^NSA::ClassA::Private::privmethod\ed\e(int\e)@Base" 1.0
 (regex|c++)N3NSA6ClassA7Private11privmethod\edEi@Base 1.0
.P
dopasuj± symbole "_ZN3NSA6ClassA7Private11privmethod1Ei@Base" i
"_ZN3NSA6ClassA7Private11privmethod2Ei@Base". Podczas dopasowywania
pierwszego wzorca, symbol surowy jest najpierw odkodowany jako symbol C++, a
odkodowana nazwa symbolu jest dopasowywana do wyra¿enia regularnego. Z
drugiej strony, gdy dopasowywany jest drugi wzorzec, wyra¿enie regularne
jest dopasowywane do surowej nazwy symbolu, nastêpnie sprawdzane jest, czy
symbol jest symbolem C++ przez próbê odkodowania go. Niepowodzenie ka¿dego
symbolu prostego spowoduje niepowodzenie ca³ego wzorca. Z tego powodu
np. "__N3NSA6ClassA7Private11privmethod\edEi@Base" nie bêdzie pasowaæ do
¿adnego ze wzorców, poniewa¿ nie jest poprawnym symbolem C++.
.P
Ogólnie, wszystkie wzorce s± podzielone na dwie grupy: aliasy (proste \fIc++\fP
i \fIsymver\fP) i wzorce ogólne (\fIregex\fP, wszystkie kombinacje wielu prostych
wzorców). Dopasowanie prostych wzorców opartych na aliasach jest szybkie
(0(1)), a wzorce ogólne maj± 0(N) (N \- liczba wzorców ogólnych) na ka¿dy
symbol. Z tego powodu nie zaleca siê nadu¿ywania wzorców ogólnych.
.P
Gdy wiele symboli pasuje do tego samego symbolu rzeczywistego, aliasy
(najpierw \fIc++\fP, nastêpnie \fIsymver\fP) s± preferowane w stosunku do wzorców
ogólnych. Wzorce ogólne s± dopasowywane w takiej kolejno¶ci, w jakiej
zostan± odnalezione w szablonie pliku symboli, a¿ do pierwszego
sukcesu. Proszê jednak zwróciæ uwagê, ¿e rêczna zmiana kolejno¶ci wpisów
pliku szablonu nie jest zalecana, poniewa¿ \fBdpkg\-gensymbols\fP tworzy diffy w
oparciu o alfanumeryczn± kolejno¶æ ich nazw.
.SS "U¿ywanie include (do³±czeñ)"
.P
Gdy zestaw eksportowanych symboli ró¿ni siê miêdzy architekturami, mo¿e
okazaæ siê, ¿e u¿ywanie pojedynczego pliku symboli nie jest wygodne. W
takich przypadkach, dyrektywa do³±czenia mo¿e okazaæ siê przydatna na kilka
sposobów:
.IP \(bu 4
Mo¿na przenie¶æ czê¶æ wspóln± do pliku zewnêtrznego i do³±czyæ go do swojego
pliku \fIpakiet\fP.symbols.\fIarch\fP u¿ywaj±c dyrektywy do³±czenia podobnej do
poni¿szej:

#include "\fIpakiet\fP.symbols.common"
.IP \(bu
Dyrektywa do³±czenia mo¿e zostaæ otagowana podobnie jak ka¿dy symbol:

(tag|...|tagN)#include "plik\-do\-do³±czenia"

W rezultacie, wszystkie symbole z \fIpliku\-do\-do³±czenia\fP zostan± domy¶lnie
oznaczone przez \fItag\fP ... \fItagN\fP. Mo¿na u¿yæ tej funkcji, aby utworzyæ
wspólny plik \fIpakiet\fP.symbols, który do³±cza pliki symboli specyficzne dla
architektury:

  common_symbol1@Base 1.0
 (arch=amd64 ia64 alpha)#include "package.symbols.64bit"
 (arch=!amd64 !ia64 !alpha)#include "package.symbols.32bit"
  common_symbol2@Base 1.0
.P
Pliki symboli s± czytane wiersz po wierszu, a dyrektywy do³±czenia s±
przetwarzane zaraz po ich wyst±pieniu. Oznacza to, ¿e zawarto¶æ za³±czonego
pliku mo¿e przes³oniæ ka¿d± zawarto¶æ, która pojawi siê przed dyrektyw±
do³±czenia, i ¿e zawarto¶æ po dyrektywie mo¿e przes³oniæ wszystko, co
znajduje siê w do³±czanym pliku. Ka¿dy symbol (lub nawet inna dyrektywa
#include) w do³±czanym pliku mo¿e okre¶liæ dodatkowe znaczniki lub
przes³oniæ warto¶ci dziedziczonych znaczników w ich okre¶leniach
znaczników. Nie ma jednak sposobu, aby symbol usun±æ jakikolwiek z
dziedziczonych znaczników.
.P
Do³±czone pliki mog± powtórzyæ wiersz nag³ówkowy zawieraj±cy SONAME
biblioteki. W takim przypadku, przes³oni on wszystkie odczytane wcze¶niej
wiersze nag³ówkowe. Najlepiej jest jednak zapobiegaæ duplikowaniu wierszy
nag³ówkowych. Oto jeden ze sposobów:
.PP
#include "libsomething1.symbols.common"
 arch_specific_symbol@Base 1.0
.SS "Dobre zarz±dzanie bibliotek±"
.P
Dobrze zarz±dzana biblioteka ma nastêpuj±ce cechy:
.IP \(bu 4
jej API jest stabilne (symbole publiczne nie s± nigdy porzucane, dodawane s±
tylko nowe symbole publiczne), a niekompatybilne zmiany s± wykonywane tylko
przy zmianach SONAME;
.IP \(bu 4
idealnie, u¿ywa wersjonowania symboli, aby osi±gn±æ stabilno¶æ ABI
niezale¿nie od zmian wewnêtrznych i rozszerzeñ API;
.IP \(bu 4
nie eksportuje symboli prywatnych (takie symbole mog± byæ tagowane jako
opcjonalne, jako obej¶cie).
.P
Podczas zarz±dzania plikiem symboli ³atwo jest zauwa¿yæ pojawienie siê lub
znikniêcie symboli. Znacznie trudniej jednak wy³apaæ niekompatybiln± zmianê
API i ABI. W zwi±zku z tym, opiekun pakietu powinien dok³adnie sprawdziæ w
dzienniku zmian projektu macierzystego, czy istnieje przypadek, ¿e zasady
dobrego zarz±dzania bibliotek± zosta³y z³amane. Je¶li odkryje siê
potencjalne problemy, macierzysty autor powinien zostaæ poinformowany, jako
¿e poprawka w projekcie macierzystym jest zawsze lepsza, ni¿ obej¶cie
problemu w samym Debianie.
.SH OPCJE
.TP 
\fB\-P\fP\fIkatalog\-budowania\-pakietu\fP
Przeszukuje \fIkatalog\-budowania\-pakietu\fP zamiast debian/tmp.
.TP 
\fB\-p\fP\fIpakiet\fP
Definiuje nazwê pakietu. Wymagane, je¶li wiêcej ni¿ jeden pakiet binarny
jest wypisany w debian/control (lub nie ma tego pliku).
.TP 
\fB\-v\fP\fIwersja\fP
Definiuje wersjê pakietu. Domy¶lnie jest to wersja wziêta z
debian/changelog. Wymagane, je¶li wywo³anie ma miejsce spoza drzewa pakietu
¼ród³owego.
.TP 
\fB\-e\fP\fIplik\-biblioteki\fP
Analizuje jedynie biblioteki wypisane jawnie, zamiast znajdowaæ wszystkie
biblioteki publiczne. Mo¿na u¿ywaæ wzorców pow³oki u¿ywanych do rozwijania
nazw ¶cie¿kowych (patrz strona podrêcznika File::Glob, aby dowiedzieæ siê
wiêcej) w \fIpliku\-biblioteki\fP, aby dopasowaæ wiele bibiotek za pomoc±
pojedynczego argumentu (w przeciwnym wypadku potrzebne bêdzie wiele \fB\-e\fP).
.TP 
\fB\-I\fP\fInazwa\-pliku\fP
U¿ywa \fInazwy\-pliku\fP jako pliku odniesienia do generowania pliku symboli,
który jest integrowany w samym pakiecie.
.TP 
\fB\-O\fP
Wypisuje plik wygenerowanych symboli na standardowe wyj¶cie, zamiast
przechowywaæ go w drzewie budowania pakietu.
.TP  
\fB\-O\fP\fInazwa\-pliku\fP
Przechowuje wygenerowany plik symboli jako \fInazwa\-pliku\fP. Je¶li
\fInazwa\-pliku\fP ju¿ istnieje, to jej zawarto¶æ jest u¿ywana jako podstawa do
wygenerowanych plików symboli. Mo¿na u¿yæ tej funkcji aby zaktualizowaæ plik
symboli, dziêki czemy pasuje on do nowszej wersji projektu macierzystego w
bibliotece.
.TP 
\fB\-t\fP
Zapisuje plik symboli w trybie szablonu, zamiast w formacie kompatybilnym z
\fIdeb\-symbols(5)\fP. G³ówn± ró¿nic± jest to, ¿e nazwy symboli i znaczniki w
trybie szablonu s± zapisywane w ich oryginalnej formie, zamiast w
przetworzonych nazwach symboli, z wyciêtymi znacznikami w trybie
kompatybilno¶ci. Co wiêcej, czê¶æ symboli mo¿e byæ pominiêta, przy zapisie
standardowego pliku \fIdeb\-symbols(5)\fP (zgodnie z regu³ami przetwarzania
znaczników), podczas gdy wszystkie symbole s± zawsze zapisywane do szablonu
pliku symboli.
.TP 
\fB\-c\fP\fI[0\-4]\fP
Definiuje sprawdzenia do wykonania podczas porównywania wygenerowanego pliku
symboli z plikiem szablonu u¿ywanym na pocz±tku. Domy¶lnym poziomem jest
1. Zwiêkszanie poziomu wykonuje wiêcej sprawdzeñ i zawiera wszystkie
sprawdzenia z ni¿szego poziomu. Poziom 0 nigdy nie koñczy siê b³êdem. Poziom
1 sprawdza, czy jakie¶ symbole nie zniknê³y. Poziom 2 zawodzi, gdy
wprowadzono jakie¶ nowe symbole. Poziom 3 zwraca b³±d, gdy zniknê³y jakie¶
biblioteki. Poziom 4 \- gdy wprowadzono biblioteki.

Warto¶æ ta mo¿e zostaæ przes³oniêta przez zmienn± ¶rodowiskow±
DPKG_GENSYMBOLS_CHECK_LEVEL.
.TP 
\fB\-q\fP
Wycisza siê i nigdy nie tworzy ró¿nicy miêdzy generowanym plikiem symboli a
plikiem szablonu u¿ywanym na pocz±tku, ani nie pokazuje ¿adnych ostrze¿eñ na
temat nowych/porzuconych bibliotek czy nowych/porzuconych symboli. Opcja
wy³±cza jedynie wy¶wietlanie informacji, ale nie same sprawdzenia (patrz
opcja \fI\-c\fP).
.TP 
\fB\-a\fP\fIarchitektura\fP
Zak³ada \fIarchitekturê\fP jako architekturê hosta w czasie przetwarzania
plików symboli. Opcji mo¿na u¿yæ, aby wygenerowaæ plik symboli lub diff dla
której¶ z architektur, zak³adaj±c ¿e jej pliki binarne s± ju¿ dostêpne.
.TP 
\fB\-d\fP
W³±cza tryb debugowania. Wy¶wietlanych jest wiele komunikatów t³umacz±cych
dzia³anie \fBdpkg\-gensymbols\fP.
.TP 
\fB\-V\fP
W³±cza tryb szczegó³owy. Wygenerowany plik symboli zawiera przestarza³e
symbole jako komentarze. Co wiêcej, w trybie szablonu po wzorcach symboli
wystêpuj± komentarze opisuj±ce symbole rzeczywiste, które dopasowano do
wzorca.
.TP 
\fB\-?\fP, \fB\-\-help\fP
Wy¶wietla informacjê o u¿ytkowaniu i koñczy dzia³anie.
.TP 
\fB\-\-version\fP
Wy¶wietla informacjê o wersji i pomy¶lnie koñczy dzia³anie.
.
.SH "ZOBACZ TAK¯E"
\fBhttp://people.redhat.com/drepper/symbol\-versioning\fP
.br
\fBhttp://people.redhat.com/drepper/goodpractice.pdf\fP
.br
\fBhttp://people.redhat.com/drepper/dsohowto.pdf\fP
.br
\fBdeb\-symbols\fP(5), \fBdpkg\-shlibdeps\fP(1).
.SH "T£UMACZE"
Piotr Roszatycki <dexter@debian.org>, 1999
.br
Bartosz Feñski <fenio@debian.org>, 2004-2005
.br
Robert Luberda <robert@debian.org>, 2006-2008
.br
Wiktor Wandachowicz <siryes@gmail.com>, 2008
.br
Micha³ Ku³ach <michal.kulach@gmail.com>, 2012
