diff -ru gcc-3.4.0.orig/gcc/config/sol2.h gcc-3.4.0/gcc/config/sol2.h
--- gcc-3.4.0.orig/gcc/config/sol2.h	2004-05-19 22:01:51.000000000 +0200
+++ gcc-3.4.0/gcc/config/sol2.h	2004-05-19 22:04:45.000000000 +0200
@@ -203,7 +203,7 @@
     long size = getpagesize ();						\
     long mask = ~(size-1);						\
     char *page = (char *) (((long) addr) & mask); 			\
-    char *end  = (char *) ((((long) (addr + TRAMPOLINE_SIZE)) & mask) + size); \
+    char *end  = (char *) ((((long) (addr + TRAMPOLINE_SIZE-1)) & mask) + size); \
 									\
     if (mprotect (page, end - page, 7 /* STACK_PROT_RWX */) < 0)	\
       perror ("mprotect of trampoline code");				\
Only in gcc-3.4.0/gcc/config: sol2.h~
diff -ru gcc-3.4.0.orig/gcc/dbxout.c gcc-3.4.0/gcc/dbxout.c
--- gcc-3.4.0.orig/gcc/dbxout.c	2004-05-19 22:09:33.000000000 +0200
+++ gcc-3.4.0/gcc/dbxout.c	2004-05-19 22:12:41.000000000 +0200
@@ -1462,7 +1462,7 @@
 	  fputs ("@s", asmfile);
 	  CHARS (2);
 	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
-	  fputs (";-20;", asmfile);
+	  fputs (";-20", asmfile);
 	  CHARS (4);
 	}
       else
@@ -1484,7 +1484,7 @@
 	  fputs ("@s", asmfile);
 	  CHARS (2);
 	  print_wide_int (BITS_PER_UNIT * int_size_in_bytes (type));
-	  fputs (";-16;", asmfile);
+	  fputs (";-16", asmfile);
 	  CHARS (4);
 	}
       else /* Define as enumeral type (False, True) */
Only in gcc-3.4.0/gcc: dbxout.c~
diff -ru gcc-3.4.0.orig/gcc/dwarf2out.c gcc-3.4.0/gcc/dwarf2out.c
--- gcc-3.4.0.orig/gcc/dwarf2out.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/dwarf2out.c	2004-05-19 22:03:12.000000000 +0200
@@ -8607,6 +8607,9 @@
     case VIEW_CONVERT_EXPR:
     case SAVE_EXPR:
     case MODIFY_EXPR:
+#ifdef GPC
+    case UNSAVE_EXPR:
+#endif
       return loc_descriptor_from_tree (TREE_OPERAND (loc, 0), addressp);
 
     case COMPONENT_REF:
@@ -8809,6 +8812,15 @@
       add_loc_descr (&ret, new_loc_descr (op, 0, 0));
       break;
 
+#ifdef GPC
+    case MIN_EXPR:
+      loc = build (COND_EXPR, TREE_TYPE (loc),
+		   build (GT_EXPR, integer_type_node,
+			  TREE_OPERAND (loc, 0), TREE_OPERAND (loc, 1)),
+		   TREE_OPERAND (loc, 1), TREE_OPERAND (loc, 0));
+      goto cond_expr;
+#endif
+
     case MAX_EXPR:
       loc = build (COND_EXPR, TREE_TYPE (loc),
 		   build (LT_EXPR, integer_type_node,
@@ -8818,6 +8830,9 @@
       /* ... fall through ...  */
 
     case COND_EXPR:
+#ifdef GPC
+    cond_expr:
+#endif
       {
 	dw_loc_descr_ref lhs
 	  = loc_descriptor_from_tree (TREE_OPERAND (loc, 1), 0);
@@ -8848,6 +8863,21 @@
       }
       break;
 
+#ifdef GPC
+    case REAL_CST:
+    case FLOAT_EXPR:
+    case FIX_TRUNC_EXPR:
+    case FIX_CEIL_EXPR:
+    case FIX_FLOOR_EXPR:
+    case FIX_ROUND_EXPR:
+    case RDIV_EXPR:
+      /* In Pascal it's possible for array bounds to contain floating point
+         expressions (e.g., p/test/emil11c.pas). I don't know if it's
+         possible to represent them in dwarf2, but it doesn't seem terribly
+         important since this occurs quite rarely. -- Frank */
+      return 0;
+#endif
+
     case EXPR_WITH_FILE_LOCATION:
       return loc_descriptor_from_tree (EXPR_WFL_NODE (loc), addressp);
 
diff -ru gcc-3.4.0.orig/gcc/expr.c gcc-3.4.0/gcc/expr.c
--- gcc-3.4.0.orig/gcc/expr.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/expr.c	2004-05-19 22:03:12.000000000 +0200
@@ -19,6 +19,9 @@
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.  */
 
+
+/* @@ PATCHED FOR GPC @@ */
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -5077,13 +5080,36 @@
 	  return;
 	}
 
+#ifndef GPC
       domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));
       domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));
+#else /* GPC */
+      domain_min = convert (sbitsizetype, TYPE_MIN_VALUE (domain));
+      domain_max = convert (sbitsizetype, TYPE_MAX_VALUE (domain));
+
+      /* Align the set.  */
+      if (set_alignment)
+        domain_min = size_binop (BIT_AND_EXPR, domain_min, sbitsize_int (-(int) set_alignment));
+
+#endif /* GPC */
       bitlength = size_binop (PLUS_EXPR,
-			      size_diffop (domain_max, domain_min),
+			      size_binop (MINUS_EXPR, domain_max, domain_min),
+#ifndef GPC
 			      ssize_int (1));
-
+#else /* GPC */
+			      sbitsize_int (1));
+#endif /* GPC */
+
+#ifdef GPC
+      if (TREE_INT_CST_HIGH (bitlength)) {
+        error ("set size too big for host integers");
+        return;
+      }
+#endif /* GPC */
       nbits = tree_low_cst (bitlength, 1);
+#ifdef GPC
+      bitlength = convert (sizetype, bitlength);
+#endif /* GPC */
 
       /* For "small" sets, or "medium-sized" (up to 32 bytes) sets that
 	 are "complicated" (more than one range), initialize (the
@@ -5091,7 +5117,9 @@
       if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD
 	  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))
 	{
+#ifndef GPC
 	  unsigned int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));
+#endif /* not GPC */
 	  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);
 	  char *bit_buffer = alloca (nbits);
 	  HOST_WIDE_INT word = 0;
@@ -5104,10 +5132,14 @@
 	    {
 	      if (bit_buffer[ibit])
 		{
+#ifndef GPC
 		  if (BYTES_BIG_ENDIAN)
-		    word |= (1 << (set_word_size - 1 - bit_pos));
+#else /* GPC */
+		  if (set_words_big_endian)
+#endif /* GPC */
+		    word |= (((HOST_WIDE_INT)1) << (set_word_size - 1 - bit_pos));
 		  else
-		    word |= 1 << bit_pos;
+		    word |= ((HOST_WIDE_INT)1) << bit_pos;
 		}
 
 	      bit_pos++;  ibit++;
@@ -5169,13 +5201,23 @@
 	      endbit = startbit;
 	    }
 
+#ifndef GPC
 	  startbit = convert (sizetype, startbit);
 	  endbit = convert (sizetype, endbit);
+#endif /* not GPC */
 	  if (! integer_zerop (domain_min))
 	    {
+#ifdef GPC
+	      startbit = convert (sbitsizetype, startbit);
+	      endbit = convert (sbitsizetype, endbit);
+#endif /* GPC */
 	      startbit = size_binop (MINUS_EXPR, startbit, domain_min);
 	      endbit = size_binop (MINUS_EXPR, endbit, domain_min);
 	    }
+#ifdef GPC
+	  startbit = convert (sizetype, startbit);
+	  endbit = convert (sizetype, endbit);
+#endif /* GPC */
 	  startbit_rtx = expand_expr (startbit, NULL_RTX, MEM,
 				      EXPAND_CONST_ADDRESS);
 	  endbit_rtx = expand_expr (endbit, NULL_RTX, MEM,
@@ -5541,8 +5583,18 @@
 	     index, then convert to sizetype and multiply by the size of the
 	     array element.  */
 	  if (low_bound != 0 && ! integer_zerop (low_bound))
+#ifdef GPC
+	    /* I think that address arithmetic should always be done on sizetype or
+	       its variants -- for Pascal signed seems to be the correct choice (and
+	       generates slightly better code). -- Waldek */
+	    index = convert (sizetype, convert (bitsizetype,
+	              size_binop (MINUS_EXPR,
+	                convert (sbitsizetype, index),
+	                convert (sbitsizetype, low_bound))));
+#else
 	    index = fold (build (MINUS_EXPR, TREE_TYPE (index),
 				 index, low_bound));
+#endif
 
 	  /* If the index has a self-referential type, pass it to a
 	     WITH_RECORD_EXPR; if the component size is, pass our
diff -ru gcc-3.4.0.orig/gcc/fold-const.c gcc-3.4.0/gcc/fold-const.c
--- gcc-3.4.0.orig/gcc/fold-const.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/fold-const.c	2004-05-19 22:03:12.000000000 +0200
@@ -19,6 +19,9 @@
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.  */
 
+
+/* @@ PATCHED FOR GPC @@ */
+
 /*@@ This file should be rewritten to use an arbitrary precision
   @@ representation for "struct tree_int_cst" and "struct tree_real_cst".
   @@ Perhaps the routines could also be used for bc/dc, and made a lib.
@@ -225,6 +228,17 @@
 	    && TYPE_IS_SIZETYPE (TREE_TYPE (t))))
     return overflow;
 
+#ifdef GPC
+  /* Sign extension for unsigned types (sizetype) seems quite wrong.
+     Though the previous comment says otherwise, but according to the
+     GCC ChangeLog entry of 2000-10-20, I suppose it was meant only
+     to allow for overflows, not to sign extension, for sizetypes.
+     The problem shows, e.g., when converting a bitsizetype to
+     sizetype where the value doesn't fit in ssizetype. -- Frank */
+  if (!TREE_UNSIGNED (TREE_TYPE (t)))
+  {
+#endif
+
   /* If the value's sign bit is set, extend the sign.  */
   if (prec != 2 * HOST_BITS_PER_WIDE_INT
       && (prec > HOST_BITS_PER_WIDE_INT
@@ -247,6 +261,10 @@
 	}
     }
 
+#ifdef GPC
+  }
+#endif
+
   /* Return nonzero if signed overflow occurred.  */
   return
     ((overflow | (low ^ TREE_INT_CST_LOW (t)) | (high ^ TREE_INT_CST_HIGH (t)))
@@ -1343,10 +1361,14 @@
     }
 
   TREE_OVERFLOW (t)
+#ifndef GPC
     = ((notrunc
 	? (!uns || is_sizetype) && overflow
 	: (force_fit_type (t, (!uns || is_sizetype) && overflow)
 	   && ! no_overflow))
+#else /* GPC */
+	  = ((notrunc ? overflow : force_fit_type (t, overflow))
+#endif /* GPC */
        | TREE_OVERFLOW (arg1)
        | TREE_OVERFLOW (arg2));
 
diff -ru gcc-3.4.0.orig/gcc/function.c gcc-3.4.0/gcc/function.c
--- gcc-3.4.0.orig/gcc/function.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/function.c	2004-05-19 22:08:25.000000000 +0200
@@ -38,6 +38,8 @@
    This function changes the DECL_RTL to be a stack slot instead of a reg
    then scans all the RTL instructions so far generated to correct them.  */
 
+/* @@ PATCHED FOR GPC @@ */
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -6962,8 +6964,13 @@
       tramp = round_trampoline_addr (XEXP (tramp, 0));
 #ifdef TRAMPOLINE_TEMPLATE
       blktramp = replace_equiv_address (initial_trampoline, tramp);
+#ifndef GPC
       emit_block_move (blktramp, initial_trampoline,
 		       GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);
+#else
+      emit_block_move (blktramp, initial_trampoline,
+                       GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NO_LIBCALL);
+#endif
 #endif
       trampolines_created = 1;
       INITIALIZE_TRAMPOLINE (tramp, XEXP (DECL_RTL (function), 0), context);
Only in gcc-3.4.0/gcc: function.c~
diff -ru gcc-3.4.0.orig/gcc/integrate.c gcc-3.4.0/gcc/integrate.c
--- gcc-3.4.0.orig/gcc/integrate.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/integrate.c	2004-05-19 22:03:12.000000000 +0200
@@ -1341,6 +1341,30 @@
     {
       rtx copy, pattern, set;
 
+#ifdef GPC
+      /* CALL_PLACEHOLDERs within inline functions seem to cause
+         trouble in Pascal (fjf709.pas). References to formal
+         parameters of the inline function might get confused. So
+         replace the CALL_PLACEHOLDER by the normal calling code
+         here, at the cost of avoiding this particular combination
+         of optimizations (inlining and tail recursion/sibling
+         calls) -- though I'm not actually sure if it should be done
+         at all; the C frontend also seems to do only inlining in a
+         similar situation, and this might be good enough already.
+
+         I don't understand all the backend does here, and I'm not
+         even sure if the real bug is in the fontend or backend, or
+         whether this is a fix or a work-around ... -- Frank */
+      if (GET_CODE (insn) == CALL_INSN
+          && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)
+        {
+          rtx tmp = PREV_INSN (insn);
+          replace_call_placeholder (insn, sibcall_use_normal);
+          insn = tmp;
+          continue;
+        }
+#endif
+
       map->orig_asm_operands_vector = 0;
 
       switch (GET_CODE (insn))
diff -ru gcc-3.4.0.orig/gcc/stor-layout.c gcc-3.4.0/gcc/stor-layout.c
--- gcc-3.4.0.orig/gcc/stor-layout.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/stor-layout.c	2004-05-19 22:38:36.000000000 +0200
@@ -20,6 +20,8 @@
 02111-1307, USA.  */
 
 
+/* @@ PATCHED FOR GPC 20040512 @@ */
+
 #include "config.h"
 #include "system.h"
 #include "coretypes.h"
@@ -59,6 +61,20 @@
    called only by a front end.  */
 static int reference_types_internal = 0;
 
+#ifdef GPC
+/* The word size of a bitstring or (power-)set value, in bits.
+   Must be non-zero.
+   May be overridden by front-ends.  */
+unsigned int set_word_size = BITS_PER_UNIT;
+
+/* If non-zero, bits in (power-)sets start with the highest bit.
+   May be overridden by front-ends.
+   In order to be backward-compatible, the Chill frontend should
+   initialize this to BYTES_BIG_ENDIAN.  */
+unsigned int set_words_big_endian = 0;
+
+#endif /* GPC */
+
 static void finalize_record_size (record_layout_info);
 static void finalize_type_size (tree);
 static void place_union_field (record_layout_info, tree);
@@ -1655,7 +1671,11 @@
 
 		if (maxvalue - minvalue == 1
 		    && (maxvalue == 1 || maxvalue == 0))
+#ifndef GPC
 		  element_size = integer_one_node;
+#else /* GPC */
+		  element_size = bitsize_int(1);
+#endif /* GPC */
 	      }
 
 	    /* If neither bound is a constant and sizetype is signed, make
@@ -1760,6 +1780,7 @@
 	abort ();
       else
 	{
+#ifndef GPC
 #ifndef SET_WORD_SIZE
 #define SET_WORD_SIZE BITS_PER_WORD
 #endif
@@ -1778,9 +1799,47 @@
 
 	  TYPE_SIZE (type) = bitsize_int (rounded_size);
 	  TYPE_SIZE_UNIT (type) = size_int (rounded_size / BITS_PER_UNIT);
+#else /* GPC */
+	  int alignment = set_alignment ? set_alignment : set_word_size;
+	  tree lower_bound = convert (sbitsizetype, 
+			TYPE_MIN_VALUE (TYPE_DOMAIN (type))); 
+	  tree upper_bound = convert (sbitsizetype,
+			TYPE_MAX_VALUE (TYPE_DOMAIN (type))); 
+	  tree size_in_bits, rounded_size;
+	  if (set_alignment)
+            {
+              lower_bound = round_down (lower_bound, alignment);
+            }
+	  size_in_bits = size_binop (PLUS_EXPR,
+				size_binop (MINUS_EXPR,
+					upper_bound,
+					lower_bound),
+				sbitsize_int(1));
+          rounded_size = round_up (size_in_bits, alignment);
+				
+	  if ( TREE_INT_CST_HIGH (rounded_size) 
+		|| TREE_INT_CST_LOW (rounded_size) > (unsigned) alignment) 
+	    {
+		TYPE_MODE (type) = BLKmode;
+	    }
+	  else 
+	    {
+		TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);
+	    } 
+
+	  TYPE_SIZE (type) = convert (bitsizetype, rounded_size);
+	  TYPE_SIZE_UNIT (type) = convert (sizetype, 
+				size_binop ( CEIL_DIV_EXPR,
+					rounded_size, 
+					sbitsize_int (BITS_PER_UNIT)));
+#endif /* GPC */
 	  TYPE_ALIGN (type) = alignment;
 	  TYPE_USER_ALIGN (type) = 0;
+#ifndef GPC
 	  TYPE_PRECISION (type) = size_in_bits;
+#else /* GPC */
+	  TYPE_PRECISION (type) = TREE_INT_CST_LOW (size_in_bits);
+#endif /* GPC */
 	}
       break;
 
Only in gcc-3.4.0/gcc: stor-layout.c~
diff -ru gcc-3.4.0.orig/gcc/tree.c gcc-3.4.0/gcc/tree.c
--- gcc-3.4.0.orig/gcc/tree.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/tree.c	2004-05-19 22:03:12.000000000 +0200
@@ -19,6 +19,8 @@
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 02111-1307, USA.  */
 
+/* @@ PATCHED FOR GPC @@ */
+
 /* This file contains the low level primitives for operating on tree nodes,
    including allocation, list operations, interning of identifiers,
    construction of data type nodes and statement nodes,
@@ -4649,10 +4651,18 @@
     = tree_low_cst (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (init))), 0);
   tree non_const_bits = NULL_TREE;
 
+#ifdef GPC
+  /* Align the set.  */
+  if (set_alignment)
+    /* Note: `domain_min -= domain_min % set_alignment' would be wrong for negative
+       numbers (rounding towards 0, while we have to round towards -inf). */
+    domain_min &= -(int) set_alignment;
+#endif /* GPC */
+
   for (i = 0; i < bit_size; i++)
     buffer[i] = 0;
 
-  for (vals = TREE_OPERAND (init, 1);
+  for (vals = CONSTRUCTOR_ELTS (init);
        vals != NULL_TREE; vals = TREE_CHAIN (vals))
     {
       if (!host_integerp (TREE_VALUE (vals), 0)
@@ -4670,7 +4680,10 @@
 
 	  if (lo_index < 0 || lo_index >= bit_size
 	      || hi_index < 0 || hi_index >= bit_size)
-	    abort ();
+	    {
+	      error ("invalid set initializer");
+	      return NULL_TREE;
+	    }
 	  for (; lo_index <= hi_index; lo_index++)
 	    buffer[lo_index] = 1;
 	}
@@ -4681,7 +4694,7 @@
 	    = tree_low_cst (TREE_VALUE (vals), 0) - domain_min;
 	  if (index < 0 || index >= bit_size)
 	    {
-	      error ("invalid initializer for bit string");
+	      error ("invalid set initializer");
 	      return NULL_TREE;
 	    }
 	  buffer[index] = 1;
@@ -4699,9 +4712,14 @@
 get_set_constructor_bytes (tree init, unsigned char *buffer, int wd_size)
 {
   int i;
+#ifdef GPC
+  int bit_size = wd_size * BITS_PER_UNIT;
+  unsigned int bit_pos = 0;
+#else /* not GPC */
   int set_word_size = BITS_PER_UNIT;
   int bit_size = wd_size * set_word_size;
   int bit_pos = 0;
+#endif /* not GPC */
   unsigned char *bytep = buffer;
   char *bit_buffer = alloca (bit_size);
   tree non_const_bits = get_set_constructor_bits (init, bit_buffer, bit_size);
@@ -4711,6 +4729,24 @@
 
   for (i = 0; i < bit_size; i++)
     {
+#ifdef GPC
+      if (bit_buffer[i])
+	{
+          int k = bit_pos / BITS_PER_UNIT;
+          if (WORDS_BIG_ENDIAN)
+            k = set_word_size / BITS_PER_UNIT - 1 - k;
+	  if (set_words_big_endian)
+	    bytep[k] |= (1 << (BITS_PER_UNIT - 1 - bit_pos % BITS_PER_UNIT));
+	  else
+	    bytep[k] |= (1 << (bit_pos % BITS_PER_UNIT));
+	}
+      bit_pos++;
+      if (bit_pos >= set_word_size)
+	{
+          bit_pos = 0;
+          bytep += set_word_size / BITS_PER_UNIT;
+        }
+#else /* not GPC */
       if (bit_buffer[i])
 	{
 	  if (BYTES_BIG_ENDIAN)
@@ -4721,6 +4757,7 @@
       bit_pos++;
       if (bit_pos >= set_word_size)
 	bit_pos = 0, bytep++;
+#endif /* not GPC */
     }
   return non_const_bits;
 }
Only in gcc-3.4.0/gcc: tree.def~
diff -ru gcc-3.4.0.orig/gcc/tree.h gcc-3.4.0/gcc/tree.h
--- gcc-3.4.0.orig/gcc/tree.h	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/tree.h	2004-05-19 22:03:12.000000000 +0200
@@ -22,6 +22,9 @@
 #ifndef GCC_TREE_H
 #define GCC_TREE_H
 
+
+/* @@ PATCHED FOR GPC @@ */
+
 #include "machmode.h"
 #include "version.h"
 #include "input.h"
@@ -2463,6 +2466,14 @@
 
 /* If nonzero, the alignment of a bitstring or (power-)set value, in bits.  */
 extern unsigned int set_alignment;
+#ifdef GPC
+
+/* The word size of a bitstring or (power-)set value, in bits.  */
+extern unsigned int set_word_size;
+
+/* If non-zero, bits in (power-)sets start with the highest bit.  */
+extern unsigned int set_words_big_endian;
+#endif /* GPC */
 
 /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
    by making the last node in X point to Y.
diff -ru gcc-3.4.0.orig/gcc/version.c gcc-3.4.0/gcc/version.c
--- gcc-3.4.0.orig/gcc/version.c	2004-05-19 21:59:36.000000000 +0200
+++ gcc-3.4.0/gcc/version.c	2004-05-19 22:03:12.000000000 +0200
@@ -14,4 +14,8 @@
    forward us bugs reported to you, if you determine that they are
    not bugs in your modifications.)  */
 
+#ifdef GPC
+const char bug_report_url[] = "<URL:http://www.gnu-pascal.de/todo.html>";
+#else
 const char bug_report_url[] = "<URL:http://gcc.gnu.org/bugs.html>";
+#endif
