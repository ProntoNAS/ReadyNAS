From 7ade279b46aec3ebe9f3ff91fd47091a87ac24db Mon Sep 17 00:00:00 2001
From: Justin Maggard <jmaggard@netgear.com>
Date: Thu, 9 Jun 2011 17:55:38 -0700
Subject: [PATCH] Port Sunil Ghai's LLMNR support code to current Avahi.

---
 avahi-common/dbus.c            |    3 +-
 avahi-common/dbus.h            |    1 +
 avahi-common/defs.h            |   24 ++-
 avahi-common/error.c           |    3 +-
 avahi-common/error.h           |    3 +-
 avahi-core/Makefile.am         |    8 +-
 avahi-core/announce.c          |  104 ++++---
 avahi-core/browse.c            |  143 ++++++++--
 avahi-core/cache.c             |    4 +-
 avahi-core/core.h              |    2 +
 avahi-core/dns.c               |  219 ++++++++++++++
 avahi-core/dns.h               |   39 +++
 avahi-core/entry.c             |  610 ++++++++++++++++++++++++++++++----------
 avahi-core/iface-linux.c       |    9 +-
 avahi-core/iface.c             |  447 +++++++++++++++++++++---------
 avahi-core/iface.h             |   67 ++++--
 avahi-core/internal.h          |  111 ++++++--
 avahi-core/llmnr-lookup.c      |  492 ++++++++++++++++++++++++++++++++
 avahi-core/llmnr-lookup.h      |  127 +++++++++
 avahi-core/llmnr-querier.c     |  196 +++++++++++++
 avahi-core/llmnr-querier.h     |   71 +++++
 avahi-core/llmnr-query-sched.c |  318 +++++++++++++++++++++
 avahi-core/llmnr-query-sched.h |   57 ++++
 avahi-core/llmnr-response.c    |  109 +++++++
 avahi-core/llmnr-response.h    |   40 +++
 avahi-core/llmnr-server.c      |  535 +++++++++++++++++++++++++++++++++++
 avahi-core/multicast-lookup.c  |    4 +-
 avahi-core/probe-sched.c       |    4 +-
 avahi-core/publish.h           |    3 +-
 avahi-core/querier.c           |   22 +-
 avahi-core/query-sched.c       |    6 +-
 avahi-core/resolve-address.c   |   46 ++-
 avahi-core/resolve-host-name.c |    4 +-
 avahi-core/response-sched.c    |    2 +-
 avahi-core/server.c            |  326 ++++++++++++---------
 avahi-core/socket.c            |   75 ++++--
 avahi-core/socket.h            |   16 +-
 avahi-core/verify.c            |  458 ++++++++++++++++++++++++++++++
 avahi-core/verify.h            |   57 ++++
 avahi-core/wide-area.c         |    4 +-
 avahi-daemon/hosts             |   16 +-
 avahi-daemon/static-hosts.c    |   61 ++++-
 42 files changed, 4218 insertions(+), 628 deletions(-)
 create mode 100644 avahi-core/llmnr-lookup.c
 create mode 100644 avahi-core/llmnr-lookup.h
 create mode 100644 avahi-core/llmnr-querier.c
 create mode 100644 avahi-core/llmnr-querier.h
 create mode 100644 avahi-core/llmnr-query-sched.c
 create mode 100644 avahi-core/llmnr-query-sched.h
 create mode 100644 avahi-core/llmnr-response.c
 create mode 100644 avahi-core/llmnr-response.h
 create mode 100644 avahi-core/llmnr-server.c
 create mode 100644 avahi-core/verify.c
 create mode 100644 avahi-core/verify.h

diff --git a/avahi-common/dbus.c b/avahi-common/dbus.c
index f19c77c..84263c4 100644
--- a/avahi-common/dbus.c
+++ b/avahi-common/dbus.c
@@ -87,7 +87,8 @@ static const char * const table[- AVAHI_ERR_MAX] = {
     AVAHI_DBUS_ERR_NOT_PERMITTED,
     AVAHI_DBUS_ERR_INVALID_ARGUMENT,
     AVAHI_DBUS_ERR_IS_EMPTY,
-    AVAHI_DBUS_ERR_NO_CHANGE
+    AVAHI_DBUS_ERR_NO_CHANGE,
+    AVAHI_DBUS_ERR_INVALID_GROUP
 };
 
 struct error_map {
diff --git a/avahi-common/dbus.h b/avahi-common/dbus.h
index ea3e8a2..9af8295 100644
--- a/avahi-common/dbus.h
+++ b/avahi-common/dbus.h
@@ -107,6 +107,7 @@ Avahi 0.6.1 implements API version 0x0202 */
 #define AVAHI_DBUS_ERR_INVALID_ARGUMENT "org.freedesktop.Avahi.InvalidArgumentError"
 #define AVAHI_DBUS_ERR_IS_EMPTY "org.freedesktop.Avahi.IsEmptyError"
 #define AVAHI_DBUS_ERR_NO_CHANGE "org.freedesktop.Avahi.NoChangeError"
+#define AVAHI_DBUS_ERR_INVALID_GROUP "org.freedesktop.Avahi.InvalidGroupError"
 
 /** Convert a DBus error string into an Avahi error number */
 int avahi_error_dbus_to_number(const char *s);
diff --git a/avahi-common/defs.h b/avahi-common/defs.h
index bb73a9d..df01a9c 100644
--- a/avahi-common/defs.h
+++ b/avahi-common/defs.h
@@ -232,7 +232,12 @@ typedef enum {
     AVAHI_ENTRY_GROUP_REGISTERING,   /**< The entries of the group are currently being registered */
     AVAHI_ENTRY_GROUP_ESTABLISHED,   /**< The entries have successfully been established */
     AVAHI_ENTRY_GROUP_COLLISION,     /**< A name collision for one of the entries in the group has been detected, the entries have been withdrawn */
-    AVAHI_ENTRY_GROUP_FAILURE        /**< Some kind of failure happened, the entries have been withdrawn */
+    AVAHI_ENTRY_GROUP_FAILURE,       /**< Some kind of failure happened, the entries have been withdrawn */
+    AVAHI_ENTRY_GROUP_LLMNR_UNCOMMITED = AVAHI_ENTRY_GROUP_UNCOMMITED,
+    AVAHI_ENTRY_GROUP_LLMNR_VERIFYING = AVAHI_ENTRY_GROUP_REGISTERING,  
+    AVAHI_ENTRY_GROUP_LLMNR_ESTABLISHED = AVAHI_ENTRY_GROUP_ESTABLISHED,
+    AVAHI_ENTRY_GROUP_LLMNR_COLLISION = AVAHI_ENTRY_GROUP_COLLISION,
+    AVAHI_ENTRY_GROUP_LLMNR_FAILURE = AVAHI_ENTRY_GROUP_FAILURE
 } AvahiEntryGroupState;
 
 /** @} */
@@ -252,7 +257,9 @@ typedef enum {
     AVAHI_PUBLISH_UPDATE = 64,          /**< Update existing records instead of adding new ones */
 /** \cond fulldocs */
     AVAHI_PUBLISH_USE_WIDE_AREA = 128,  /**< Register the record using wide area DNS (i.e. unicast DNS update) */
-    AVAHI_PUBLISH_USE_MULTICAST = 256   /**< Register the record using multicast DNS */
+    AVAHI_PUBLISH_USE_MULTICAST = 256,  /**< Register the record using multicast DNS */
+    AVAHI_PUBLISH_USE_LLMNR = 512,
+    AVAHI_PUBLISH_NO_VERIFY = 1024
 /** \endcond */
 } AvahiPublishFlags;
 
@@ -263,7 +270,8 @@ typedef enum {
     AVAHI_LOOKUP_USE_MULTICAST = 2,    /**< Force lookup via multicast DNS */
 /** \endcond */
     AVAHI_LOOKUP_NO_TXT = 4,           /**< When doing service resolving, don't lookup TXT record */
-    AVAHI_LOOKUP_NO_ADDRESS = 8        /**< When doing service resolving, don't lookup A/AAAA record */
+    AVAHI_LOOKUP_NO_ADDRESS = 8,       /**< When doing service resolving, don't lookup A/AAAA record */
+    AVAHI_LOOKUP_USE_LLMNR = 16
 } AvahiLookupFlags;
 
 /** Some flags for lookup callback functions */
@@ -273,11 +281,16 @@ typedef enum {
     AVAHI_LOOKUP_RESULT_MULTICAST = 4,      /**< This response originates from multicast DNS */
     AVAHI_LOOKUP_RESULT_LOCAL = 8,          /**< This record/service resides on and was announced by the local host. Only available in service and record browsers and only on AVAHI_BROWSER_NEW. */
     AVAHI_LOOKUP_RESULT_OUR_OWN = 16,       /**< This service belongs to the same local client as the browser object. Only available in avahi-client, and only for service browsers and only on AVAHI_BROWSER_NEW. */
-    AVAHI_LOOKUP_RESULT_STATIC = 32         /**< The returned data has been defined statically by some configuration option */
+    AVAHI_LOOKUP_RESULT_STATIC = 32,        /**< The returned data has been defined statically by some configuration option */
+    AVAHI_LOOKUP_RESULT_LLMNR = 64
 } AvahiLookupResultFlags;
 
 /** @} */
-
+typedef enum {
+    AVAHI_MDNS,
+    AVAHI_LLMNR,
+    AVAHI_WIDE_AREA
+} AvahiPublishProtocol;
 /** @{ \name Events */
 
 /** Type of callback event when browsing */
@@ -347,6 +360,7 @@ enum {
 
 /** The default TTL for RRs which contain a host name of some kind. */
 #define AVAHI_DEFAULT_TTL_HOST_NAME (120)
+#define AVAHI_DEFAULT_LLMNR_TTL_HOST_NAME (30)
 
 /** The default TTL for all other records. */
 #define AVAHI_DEFAULT_TTL (75*60)
diff --git a/avahi-common/error.c b/avahi-common/error.c
index b0b66ea..5b5a790 100644
--- a/avahi-common/error.c
+++ b/avahi-common/error.c
@@ -85,7 +85,8 @@ const char *avahi_strerror(int error) {
         N_("Not permitted"),
         N_("Invalid argument"),
         N_("Is empty"),
-        N_("The requested operation is invalid because redundant")
+        N_("The requested operation is invalid because redundant"),
+        N_("New entry is requested to be published with invalid group")
     };
 
     avahi_init_i18n();
diff --git a/avahi-common/error.h b/avahi-common/error.h
index 392aaf5..7e3fbfe 100644
--- a/avahi-common/error.h
+++ b/avahi-common/error.h
@@ -87,6 +87,7 @@ enum {
     AVAHI_ERR_INVALID_ARGUMENT = -51,        /**< Invalid argument */
     AVAHI_ERR_IS_EMPTY = -52,                /**< Is empty */
     AVAHI_ERR_NO_CHANGE = -53,               /**< The requested operation is invalid because it is redundant */
+    AVAHI_ERR_INVALID_GROUP = -54,           /**< New entry is requested to be published with invalid group */
 
     /****
      ****    IF YOU ADD A NEW ERROR CODE HERE, PLEASE DON'T FORGET TO ADD
@@ -96,7 +97,7 @@ enum {
      ****    Also remember to update the MAX value below.
      ****/
 
-    AVAHI_ERR_MAX = -54
+    AVAHI_ERR_MAX = -55
 };
 
 /** Return a human readable error string for the specified error code */
diff --git a/avahi-core/Makefile.am b/avahi-core/Makefile.am
index 2f09596..093b899 100644
--- a/avahi-core/Makefile.am
+++ b/avahi-core/Makefile.am
@@ -83,7 +83,13 @@ libavahi_core_la_SOURCES = \
 	querier.c querier.h \
 	addr-util.h addr-util.c \
 	domain-util.h domain-util.c \
-	dns-srv-rr.h
+	dns-srv-rr.h \
+	llmnr-querier.c llmnr-querier.h \
+	llmnr-query-sched.c llmnr-query-sched.h \
+	verify.c verify.h \
+	llmnr-lookup.c llmnr-lookup.h \
+	llmnr-response.c llmnr-response.h \
+	llmnr-server.c 
 
 if HAVE_NETLINK
 libavahi_core_la_SOURCES += \
diff --git a/avahi-core/announce.c b/avahi-core/announce.c
index ccdbf15..81e0ca5 100644
--- a/avahi-core/announce.c
+++ b/avahi-core/announce.c
@@ -41,8 +41,10 @@ static void remove_announcer(AvahiServer *s, AvahiAnnouncer *a) {
     if (a->time_event)
         avahi_time_event_free(a->time_event);
 
-    AVAHI_LLIST_REMOVE(AvahiAnnouncer, by_interface, a->interface->announcers, a);
-    AVAHI_LLIST_REMOVE(AvahiAnnouncer, by_entry, a->entry->announcers, a);
+    AVAHI_LLIST_REMOVE(AvahiAnnouncer, by_interface, a->interface->mdns.announcers, a);
+
+    assert(a->entry->type == AVAHI_ENTRY_MDNS);
+    AVAHI_LLIST_REMOVE(AvahiAnnouncer, by_entry, a->entry->proto.mdns.announcers, a);
 
     avahi_free(a);
 }
@@ -71,11 +73,11 @@ static void next_state(AvahiAnnouncer *a);
 void avahi_s_entry_group_check_probed(AvahiSEntryGroup *g, int immediately) {
     AvahiEntry *e;
     assert(g);
-    assert(!g->dead);
+    assert(!g->dead && g->type == AVAHI_GROUP_MDNS);
 
     /* Check whether all group members have been probed */
 
-    if (g->state != AVAHI_ENTRY_GROUP_REGISTERING || g->n_probing > 0)
+    if (g->state != AVAHI_ENTRY_GROUP_REGISTERING || g->proto.mdns.n_probing > 0)
         return;
 
     avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_ESTABLISHED);
@@ -85,8 +87,9 @@ void avahi_s_entry_group_check_probed(AvahiSEntryGroup *g, int immediately) {
 
     for (e = g->entries; e; e = e->by_group_next) {
         AvahiAnnouncer *a;
+        assert(e->type == AVAHI_ENTRY_MDNS);
 
-        for (a = e->announcers; a; a = a->by_entry_next) {
+        for (a = e->proto.mdns.announcers; a; a = a->by_entry_next) {
 
             if (a->state != AVAHI_WAITING)
                 continue;
@@ -113,7 +116,7 @@ static void next_state(AvahiAnnouncer *a) {
 
     if (a->state == AVAHI_WAITING) {
 
-        assert(a->entry->group);
+        assert(a->entry->group && a->entry->group->type == AVAHI_GROUP_MDNS);
 
         avahi_s_entry_group_check_probed(a->entry->group, 1);
 
@@ -123,8 +126,8 @@ static void next_state(AvahiAnnouncer *a) {
             /* Probing done */
 
             if (a->entry->group) {
-                assert(a->entry->group->n_probing);
-                a->entry->group->n_probing--;
+                assert(a->entry->group->type == AVAHI_GROUP_MDNS && a->entry->group->proto.mdns.n_probing);
+                a->entry->group->proto.mdns.n_probing--;
             }
 
             if (a->entry->group && a->entry->group->state == AVAHI_ENTRY_GROUP_REGISTERING)
@@ -185,10 +188,10 @@ static AvahiAnnouncer *get_announcer(AvahiServer *s, AvahiEntry *e, AvahiInterfa
     AvahiAnnouncer *a;
 
     assert(s);
-    assert(e);
+    assert(e && e->type == AVAHI_ENTRY_MDNS);
     assert(i);
 
-    for (a = e->announcers; a; a = a->by_entry_next)
+    for (a = e->proto.mdns.announcers; a; a = a->by_entry_next)
         if (a->interface == i)
             return a;
 
@@ -201,6 +204,7 @@ static void go_to_initial_state(AvahiAnnouncer *a) {
 
     assert(a);
     e = a->entry;
+    assert(e->type == AVAHI_ENTRY_MDNS);
 
     if ((e->flags & AVAHI_PUBLISH_UNIQUE) && !(e->flags & AVAHI_PUBLISH_NO_PROBE))
         a->state = AVAHI_PROBING;
@@ -217,8 +221,10 @@ static void go_to_initial_state(AvahiAnnouncer *a) {
     a->n_iteration = 1;
     a->sec_delay = 1;
 
-    if (a->state == AVAHI_PROBING && e->group)
-        e->group->n_probing++;
+    if (a->state == AVAHI_PROBING && e->group) {
+        assert(e->group->type == AVAHI_GROUP_MDNS);
+        e->group->proto.mdns.n_probing++;
+    }
 
     if (a->state == AVAHI_PROBING)
         set_timeout(a, avahi_elapse_time(&tv, 0, AVAHI_PROBE_JITTER_MSEC));
@@ -234,9 +240,9 @@ static void new_announcer(AvahiServer *s, AvahiInterface *i, AvahiEntry *e) {
     assert(s);
     assert(i);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
-    if (!avahi_interface_match(i, e->interface, e->protocol) || !i->announcing || !avahi_entry_is_commited(e))
+    if (!avahi_interface_match(i, e->interface, e->protocol) || !i->mdns.announcing || !avahi_entry_is_commited(e))
         return;
 
     /* We don't want duplicate announcers */
@@ -253,8 +259,8 @@ static void new_announcer(AvahiServer *s, AvahiInterface *i, AvahiEntry *e) {
     a->entry = e;
     a->time_event = NULL;
 
-    AVAHI_LLIST_PREPEND(AvahiAnnouncer, by_interface, i->announcers, a);
-    AVAHI_LLIST_PREPEND(AvahiAnnouncer, by_entry, e->announcers, a);
+    AVAHI_LLIST_PREPEND(AvahiAnnouncer, by_interface, i->mdns.announcers, a);
+    AVAHI_LLIST_PREPEND(AvahiAnnouncer, by_entry, e->proto.mdns.announcers, a);
 
     go_to_initial_state(a);
 }
@@ -265,10 +271,10 @@ void avahi_announce_interface(AvahiServer *s, AvahiInterface *i) {
     assert(s);
     assert(i);
 
-    if (!i->announcing)
+    if (!i->mdns.announcing)
         return;
 
-    for (e = s->entries; e; e = e->entries_next)
+    for (e = s->mdns.entries; e; e = e->entries_next)
         if (!e->dead)
             new_announcer(s, i, e);
 }
@@ -279,7 +285,7 @@ static void announce_walk_callback(AvahiInterfaceMonitor *m, AvahiInterface *i,
     assert(m);
     assert(i);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     new_announcer(m->server, i, e);
 }
@@ -287,7 +293,7 @@ static void announce_walk_callback(AvahiInterfaceMonitor *m, AvahiInterface *i,
 void avahi_announce_entry(AvahiServer *s, AvahiEntry *e) {
     assert(s);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     avahi_interface_monitor_walk(s->monitor, e->interface, e->protocol, announce_walk_callback, e);
 }
@@ -296,11 +302,13 @@ void avahi_announce_group(AvahiServer *s, AvahiSEntryGroup *g) {
     AvahiEntry *e;
 
     assert(s);
-    assert(g);
+    assert(g && g->type == AVAHI_GROUP_MDNS);
 
     for (e = g->entries; e; e = e->by_group_next)
-        if (!e->dead)
+        if (!e->dead) {
+            assert(e->type == AVAHI_ENTRY_MDNS);
             avahi_announce_entry(s, e);
+        }
 }
 
 int avahi_entry_is_registered(AvahiServer *s, AvahiEntry *e, AvahiInterface *i) {
@@ -309,7 +317,7 @@ int avahi_entry_is_registered(AvahiServer *s, AvahiEntry *e, AvahiInterface *i)
     assert(s);
     assert(e);
     assert(i);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     if (!(a = get_announcer(s, e, i)))
         return 0;
@@ -326,7 +334,7 @@ int avahi_entry_is_probing(AvahiServer *s, AvahiEntry *e, AvahiInterface *i) {
     assert(s);
     assert(e);
     assert(i);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     if (!(a = get_announcer(s, e, i)))
         return 0;
@@ -340,14 +348,16 @@ void avahi_entry_return_to_initial_state(AvahiServer *s, AvahiEntry *e, AvahiInt
     AvahiAnnouncer *a;
 
     assert(s);
-    assert(e);
+    assert(e && e->type == AVAHI_ENTRY_MDNS);
     assert(i);
 
     if (!(a = get_announcer(s, e, i)))
         return;
 
-    if (a->state == AVAHI_PROBING && a->entry->group)
-        a->entry->group->n_probing--;
+    if (a->state == AVAHI_PROBING && a->entry->group) {
+        assert(a->entry->group->type == AVAHI_GROUP_MDNS);
+        a->entry->group->proto.mdns.n_probing--;
+    }
 
     go_to_initial_state(a);
 }
@@ -370,9 +380,10 @@ static int is_duplicate_entry(AvahiServer *s, AvahiEntry *e) {
     AvahiEntry *i;
 
     assert(s);
-    assert(e);
+    assert(e && e->type == AVAHI_ENTRY_MDNS);
 
-    for (i = avahi_hashmap_lookup(s->entries_by_key, e->record->key); i; i = i->by_key_next) {
+    for (i = avahi_hashmap_lookup(s->mdns.entries_by_key, e->record->key); i; i = i->by_key_next) {
+        assert(i->type == AVAHI_ENTRY_MDNS);
 
         if ((i == e) || (i->dead))
             continue;
@@ -393,7 +404,7 @@ static void send_goodbye_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, v
     assert(m);
     assert(i);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     if (!avahi_interface_match(i, e->interface, e->protocol))
         return;
@@ -420,14 +431,18 @@ static void reannounce(AvahiAnnouncer *a) {
 
     assert(a);
     e = a->entry;
+    assert(e->type == AVAHI_ENTRY_MDNS);
 
     /* If the group this entry belongs to is not even commited, there's nothing to reannounce */
-    if (e->group && (e->group->state == AVAHI_ENTRY_GROUP_UNCOMMITED || e->group->state == AVAHI_ENTRY_GROUP_COLLISION))
-        return;
+    if (e->group) {
+        assert(e->group->type == AVAHI_GROUP_MDNS);
+        if (e->group->state == AVAHI_ENTRY_GROUP_UNCOMMITED || e->group->state == AVAHI_ENTRY_GROUP_COLLISION)
+            return;
+    }
 
     /* Because we might change state we decrease the probing counter first */
     if (a->state == AVAHI_PROBING && a->entry->group)
-        a->entry->group->n_probing--;
+        a->entry->group->proto.mdns.n_probing--;
 
     if (a->state == AVAHI_PROBING ||
         (a->state == AVAHI_WAITING && (e->flags & AVAHI_PUBLISH_UNIQUE) && !(e->flags & AVAHI_PUBLISH_NO_PROBE)))
@@ -453,7 +468,7 @@ static void reannounce(AvahiAnnouncer *a) {
 
     /* Now let's increase the probing counter again */
     if (a->state == AVAHI_PROBING && e->group)
-        e->group->n_probing++;
+        e->group->proto.mdns.n_probing++;
 
     a->n_iteration = 1;
     a->sec_delay = 1;
@@ -474,7 +489,7 @@ static void reannounce_walk_callback(AvahiInterfaceMonitor *m, AvahiInterface *i
     assert(m);
     assert(i);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     if (!(a = get_announcer(m->server, e, i)))
         return;
@@ -486,7 +501,7 @@ void avahi_reannounce_entry(AvahiServer *s, AvahiEntry *e) {
 
     assert(s);
     assert(e);
-    assert(!e->dead);
+    assert(!e->dead && e->type == AVAHI_ENTRY_MDNS);
 
     avahi_interface_monitor_walk(s->monitor, e->interface, e->protocol, reannounce_walk_callback, e);
 }
@@ -496,29 +511,30 @@ void avahi_goodbye_interface(AvahiServer *s, AvahiInterface *i, int send_goodbye
     assert(i);
 
     if (send_goodbye)
-        if (i->announcing) {
+        if (i->mdns.announcing) {
             AvahiEntry *e;
 
-            for (e = s->entries; e; e = e->entries_next)
+            for (e = s->mdns.entries; e; e = e->entries_next) {
+                assert(e->type == AVAHI_ENTRY_MDNS);
                 if (!e->dead)
                     send_goodbye_callback(s->monitor, i, e);
+            }
         }
 
     if (remove)
-        while (i->announcers)
-            remove_announcer(s, i->announcers);
+        while (i->mdns.announcers)
+            remove_announcer(s, i->mdns.announcers);
 }
 
 void avahi_goodbye_entry(AvahiServer *s, AvahiEntry *e, int send_goodbye, int remove) {
     assert(s);
-    assert(e);
+    assert(e && e->type == AVAHI_ENTRY_MDNS);
 
     if (send_goodbye)
         if (!e->dead)
             avahi_interface_monitor_walk(s->monitor, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, send_goodbye_callback, e);
 
     if (remove)
-        while (e->announcers)
-            remove_announcer(s, e->announcers);
+        while (e->proto.mdns.announcers)
+            remove_announcer(s, e->proto.mdns.announcers);
 }
-
diff --git a/avahi-core/browse.c b/avahi-core/browse.c
index eabd7ea..3ca8979 100644
--- a/avahi-core/browse.c
+++ b/avahi-core/browse.c
@@ -51,6 +51,7 @@ struct AvahiSRBLookup {
 
     AvahiWideAreaLookup *wide_area;
     AvahiMulticastLookup *multicast;
+    AvahiLLMNRLookup *llmnr;
 
     AvahiRList *cname_lookups;
 
@@ -65,15 +66,19 @@ static void transport_flags_from_domain(AvahiServer *s, AvahiLookupFlags *flags,
     assert(domain);
 
     assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_WIDE_AREA)));
+    assert(!((*flags & AVAHI_LOOKUP_USE_MULTICAST) && (*flags & AVAHI_LOOKUP_USE_LLMNR)));
+    assert(!((*flags & AVAHI_LOOKUP_USE_WIDE_AREA) && (*flags & AVAHI_LOOKUP_USE_LLMNR)));
 
-    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))
+    if (*flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_LLMNR))
         return;
 
-    if (!s->wide_area_lookup_engine ||
-        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
+    if (avahi_is_valid_host_name(domain))
+        *flags |= AVAHI_LOOKUP_USE_LLMNR;
+    else if (!s->wide_area.wide_area_lookup_engine ||
+             !avahi_wide_area_has_servers(s->wide_area.wide_area_lookup_engine) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
         *flags |= AVAHI_LOOKUP_USE_MULTICAST;
     else
         *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
@@ -106,6 +111,7 @@ static AvahiSRBLookup* lookup_new(
     l->key = avahi_key_ref(key);
     l->wide_area = NULL;
     l->multicast = NULL;
+    l->llmnr = NULL;
     l->cname_lookups = NULL;
     l->flags = flags;
 
@@ -138,6 +144,11 @@ static void lookup_unref(AvahiSRBLookup *l) {
         l->multicast = NULL;
     }
 
+    if (l->llmnr) {
+        avahi_llmnr_lookup_free(l->llmnr);
+        l->llmnr = NULL;
+    }
+
     while (l->cname_lookups) {
         lookup_unref(l->cname_lookups->data);
         l->cname_lookups = avahi_rlist_remove_by_link(l->cname_lookups, l->cname_lookups);
@@ -316,21 +327,83 @@ static void lookup_multicast_callback(
     lookup_unref(l);
 }
 
+static void lookup_llmnr_callback(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex interface,
+    AvahiProtocol protocol,
+    AvahiBrowserEvent event,
+    AvahiLookupResultFlags flags,
+    AvahiRecord *r,
+    void *userdata) {
+
+    AvahiSRBLookup *l = userdata;
+    AvahiSRecordBrowser *b;
+
+    assert(e);
+    assert(l);
+
+    b = l->record_browser;
+
+    if (b->dead)
+        return;
+
+    lookup_ref(l);
+
+    switch(event) {
+        case AVAHI_BROWSER_NEW:
+            assert(r);
+
+            if (r->key->clazz == AVAHI_DNS_CLASS_IN &&
+                r->key->type == AVAHI_DNS_TYPE_CNAME)
+                lookup_handle_cname(l, interface, protocol, b->flags, r);
+            else
+                /* We are discrading packets originating from our own interface/s
+                   or should we accept them? TODO AVAHI_LOOKUP_RESULT_LOCAL*/
+                b->callback(b, interface, protocol, event, r, flags, b->userdata);
+            break;
+
+        case AVAHI_BROWSER_REMOVE:
+        case AVAHI_BROWSER_CACHE_EXHAUSTED:
+            abort();
+
+        case AVAHI_BROWSER_ALL_FOR_NOW:
+
+            b->callback(b, interface, protocol, event, NULL, flags, b->userdata);
+            break;
+
+        case AVAHI_BROWSER_FAILURE:
+            /* This event states that LLMNR query has been sent three times on specified
+            interface and protocol and we don't have any records available */
+            /*b->callback(b, interface, protocol, event, NULL, flags, b->userdata);
+            lookup_ref(l);*/
+            abort();
+    }
+
+    lookup_unref(l);
+}
+
 static int lookup_start(AvahiSRBLookup *l) {
+
     assert(l);
 
-    assert(!(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) != !(l->flags & AVAHI_LOOKUP_USE_MULTICAST));
-    assert(!l->wide_area && !l->multicast);
+    assert((!(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) && !(l->flags & AVAHI_LOOKUP_USE_LLMNR)) ||
+           (!(l->flags & AVAHI_LOOKUP_USE_LLMNR) && !(l->flags & AVAHI_LOOKUP_USE_MULTICAST)) ||
+           (!(l->flags & AVAHI_LOOKUP_USE_MULTICAST) && !(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA)));
 
-    if (l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) {
+    assert(!l->wide_area && !l->multicast && !l->llmnr);
 
-        if (!(l->wide_area = avahi_wide_area_lookup_new(l->record_browser->server->wide_area_lookup_engine, l->key, lookup_wide_area_callback, l)))
+    if (l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) {
+        /* Wide Area */
+        if (!(l->wide_area = avahi_wide_area_lookup_new(l->record_browser->server->wide_area.wide_area_lookup_engine, l->key, lookup_wide_area_callback, l)))
+            return -1;
+    } else if (l->flags & AVAHI_LOOKUP_USE_MULTICAST) {
+        /* Multicast */
+        if (!(l->multicast = avahi_multicast_lookup_new(l->record_browser->server->mdns.multicast_lookup_engine, l->interface, l->protocol, l->key, lookup_multicast_callback, l)))
             return -1;
-
     } else {
-        assert(l->flags & AVAHI_LOOKUP_USE_MULTICAST);
-
-        if (!(l->multicast = avahi_multicast_lookup_new(l->record_browser->server->multicast_lookup_engine, l->interface, l->protocol, l->key, lookup_multicast_callback, l)))
+        /* LLMNR */
+        assert(l->flags & AVAHI_LOOKUP_USE_LLMNR);
+        if (!(l->llmnr = avahi_llmnr_lookup_new(l->record_browser->server->llmnr.llmnr_lookup_engine, l->interface, l->protocol, l->key, lookup_llmnr_callback, l)))
             return -1;
     }
 
@@ -342,15 +415,19 @@ static int lookup_scan_cache(AvahiSRBLookup *l) {
 
     assert(l);
 
-    assert(!(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) != !(l->flags & AVAHI_LOOKUP_USE_MULTICAST));
-
+    assert((!(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) && !(l->flags & AVAHI_LOOKUP_USE_LLMNR)) ||
+           (!(l->flags & AVAHI_LOOKUP_USE_LLMNR) && !(l->flags & AVAHI_LOOKUP_USE_MULTICAST)) ||
+           (!(l->flags & AVAHI_LOOKUP_USE_MULTICAST) && !(l->flags & AVAHI_LOOKUP_USE_WIDE_AREA)) );
 
     if (l->flags & AVAHI_LOOKUP_USE_WIDE_AREA) {
-        n = (int) avahi_wide_area_scan_cache(l->record_browser->server->wide_area_lookup_engine, l->key, lookup_wide_area_callback, l);
+        n = (int) avahi_wide_area_scan_cache(l->record_browser->server->wide_area.wide_area_lookup_engine, l->key, lookup_wide_area_callback, l);
+
+    } else if (l->flags & AVAHI_LOOKUP_USE_MULTICAST) {
+        n = (int) avahi_multicast_lookup_engine_scan_cache(l->record_browser->server->mdns.multicast_lookup_engine, l->interface, l->protocol, l->key, lookup_multicast_callback, l);
 
     } else {
-        assert(l->flags & AVAHI_LOOKUP_USE_MULTICAST);
-        n = (int) avahi_multicast_lookup_engine_scan_cache(l->record_browser->server->multicast_lookup_engine, l->interface, l->protocol, l->key, lookup_multicast_callback, l);
+        assert(l->flags & AVAHI_LOOKUP_USE_LLMNR);
+        n = (int) avahi_scan_llmnr_cache(l->record_browser->server->llmnr.llmnr_lookup_engine, l->interface, l->protocol, l->key, lookup_llmnr_callback, l);
     }
 
     return n;
@@ -386,11 +463,11 @@ static int lookup_go(AvahiSRBLookup *l) {
     /* Start the lookup */
     if (!l->record_browser->dead && l->ref > 1) {
 
-        if ((l->flags & AVAHI_LOOKUP_USE_MULTICAST) || n == 0)
+        if ((l->flags & AVAHI_LOOKUP_USE_MULTICAST) || (l->flags & AVAHI_LOOKUP_USE_LLMNR) || n == 0) {
             /* We do no start a query if the cache contained entries and we're on wide area */
-
             if (lookup_start(l) < 0)
                 n = -1;
+        }
     }
 
     lookup_unref(l);
@@ -455,7 +532,7 @@ static void lookup_drop_cname(AvahiSRBLookup *l, AvahiIfIndex interface, AvahiPr
 
 static void defer_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
     AvahiSRecordBrowser *b = userdata;
-    int n;
+    int n = 0;
 
     assert(b);
     assert(!b->dead);
@@ -483,7 +560,8 @@ static void defer_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
 
         b->callback(
             b, b->interface, b->protocol, AVAHI_BROWSER_FAILURE, NULL,
-            b->flags & AVAHI_LOOKUP_USE_WIDE_AREA ? AVAHI_LOOKUP_RESULT_WIDE_AREA : AVAHI_LOOKUP_RESULT_MULTICAST,
+            b->flags & AVAHI_LOOKUP_USE_WIDE_AREA ? AVAHI_LOOKUP_RESULT_WIDE_AREA :
+            (b->flags & AVAHI_LOOKUP_RESULT_MULTICAST ? AVAHI_LOOKUP_RESULT_MULTICAST : AVAHI_LOOKUP_RESULT_LLMNR),
             b->userdata);
 
         browser_cancel(b);
@@ -493,16 +571,19 @@ static void defer_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
     /* Tell the client that we're done with the cache */
     b->callback(
         b, b->interface, b->protocol, AVAHI_BROWSER_CACHE_EXHAUSTED, NULL,
-        b->flags & AVAHI_LOOKUP_USE_WIDE_AREA ? AVAHI_LOOKUP_RESULT_WIDE_AREA : AVAHI_LOOKUP_RESULT_MULTICAST,
+        b->flags & AVAHI_LOOKUP_USE_WIDE_AREA ? AVAHI_LOOKUP_RESULT_WIDE_AREA :
+        (b->flags & AVAHI_LOOKUP_RESULT_MULTICAST ? AVAHI_LOOKUP_RESULT_MULTICAST : AVAHI_LOOKUP_RESULT_LLMNR),
         b->userdata);
 
-    if (!b->dead && b->root_lookup && b->root_lookup->flags & AVAHI_LOOKUP_USE_WIDE_AREA && n > 0) {
+    if (!b->dead && b->root_lookup &&
+        (b->root_lookup->flags & AVAHI_LOOKUP_USE_WIDE_AREA) &&
+        n > 0 ) {
 
         /* If we do wide area lookups and the the cache contained
          * entries, we assume that it is complete, and tell the user
          * so by firing ALL_FOR_NOW. */
 
-        b->callback(b, b->interface, b->protocol, AVAHI_BROWSER_ALL_FOR_NOW, NULL, AVAHI_LOOKUP_RESULT_WIDE_AREA, b->userdata);
+        b->callback(b, b->interface, b->protocol, AVAHI_BROWSER_ALL_FOR_NOW, NULL, AVAHI_LOOKUP_RESULT_LLMNR, b->userdata);
     }
 }
 
@@ -538,7 +619,7 @@ AvahiSRecordBrowser *avahi_s_record_browser_new(
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_PROTO_VALID(protocol), AVAHI_ERR_INVALID_PROTOCOL);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, !avahi_key_is_pattern(key), AVAHI_ERR_IS_PATTERN);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, avahi_key_is_valid(key), AVAHI_ERR_INVALID_KEY);
-    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, !(flags & AVAHI_LOOKUP_USE_WIDE_AREA) || !(flags & AVAHI_LOOKUP_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
 
     if (!(b = avahi_new(AvahiSRecordBrowser, 1))) {
@@ -606,8 +687,10 @@ void avahi_browser_cleanup(AvahiServer *server) {
         }
     }
 
-    if (server->wide_area_lookup_engine)
-        avahi_wide_area_cleanup(server->wide_area_lookup_engine);
-    avahi_multicast_lookup_engine_cleanup(server->multicast_lookup_engine);
+    if (server->wide_area.wide_area_lookup_engine)
+        avahi_wide_area_cleanup(server->wide_area.wide_area_lookup_engine);
+
+    avahi_multicast_lookup_engine_cleanup(server->mdns.multicast_lookup_engine);
+    avahi_llmnr_lookup_engine_cleanup(server->llmnr.llmnr_lookup_engine);
 }
 
diff --git a/avahi-core/cache.c b/avahi-core/cache.c
index 454aac5..4518578 100644
--- a/avahi-core/cache.c
+++ b/avahi-core/cache.c
@@ -54,7 +54,7 @@ static void remove_entry(AvahiCache *c, AvahiCacheEntry *e) {
     if (e->time_event)
         avahi_time_event_free(e->time_event);
 
-    avahi_multicast_lookup_engine_notify(c->server->multicast_lookup_engine, c->interface, e->record, AVAHI_BROWSER_REMOVE);
+    avahi_multicast_lookup_engine_notify(c->server->mdns.multicast_lookup_engine, c->interface, e->record, AVAHI_BROWSER_REMOVE);
 
     avahi_record_unref(e->record);
 
@@ -360,7 +360,7 @@ void avahi_cache_update(AvahiCache *c, AvahiRecord *r, int cache_flush, const Av
             c->n_entries++;
 
             /* Notify subscribers */
-            avahi_multicast_lookup_engine_notify(c->server->multicast_lookup_engine, c->interface, e->record, AVAHI_BROWSER_NEW);
+            avahi_multicast_lookup_engine_notify(c->server->mdns.multicast_lookup_engine, c->interface, e->record, AVAHI_BROWSER_NEW);
         }
 
         e->origin = *a;
diff --git a/avahi-core/core.h b/avahi-core/core.h
index f50c612..8f75b34 100644
--- a/avahi-core/core.h
+++ b/avahi-core/core.h
@@ -139,6 +139,8 @@ void avahi_server_set_data(AvahiServer *s, void* userdata);
 /** Return the current state of the server object */
 AvahiServerState avahi_server_get_state(AvahiServer *s);
 
+int setup_llmnr_sockets(AvahiServer *s);
+
 /** Callback prototype for avahi_server_dump() */
 typedef void (*AvahiDumpCallback)(const char *text, void* userdata);
 
diff --git a/avahi-core/dns.c b/avahi-core/dns.c
index 2fcd91f..f33c31f 100644
--- a/avahi-core/dns.c
+++ b/avahi-core/dns.c
@@ -875,3 +875,222 @@ size_t avahi_rdata_serialize(AvahiRecord *record, void *rdata, size_t max_size)
 
     return p.size;
 }
+
+/* LLMNR Functions */
+/* New LLMNR Query */
+AvahiDnsPacket* avahi_llmnr_packet_new_query(unsigned mtu) {
+    AvahiDnsPacket *p;
+
+    if (!(p = avahi_dns_packet_new(mtu)))
+        return NULL;
+
+    avahi_dns_packet_set_field(p, AVAHI_LLMNR_FIELD_FLAGS, AVAHI_LLMNR_FLAGS(0, 0, 0, 0, 0, 0, 0));
+
+    return p;
+}
+
+AvahiDnsPacket* avahi_llmnr_packet_new_response(unsigned mtu, int c) {
+    AvahiDnsPacket *p;
+
+    if (!(p = avahi_dns_packet_new(mtu)))
+        return NULL;
+
+    avahi_dns_packet_set_field(p, AVAHI_LLMNR_FIELD_FLAGS, AVAHI_LLMNR_FLAGS(1, 0, c, 0, 0, 0, 0));
+
+    return p;
+}
+
+/* New becasue LLMNR packets in Vista don't like message compression in RR's*/
+uint8_t* avahi_llmnr_packet_append_name(AvahiDnsPacket *p, const char *name) {
+    uint8_t *d, *saved_ptr = NULL;
+    size_t saved_size;
+
+    assert(p);
+    assert(name);
+
+    saved_size = p->size;
+    saved_ptr = avahi_dns_packet_extend(p, 0);
+
+    while (*name) {
+        const char *pname;
+        char label[64];
+
+        pname = name;
+
+        if (!(avahi_unescape_label(&name, label, sizeof(label))))
+            goto fail;
+
+        if (!(d = avahi_dns_packet_append_string(p, label)))
+            goto fail;
+    }
+
+    if (!(d = avahi_dns_packet_extend(p, 1)))
+        goto fail;
+
+    *d = 0;
+
+    return saved_ptr;
+
+fail:
+    p->size = saved_size;
+    avahi_dns_packet_cleanup_name_table(p);
+
+    return NULL;
+}
+
+/* New LLMNR Reply */
+AvahiDnsPacket* avahi_llmnr_packet_new_reply(AvahiDnsPacket *p, unsigned mtu, int copy_queries, int c) {
+    AvahiDnsPacket *r;
+    assert(p);
+
+    if (!(r = avahi_llmnr_packet_new_response(mtu, c)))
+        return NULL;
+
+    if (copy_queries) {
+        unsigned saved_rindex;
+        uint32_t n;
+
+        saved_rindex = p->rindex;
+        p->rindex = AVAHI_DNS_PACKET_HEADER_SIZE;
+
+        for (n = avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_QDCOUNT); n > 0; n--) {
+            AvahiKey *k;
+
+            if ((k = avahi_llmnr_packet_consume_key(p))) {
+                avahi_llmnr_packet_append_key(r, k);
+                avahi_key_unref(k);
+            }
+        }
+
+        p->rindex = saved_rindex;
+        avahi_dns_packet_set_field(r, AVAHI_LLMNR_FIELD_QDCOUNT, avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_QDCOUNT));
+    }
+
+    avahi_dns_packet_set_field(r, AVAHI_LLMNR_FIELD_ID, avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_ID));
+    avahi_dns_packet_set_field(r, AVAHI_LLMNR_FIELD_ANCOUNT, 0);
+    avahi_dns_packet_set_field(r, AVAHI_LLMNR_FIELD_NSCOUNT, 0);
+    avahi_dns_packet_set_field(r, AVAHI_LLMNR_FIELD_ARCOUNT, 0);
+    return r;
+}
+
+int avahi_llmnr_packet_check_valid(AvahiDnsPacket *p) {
+    uint16_t flags;
+
+    assert(p);
+
+    /* OPCODE */
+    if ((avahi_dns_packet_check_valid(p) < 0))
+        return -1;
+
+    flags = avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_FLAGS);
+
+    /* RCODE in incoming queries is to be ignored*/
+    /* RCODE in incoming responses is to be checked*/
+    if (flags & AVAHI_LLMNR_FLAG_Z)
+        return -1;
+
+    return 0;
+}
+
+AvahiRecord* avahi_llmnr_packet_consume_record(AvahiDnsPacket *p) {
+    AvahiRecord *r;
+    int unicast_response;
+
+    if (!(r = avahi_dns_packet_consume_record(p, &unicast_response)))
+        return NULL;
+
+    /* LLMNR uses standard class values. So unicast response
+    should be zero in all cases */
+    assert(!unicast_response);
+
+/*    unicast_response = (uint32_t) (unicast_response);
+    unicast_response = ~unicast_response;
+    unicast_response = unicast_response << 28;
+    unicast_response = ~unicast_response;
+    r->key->clazz = r->key->clazz & unicast_response; */
+
+    return r;
+}
+
+AvahiKey* avahi_llmnr_packet_consume_key(AvahiDnsPacket *p) {
+    AvahiKey *key;
+    int unicast_response;
+
+    if (!(key = avahi_dns_packet_consume_key(p, &unicast_response)))
+        return NULL;
+
+    assert(!unicast_response);
+/*    unicast_response = (uint32_t) (unicast_response);
+    avahi_log_info("UR : %d", unicast_response);
+    unicast_response = ~unicast_response;
+    avahi_log_info("UR : %d", unicast_response);
+    unicast_response = unicast_response << 28;
+    avahi_log_info("UR : %d", unicast_response);
+    unicast_response = ~unicast_response;
+    avahi_log_info("UR : %d", unicast_response);
+
+    key->clazz = key->clazz & unicast_response; */
+
+    return key;
+}
+
+/* we can't use avahi_dns_packet_append_name()
+So it's better to define them again */
+uint8_t* avahi_llmnr_packet_append_key(AvahiDnsPacket *p, AvahiKey *k) {
+    uint8_t *t;
+    size_t size;
+
+    assert(p);
+    assert(k);
+
+    size = p->size;
+
+    if (!(t = avahi_llmnr_packet_append_name(p, k->name)) ||
+        !avahi_dns_packet_append_uint16(p, k->type) ||
+        !avahi_dns_packet_append_uint16(p, k->clazz) ) {
+        p->size = size;
+        avahi_dns_packet_cleanup_name_table(p);
+
+        return NULL;
+    }
+
+    return t;
+}
+
+/* Need append_rdata in /avahi-core/dns.c to be defines as non-static */
+uint8_t* avahi_llmnr_packet_append_record(AvahiDnsPacket *p, AvahiRecord *r, unsigned max_ttl) {
+    uint8_t *t, *l, *start;
+    size_t size;
+
+    assert(p);
+    assert(r);
+
+    size = p->size;
+
+    if (!(t = avahi_dns_packet_append_name(p, r->key->name)) ||
+        !avahi_dns_packet_append_uint16(p, r->key->type) ||
+        !avahi_dns_packet_append_uint16(p, r->key->clazz)||
+        !avahi_dns_packet_append_uint32(p, (max_ttl && r->ttl > max_ttl) ? max_ttl : r->ttl) ||
+        !(l = avahi_dns_packet_append_uint16(p, 0)))
+            goto fail;
+
+    start = avahi_dns_packet_extend(p, 0);
+
+    if (append_rdata(p, r) < 0)
+        goto fail;
+
+    size = avahi_dns_packet_extend(p, 0) - start;
+    assert(size <= AVAHI_DNS_RDATA_MAX);
+
+    l[0] = (uint8_t) ((uint16_t) size >> 8);
+    l[1] = (uint8_t) ((uint16_t) size);
+
+    return t;
+
+fail:
+    p->size = size;
+    avahi_dns_packet_cleanup_name_table(p);
+
+    return NULL;
+}
+
diff --git a/avahi-core/dns.h b/avahi-core/dns.h
index 52e8d88..d4a7d84 100644
--- a/avahi-core/dns.h
+++ b/avahi-core/dns.h
@@ -81,6 +81,21 @@ size_t avahi_dns_packet_space(AvahiDnsPacket *p);
 size_t avahi_dns_packet_reserve_size(AvahiDnsPacket *p, size_t res_size);
 size_t avahi_dns_packet_reserved_space(AvahiDnsPacket *p);
 
+/* LLMNR Functions */
+AvahiDnsPacket* avahi_llmnr_packet_new_query(unsigned mtu);
+AvahiDnsPacket* avahi_llmnr_packet_new_response(unsigned mtu, int c);
+AvahiDnsPacket* avahi_llmnr_packet_new_reply(AvahiDnsPacket *p, unsigned mtu, int copy_queries, int c);
+
+int avahi_llmnr_packet_check_valid(AvahiDnsPacket *p);
+
+AvahiRecord* avahi_llmnr_packet_consume_record(AvahiDnsPacket *p);
+AvahiKey* avahi_llmnr_packet_consume_key(AvahiDnsPacket *p);
+
+/* New becasue LLMNR packets in Vista don't like message compression in RR's*/
+uint8_t* avahi_llmnr_packet_append_name(AvahiDnsPacket *p, const char *name);
+uint8_t* avahi_llmnr_packet_append_key(AvahiDnsPacket *p, AvahiKey *k);
+uint8_t* avahi_llmnr_packet_append_record(AvahiDnsPacket *p, AvahiRecord *r, unsigned max_ttl);
+
 #define AVAHI_DNS_FIELD_ID 0
 #define AVAHI_DNS_FIELD_FLAGS 1
 #define AVAHI_DNS_FIELD_QDCOUNT 2
@@ -88,12 +103,27 @@ size_t avahi_dns_packet_reserved_space(AvahiDnsPacket *p);
 #define AVAHI_DNS_FIELD_NSCOUNT 4
 #define AVAHI_DNS_FIELD_ARCOUNT 5
 
+#define AVAHI_LLMNR_FIELD_ID AVAHI_DNS_FIELD_ID
+#define AVAHI_LLMNR_FIELD_FLAGS AVAHI_DNS_FIELD_FLAGS
+#define AVAHI_LLMNR_FIELD_QDCOUNT AVAHI_DNS_FIELD_QDCOUNT
+#define AVAHI_LLMNR_FIELD_ANCOUNT AVAHI_DNS_FIELD_ANCOUNT
+#define AVAHI_LLMNR_FIELD_NSCOUNT AVAHI_DNS_FIELD_NSCOUNT
+#define AVAHI_LLMNR_FIELD_ARCOUNT AVAHI_DNS_FIELD_ARCOUNT
+
 #define AVAHI_DNS_FLAG_QR (1 << 15)
 #define AVAHI_DNS_FLAG_OPCODE (15 << 11)
 #define AVAHI_DNS_FLAG_RCODE (15)
 #define AVAHI_DNS_FLAG_TC (1 << 9)
 #define AVAHI_DNS_FLAG_AA (1 << 10)
 
+#define AVAHI_LLMNR_FLAG_QR (1 << 15)
+#define AVAHI_LLMNR_FLAG_OPCODE (15 << 11)
+#define AVAHI_LLMNR_FLAG_C (1 << 10)
+#define AVAHI_LLMNR_FLAG_TC (1 << 9)
+#define AVAHI_LLMNR_FLAG_T (1 << 8)
+#define AVAHI_LLMNR_FLAG_Z (15 << 4)
+#define AVAHI_LLMNR_FLAG_RCODE (15)
+
 #define AVAHI_DNS_FLAGS(qr, opcode, aa, tc, rd, ra, z, ad, cd, rcode) \
         (((uint16_t) !!qr << 15) |  \
          ((uint16_t) (opcode & 15) << 11) | \
@@ -105,6 +135,15 @@ size_t avahi_dns_packet_reserved_space(AvahiDnsPacket *p);
          ((uint16_t) !!cd << 4) | \
          ((uint16_t) (rcode & 15)))
 
+#define AVAHI_LLMNR_FLAGS(qr, opcode, c, tc, t, z,rcode) \
+        (((uint16_t) !!qr << 15) |  \
+         ((uint16_t) (opcode & 15) << 11) | \
+         ((uint16_t) !!c << 10) | \
+         ((uint16_t) !!tc << 9) | \
+         ((uint16_t) !!t << 8) | \
+         ((uint16_t) (z & 15) << 4) | \
+         ((uint16_t) (rcode & 15)))
+
 #define AVAHI_MDNS_SUFFIX_LOCAL "local"
 #define AVAHI_MDNS_SUFFIX_ADDR_IPV4 "254.169.in-addr.arpa"
 #define AVAHI_MDNS_SUFFIX_ADDR_IPV6 "0.8.e.f.ip6.arpa"
diff --git a/avahi-core/entry.c b/avahi-core/entry.c
index 0d86213..ff5aa09 100644
--- a/avahi-core/entry.c
+++ b/avahi-core/entry.c
@@ -39,6 +39,7 @@
 #include <avahi-common/malloc.h>
 #include <avahi-common/error.h>
 #include <avahi-common/domain.h>
+#include <avahi-common/defs.h>
 
 #include "internal.h"
 #include "iface.h"
@@ -50,20 +51,29 @@
 #include "rr-util.h"
 #include "domain-util.h"
 
-static void transport_flags_from_domain(AvahiServer *s, AvahiPublishFlags *flags, const char *domain) {
+static void transport_flags_from_domain(AvahiServer *s, AvahiPublishFlags *flags, const char *domain, int check_for_llmnr) {
     assert(flags);
     assert(domain);
-
     assert(!((*flags & AVAHI_PUBLISH_USE_MULTICAST) && (*flags & AVAHI_PUBLISH_USE_WIDE_AREA)));
 
-    if (*flags & (AVAHI_PUBLISH_USE_MULTICAST|AVAHI_PUBLISH_USE_WIDE_AREA))
-        return;
+    if (check_for_llmnr) {
+        assert(!((*flags & AVAHI_PUBLISH_USE_WIDE_AREA) && (*flags & AVAHI_PUBLISH_USE_LLMNR)));
+        assert(!((*flags & AVAHI_PUBLISH_USE_MULTICAST) && (*flags & AVAHI_PUBLISH_USE_LLMNR)));
+
+        if (*flags & (AVAHI_PUBLISH_USE_MULTICAST | AVAHI_PUBLISH_USE_WIDE_AREA | AVAHI_PUBLISH_USE_LLMNR))
+            return;
+
+    } else /*!check_for_llmnr*/
+        if (*flags & (AVAHI_PUBLISH_USE_MULTICAST | AVAHI_PUBLISH_USE_WIDE_AREA))
+            return;
 
-    if (!s->wide_area_lookup_engine ||
-        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
-        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
+    if (check_for_llmnr && avahi_is_valid_host_name(domain))
+           *flags |= AVAHI_PUBLISH_USE_LLMNR;
+    else if (!s->wide_area.wide_area_lookup_engine ||
+             !avahi_wide_area_has_servers(s->wide_area.wide_area_lookup_engine) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
+             avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
         *flags |= AVAHI_PUBLISH_USE_MULTICAST;
     else
         *flags |= AVAHI_PUBLISH_USE_WIDE_AREA;
@@ -71,22 +81,28 @@ static void transport_flags_from_domain(AvahiServer *s, AvahiPublishFlags *flags
 
 void avahi_entry_free(AvahiServer*s, AvahiEntry *e) {
     AvahiEntry *t;
+    AvahiHashmap *entries_by_key;
 
     assert(s);
     assert(e);
 
-    avahi_goodbye_entry(s, e, 1, 1);
-
-    /* Remove from linked list */
-    AVAHI_LLIST_REMOVE(AvahiEntry, entries, s->entries, e);
+    if (e->type == AVAHI_ENTRY_MDNS) {
+        avahi_goodbye_entry(s, e, 1, 1);
+        AVAHI_LLIST_REMOVE(AvahiEntry, entries, s->mdns.entries, e);
+        entries_by_key = s->mdns.entries_by_key;
+    } else {
+        assert (e->type == AVAHI_ENTRY_LLMNR);
+        avahi_remove_verifiers (s, e);
+        AVAHI_LLIST_REMOVE(AvahiEntry, entries, s->llmnr.entries, e);
+        entries_by_key = s->llmnr.entries_by_key;
+    }
 
-    /* Remove from hash table indexed by name */
-    t = avahi_hashmap_lookup(s->entries_by_key, e->record->key);
+    t = avahi_hashmap_lookup(entries_by_key, e->record->key);
     AVAHI_LLIST_REMOVE(AvahiEntry, by_key, t, e);
     if (t)
-        avahi_hashmap_replace(s->entries_by_key, t->record->key, t);
+        avahi_hashmap_replace(entries_by_key, t->record->key, t);
     else
-        avahi_hashmap_remove(s->entries_by_key, e->record->key);
+        avahi_hashmap_remove(entries_by_key, e->record->key);
 
     /* Remove from associated group */
     if (e->group)
@@ -103,40 +119,44 @@ void avahi_entry_group_free(AvahiServer *s, AvahiSEntryGroup *g) {
     while (g->entries)
         avahi_entry_free(s, g->entries);
 
-    if (g->register_time_event)
-        avahi_time_event_free(g->register_time_event);
+    if (g->type == AVAHI_GROUP_MDNS && g->proto.mdns.register_time_event)
+        avahi_time_event_free(g->proto.mdns.register_time_event);
+
+    if (g->type == AVAHI_GROUP_MDNS)
+        AVAHI_LLIST_REMOVE(AvahiSEntryGroup, groups, s->mdns.groups, g);
+    else
+        AVAHI_LLIST_REMOVE(AvahiSEntryGroup, groups, s->llmnr.groups, g);
 
-    AVAHI_LLIST_REMOVE(AvahiSEntryGroup, groups, s->groups, g);
     avahi_free(g);
 }
 
 void avahi_cleanup_dead_entries(AvahiServer *s) {
     assert(s);
 
-    if (s->need_group_cleanup) {
+    if (s->mdns.need_group_cleanup) {
         AvahiSEntryGroup *g, *next;
 
-        for (g = s->groups; g; g = next) {
+        for (g = s->mdns.groups; g; g = next) {
             next = g->groups_next;
 
             if (g->dead)
                 avahi_entry_group_free(s, g);
         }
 
-        s->need_group_cleanup = 0;
+        s->mdns.need_group_cleanup = 0;
     }
 
-    if (s->need_entry_cleanup) {
+    if (s->mdns.need_entry_cleanup) {
         AvahiEntry *e, *next;
 
-        for (e = s->entries; e; e = next) {
+        for (e = s->mdns.entries; e; e = next) {
             next = e->entries_next;
 
             if (e->dead)
                 avahi_entry_free(s, e);
         }
 
-        s->need_entry_cleanup = 0;
+        s->mdns.need_entry_cleanup = 0;
     }
 
     if (s->need_browser_cleanup)
@@ -148,13 +168,19 @@ void avahi_cleanup_dead_entries(AvahiServer *s) {
     }
 }
 
-static int check_record_conflict(AvahiServer *s, AvahiIfIndex interface, AvahiProtocol protocol, AvahiRecord *r, AvahiPublishFlags flags) {
+static int check_record_conflict(AvahiServer *s, AvahiIfIndex interface, AvahiProtocol protocol, AvahiRecord *r, AvahiPublishFlags flags, AvahiPublishProtocol proto) {
     AvahiEntry *e;
 
     assert(s);
     assert(r);
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, r->key); e; e = e->by_key_next) {
+    for (e = avahi_hashmap_lookup(proto == AVAHI_MDNS ? s->mdns.entries_by_key : s->llmnr.entries_by_key, r->key); e; e = e->by_key_next) {
+
+        if (proto == AVAHI_MDNS)
+            assert(e->type == AVAHI_ENTRY_MDNS);
+        else
+            assert(e->type == AVAHI_ENTRY_LLMNR);
+
         if (e->dead)
             continue;
 
@@ -182,6 +208,135 @@ static int check_record_conflict(AvahiServer *s, AvahiIfIndex interface, AvahiPr
     return 0;
 }
 
+static AvahiEntry *server_add_llmnr_internal(
+    AvahiServer *s,
+    AvahiSEntryGroup *g,
+    AvahiIfIndex interface,
+    AvahiProtocol protocol,
+    AvahiPublishFlags flags,
+    AvahiRecord *r) {
+
+    AvahiEntry *e;
+
+    assert(s);
+    assert(r);
+
+    /* Flags should be LLMNR flags only */
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(s, AVAHI_FLAGS_VALID(
+                                    flags,
+                                    AVAHI_PUBLISH_UNIQUE|
+                                    AVAHI_PUBLISH_ALLOW_MULTIPLE|
+                                    AVAHI_PUBLISH_UPDATE|
+                                    AVAHI_PUBLISH_NO_VERIFY|
+                                    AVAHI_PUBLISH_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
+
+    /* Publishing of only A/AAAA/PTR records is supported using LLMNR */
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(s,
+                                    (r->key->type == AVAHI_DNS_TYPE_A) ||
+                                    (r->key->type == AVAHI_DNS_TYPE_AAAA) ||
+                                    (r->key->type == AVAHI_DNS_TYPE_PTR), AVAHI_ERR_INVALID_DNS_TYPE);
+
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(s,
+                                     !g ||
+                                     (g->state != AVAHI_ENTRY_GROUP_LLMNR_ESTABLISHED &&
+                                      g->state != AVAHI_ENTRY_GROUP_LLMNR_VERIFYING) ||
+                                     (flags & AVAHI_PUBLISH_UPDATE), AVAHI_ERR_BAD_STATE);
+
+    /* Copy Copy Copy. */
+    if (flags & AVAHI_PUBLISH_UPDATE) {
+        AvahiRecord *old_record;
+        int is_first = 1;
+
+        /* type can't be _UNSET*/
+        AVAHI_CHECK_VALIDITY_RETURN_NULL(s, !g || g->type == AVAHI_GROUP_LLMNR, AVAHI_ERR_INVALID_GROUP);
+
+        /* Find the first matching entry */
+        for (e = avahi_hashmap_lookup(s->llmnr.entries_by_key, r->key); e; e = e->by_key_next) {
+
+            assert(e->type == AVAHI_ENTRY_LLMNR);
+            if (!e->dead && e->group == g && e->interface == interface && e->protocol == protocol)
+                break;
+
+            is_first = 0;
+        }
+
+        if (!e) {
+            avahi_server_set_errno(s, AVAHI_ERR_NOT_FOUND);
+            return NULL;
+        }
+
+        /* Update the entry */
+        old_record = e->record;
+        e->record = avahi_record_ref(r);
+        e->flags = flags;
+
+        /* Reverify changes, if needed */
+        if (!avahi_record_equal_no_ttl(old_record, r) && (!g || g->state != AVAHI_ENTRY_GROUP_LLMNR_UNCOMMITED))
+            /* Reverify our updated entry */
+            avahi_reverify_entry(s, e);
+
+        /* If we were the first entry in the list, we need to update the key */
+        if (is_first)
+            avahi_hashmap_replace(s->llmnr.entries_by_key, e->record->key, e);
+
+        avahi_record_unref(old_record);
+
+    } else {
+        AvahiEntry *t;
+
+        AVAHI_CHECK_VALIDITY_RETURN_NULL(s,
+                                         !g ||
+                                         g->type == AVAHI_GROUP_UNSET ||
+                                         g->type == AVAHI_GROUP_LLMNR, AVAHI_ERR_INVALID_GROUP);
+
+        if (g && g->type == AVAHI_GROUP_UNSET) {
+            g->proto.llmnr.n_verifying = 0;
+            g->proto.llmnr.n_entries = 0;
+            g->type = AVAHI_GROUP_LLMNR;
+
+            AVAHI_LLIST_HEAD_INIT(AvahiEntry, g->entries);
+            AVAHI_LLIST_PREPEND(AvahiSEntryGroup, groups, s->llmnr.groups, g);
+        }
+        /* Check for the conflict */
+
+        if (check_record_conflict(s, interface, protocol, r, flags, AVAHI_LLMNR) < 0) {
+            avahi_server_set_errno(s, AVAHI_ERR_COLLISION);
+            return NULL;
+        }
+
+        if (!(e = avahi_new(AvahiEntry, 1))) {
+            avahi_server_set_errno(s, AVAHI_ERR_NO_MEMORY);
+            return NULL;
+        }
+
+        e->server = s;
+        e->record = avahi_record_ref(r);
+        e->group = g;
+        e->interface = interface;
+        e->protocol = protocol;
+        e->flags = flags;
+        e->dead = 0;
+        e->type = AVAHI_ENTRY_LLMNR;
+        AVAHI_LLIST_HEAD_INIT(AvahiLLMNREntryVerify, e->proto.llmnr.verifiers);
+
+        AVAHI_LLIST_PREPEND(AvahiEntry, entries, s->llmnr.entries, e);
+
+        /* Insert into hash table indexed by name */
+        t = avahi_hashmap_lookup(s->llmnr.entries_by_key, r->key);
+        AVAHI_LLIST_PREPEND(AvahiEntry, by_key, t, e);
+        avahi_hashmap_replace(s->llmnr.entries_by_key, e->record->key, t);
+
+        /* Insert into group list */
+        if (g)
+            AVAHI_LLIST_PREPEND(AvahiEntry, by_group, g->entries, e);
+        else
+            /* Verify now if it doesn't belong to any group otherwise entry will be verified
+            when group will be commited */
+            avahi_verify_entry(s, e);
+      }
+
+    return e;
+}
 static AvahiEntry * server_add_internal(
     AvahiServer *s,
     AvahiSEntryGroup *g,
@@ -202,11 +357,14 @@ static AvahiEntry * server_add_internal(
                                          flags,
                                          AVAHI_PUBLISH_NO_ANNOUNCE|
                                          AVAHI_PUBLISH_NO_PROBE|
+                                         AVAHI_PUBLISH_NO_VERIFY|
                                          AVAHI_PUBLISH_UNIQUE|
                                          AVAHI_PUBLISH_ALLOW_MULTIPLE|
                                          AVAHI_PUBLISH_UPDATE|
                                          AVAHI_PUBLISH_USE_WIDE_AREA|
-                                         AVAHI_PUBLISH_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
+                                         AVAHI_PUBLISH_USE_MULTICAST|
+                                         AVAHI_PUBLISH_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
+
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, avahi_is_valid_domain_name(r->key->name), AVAHI_ERR_INVALID_HOST_NAME);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, r->ttl != 0, AVAHI_ERR_INVALID_TTL);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, !avahi_key_is_pattern(r->key), AVAHI_ERR_IS_PATTERN);
@@ -221,9 +379,16 @@ static AvahiEntry * server_add_internal(
                                      (r->key->type != AVAHI_DNS_TYPE_IXFR) &&
                                      (r->key->type != AVAHI_DNS_TYPE_AXFR), AVAHI_ERR_INVALID_DNS_TYPE);
 
-    transport_flags_from_domain(s, &flags, r->key->name);
-    AVAHI_CHECK_VALIDITY_RETURN_NULL(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
+    transport_flags_from_domain(s, &flags, r->key->name, 1);
+
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(s, (flags & AVAHI_PUBLISH_USE_MULTICAST) || (flags & AVAHI_PUBLISH_USE_LLMNR), AVAHI_ERR_NOT_SUPPORTED);
+
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, !s->config.disable_publishing, AVAHI_ERR_NOT_PERMITTED);
+
+    if (flags & AVAHI_PUBLISH_USE_LLMNR)
+        return server_add_llmnr_internal(s, g, interface, protocol, flags, r);
+
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(s, !(flags & AVAHI_PUBLISH_NO_VERIFY), AVAHI_ERR_INVALID_FLAGS);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s,
                                      !g ||
                                      (g->state != AVAHI_ENTRY_GROUP_ESTABLISHED && g->state != AVAHI_ENTRY_GROUP_REGISTERING) ||
@@ -233,10 +398,13 @@ static AvahiEntry * server_add_internal(
         AvahiRecord *old_record;
         int is_first = 1;
 
-        /* Update and existing record */
+        AVAHI_CHECK_VALIDITY_RETURN_NULL(s, !g || g->type == AVAHI_GROUP_MDNS, AVAHI_ERR_INVALID_GROUP);
 
-        /* Find the first matching entry */
-        for (e = avahi_hashmap_lookup(s->entries_by_key, r->key); e; e = e->by_key_next) {
+       /* Update an existing record */
+
+       /* Find the first matching entry */
+        for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, r->key); e; e = e->by_key_next) {
+            assert(e->type == AVAHI_ENTRY_MDNS);
             if (!e->dead && e->group == g && e->interface == interface && e->protocol == protocol)
                 break;
 
@@ -267,16 +435,32 @@ static AvahiEntry * server_add_internal(
 
         /* If we were the first entry in the list, we need to update the key */
         if (is_first)
-            avahi_hashmap_replace(s->entries_by_key, e->record->key, e);
+            avahi_hashmap_replace(s->mdns.entries_by_key, e->record->key, e);
 
         avahi_record_unref(old_record);
 
     } else {
         AvahiEntry *t;
 
+        AVAHI_CHECK_VALIDITY_RETURN_NULL(s,
+                                         !g ||
+                                         g->type == AVAHI_GROUP_UNSET ||
+                                         g->type == AVAHI_GROUP_MDNS, AVAHI_ERR_INVALID_GROUP);
+
+        if (g && g->type == AVAHI_GROUP_UNSET) {
+            g->proto.mdns.n_probing = 0;
+            g->proto.mdns.n_register_try = 0;
+            g->proto.mdns.register_time_event = NULL;
+            g->proto.mdns.register_time.tv_sec = 0;
+            g->proto.mdns.register_time.tv_usec = 0;
+            g->type = AVAHI_GROUP_MDNS;
+
+            AVAHI_LLIST_HEAD_INIT(AvahiEntry, g->entries);
+            AVAHI_LLIST_PREPEND(AvahiSEntryGroup, groups, s->mdns.groups, g);
+        }
         /* Add a new record */
 
-        if (check_record_conflict(s, interface, protocol, r, flags) < 0) {
+        if (check_record_conflict(s, interface, protocol, r, flags, AVAHI_MDNS) < 0) {
             avahi_server_set_errno(s, AVAHI_ERR_COLLISION);
             return NULL;
         }
@@ -293,15 +477,16 @@ static AvahiEntry * server_add_internal(
         e->protocol = protocol;
         e->flags = flags;
         e->dead = 0;
+        e->type = AVAHI_ENTRY_MDNS;
 
-        AVAHI_LLIST_HEAD_INIT(AvahiAnnouncer, e->announcers);
+        AVAHI_LLIST_HEAD_INIT(AvahiAnnouncer, e->proto.mdns.announcers);
 
-        AVAHI_LLIST_PREPEND(AvahiEntry, entries, s->entries, e);
+        AVAHI_LLIST_PREPEND(AvahiEntry, entries, s->mdns.entries, e);
 
         /* Insert into hash table indexed by name */
-        t = avahi_hashmap_lookup(s->entries_by_key, e->record->key);
+        t = avahi_hashmap_lookup(s->mdns.entries_by_key, e->record->key);
         AVAHI_LLIST_PREPEND(AvahiEntry, by_key, t, e);
-        avahi_hashmap_replace(s->entries_by_key, e->record->key, t);
+        avahi_hashmap_replace(s->mdns.entries_by_key, e->record->key, t);
 
         /* Insert into group list */
         if (g)
@@ -327,13 +512,13 @@ int avahi_server_add(
     return AVAHI_OK;
 }
 
-const AvahiRecord *avahi_server_iterate(AvahiServer *s, AvahiSEntryGroup *g, void **state) {
+const AvahiRecord *avahi_server_iterate(AvahiServer *s, AvahiSEntryGroup *g, void **state, AvahiPublishProtocol proto) {
     AvahiEntry **e = (AvahiEntry**) state;
     assert(s);
     assert(e);
 
     if (!*e)
-        *e = g ? g->entries : s->entries;
+        *e = g ? g->entries : (proto == AVAHI_MDNS ? s->mdns.entries : s->llmnr.entries);
 
     while (*e && (*e)->dead)
         *e = g ? (*e)->by_group_next : (*e)->entries_next;
@@ -344,34 +529,43 @@ const AvahiRecord *avahi_server_iterate(AvahiServer *s, AvahiSEntryGroup *g, voi
     return avahi_record_ref((*e)->record);
 }
 
-int avahi_server_dump(AvahiServer *s, AvahiDumpCallback callback, void* userdata) {
+static void zone_dump(AvahiServer *s, AvahiDumpCallback callback, void* userdata, AvahiPublishProtocol proto) {
     AvahiEntry *e;
 
-    assert(s);
-    assert(callback);
-
-    callback(";;; ZONE DUMP FOLLOWS ;;;", userdata);
-
-    for (e = s->entries; e; e = e->entries_next) {
+    for (e = ((proto == AVAHI_MDNS) ? (s->mdns.entries) : (s->llmnr.entries)); e; e = e->entries_next) {
         char *t;
         char ln[256];
 
         if (e->dead)
             continue;
 
-        if (!(t = avahi_record_to_string(e->record)))
-            return avahi_server_set_errno(s, AVAHI_ERR_NO_MEMORY);
+        if (!(t = avahi_record_to_string(e->record))) {
+            avahi_server_set_errno(s, AVAHI_ERR_NO_MEMORY);
+            return;
+        }
 
         snprintf(ln, sizeof(ln), "%s ; iface=%i proto=%i", t, e->interface, e->protocol);
         avahi_free(t);
 
         callback(ln, userdata);
     }
+}
 
+int avahi_server_dump(AvahiServer *s, AvahiDumpCallback callback, void* userdata) {
+    assert(s);
+    assert(callback);
+
+    callback(";;; mDNS ZONE DUMP FOLLOWS ;;;", userdata);
+    zone_dump(s, callback, userdata, AVAHI_MDNS);
     avahi_dump_caches(s->monitor, callback, userdata);
 
-    if (s->wide_area_lookup_engine)
-        avahi_wide_area_cache_dump(s->wide_area_lookup_engine, callback, userdata);
+    callback(";;; LLMNR ZONE DUMP FOLLOWS ;;;", userdata);
+    zone_dump(s, callback, userdata, AVAHI_LLMNR);
+    avahi_llmnr_cache_dump(s->llmnr.llmnr_lookup_engine, callback, userdata);
+
+    if (s->wide_area.wide_area_lookup_engine)
+        avahi_wide_area_cache_dump(s->wide_area.wide_area_lookup_engine, callback, userdata);
+
     return AVAHI_OK;
 }
 
@@ -428,51 +622,28 @@ int avahi_server_add_ptr(
     return AVAHI_OK;
 }
 
-int avahi_server_add_address(
+static int server_add_address_internal (
     AvahiServer *s,
     AvahiSEntryGroup *g,
     AvahiIfIndex interface,
     AvahiProtocol protocol,
     AvahiPublishFlags flags,
     const char *name,
-    AvahiAddress *a) {
+    AvahiAddress *a,
+    uint32_t ttl) {
 
-    char n[AVAHI_DOMAIN_NAME_MAX];
+    AvahiRecord *r;
     int ret = AVAHI_OK;
-    AvahiEntry *entry = NULL, *reverse = NULL;
-    AvahiRecord  *r;
+    AvahiEntry *reverse = NULL, *entry = NULL;
 
     assert(s);
     assert(a);
-
-    AVAHI_CHECK_VALIDITY(s, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
-    AVAHI_CHECK_VALIDITY(s, AVAHI_PROTO_VALID(protocol) && AVAHI_PROTO_VALID(a->proto), AVAHI_ERR_INVALID_PROTOCOL);
-    AVAHI_CHECK_VALIDITY(s, AVAHI_FLAGS_VALID(flags,
-                                              AVAHI_PUBLISH_NO_REVERSE|
-                                              AVAHI_PUBLISH_NO_ANNOUNCE|
-                                              AVAHI_PUBLISH_NO_PROBE|
-                                              AVAHI_PUBLISH_UPDATE|
-                                              AVAHI_PUBLISH_USE_WIDE_AREA|
-                                              AVAHI_PUBLISH_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
-    AVAHI_CHECK_VALIDITY(s, !name || avahi_is_valid_fqdn(name), AVAHI_ERR_INVALID_HOST_NAME);
-
-    /* Prepare the host naem */
-
-    if (!name)
-        name = s->host_name_fqdn;
-    else {
-        AVAHI_ASSERT_TRUE(avahi_normalize_name(name, n, sizeof(n)));
-        name = n;
-    }
-
-    transport_flags_from_domain(s, &flags, name);
-    AVAHI_CHECK_VALIDITY(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
+    assert(name);
 
     /* Create the A/AAAA record */
-
     if (a->proto == AVAHI_PROTO_INET) {
 
-        if (!(r = avahi_record_new_full(name, AVAHI_DNS_CLASS_IN, AVAHI_DNS_TYPE_A, AVAHI_DEFAULT_TTL_HOST_NAME))) {
+        if (!(r = avahi_record_new_full(name, AVAHI_DNS_CLASS_IN, AVAHI_DNS_TYPE_A, ttl))) {
             ret = avahi_server_set_errno(s, AVAHI_ERR_NO_MEMORY);
             goto finish;
         }
@@ -482,7 +653,7 @@ int avahi_server_add_address(
     } else {
         assert(a->proto == AVAHI_PROTO_INET6);
 
-        if (!(r = avahi_record_new_full(name, AVAHI_DNS_CLASS_IN, AVAHI_DNS_TYPE_AAAA, AVAHI_DEFAULT_TTL_HOST_NAME))) {
+        if (!(r = avahi_record_new_full(name, AVAHI_DNS_CLASS_IN, AVAHI_DNS_TYPE_AAAA, ttl))) {
             ret = avahi_server_set_errno(s, AVAHI_ERR_NO_MEMORY);
             goto finish;
         }
@@ -504,7 +675,7 @@ int avahi_server_add_address(
         char reverse_n[AVAHI_DOMAIN_NAME_MAX];
         avahi_reverse_lookup_name(a, reverse_n, sizeof(reverse_n));
 
-        if (!(reverse = server_add_ptr_internal(s, g, interface, protocol, flags | AVAHI_PUBLISH_UNIQUE, AVAHI_DEFAULT_TTL_HOST_NAME, reverse_n, name))) {
+        if (!(reverse = server_add_ptr_internal(s, g, interface, protocol, flags | AVAHI_PUBLISH_UNIQUE, ttl, reverse_n, name))) {
             ret = avahi_server_errno(s);
             goto finish;
         }
@@ -522,6 +693,72 @@ finish:
     return ret;
 }
 
+
+int avahi_server_add_address(
+    AvahiServer *s,
+    AvahiSEntryGroup *g,
+    AvahiIfIndex interface,
+    AvahiProtocol protocol,
+    AvahiPublishFlags flags,
+    const char *name,
+    AvahiAddress *a) {
+
+    char n[AVAHI_DOMAIN_NAME_MAX];
+    int ret_fqdn, null_name = 0;
+
+    assert(s);
+    assert(a);
+    /*assert(name || (flags & (AVAHI_PUBLISH_USE_MULTICAST | AVAHI_PUBLISH_USE_LLMNR | AVAHI_PUBLISH_USE_WIDE_AREA));*/
+
+    AVAHI_CHECK_VALIDITY(s, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
+    AVAHI_CHECK_VALIDITY(s, AVAHI_PROTO_VALID(protocol) && AVAHI_PROTO_VALID(a->proto), AVAHI_ERR_INVALID_PROTOCOL);
+    AVAHI_CHECK_VALIDITY(s, AVAHI_FLAGS_VALID(flags,
+                                              AVAHI_PUBLISH_NO_REVERSE|
+                                              AVAHI_PUBLISH_NO_ANNOUNCE|
+                                              AVAHI_PUBLISH_NO_PROBE|
+                                              AVAHI_PUBLISH_NO_VERIFY|
+                                              AVAHI_PUBLISH_UPDATE|
+                                              AVAHI_PUBLISH_USE_WIDE_AREA|
+                                              AVAHI_PUBLISH_USE_MULTICAST|
+                                              AVAHI_PUBLISH_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
+
+    AVAHI_CHECK_VALIDITY(s,
+                         !name ||
+                         ((flags & AVAHI_PUBLISH_USE_MULTICAST) ? (avahi_is_valid_fqdn(name)) : (avahi_is_valid_domain_name(name))),
+                         AVAHI_ERR_INVALID_HOST_NAME);
+
+    /* Prepare the host name */
+    if (!name) {
+        name = s->host_name_fqdn;
+        null_name = 1;
+    } else {
+        AVAHI_ASSERT_TRUE(avahi_normalize_name(name, n, sizeof(n)));
+        name = n;
+    }
+
+    /* transport flags */
+    transport_flags_from_domain(s, &flags, name, 1);
+    AVAHI_CHECK_VALIDITY(s, (flags & (AVAHI_PUBLISH_USE_MULTICAST | AVAHI_PUBLISH_USE_LLMNR)), AVAHI_ERR_NOT_SUPPORTED);
+
+    /* No matter mDNS or LLMNR */
+    if (flags & AVAHI_PUBLISH_USE_MULTICAST)
+        ret_fqdn = server_add_address_internal(s, g, interface, protocol, flags, name, a, AVAHI_DEFAULT_TTL_HOST_NAME);
+    else
+        ret_fqdn = server_add_address_internal(s, g,
+                                               interface,
+                                               protocol,
+                                               (null_name == 1) ? (flags |= AVAHI_PUBLISH_NO_REVERSE) : (flags),
+                                               name, a,
+                                               AVAHI_DEFAULT_LLMNR_TTL_HOST_NAME);
+
+    /* If previous entries have been added successfully && name parameter was NULL && we are using LLMNR,
+    publish hostname -> A/AAAA entry and PTR entry*/
+    if (ret_fqdn == AVAHI_OK && null_name == 1 && flags & AVAHI_PUBLISH_USE_LLMNR )
+        return server_add_address_internal(s, g, interface, protocol, flags & ~ AVAHI_PUBLISH_NO_REVERSE, s->host_name, a, AVAHI_DEFAULT_LLMNR_TTL_HOST_NAME);
+
+    return ret_fqdn;
+}
+
 static AvahiEntry *server_add_txt_strlst_nocopy(
     AvahiServer *s,
     AvahiSEntryGroup *g,
@@ -606,7 +843,7 @@ static int server_add_service_strlst_nocopy(
     if (!host)
         host = s->host_name_fqdn;
 
-    transport_flags_from_domain(s, &flags, domain);
+    transport_flags_from_domain(s, &flags, domain, 0);
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
 
     if (!(h = avahi_normalize_name_strdup(host))) {
@@ -669,7 +906,7 @@ static int server_add_service_strlst_nocopy(
     }
 
 fail:
-    if (ret != AVAHI_OK && !(flags & AVAHI_PUBLISH_UPDATE)) {
+   if (ret != AVAHI_OK && !(flags & AVAHI_PUBLISH_UPDATE)) {
         if (srv_entry)
             avahi_entry_free(s, srv_entry);
         if (txt_entry)
@@ -747,6 +984,7 @@ static int server_update_service_txt_strlst_nocopy(
     assert(s);
     assert(type);
     assert(name);
+    assert (flags & AVAHI_PUBLISH_USE_MULTICAST || flags & AVAHI_PUBLISH_USE_WIDE_AREA);
 
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, AVAHI_PROTO_VALID(protocol), AVAHI_ERR_INVALID_PROTOCOL);
@@ -761,7 +999,7 @@ static int server_update_service_txt_strlst_nocopy(
     if (!domain)
         domain = s->domain_name;
 
-    transport_flags_from_domain(s, &flags, domain);
+    transport_flags_from_domain(s, &flags, domain, 0);
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
 
     if ((ret = avahi_service_name_join(svc_name, sizeof(svc_name), name, type, domain)) < 0) {
@@ -839,6 +1077,7 @@ int avahi_server_add_service_subtype(
     assert(name);
     assert(type);
     assert(subtype);
+    assert (flags & AVAHI_PUBLISH_USE_MULTICAST || flags & AVAHI_PUBLISH_USE_WIDE_AREA);
 
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, AVAHI_PROTO_VALID(protocol), AVAHI_ERR_INVALID_PROTOCOL);
@@ -851,7 +1090,7 @@ int avahi_server_add_service_subtype(
     if (!domain)
         domain = s->domain_name;
 
-    transport_flags_from_domain(s, &flags, domain);
+    transport_flags_from_domain(s, &flags, domain, 0);
     AVAHI_CHECK_VALIDITY_SET_RET_GOTO_FAIL(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
 
     if ((ret = avahi_service_name_join(svc_name, sizeof(svc_name), name, type, domain)) < 0 ||
@@ -908,6 +1147,7 @@ static AvahiEntry *server_add_dns_server_name(
 
     assert(s);
     assert(name);
+    assert (flags & AVAHI_PUBLISH_USE_MULTICAST || flags & AVAHI_PUBLISH_USE_WIDE_AREA);
 
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, AVAHI_FLAGS_VALID(flags, AVAHI_PUBLISH_USE_WIDE_AREA|AVAHI_PUBLISH_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, type == AVAHI_DNS_SERVER_UPDATE || type == AVAHI_DNS_SERVER_RESOLVE, AVAHI_ERR_INVALID_FLAGS);
@@ -918,7 +1158,7 @@ static AvahiEntry *server_add_dns_server_name(
     if (!domain)
         domain = s->domain_name;
 
-    transport_flags_from_domain(s, &flags, domain);
+    transport_flags_from_domain(s, &flags, domain, 0);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
 
     if (!(n = avahi_normalize_name_strdup(name))) {
@@ -963,6 +1203,7 @@ int avahi_server_add_dns_server_address(
 
     assert(s);
     assert(address);
+    assert (flags & AVAHI_PUBLISH_USE_MULTICAST || flags & AVAHI_PUBLISH_USE_WIDE_AREA);
 
     AVAHI_CHECK_VALIDITY(s, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
     AVAHI_CHECK_VALIDITY(s, AVAHI_PROTO_VALID(protocol) && AVAHI_PROTO_VALID(address->proto), AVAHI_ERR_INVALID_PROTOCOL);
@@ -974,7 +1215,7 @@ int avahi_server_add_dns_server_address(
     if (!domain)
         domain = s->domain_name;
 
-    transport_flags_from_domain(s, &flags, domain);
+    transport_flags_from_domain(s, &flags, domain, 0);
     AVAHI_CHECK_VALIDITY(s, flags & AVAHI_PUBLISH_USE_MULTICAST, AVAHI_ERR_NOT_SUPPORTED);
 
     if (address->proto == AVAHI_PROTO_INET) {
@@ -1009,32 +1250,33 @@ int avahi_server_add_dns_server_address(
 
 void avahi_s_entry_group_change_state(AvahiSEntryGroup *g, AvahiEntryGroupState state) {
     assert(g);
+    assert(g->type != AVAHI_GROUP_UNSET);
 
     if (g->state == state)
         return;
 
     assert(state <= AVAHI_ENTRY_GROUP_COLLISION);
 
-    if (g->state == AVAHI_ENTRY_GROUP_ESTABLISHED) {
+    if (g->state == AVAHI_ENTRY_GROUP_ESTABLISHED && g->type == AVAHI_GROUP_MDNS) {
 
         /* If the entry group was established for a time longer then
          * 5s, reset the establishment trial counter */
 
-        if (avahi_age(&g->established_at) > 5000000)
-            g->n_register_try = 0;
-    } else if (g->state == AVAHI_ENTRY_GROUP_REGISTERING) {
-        if (g->register_time_event) {
-            avahi_time_event_free(g->register_time_event);
-            g->register_time_event = NULL;
+        if (avahi_age(&g->proto.mdns.established_at) > 5000000)
+            g->proto.mdns.n_register_try = 0;
+    } else if (g->state == AVAHI_ENTRY_GROUP_REGISTERING && g->type == AVAHI_GROUP_MDNS) {
+        if (g->proto.mdns.register_time_event) {
+            avahi_time_event_free(g->proto.mdns.register_time_event);
+            g->proto.mdns.register_time_event = NULL;
         }
     }
 
-    if (state == AVAHI_ENTRY_GROUP_ESTABLISHED)
+    if (state == AVAHI_ENTRY_GROUP_ESTABLISHED && g->type == AVAHI_GROUP_MDNS)
 
         /* If the entry group is now established, remember the time
          * this happened */
 
-        gettimeofday(&g->established_at, NULL);
+        gettimeofday(&g->proto.mdns.established_at, NULL);
 
     g->state = state;
 
@@ -1057,14 +1299,8 @@ AvahiSEntryGroup *avahi_s_entry_group_new(AvahiServer *s, AvahiSEntryGroupCallba
     g->userdata = userdata;
     g->dead = 0;
     g->state = AVAHI_ENTRY_GROUP_UNCOMMITED;
-    g->n_probing = 0;
-    g->n_register_try = 0;
-    g->register_time_event = NULL;
-    g->register_time.tv_sec = 0;
-    g->register_time.tv_usec = 0;
-    AVAHI_LLIST_HEAD_INIT(AvahiEntry, g->entries);
-
-    AVAHI_LLIST_PREPEND(AvahiSEntryGroup, groups, s->groups, g);
+    g->type = AVAHI_GROUP_UNSET;
+
     return g;
 }
 
@@ -1091,30 +1327,52 @@ void avahi_s_entry_group_free(AvahiSEntryGroup *g) {
     assert(g);
     assert(g->server);
 
-    for (e = g->entries; e; e = e->by_group_next) {
-        if (!e->dead) {
-            avahi_goodbye_entry(g->server, e, 1, 1);
-            e->dead = 1;
+    if (g->type == AVAHI_GROUP_UNSET) {
+        avahi_free(g);
+
+    } else if (g->type == AVAHI_GROUP_MDNS) {
+        for (e = g->entries; e; e = e->by_group_next) {
+            assert(e->type == AVAHI_ENTRY_MDNS);
+
+            if (!e->dead) {
+                avahi_goodbye_entry(g->server, e, 1, 1);
+                e->dead = 1;
+            }
+        }
+
+        if (g->proto.mdns.register_time_event) {
+            avahi_time_event_free(g->proto.mdns.register_time_event);
+            g->proto.mdns.register_time_event = NULL;
         }
-    }
 
-    if (g->register_time_event) {
-        avahi_time_event_free(g->register_time_event);
-        g->register_time_event = NULL;
+        g->server->mdns.need_group_cleanup = 1;
+        g->server->mdns.need_entry_cleanup = 1;
+
+    } else {
+        assert (g->type == AVAHI_GROUP_LLMNR);
+        for (e = g->entries; e; e = e->by_group_next) {
+            assert(e->type == AVAHI_ENTRY_LLMNR);
+
+            if (!e->dead) {
+                avahi_remove_verifiers(g->server, e);
+                e->dead = 1;
+            }
+        }
+
+        g->server->llmnr.need_entry_cleanup = 1;
+        g->server->llmnr.need_group_cleanup = 1;
     }
 
     g->dead = 1;
 
-    g->server->need_group_cleanup = 1;
-    g->server->need_entry_cleanup = 1;
-
     schedule_cleanup(g->server);
 }
 
 static void entry_group_commit_real(AvahiSEntryGroup *g) {
     assert(g);
+    assert(g->type == AVAHI_GROUP_MDNS);
 
-    gettimeofday(&g->register_time, NULL);
+    gettimeofday(&g->proto.mdns.register_time, NULL);
 
     avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_REGISTERING);
 
@@ -1128,9 +1386,10 @@ static void entry_group_commit_real(AvahiSEntryGroup *g) {
 static void entry_group_register_time_event_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void* userdata) {
     AvahiSEntryGroup *g = userdata;
     assert(g);
+    assert(g->type == AVAHI_GROUP_MDNS);
 
-    avahi_time_event_free(g->register_time_event);
-    g->register_time_event = NULL;
+    avahi_time_event_free(g->proto.mdns.register_time_event);
+    g->proto.mdns.register_time_event = NULL;
 
     /* Holdoff time passed, so let's start probing */
     entry_group_commit_real(g);
@@ -1142,32 +1401,50 @@ int avahi_s_entry_group_commit(AvahiSEntryGroup *g) {
     assert(g);
     assert(!g->dead);
 
-    if (g->state != AVAHI_ENTRY_GROUP_UNCOMMITED && g->state != AVAHI_ENTRY_GROUP_COLLISION)
-        return avahi_server_set_errno(g->server, AVAHI_ERR_BAD_STATE);
-
-    if (avahi_s_entry_group_is_empty(g))
+    if (g->type == AVAHI_GROUP_UNSET)
+        /* Group is empty */
         return avahi_server_set_errno(g->server, AVAHI_ERR_IS_EMPTY);
 
-    g->n_register_try++;
+    if (g->type == AVAHI_GROUP_MDNS) {
+        if (g->state != AVAHI_ENTRY_GROUP_UNCOMMITED && g->state != AVAHI_ENTRY_GROUP_COLLISION)
+            return avahi_server_set_errno(g->server, AVAHI_ERR_BAD_STATE);
+
+/*        if (avahi_s_entry_group_is_empty(g))
+            return avahi_server_set_errno(g->server, AVAHI_ERR_IS_EMPTY);*/
 
-    avahi_timeval_add(&g->register_time,
-                      1000*(g->n_register_try >= AVAHI_RR_RATE_LIMIT_COUNT ?
-                            AVAHI_RR_HOLDOFF_MSEC_RATE_LIMIT :
-                            AVAHI_RR_HOLDOFF_MSEC));
+        g->proto.mdns.n_register_try++;
 
-    gettimeofday(&now, NULL);
+        avahi_timeval_add(&g->proto.mdns.register_time,
+                          1000*(g->proto.mdns.n_register_try >= AVAHI_RR_RATE_LIMIT_COUNT ?
+                                AVAHI_RR_HOLDOFF_MSEC_RATE_LIMIT :
+                                AVAHI_RR_HOLDOFF_MSEC));
 
-    if (avahi_timeval_compare(&g->register_time, &now) <= 0) {
+        gettimeofday(&now, NULL);
+
+        if (avahi_timeval_compare(&g->proto.mdns.register_time, &now) <= 0) {
+
+            /* Holdoff time passed, so let's start probing */
+            entry_group_commit_real(g);
+        } else {
+
+             /* Holdoff time has not yet passed, so let's wait */
+            assert(!g->proto.mdns.register_time_event);
+            g->proto.mdns.register_time_event = avahi_time_event_new(g->server->time_event_queue, &g->proto.mdns.register_time, entry_group_register_time_event_callback, g);
+
+            avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_REGISTERING);
+        }
 
-        /* Holdoff time passed, so let's start probing */
-        entry_group_commit_real(g);
     } else {
+        assert(g->type == AVAHI_GROUP_LLMNR);
+
+        if (g->state != AVAHI_ENTRY_GROUP_LLMNR_UNCOMMITED && g->state != AVAHI_ENTRY_GROUP_LLMNR_COLLISION)
+            return avahi_server_set_errno(g->server, AVAHI_ERR_BAD_STATE);
 
-         /* Holdoff time has not yet passed, so let's wait */
-        assert(!g->register_time_event);
-        g->register_time_event = avahi_time_event_new(g->server->time_event_queue, &g->register_time, entry_group_register_time_event_callback, g);
+/*        if (avahi_s_entry_group_is_empty(g))
+            return avahi_server_set_errno(g->server, AVAHI_ERR_IS_EMPTY);*/
 
-        avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_REGISTERING);
+        avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_LLMNR_VERIFYING);
+        avahi_verify_group(g->server, g);
     }
 
     return AVAHI_OK;
@@ -1177,17 +1454,40 @@ void avahi_s_entry_group_reset(AvahiSEntryGroup *g) {
     AvahiEntry *e;
     assert(g);
 
-    for (e = g->entries; e; e = e->by_group_next) {
-        if (!e->dead) {
-            avahi_goodbye_entry(g->server, e, 1, 1);
-            e->dead = 1;
+    if (g->type == AVAHI_GROUP_UNSET)
+        return;
+
+    if (g->type == AVAHI_GROUP_MDNS) {
+
+        for (e = g->entries; e; e = e->by_group_next) {
+            assert(e->type == AVAHI_ENTRY_MDNS);
+            if (!e->dead) {
+                avahi_goodbye_entry(g->server, e, 1, 1);
+                e->dead = 1;
+            }
         }
-    }
-    g->server->need_entry_cleanup = 1;
+        g->server->mdns.need_entry_cleanup = 1;
 
-    g->n_probing = 0;
+        g->proto.mdns.n_probing = 0;
 
-    avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_UNCOMMITED);
+        avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_UNCOMMITED);
+
+    } else {
+        assert(g->type == AVAHI_GROUP_LLMNR);
+
+        for (e = g->entries; e; e = e->by_group_next) {
+            assert(e->type == AVAHI_ENTRY_LLMNR);
+            if (!e->dead) {
+                avahi_remove_verifiers(g->server, e);
+                e->dead = 1;
+            }
+        }
+        g->server->llmnr.need_entry_cleanup = 1;
+
+        g->proto.llmnr.n_verifying = 0;
+
+        avahi_s_entry_group_change_state(g, AVAHI_ENTRY_GROUP_LLMNR_UNCOMMITED);
+    }
 
     schedule_cleanup(g->server);
 }
@@ -1196,9 +1496,15 @@ int avahi_entry_is_commited(AvahiEntry *e) {
     assert(e);
     assert(!e->dead);
 
-    return !e->group ||
-        e->group->state == AVAHI_ENTRY_GROUP_REGISTERING ||
-        e->group->state == AVAHI_ENTRY_GROUP_ESTABLISHED;
+    if (e->type == AVAHI_ENTRY_MDNS)
+        return !e->group ||
+            e->group->state == AVAHI_ENTRY_GROUP_REGISTERING ||
+            e->group->state == AVAHI_ENTRY_GROUP_ESTABLISHED;
+
+    else
+        return (!e->group ||
+            e->group->state == AVAHI_ENTRY_GROUP_LLMNR_VERIFYING ||
+            e->group->state == AVAHI_ENTRY_GROUP_LLMNR_ESTABLISHED );
 }
 
 AvahiEntryGroupState avahi_s_entry_group_get_state(AvahiSEntryGroup *g) {
@@ -1224,6 +1530,10 @@ int avahi_s_entry_group_is_empty(AvahiSEntryGroup *g) {
     AvahiEntry *e;
     assert(g);
 
+    if (g->type == AVAHI_GROUP_UNSET)
+        /* There has not been any entry added in this group so far. */
+        return 1;
+
     /* Look for an entry that is not dead */
     for (e = g->entries; e; e = e->by_group_next)
         if (!e->dead)
diff --git a/avahi-core/iface-linux.c b/avahi-core/iface-linux.c
index da497bc..1c3dce9 100644
--- a/avahi-core/iface-linux.c
+++ b/avahi-core/iface-linux.c
@@ -149,7 +149,8 @@ static void netlink_callback(AvahiNetlink *nl, struct nlmsghdr *n, void* userdat
          * it is Avahi will start to announce its records on this
          * interface and send out queries for subscribed records on
          * it */
-        avahi_hw_interface_check_relevant(hw);
+        avahi_hw_interface_check_relevant(hw, AVAHI_MDNS);
+        avahi_hw_interface_check_relevant(hw, AVAHI_LLMNR);
 
         /* Update any associated RRs of this interface. (i.e. the
          * _workstation._tcp record containing the MAC address) */
@@ -276,7 +277,8 @@ static void netlink_callback(AvahiNetlink *nl, struct nlmsghdr *n, void* userdat
          * attached relevant. Since we migh have added or removed an
          * address, let's have it check again whether the interface is
          * now relevant */
-        avahi_interface_check_relevant(i);
+        avahi_interface_check_relevant(i, AVAHI_MDNS);
+        avahi_interface_check_relevant(i, AVAHI_LLMNR);
 
         /* Update any associated RRs, like A or AAAA for our new/removed address */
         avahi_interface_update_rrs(i, 0);
@@ -312,7 +314,8 @@ static void netlink_callback(AvahiNetlink *nl, struct nlmsghdr *n, void* userdat
             m->list_complete = 1;
 
             /* So let's check if any interfaces are relevant now */
-            avahi_interface_monitor_check_relevant(m);
+            avahi_interface_monitor_check_relevant(m, AVAHI_MDNS);
+            avahi_interface_monitor_check_relevant(m, AVAHI_LLMNR);
 
             /* And update all RRs attached to any interface */
             avahi_interface_monitor_update_rrs(m, 0);
diff --git a/avahi-core/iface.c b/avahi-core/iface.c
index 39a860a..4c4613e 100644
--- a/avahi-core/iface.c
+++ b/avahi-core/iface.c
@@ -44,6 +44,7 @@
 
 void avahi_interface_address_update_rrs(AvahiInterfaceAddress *a, int remove_rrs) {
     AvahiInterfaceMonitor *m;
+    AvahiProtocol p;
 
     assert(a);
     m = a->monitor;
@@ -57,46 +58,77 @@ void avahi_interface_address_update_rrs(AvahiInterfaceAddress *a, int remove_rrs
         m->server->state == AVAHI_SERVER_REGISTERING)) {
 
         /* Fill the entry group */
-        if (!a->entry_group)
-            a->entry_group = avahi_s_entry_group_new(m->server, avahi_host_rr_entry_group_callback, NULL);
+        if (!a->entry_mdns_group)
+            a->entry_mdns_group = avahi_s_entry_group_new(m->server, avahi_host_rr_entry_group_callback, NULL);
 
-        if (!a->entry_group) /* OOM */
+        if (!a->entry_llmnr_group)
+            a->entry_llmnr_group = avahi_s_entry_group_new(m->server, avahi_host_rr_entry_group_callback, NULL);
+
+        if (!a->entry_mdns_group || !a->entry_llmnr_group)
             return;
 
-        if (avahi_s_entry_group_is_empty(a->entry_group)) {
-            char t[AVAHI_ADDRESS_STR_MAX];
-            AvahiProtocol p;
+        p = (a->interface->protocol == AVAHI_PROTO_INET && m->server->config.publish_a_on_ipv6) ||
+             (a->interface->protocol == AVAHI_PROTO_INET6 && m->server->config.publish_aaaa_on_ipv4) ?
+             AVAHI_PROTO_UNSPEC : a->interface->protocol;
 
-            p = (a->interface->protocol == AVAHI_PROTO_INET && m->server->config.publish_a_on_ipv6) ||
-                (a->interface->protocol == AVAHI_PROTO_INET6 && m->server->config.publish_aaaa_on_ipv4) ? AVAHI_PROTO_UNSPEC : a->interface->protocol;
+        if (avahi_s_entry_group_is_empty(a->entry_mdns_group)) {
+            char t[AVAHI_ADDRESS_STR_MAX];
 
             avahi_address_snprint(t, sizeof(t), &a->address);
-            avahi_log_info("Registering new address record for %s on %s.%s.", t, a->interface->hardware->name, p == AVAHI_PROTO_UNSPEC ? "*" : avahi_proto_to_string(p));
+            avahi_log_info("Registering new mDNS address record for %s on %s.%s.", t, a->interface->hardware->name, p == AVAHI_PROTO_UNSPEC ? "*" : avahi_proto_to_string(p));
 
-            if (avahi_server_add_address(m->server, a->entry_group, a->interface->hardware->index, p, 0, NULL, &a->address) < 0) {
+            if (avahi_server_add_address(m->server, a->entry_mdns_group, a->interface->hardware->index, p, AVAHI_PUBLISH_USE_MULTICAST, NULL, &a->address) < 0) {
                 avahi_log_warn(__FILE__": avahi_server_add_address() failed: %s", avahi_strerror(m->server->error));
-                avahi_s_entry_group_free(a->entry_group);
-                a->entry_group = NULL;
+                avahi_s_entry_group_free(a->entry_mdns_group);
+                a->entry_mdns_group = NULL;
                 return;
             }
 
-            avahi_s_entry_group_commit(a->entry_group);
+            avahi_s_entry_group_commit(a->entry_mdns_group);
+        }
+
+        if (avahi_s_entry_group_is_empty(a->entry_llmnr_group)) {
+            char t[AVAHI_ADDRESS_STR_MAX];
+
+            avahi_address_snprint(t, sizeof(t), &a->address);
+            avahi_log_info("Registering new LLMNR address record for %s on %s.%s.", t, a->interface->hardware->name, p == AVAHI_PROTO_UNSPEC ? "*" : avahi_proto_to_string(p));
+
+            if (avahi_server_add_address(m->server, a->entry_llmnr_group, a->interface->hardware->index, p, AVAHI_PUBLISH_USE_LLMNR, NULL, &a->address) < 0) {
+                avahi_log_warn(__FILE__": avahi_server_add_address() failed: %s", avahi_strerror(m->server->error));
+                avahi_s_entry_group_free(a->entry_llmnr_group);
+                a->entry_llmnr_group = NULL;
+                return;
+            }
+            avahi_s_entry_group_commit(a->entry_llmnr_group);
         }
+
     } else {
 
-        /* Clear the entry group */
+        /* Clear the entry groups */
+        if (a->entry_mdns_group && !avahi_s_entry_group_is_empty(a->entry_mdns_group)) {
+            char t[AVAHI_ADDRESS_STR_MAX];
+            avahi_address_snprint(t, sizeof(t), &a->address);
+
+            avahi_log_info("Withdrawing mDNS address records for %s on %s.", t, a->interface->hardware->name);
 
-        if (a->entry_group && !avahi_s_entry_group_is_empty(a->entry_group)) {
+            if (avahi_s_entry_group_get_state(a->entry_mdns_group) == AVAHI_ENTRY_GROUP_REGISTERING &&
+                m->server->state == AVAHI_SERVER_REGISTERING)
+                avahi_server_decrease_host_rr_pending(m->server);
+
+            avahi_s_entry_group_reset(a->entry_mdns_group);
+        }
+
+        if (a->entry_llmnr_group && !avahi_s_entry_group_is_empty(a->entry_llmnr_group)) {
             char t[AVAHI_ADDRESS_STR_MAX];
             avahi_address_snprint(t, sizeof(t), &a->address);
 
-            avahi_log_info("Withdrawing address record for %s on %s.", t, a->interface->hardware->name);
+            avahi_log_info("Withdrawing LLMNR address records for %s on %s.", t, a->interface->hardware->name);
 
-            if (avahi_s_entry_group_get_state(a->entry_group) == AVAHI_ENTRY_GROUP_REGISTERING &&
+            if (avahi_s_entry_group_get_state(a->entry_llmnr_group) == AVAHI_ENTRY_GROUP_LLMNR_VERIFYING &&
                 m->server->state == AVAHI_SERVER_REGISTERING)
                 avahi_server_decrease_host_rr_pending(m->server);
 
-            avahi_s_entry_group_reset(a->entry_group);
+            avahi_s_entry_group_reset(a->entry_llmnr_group);
         }
     }
 }
@@ -139,7 +171,7 @@ void avahi_hw_interface_update_rrs(AvahiHwInterface *hw, int remove_rrs) {
             avahi_format_mac_address(mac, sizeof(mac), hw->mac_address, hw->mac_address_size);
             snprintf(name, sizeof(name), "%s [%s]", unescaped, mac);
 
-            if (avahi_server_add_service(m->server, hw->entry_group, hw->index, AVAHI_PROTO_UNSPEC, 0, name, "_workstation._tcp", NULL, NULL, 9, NULL) < 0) {
+            if (avahi_server_add_service(m->server, hw->entry_group, hw->index, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_USE_MULTICAST, name, "_workstation._tcp", NULL, NULL, 9, NULL) < 0) {
                 avahi_log_warn(__FILE__": avahi_server_add_service() failed: %s", avahi_strerror(m->server->error));
                 avahi_s_entry_group_free(hw->entry_group);
                 hw->entry_group = NULL;
@@ -171,16 +203,19 @@ void avahi_interface_monitor_update_rrs(AvahiInterfaceMonitor *m, int remove_rrs
         avahi_hw_interface_update_rrs(hw, remove_rrs);
 }
 
-static int interface_mdns_mcast_join(AvahiInterface *i, int join) {
+static int interface_mcast_join(AvahiInterface *i, int join, AvahiPublishProtocol proto) {
     char at[AVAHI_ADDRESS_STR_MAX];
     int r;
     assert(i);
 
-    if (!!join  == !!i->mcast_joined)
+    //avahi_log_info("In interface_mcast_join with join : %d", join);
+    if (!!join  == (proto == AVAHI_MDNS ? !!i->mdns.mcast_joined : !!i->llmnr.llmnr_joined))
         return 0;
 
-    if ((i->protocol == AVAHI_PROTO_INET6 && i->monitor->server->fd_ipv6 < 0) ||
-        (i->protocol == AVAHI_PROTO_INET && i->monitor->server->fd_ipv4 < 0))
+    if ((i->protocol == AVAHI_PROTO_INET6 &&
+        (proto == AVAHI_MDNS ? (i->monitor->server->mdns.fd_ipv6 < 0) : (i->monitor->server->llmnr.fd_ipv6 < 0))) ||
+        (i->protocol == AVAHI_PROTO_INET &&
+        (proto == AVAHI_MDNS ? (i->monitor->server->mdns.fd_ipv4 < 0) : (i->monitor->server->llmnr.fd_ipv4 < 0))))
         return -1;
 
     if (join) {
@@ -200,36 +235,46 @@ static int interface_mdns_mcast_join(AvahiInterface *i, int join) {
         if (!a)
             return -1;
 
-        i->local_mcast_address = a->address;
+        if (proto == AVAHI_MDNS)
+            i->mdns.local_mcast_address = a->address;
+        else
+            i->llmnr.local_llmnr_address = a->address;
     }
 
-    avahi_log_info("%s mDNS multicast group on interface %s.%s with address %s.",
+    avahi_log_info("%s %s multicast group on interface %s.%s with address %s.",
                    join ? "Joining" : "Leaving",
+                   proto == AVAHI_MDNS ? "mDNS" : "LLMNR",
                    i->hardware->name,
                    avahi_proto_to_string(i->protocol),
-                   avahi_address_snprint(at, sizeof(at), &i->local_mcast_address));
+                   avahi_address_snprint(at, sizeof(at), proto == AVAHI_MDNS ? &i->mdns.local_mcast_address : &i->llmnr.local_llmnr_address));
 
-    if (i->protocol == AVAHI_PROTO_INET6)
-        r = avahi_mdns_mcast_join_ipv6(i->monitor->server->fd_ipv6, &i->local_mcast_address.data.ipv6, i->hardware->index, join);
-    else {
-        assert(i->protocol == AVAHI_PROTO_INET);
+    if (i->protocol == AVAHI_PROTO_INET6) {
+        if (proto == AVAHI_MDNS)
+            r = avahi_mcast_join_ipv6(i->monitor->server->mdns.fd_ipv6, &i->mdns.local_mcast_address.data.ipv6, i->hardware->index, join, proto);
+        else
+            r = avahi_mcast_join_ipv6(i->monitor->server->llmnr.fd_ipv6, &i->llmnr.local_llmnr_address.data.ipv6, i->hardware->index, join, proto);
 
-        r = avahi_mdns_mcast_join_ipv4(i->monitor->server->fd_ipv4, &i->local_mcast_address.data.ipv4, i->hardware->index, join);
+    } else {
+        assert(i->protocol == AVAHI_PROTO_INET);
+        if (proto == AVAHI_MDNS)
+            r = avahi_mcast_join_ipv4(i->monitor->server->mdns.fd_ipv4, &i->mdns.local_mcast_address.data.ipv4, i->hardware->index, join, proto);
+        else
+            r = avahi_mcast_join_ipv4(i->monitor->server->llmnr.fd_ipv4, &i->llmnr.local_llmnr_address.data.ipv4, i->hardware->index, join, proto);
     }
 
     if (r < 0)
-        i->mcast_joined = 0;
+        proto == AVAHI_MDNS ? ( i->mdns.mcast_joined = 0 ) : ( i->llmnr.llmnr_joined = 0 );
     else
-        i->mcast_joined = join;
+        proto == AVAHI_MDNS ? ( i->mdns.mcast_joined = join ) : ( i->llmnr.llmnr_joined = join );
 
     return 0;
 }
 
-static int interface_mdns_mcast_rejoin(AvahiInterface *i) {
+static int interface_mcast_rejoin(AvahiInterface *i, AvahiPublishProtocol proto) {
     AvahiInterfaceAddress *a, *usable = NULL, *found = NULL;
     assert(i);
 
-    if (!i->mcast_joined)
+    if (proto == AVAHI_MDNS ? (!i->mdns.mcast_joined) : (!i->llmnr.llmnr_joined))
         return 0;
 
     /* Check whether old address we joined with is still available. If
@@ -239,8 +284,7 @@ static int interface_mdns_mcast_rejoin(AvahiInterface *i) {
         if (a->global_scope && !usable)
             usable = a;
 
-        if (avahi_address_cmp(&a->address, &i->local_mcast_address) == 0) {
-
+        if (avahi_address_cmp(&a->address, proto == AVAHI_MDNS ? &i->mdns.local_mcast_address : &i->llmnr.local_llmnr_address) == 0) {
             if (a->global_scope)
                 /* No action necessary: the address still exists and
                  * has global scope. */
@@ -254,8 +298,8 @@ static int interface_mdns_mcast_rejoin(AvahiInterface *i) {
         /* No action necessary: the address still exists and no better one has been found */
         return 0;
 
-    interface_mdns_mcast_join(i, 0);
-    return interface_mdns_mcast_join(i, 1);
+    interface_mcast_join(i, 0, proto);
+    return interface_mcast_join(i, 1, proto);
 }
 
 void avahi_interface_address_free(AvahiInterfaceAddress *a) {
@@ -265,10 +309,16 @@ void avahi_interface_address_free(AvahiInterfaceAddress *a) {
     avahi_interface_address_update_rrs(a, 1);
     AVAHI_LLIST_REMOVE(AvahiInterfaceAddress, address, a->interface->addresses, a);
 
-    if (a->entry_group)
-        avahi_s_entry_group_free(a->entry_group);
+    if (a->entry_mdns_group)
+        avahi_s_entry_group_free(a->entry_mdns_group);
+
+    if (a->entry_llmnr_group)
+        avahi_s_entry_group_free(a->entry_llmnr_group);
 
-    interface_mdns_mcast_rejoin(a->interface);
+    /*mDNS*/
+    interface_mcast_rejoin(a->interface, AVAHI_MDNS);
+    /*LLMNR*/
+    interface_mcast_rejoin(a->interface, AVAHI_LLMNR);
 
     avahi_free(a);
 }
@@ -276,28 +326,46 @@ void avahi_interface_address_free(AvahiInterfaceAddress *a) {
 void avahi_interface_free(AvahiInterface *i, int send_goodbye) {
     assert(i);
 
-    /* Handle goodbyes and remove announcers */
+    /* Handle goodbyes and remove announcers and verifiers*/
     avahi_goodbye_interface(i->monitor->server, i, send_goodbye, 1);
-    avahi_response_scheduler_force(i->response_scheduler);
-    assert(!i->announcers);
+    avahi_remove_interface_verifiers(i->monitor->server, i);
 
-    if (i->mcast_joined)
-        interface_mdns_mcast_join(i, 0);
+    avahi_response_scheduler_force(i->mdns.response_scheduler);
+
+    assert(!i->mdns.announcers);
+    assert(!i->llmnr.verifiers);
+
+    if (i->mdns.mcast_joined)
+        interface_mcast_join(i, 0, AVAHI_MDNS);
+    if (i->llmnr.llmnr_joined)
+        interface_mcast_join(i, 0, AVAHI_LLMNR);
 
     /* Remove queriers */
+    /* mDNS */
     avahi_querier_free_all(i);
-    avahi_hashmap_free(i->queriers_by_key);
+    avahi_hashmap_free(i->mdns.queriers_by_key);
+    /*LLMNR*/
+    avahi_llmnr_queries_free(i);
+    avahi_hashmap_free(i->llmnr.queryjobs_by_key);
 
     /* Remove local RRs */
+
+    /* This will update both mDNS and LLMNR addresses */
     avahi_interface_update_rrs(i, 1);
 
     while (i->addresses)
         avahi_interface_address_free(i->addresses);
 
-    avahi_response_scheduler_free(i->response_scheduler);
-    avahi_query_scheduler_free(i->query_scheduler);
-    avahi_probe_scheduler_free(i->probe_scheduler);
-    avahi_cache_free(i->cache);
+    avahi_response_scheduler_free(i->mdns.response_scheduler);
+    avahi_llmnr_response_scheduler_free(i->llmnr.response_scheduler);
+
+    avahi_query_scheduler_free(i->mdns.query_scheduler);
+    avahi_llmnr_query_scheduler_free(i->llmnr.query_scheduler);
+
+    avahi_probe_scheduler_free(i->mdns.probe_scheduler);
+
+    avahi_cache_free(i->mdns.cache);
+    avahi_llmnr_clear_cache(i->monitor->server->llmnr.llmnr_lookup_engine, i);
 
     AVAHI_LLIST_REMOVE(AvahiInterface, interface, i->monitor->interfaces, i);
     AVAHI_LLIST_REMOVE(AvahiInterface, by_hardware, i->hardware->interfaces, i);
@@ -336,23 +404,40 @@ AvahiInterface* avahi_interface_new(AvahiInterfaceMonitor *m, AvahiHwInterface *
     i->monitor = m;
     i->hardware = hw;
     i->protocol = protocol;
-    i->announcing = 0;
-    i->mcast_joined = 0;
-
     AVAHI_LLIST_HEAD_INIT(AvahiInterfaceAddress, i->addresses);
-    AVAHI_LLIST_HEAD_INIT(AvahiAnnouncer, i->announcers);
 
-    AVAHI_LLIST_HEAD_INIT(AvahiQuerier, i->queriers);
-    i->queriers_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
+    /*mDNS data*/
+    i->mdns.announcing = 0;
+    i->mdns.mcast_joined = 0;
+
+    AVAHI_LLIST_HEAD_INIT(AvahiAnnouncer, i->mdns.announcers);
+    AVAHI_LLIST_HEAD_INIT(AvahiQuerier, i->mdns.queriers);
 
-    i->cache = avahi_cache_new(m->server, i);
-    i->response_scheduler = avahi_response_scheduler_new(i);
-    i->query_scheduler = avahi_query_scheduler_new(i);
-    i->probe_scheduler = avahi_probe_scheduler_new(i);
+    i->mdns.queriers_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
 
-    if (!i->cache || !i->response_scheduler || !i->query_scheduler || !i->probe_scheduler)
+    i->mdns.cache = avahi_cache_new(m->server, i);
+    i->mdns.response_scheduler = avahi_response_scheduler_new(i);
+    i->mdns.query_scheduler = avahi_query_scheduler_new(i);
+    i->mdns.probe_scheduler = avahi_probe_scheduler_new(i);
+
+    if (!i->mdns.cache || !i->mdns.response_scheduler || !i->mdns.query_scheduler || !i->mdns.probe_scheduler)
         goto fail; /* OOM */
 
+    /* LLMNR data */
+    i->llmnr.llmnr_joined = 0;
+    i->llmnr.verifying = 0;
+
+    i->llmnr.query_scheduler = avahi_llmnr_query_scheduler_new(i);
+    i->llmnr.response_scheduler = avahi_llmnr_response_scheduler_new(i);
+
+    i->llmnr.queryjobs_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, (AvahiFreeFunc) avahi_key_unref, NULL);
+
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNRQueryJob, i->llmnr.queryjobs);
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNREntryVerify, i->llmnr.verifiers);
+
+    if (!i->llmnr.query_scheduler || !i->llmnr.response_scheduler)
+    goto fail;
+
     AVAHI_LLIST_PREPEND(AvahiInterface, by_hardware, hw->interfaces, i);
     AVAHI_LLIST_PREPEND(AvahiInterface, interface, m->interfaces, i);
 
@@ -361,14 +446,18 @@ AvahiInterface* avahi_interface_new(AvahiInterfaceMonitor *m, AvahiHwInterface *
 fail:
 
     if (i) {
-        if (i->cache)
-            avahi_cache_free(i->cache);
-        if (i->response_scheduler)
-            avahi_response_scheduler_free(i->response_scheduler);
-        if (i->query_scheduler)
-            avahi_query_scheduler_free(i->query_scheduler);
-        if (i->probe_scheduler)
-            avahi_probe_scheduler_free(i->probe_scheduler);
+        if (i->mdns.cache)
+            avahi_cache_free(i->mdns.cache);
+        if (i->mdns.response_scheduler)
+            avahi_response_scheduler_free(i->mdns.response_scheduler);
+        if (i->mdns.query_scheduler)
+            avahi_query_scheduler_free(i->mdns.query_scheduler);
+        if (i->mdns.probe_scheduler)
+            avahi_probe_scheduler_free(i->mdns.probe_scheduler);
+        if (i->llmnr.query_scheduler)
+            avahi_llmnr_query_scheduler_free(i->llmnr.query_scheduler);
+        if (i->llmnr.response_scheduler)
+            avahi_llmnr_response_scheduler_free(i->llmnr.response_scheduler);
     }
 
     return NULL;
@@ -399,9 +488,12 @@ AvahiHwInterface *avahi_hw_interface_new(AvahiInterfaceMonitor *m, AvahiIfIndex
 
     avahi_hashmap_insert(m->hashmap, &hw->index, hw);
 
-    if (m->server->fd_ipv4 >= 0 || m->server->config.publish_a_on_ipv6)
+    if ((m->server->mdns.fd_ipv4 >= 0 || m->server->llmnr.fd_ipv4 >= 0 ) ||
+        m->server->config.publish_a_on_ipv6)
         avahi_interface_new(m, hw, AVAHI_PROTO_INET);
-    if (m->server->fd_ipv6 >= 0 || m->server->config.publish_aaaa_on_ipv4)
+
+    if ((m->server->mdns.fd_ipv6 >= 0 || m->server->llmnr.fd_ipv6 >= 0 ) ||
+        m->server->config.publish_aaaa_on_ipv4)
         avahi_interface_new(m, hw, AVAHI_PROTO_INET6);
 
     return hw;
@@ -422,14 +514,15 @@ AvahiInterfaceAddress *avahi_interface_address_new(AvahiInterfaceMonitor *m, Ava
     a->prefix_len = prefix_len;
     a->global_scope = 0;
     a->deprecated = 0;
-    a->entry_group = NULL;
+    a->entry_mdns_group = NULL;
+    a->entry_llmnr_group = NULL;
 
     AVAHI_LLIST_PREPEND(AvahiInterfaceAddress, address, i->addresses, a);
 
     return a;
 }
 
-void avahi_interface_check_relevant(AvahiInterface *i) {
+void avahi_interface_check_relevant(AvahiInterface *i, AvahiPublishProtocol proto) {
     int b;
     AvahiInterfaceMonitor *m;
 
@@ -438,52 +531,71 @@ void avahi_interface_check_relevant(AvahiInterface *i) {
 
     b = avahi_interface_is_relevant(i);
 
-    if (m->list_complete && b && !i->announcing) {
-        interface_mdns_mcast_join(i, 1);
+    if (m->list_complete && b && (proto == AVAHI_MDNS ? (!i->mdns.announcing) : (!i->llmnr.verifying))) {
+        interface_mcast_join(i, 1, proto);
+
+        if ((proto == AVAHI_MDNS ? (i->mdns.mcast_joined) : (i->llmnr.llmnr_joined))) {
+            avahi_log_info("New relevant interface %s.%s for %s.", i->hardware->name, avahi_proto_to_string(i->protocol), proto == AVAHI_MDNS ? "mDNS" : "LLMNR");
 
-        if (i->mcast_joined) {
-            avahi_log_info("New relevant interface %s.%s for mDNS.", i->hardware->name, avahi_proto_to_string(i->protocol));
+            if (proto == AVAHI_MDNS) {
+                i->mdns.announcing = 1;
+                avahi_announce_interface(m->server, i);
+                avahi_multicast_lookup_engine_new_interface(m->server->mdns.multicast_lookup_engine, i);
 
-            i->announcing = 1;
-            avahi_announce_interface(m->server, i);
-            avahi_multicast_lookup_engine_new_interface(m->server->multicast_lookup_engine, i);
+            } else {
+                i->llmnr.verifying = 1;
+                avahi_verify_interface(m->server, i);
+                avahi_llmnr_lookup_engine_new_interface(m->server->llmnr.llmnr_lookup_engine, i);
+            }
         }
 
-    } else if (!b && i->announcing) {
-        avahi_log_info("Interface %s.%s no longer relevant for mDNS.", i->hardware->name, avahi_proto_to_string(i->protocol));
+    } else if (!b && ((proto == AVAHI_MDNS ? (i->mdns.announcing) : (i->llmnr.verifying)))) {
+        avahi_log_info("Interface %s.%s no longer relevant for %s.", i->hardware->name, avahi_proto_to_string(i->protocol), proto == AVAHI_MDNS ? "mDNS" : "LLMNR");
+        interface_mcast_join(i, 0, proto);
+
+        if (proto == AVAHI_MDNS) {
+            avahi_goodbye_interface(m->server, i, 0, 1);
+            avahi_querier_free_all(i);
+
+            avahi_response_scheduler_clear(i->mdns.response_scheduler);
+            avahi_query_scheduler_clear(i->mdns.query_scheduler);
+            avahi_probe_scheduler_clear(i->mdns.probe_scheduler);
+            avahi_cache_flush(i->mdns.cache);
 
-        interface_mdns_mcast_join(i, 0);
+            i->mdns.announcing = 0;
 
-        avahi_goodbye_interface(m->server, i, 0, 1);
-        avahi_querier_free_all(i);
+        } else {
+            assert(proto == AVAHI_LLMNR);
+            avahi_remove_interface_verifiers(m->server, i);
+            avahi_llmnr_queries_free(i);
 
-        avahi_response_scheduler_clear(i->response_scheduler);
-        avahi_query_scheduler_clear(i->query_scheduler);
-        avahi_probe_scheduler_clear(i->probe_scheduler);
-        avahi_cache_flush(i->cache);
+            avahi_llmnr_query_scheduler_clear(i->llmnr.query_scheduler);
+            avahi_llmnr_response_scheduler_clear(i->llmnr.response_scheduler);
 
-        i->announcing = 0;
+            avahi_llmnr_clear_cache(m->server->llmnr.llmnr_lookup_engine, i);
 
+            i->llmnr.verifying = 0;
+        }
     } else
-        interface_mdns_mcast_rejoin(i);
+        interface_mcast_rejoin(i, proto);
 }
 
-void avahi_hw_interface_check_relevant(AvahiHwInterface *hw) {
+void avahi_hw_interface_check_relevant(AvahiHwInterface *hw, AvahiPublishProtocol proto) {
     AvahiInterface *i;
 
     assert(hw);
 
     for (i = hw->interfaces; i; i = i->by_hardware_next)
-        avahi_interface_check_relevant(i);
+        avahi_interface_check_relevant(i, proto);
 }
 
-void avahi_interface_monitor_check_relevant(AvahiInterfaceMonitor *m) {
+void avahi_interface_monitor_check_relevant(AvahiInterfaceMonitor *m, AvahiPublishProtocol proto) {
     AvahiInterface *i;
 
     assert(m);
 
     for (i = m->interfaces; i; i = i->interface_next)
-        avahi_interface_check_relevant(i);
+        avahi_interface_check_relevant(i, proto);
 }
 
 AvahiInterfaceMonitor *avahi_interface_monitor_new(AvahiServer *s) {
@@ -565,83 +677,164 @@ AvahiInterfaceAddress* avahi_interface_monitor_get_address(AvahiInterfaceMonitor
     return NULL;
 }
 
-void avahi_interface_send_packet_unicast(AvahiInterface *i, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port) {
+void avahi_interface_send_packet_unicast(
+    AvahiInterface *i,
+    AvahiDnsPacket *p,
+    const AvahiAddress *a,
+    uint16_t port,
+    AvahiPublishProtocol proto) {
+
     assert(i);
     assert(p);
 
-    if (!i->announcing)
-        return;
+    if (proto == AVAHI_MDNS) {
+
+        if (!i->mdns.announcing)
+            return;
+
+        assert(!a || a->proto == i->protocol);
 
-    assert(!a || a->proto == i->protocol);
+        if (i->monitor->server->config.ratelimit_interval > 0) {
+            struct timeval now, end;
 
-    if (i->monitor->server->config.ratelimit_interval > 0) {
-        struct timeval now, end;
+            gettimeofday(&now, NULL);
 
-        gettimeofday(&now, NULL);
+            end = i->hardware->ratelimit_begin;
+            avahi_timeval_add(&end, i->monitor->server->config.ratelimit_interval);
 
-        end = i->hardware->ratelimit_begin;
-        avahi_timeval_add(&end, i->monitor->server->config.ratelimit_interval);
+            if (i->hardware->ratelimit_begin.tv_sec <= 0 ||
+                avahi_timeval_compare(&end, &now) < 0) {
 
-        if (i->hardware->ratelimit_begin.tv_sec <= 0 ||
-            avahi_timeval_compare(&end, &now) < 0) {
+                i->hardware->ratelimit_begin = now;
+                i->hardware->ratelimit_counter = 0;
+            }
+
+            if (i->hardware->ratelimit_counter > i->monitor->server->config.ratelimit_burst)
+                return;
 
-            i->hardware->ratelimit_begin = now;
-            i->hardware->ratelimit_counter = 0;
+            i->hardware->ratelimit_counter++;
         }
 
-        if (i->hardware->ratelimit_counter > i->monitor->server->config.ratelimit_burst)
+        if (i->protocol == AVAHI_PROTO_INET && i->monitor->server->mdns.fd_ipv4 >= 0)
+            avahi_send_dns_packet_ipv4(i->monitor->server->mdns.fd_ipv4, i->hardware->index, p, i->mdns.mcast_joined ? &i->mdns.local_mcast_address.data.ipv4 : NULL, a ? &a->data.ipv4 : NULL, port, proto);
+        else if (i->protocol == AVAHI_PROTO_INET6 && i->monitor->server->mdns.fd_ipv6 >= 0)
+            avahi_send_dns_packet_ipv6(i->monitor->server->mdns.fd_ipv6, i->hardware->index, p, i->mdns.mcast_joined ? &i->mdns.local_mcast_address.data.ipv6 : NULL, a ? &a->data.ipv6 : NULL, port, proto);
+
+    } else {
+
+        assert(proto == AVAHI_LLMNR);
+
+        if (!i->llmnr.verifying)
             return;
 
-        i->hardware->ratelimit_counter++;
-    }
+        assert(!a || a->proto == i->protocol);
+
+        if (i->monitor->server->config.ratelimit_interval > 0) {
+            struct timeval now, end;
+
+            gettimeofday(&now, NULL);
+
+            end = i->hardware->ratelimit_begin;
+            avahi_timeval_add(&end, i->monitor->server->config.ratelimit_interval);
+
+            if (i->hardware->ratelimit_begin.tv_sec <= 0 ||
+                avahi_timeval_compare(&end, &now) < 0) {
 
-    if (i->protocol == AVAHI_PROTO_INET && i->monitor->server->fd_ipv4 >= 0)
-        avahi_send_dns_packet_ipv4(i->monitor->server->fd_ipv4, i->hardware->index, p, i->mcast_joined ? &i->local_mcast_address.data.ipv4 : NULL, a ? &a->data.ipv4 : NULL, port);
-    else if (i->protocol == AVAHI_PROTO_INET6 && i->monitor->server->fd_ipv6 >= 0)
-        avahi_send_dns_packet_ipv6(i->monitor->server->fd_ipv6, i->hardware->index, p, i->mcast_joined ? &i->local_mcast_address.data.ipv6 : NULL, a ? &a->data.ipv6 : NULL, port);
+                i->hardware->ratelimit_begin = now;
+                i->hardware->ratelimit_counter = 0;
+            }
+
+            if (i->hardware->ratelimit_counter > i->monitor->server->config.ratelimit_burst)
+                return;
+
+            i->hardware->ratelimit_counter++;
+        }
+
+        if (i->protocol == AVAHI_PROTO_INET && i->monitor->server->llmnr.fd_ipv4 >= 0)
+            avahi_send_dns_packet_ipv4(i->monitor->server->llmnr.fd_ipv4, i->hardware->index, p,
+                                       i->llmnr.llmnr_joined ? &i->llmnr.local_llmnr_address.data.ipv4 : NULL,
+                                       a ? &a->data.ipv4 : NULL, port, proto);
+        else if (i->protocol == AVAHI_PROTO_INET6 && i->monitor->server->llmnr.fd_ipv6 >= 0)
+            avahi_send_dns_packet_ipv6(i->monitor->server->llmnr.fd_ipv6, i->hardware->index, p,
+                                       i->llmnr.llmnr_joined ? &i->llmnr.local_llmnr_address.data.ipv6 : NULL,
+                                       a ? &a->data.ipv6 : NULL, port, proto);
+    }
 }
 
-void avahi_interface_send_packet(AvahiInterface *i, AvahiDnsPacket *p) {
+void avahi_interface_send_packet(AvahiInterface *i, AvahiDnsPacket *p, AvahiPublishProtocol proto) {
     assert(i);
     assert(p);
 
-    avahi_interface_send_packet_unicast(i, p, NULL, 0);
+    avahi_interface_send_packet_unicast(i, p, NULL, 0, proto);
 }
 
 int avahi_interface_post_query(AvahiInterface *i, AvahiKey *key, int immediately, unsigned *ret_id) {
     assert(i);
     assert(key);
 
-    if (!i->announcing)
+    if (!i->mdns.announcing)
         return 0;
 
-    return avahi_query_scheduler_post(i->query_scheduler, key, immediately, ret_id);
+    return avahi_query_scheduler_post(i->mdns.query_scheduler, key, immediately, ret_id);
 }
 
 int avahi_interface_withraw_query(AvahiInterface *i, unsigned id) {
 
-    return avahi_query_scheduler_withdraw_by_id(i->query_scheduler, id);
+    return avahi_query_scheduler_withdraw_by_id(i->mdns.query_scheduler, id);
 }
 
 int avahi_interface_post_response(AvahiInterface *i, AvahiRecord *record, int flush_cache, const AvahiAddress *querier, int immediately) {
     assert(i);
     assert(record);
 
-    if (!i->announcing)
+    if (!i->mdns.announcing)
         return 0;
 
-    return avahi_response_scheduler_post(i->response_scheduler, record, flush_cache, querier, immediately);
+    return avahi_response_scheduler_post(i->mdns.response_scheduler, record, flush_cache, querier, immediately);
 }
 
+
 int avahi_interface_post_probe(AvahiInterface *i, AvahiRecord *record, int immediately) {
     assert(i);
     assert(record);
 
-    if (!i->announcing)
+    if (!i->mdns.announcing)
         return 0;
 
-    return avahi_probe_scheduler_post(i->probe_scheduler, record, immediately);
+    return avahi_probe_scheduler_post(i->mdns.probe_scheduler, record, immediately);
+}
+
+/* LLMNR */
+int avahi_interface_post_llmnr_query(AvahiInterface *i, AvahiLLMNRQuery *lq, int im) {
+    assert(i);
+    assert(lq);
+
+    if (!i->llmnr.verifying)
+        return 0;
+
+    /*lq object  post id will be filled by qj there only */
+    if (avahi_llmnr_query_scheduler_post(i->llmnr.query_scheduler, lq, im))
+        return 1;
+
+    return 0;
+}
+
+int avahi_interface_withdraw_llmnr_query(AvahiInterface *i, unsigned id) {
+    assert(i);
+
+    return (avahi_llmnr_query_scheduler_withdraw_by_id(i->llmnr.query_scheduler, id));
+}
+
+
+int avahi_schedule_llmnr_response_job(AvahiLLMNRResponseScheduler *s, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port) {
+    assert(s);
+    assert(p);
+    assert(a);
+    assert(port);
+
+    return avahi_post_llmnr_response(s, p, a, port);
 }
+/* /LLMNR */
 
 int avahi_dump_caches(AvahiInterfaceMonitor *m, AvahiDumpCallback callback, void* userdata) {
     AvahiInterface *i;
@@ -652,7 +845,7 @@ int avahi_dump_caches(AvahiInterfaceMonitor *m, AvahiDumpCallback callback, void
             char ln[256];
             snprintf(ln, sizeof(ln), ";;; INTERFACE %s.%s ;;;", i->hardware->name, avahi_proto_to_string(i->protocol));
             callback(ln, userdata);
-            if (avahi_cache_dump(i->cache, callback, userdata) < 0)
+            if (avahi_cache_dump(i->mdns.cache, callback, userdata) < 0)
                 return -1;
         }
     }
diff --git a/avahi-core/iface.h b/avahi-core/iface.h
index c3f24af..b8c188d 100644
--- a/avahi-core/iface.h
+++ b/avahi-core/iface.h
@@ -27,6 +27,7 @@ typedef struct AvahiHwInterface AvahiHwInterface;
 
 #include <avahi-common/llist.h>
 #include <avahi-common/address.h>
+#include <avahi-common/defs.h>
 
 #include "internal.h"
 #include "cache.h"
@@ -38,6 +39,12 @@ typedef struct AvahiHwInterface AvahiHwInterface;
 #include "browse.h"
 #include "querier.h"
 
+#include "llmnr-querier.h"
+#include "llmnr-query-sched.h"
+#include "llmnr-response.h"
+
+#include "verify.h"
+
 #ifdef HAVE_NETLINK
 #include "iface-linux.h"
 #elif defined(HAVE_PF_ROUTE)
@@ -100,21 +107,39 @@ struct AvahiInterface {
     AVAHI_LLIST_FIELDS(AvahiInterface, by_hardware);
 
     AvahiProtocol protocol;
-    int announcing;
-    AvahiAddress local_mcast_address;
-    int mcast_joined;
+    AVAHI_LLIST_HEAD(AvahiInterfaceAddress, addresses);
 
-    AvahiCache *cache;
+    struct {
+        int announcing;
+        AvahiAddress local_mcast_address;
+        int mcast_joined;
 
-    AvahiQueryScheduler *query_scheduler;
-    AvahiResponseScheduler * response_scheduler;
-    AvahiProbeScheduler *probe_scheduler;
+        AvahiCache *cache;
 
-    AVAHI_LLIST_HEAD(AvahiInterfaceAddress, addresses);
-    AVAHI_LLIST_HEAD(AvahiAnnouncer, announcers);
+        AvahiQueryScheduler *query_scheduler;
+        AvahiResponseScheduler * response_scheduler;
+        AvahiProbeScheduler *probe_scheduler;
+
+        AVAHI_LLIST_HEAD(AvahiAnnouncer, announcers);
+
+        AvahiHashmap *queriers_by_key;
+        AVAHI_LLIST_HEAD(AvahiQuerier, queriers);
+    } mdns;
 
-    AvahiHashmap *queriers_by_key;
-    AVAHI_LLIST_HEAD(AvahiQuerier, queriers);
+    struct {
+        int verifying;
+        AvahiAddress local_llmnr_address;
+        int llmnr_joined;
+
+        AvahiLLMNRQueryScheduler *query_scheduler;
+        AvahiLLMNRResponseScheduler *response_scheduler;
+
+        AvahiHashmap *queryjobs_by_key;
+
+        AVAHI_LLIST_HEAD(AvahiLLMNRQueryJob, queryjobs);
+        /*AVAHI_LLIST_HEAD(AvahiEntry, entries);*/
+        AVAHI_LLIST_HEAD(AvahiLLMNREntryVerify, verifiers);
+    } llmnr;
 };
 
 struct AvahiInterfaceAddress {
@@ -129,7 +154,8 @@ struct AvahiInterfaceAddress {
     int global_scope;
     int deprecated;
 
-    AvahiSEntryGroup *entry_group;
+    AvahiSEntryGroup *entry_mdns_group;
+    AvahiSEntryGroup *entry_llmnr_group;
 };
 
 AvahiInterfaceMonitor *avahi_interface_monitor_new(AvahiServer *server);
@@ -145,7 +171,7 @@ int avahi_dump_caches(AvahiInterfaceMonitor *m, AvahiDumpCallback callback, void
 
 void avahi_interface_monitor_update_rrs(AvahiInterfaceMonitor *m, int remove_rrs);
 int avahi_address_is_local(AvahiInterfaceMonitor *m, const AvahiAddress *a);
-void avahi_interface_monitor_check_relevant(AvahiInterfaceMonitor *m);
+void avahi_interface_monitor_check_relevant(AvahiInterfaceMonitor *m, AvahiPublishProtocol proto);
 
 /* AvahiHwInterface */
 
@@ -153,7 +179,7 @@ AvahiHwInterface *avahi_hw_interface_new(AvahiInterfaceMonitor *m, AvahiIfIndex
 void avahi_hw_interface_free(AvahiHwInterface *hw, int send_goodbye);
 
 void avahi_hw_interface_update_rrs(AvahiHwInterface *hw, int remove_rrs);
-void avahi_hw_interface_check_relevant(AvahiHwInterface *hw);
+void avahi_hw_interface_check_relevant(AvahiHwInterface *hw, AvahiPublishProtocol proto);
 
 AvahiHwInterface* avahi_interface_monitor_get_hw_interface(AvahiInterfaceMonitor *m, int idx);
 
@@ -163,17 +189,22 @@ AvahiInterface* avahi_interface_new(AvahiInterfaceMonitor *m, AvahiHwInterface *
 void avahi_interface_free(AvahiInterface *i, int send_goodbye);
 
 void avahi_interface_update_rrs(AvahiInterface *i, int remove_rrs);
-void avahi_interface_check_relevant(AvahiInterface *i);
+void avahi_interface_check_relevant(AvahiInterface *i, AvahiPublishProtocol proto);
 int avahi_interface_is_relevant(AvahiInterface *i);
 
-void avahi_interface_send_packet(AvahiInterface *i, AvahiDnsPacket *p);
-void avahi_interface_send_packet_unicast(AvahiInterface *i, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port);
-
+void avahi_interface_send_packet(AvahiInterface *i, AvahiDnsPacket *p, AvahiPublishProtocol proto);
+void avahi_interface_send_packet_unicast(AvahiInterface *i, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port, AvahiPublishProtocol proto);
 int avahi_interface_post_query(AvahiInterface *i, AvahiKey *k, int immediately, unsigned *ret_id);
 int avahi_interface_withraw_query(AvahiInterface *i, unsigned id);
 int avahi_interface_post_response(AvahiInterface *i, AvahiRecord *record, int flush_cache, const AvahiAddress *querier, int immediately);
 int avahi_interface_post_probe(AvahiInterface *i, AvahiRecord *p, int immediately);
 
+/*LLMNR*/
+int avahi_schedule_llmnr_response_job(AvahiLLMNRResponseScheduler *s, AvahiDnsPacket *p, const AvahiAddress *querier, uint16_t port);
+int avahi_interface_post_llmnr_query(AvahiInterface *i, AvahiLLMNRQuery *lq, int im);
+int avahi_interface_withdraw_llmnr_query(AvahiInterface *i, unsigned id);
+/* /LLMNR */
+
 int avahi_interface_match(AvahiInterface *i, AvahiIfIndex idx, AvahiProtocol protocol);
 int avahi_interface_address_on_link(AvahiInterface *i, const AvahiAddress *a);
 int avahi_interface_has_address(AvahiInterfaceMonitor *m, AvahiIfIndex iface, const AvahiAddress *a);
diff --git a/avahi-core/internal.h b/avahi-core/internal.h
index b8f9302..a3713b4 100644
--- a/avahi-core/internal.h
+++ b/avahi-core/internal.h
@@ -40,6 +40,10 @@ typedef struct AvahiEntry AvahiEntry;
 #include "multicast-lookup.h"
 #include "dns-srv-rr.h"
 
+#include "llmnr-querier.h"
+#include "verify.h"
+#include "llmnr-lookup.h"
+
 #define AVAHI_LEGACY_UNICAST_REFLECT_SLOTS_MAX 100
 
 #define AVAHI_FLAGS_VALID(flags, max) (!((flags) & ~(max)))
@@ -61,6 +65,11 @@ struct AvahiLegacyUnicastReflectSlot {
     AvahiTimeEvent *time_event;
 };
 
+typedef enum {
+    AVAHI_ENTRY_MDNS,
+    AVAHI_ENTRY_LLMNR
+} AvahiEntryType;
+
 struct AvahiEntry {
     AvahiServer *server;
     AvahiSEntryGroup *group;
@@ -76,9 +85,27 @@ struct AvahiEntry {
     AVAHI_LLIST_FIELDS(AvahiEntry, by_key);
     AVAHI_LLIST_FIELDS(AvahiEntry, by_group);
 
-    AVAHI_LLIST_HEAD(AvahiAnnouncer, announcers);
+    /* Type to decide whether an mDNS entry of LLMNR */
+    AvahiEntryType type;
+
+    union {
+        struct {
+            AVAHI_LLIST_HEAD(AvahiAnnouncer, announcers);
+        } mdns;
+
+        struct {
+            AVAHI_LLIST_HEAD(AvahiLLMNREntryVerify, verifiers);
+        } llmnr;
+    } proto;
 };
 
+
+typedef enum {
+    AVAHI_GROUP_UNSET,
+    AVAHI_GROUP_MDNS,
+    AVAHI_GROUP_LLMNR
+} AvahiSEntryGroupType;
+
 struct AvahiSEntryGroup {
     AvahiServer *server;
     int dead;
@@ -87,13 +114,22 @@ struct AvahiSEntryGroup {
     void* userdata;
     AvahiSEntryGroupCallback callback;
 
-    unsigned n_probing;
+    AvahiSEntryGroupType type;
+    union {
+        struct {
+            unsigned n_probing;
+            unsigned n_register_try;
 
-    unsigned n_register_try;
-    struct timeval register_time;
-    AvahiTimeEvent *register_time_event;
+            struct timeval register_time;
+            AvahiTimeEvent *register_time_event;
+            struct timeval established_at;
+        } mdns;
 
-    struct timeval established_at;
+        struct {
+            unsigned n_verifying;
+            unsigned n_entries;
+        } llmnr;
+    } proto;
 
     AVAHI_LLIST_FIELDS(AvahiSEntryGroup, groups);
     AVAHI_LLIST_HEAD(AvahiEntry, entries);
@@ -105,10 +141,51 @@ struct AvahiServer {
     AvahiInterfaceMonitor *monitor;
     AvahiServerConfig config;
 
-    AVAHI_LLIST_HEAD(AvahiEntry, entries);
-    AvahiHashmap *entries_by_key;
+    struct {
+        /* mDNS entries and groups */
+        AVAHI_LLIST_HEAD(AvahiEntry, entries);
+        AvahiHashmap *entries_by_key;
+        AVAHI_LLIST_HEAD(AvahiSEntryGroup, groups);
+        int need_entry_cleanup, need_group_cleanup;
+
+        /*mDNS sockets and watch objects */
+        int fd_ipv4, fd_ipv6,
+        /* The following two sockets two are used for reflection only */
+        fd_legacy_unicast_ipv4, fd_legacy_unicast_ipv6;
+
+        AvahiWatch *watch_ipv4, *watch_ipv6,
+        *watch_legacy_unicast_ipv4, *watch_legacy_unicast_ipv6;
+
+        /* mDNS record list to assemble responses*/
+        AvahiRecordList *record_list;
 
-    AVAHI_LLIST_HEAD(AvahiSEntryGroup, groups);
+        AvahiSEntryGroup *hinfo_entry_group;
+        AvahiSEntryGroup *browse_domain_entry_group;
+
+        AvahiMulticastLookupEngine *multicast_lookup_engine;
+    } mdns;
+
+    struct {
+        /* LLMNR entries and groups */
+        AVAHI_LLIST_HEAD(AvahiEntry, entries);
+        AvahiHashmap *entries_by_key;
+        AVAHI_LLIST_HEAD(AvahiSEntryGroup, groups);
+        int need_entry_cleanup, need_group_cleanup;
+
+        /* LLMNR sockets and watch objects */
+        int fd_ipv4, fd_ipv6;
+        AvahiWatch *watch_ipv4, *watch_ipv6;
+
+        /* LLMNR record list to assemble LLMNR responses */
+        AvahiRecordList *record_list;
+
+        AvahiLLMNRLookupEngine *llmnr_lookup_engine;
+
+    } llmnr;
+
+    struct {
+        AvahiWideAreaLookupEngine *wide_area_lookup_engine;
+    } wide_area;
 
     AVAHI_LLIST_HEAD(AvahiSRecordBrowser, record_browsers);
     AvahiHashmap *record_browser_hashmap;
@@ -120,7 +197,7 @@ struct AvahiServer {
     AVAHI_LLIST_HEAD(AvahiSServiceResolver, service_resolvers);
     AVAHI_LLIST_HEAD(AvahiSDNSServerBrowser, dns_server_browsers);
 
-    int need_entry_cleanup, need_group_cleanup, need_browser_cleanup;
+    int need_browser_cleanup;
 
     /* Used for scheduling RR cleanup */
     AvahiTimeEvent *cleanup_time_event;
@@ -129,24 +206,12 @@ struct AvahiServer {
 
     char *host_name, *host_name_fqdn, *domain_name;
 
-    int fd_ipv4, fd_ipv6,
-        /* The following two sockets two are used for reflection only */
-        fd_legacy_unicast_ipv4, fd_legacy_unicast_ipv6;
-
-    AvahiWatch *watch_ipv4, *watch_ipv6,
-        *watch_legacy_unicast_ipv4, *watch_legacy_unicast_ipv6;
-
     AvahiServerState state;
     AvahiServerCallback callback;
     void* userdata;
 
-    AvahiSEntryGroup *hinfo_entry_group;
-    AvahiSEntryGroup *browse_domain_entry_group;
     unsigned n_host_rr_pending;
 
-    /* Used for assembling responses */
-    AvahiRecordList *record_list;
-
     /* Used for reflection of legacy unicast packets */
     AvahiLegacyUnicastReflectSlot **legacy_unicast_reflect_slots;
     uint16_t legacy_unicast_reflect_id;
@@ -157,8 +222,6 @@ struct AvahiServer {
     /* The local service cookie */
     uint32_t local_service_cookie;
 
-    AvahiMulticastLookupEngine *multicast_lookup_engine;
-    AvahiWideAreaLookupEngine *wide_area_lookup_engine;
 };
 
 void avahi_entry_free(AvahiServer*s, AvahiEntry *e);
diff --git a/avahi-core/llmnr-lookup.c b/avahi-core/llmnr-lookup.c
new file mode 100644
index 0000000..cfef0db
--- /dev/null
+++ b/avahi-core/llmnr-lookup.c
@@ -0,0 +1,492 @@
+#include <stdlib.h>
+
+#include <avahi-common/malloc.h>
+#include <avahi-common/timeval.h>
+#include <avahi-common/defs.h>
+#include <avahi-common/error.h>
+
+#include "internal.h"
+#include "browse.h"
+#include "socket.h"
+#include "log.h"
+#include "hashmap.h"
+#include "rr-util.h"
+
+#include "llmnr-lookup.h"
+
+/* Lookups Function */
+
+/* AvahiLLMNRQuery Callback */
+static void query_callback (AvahiIfIndex idx, AvahiProtocol protocol, AvahiRecord *r, void *userdata);
+
+static void elapse_timeout_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata);
+
+/* New lookup */
+AvahiLLMNRLookup* avahi_llmnr_lookup_new(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex interface,
+    AvahiProtocol protocol,
+    AvahiKey *key,
+    AvahiLLMNRLookupCallback callback,
+    void *userdata) {
+
+    struct timeval tv;
+    AvahiLLMNRLookup *l, *t;
+
+    assert(e);
+    assert(AVAHI_IF_VALID(interface));
+    assert(AVAHI_PROTO_VALID(protocol));
+    assert(key);
+    assert(callback);
+
+    if (!(l = avahi_new(AvahiLLMNRLookup, 1)))
+        return NULL;
+
+    /* Initialize parameters */
+    l->engine = e;
+    l->dead = 0;
+    l->key = avahi_key_ref(key);
+    /* TODO*/
+    l->cname_key =  avahi_key_new_cname(l->key);
+    l->interface = interface;
+    l->protocol = protocol;
+    l->callback = callback;
+    l->userdata = userdata;
+    l->queries_issued = 0;
+    l->time_event = NULL;
+
+    /* Prepend in list */
+    AVAHI_LLIST_PREPEND(AvahiLLMNRLookup, lookups, e->lookups, l);
+
+    /* In hashmap */
+    t = avahi_hashmap_lookup(e->lookups_by_key, key);
+    AVAHI_LLIST_PREPEND(AvahiLLMNRLookup, by_key, t, l);
+    avahi_hashmap_replace(e->lookups_by_key, avahi_key_ref(key), t);
+
+    /* Issue LLMNR Queries on all interfaces that match the id and protocol*/
+    avahi_llmnr_query_add_for_all(e->s, interface, protocol, key, query_callback, l);
+    l->queries_issued = 1;
+
+    /* All queries are issued right now. To the max we get response from each interface maximum
+    after 3 seconds (3 queries). still we keep it 4 seconds .AVAHI_BROWSER_ALL_FOR_NOW event */
+    gettimeofday(&tv, NULL);
+    avahi_timeval_add(&tv, 4000000);
+
+    l->time_event = avahi_time_event_new(e->s->time_event_queue, &tv, elapse_timeout_callback, l);
+
+    return l;
+}
+
+/* Stop lookup */
+static void lookup_stop(AvahiLLMNRLookup *l) {
+    assert(l);
+
+    l->callback = NULL;
+
+    if (l->queries_issued) {
+        avahi_llmnr_query_remove_for_all(l->engine->s, l->interface, l->protocol, l->key);
+        l->queries_issued = 0;
+    }
+
+    if (l->time_event) {
+        avahi_time_event_free(l->time_event);
+        l->time_event = NULL;
+    }
+}
+
+/* Destroy Lookup */
+static void lookup_destroy(AvahiLLMNRLookup *l) {
+    AvahiLLMNRLookup *t;
+    assert(l);
+
+    lookup_stop(l);
+
+    t = avahi_hashmap_lookup(l->engine->lookups_by_key, l->key);
+    AVAHI_LLIST_REMOVE(AvahiLLMNRLookup, by_key, t, l);
+
+    if (t)
+        avahi_hashmap_replace(l->engine->lookups_by_key, avahi_key_ref(l->key), t);
+    else
+        avahi_hashmap_remove(l->engine->lookups_by_key, l->key);
+
+    AVAHI_LLIST_REMOVE(AvahiLLMNRLookup, lookups, l->engine->lookups, l);
+
+    if (l->key)
+        avahi_key_unref(l->key);
+
+
+    /* What this CNAME key is for? :( */
+    if (l->cname_key)
+        avahi_key_unref(l->cname_key);
+
+    avahi_free(l);
+}
+
+/* Free lookup (and stop) */
+void avahi_llmnr_lookup_free(AvahiLLMNRLookup *l) {
+    assert(l);
+
+    if (l->dead)
+        return;
+
+    l->dead = 1;
+    l->engine->cleanup_dead = 1;
+    lookup_stop(l);
+}
+
+static void elapse_timeout_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
+    AvahiLLMNRLookup *l = userdata;
+
+    l->callback(l->engine, l->interface, l->protocol, AVAHI_BROWSER_ALL_FOR_NOW, AVAHI_LOOKUP_RESULT_LLMNR, NULL, l->userdata);
+
+    if (l->time_event) {
+        avahi_time_event_free(l->time_event);
+        l->time_event = NULL;
+    }
+
+    lookup_stop(l);
+
+    return;
+}
+
+/* Cache Functions */
+
+/* Run callbacks for all lookups belong to e and were issued for r->key, idx and proto */
+static void run_callbacks(AvahiLLMNRLookupEngine *e, AvahiIfIndex idx, AvahiProtocol proto, AvahiRecord *r, AvahiBrowserEvent event) {
+    AvahiLLMNRLookup *l;
+
+    assert(e);
+    assert(r);
+
+
+    for (l = avahi_hashmap_lookup(e->lookups_by_key, r->key); l; l = l->by_key_next)
+        if ( !(l->dead) &&
+            (l->callback) &&
+            /* lookups can have UNSPEC iface or protocol */
+            (l->interface < 0 || (l->interface == idx)) &&
+            (l->protocol < 0 || (l->protocol == proto)) )
+
+            /* Call callback funtion */
+            l->callback(e, idx, proto, event, AVAHI_LOOKUP_RESULT_LLMNR, r, l->userdata);
+
+
+    if (r->key->clazz == AVAHI_DNS_CLASS_IN && r->key->type == AVAHI_DNS_TYPE_CNAME) {
+
+        for (l = e->lookups; l; l = l->lookups_next) {
+            AvahiKey *key;
+
+            if (l->dead || !l->callback)
+                continue;
+
+            if ((key = avahi_key_new_cname(l->key))) {
+
+                if (avahi_key_equal(r->key, key) &&
+                    (l->interface < 0 || l->interface == idx) &&
+                    (l->protocol < 0 || l->protocol == proto) )
+                    /* Call callback */
+                    l->callback(e, idx, proto, AVAHI_BROWSER_NEW, AVAHI_LOOKUP_RESULT_LLMNR, r, l->userdata);
+                avahi_key_unref(key);
+            }
+        }
+    }
+}
+
+/* find cache entry (idx, protocol, r)*/
+static AvahiLLMNRCacheEntry *find_cache_entry(AvahiLLMNRLookupEngine *e, AvahiIfIndex idx, AvahiProtocol protocol, AvahiRecord *r) {
+    AvahiLLMNRCacheEntry *c;
+
+    assert(e);
+    assert(r);
+
+    assert(idx != AVAHI_IF_UNSPEC);
+    assert(protocol != AVAHI_PROTO_UNSPEC);
+
+    for (c = avahi_hashmap_lookup(e->cache_by_key, r->key); c; c = c->cache_next) {
+
+        if ( (c->interface == idx) &&
+            (c->protocol == protocol) &&
+            avahi_record_equal_no_ttl(c->record, r) )
+
+            return c;
+    }
+
+    return NULL;
+}
+
+/* remove/destroy cache entry */
+static void destroy_cache_entry(AvahiLLMNRCacheEntry *c) {
+
+    AvahiLLMNRCacheEntry *t;
+    assert(c);
+
+    if (c->time_event)
+        avahi_time_event_free(c->time_event);
+
+    AVAHI_LLIST_REMOVE(AvahiLLMNRCacheEntry, cache, c->engine->cache, c);
+
+    t = avahi_hashmap_lookup(c->engine->cache_by_key, c->record->key);
+    AVAHI_LLIST_REMOVE(AvahiLLMNRCacheEntry, by_key, t, c);
+    if (t)
+        avahi_hashmap_replace(c->engine->cache_by_key, avahi_key_ref(c->record->key), t);
+    else
+        avahi_hashmap_remove(c->engine->cache_by_key, c->record->key);
+
+    /* Run callbacks that entry has been deleted */
+    /* run_callbacks(c->engine, c->interface, c->protocol, c->record, AVAHI_BROWSER_REMOVE); */
+
+    assert(c->engine->n_cache_entries > 0);
+    c->engine->n_cache_entries--;
+
+    avahi_record_unref(c->record);
+
+    avahi_free(c);
+}
+
+/* callback funtion when cache entry timeout reaches */
+static void cache_entry_timeout(AvahiTimeEvent *e, void *userdata) {
+    AvahiLLMNRCacheEntry *c = userdata;
+
+    assert(e);
+    assert(c);
+
+    destroy_cache_entry(c);
+}
+
+/* Update cache */
+static void update_cache(AvahiLLMNRLookupEngine *e, AvahiIfIndex idx, AvahiProtocol protocol, AvahiRecord *r) {
+    AvahiLLMNRCacheEntry *c;
+    int new = 1;
+
+    assert(e);
+    assert(r);
+
+    if ((c = find_cache_entry(e, idx, protocol, r))) {
+/*        new = 0;*/
+
+        /* Update the existine entry. Remove c->record
+        point c->record to r*/
+        avahi_record_unref(c->record);
+    } else {
+        AvahiLLMNRCacheEntry *t;
+
+/*        new = 1;*/
+
+        /* Check for the cache limit */
+        if (e->n_cache_entries >= LLMNR_CACHE_ENTRIES_MAX)
+            goto finish;
+
+        c = avahi_new(AvahiLLMNRCacheEntry, 1);
+        c->engine = e;
+        c->interface = idx;
+        c->protocol = protocol;
+        c->time_event = NULL;
+
+        AVAHI_LLIST_PREPEND(AvahiLLMNRCacheEntry, cache, e->cache, c);
+
+        t = avahi_hashmap_lookup(e->cache_by_key, r->key);
+        AVAHI_LLIST_PREPEND(AvahiLLMNRCacheEntry, by_key, t, c);
+        avahi_hashmap_replace(e->cache_by_key, avahi_key_ref(r->key), t);
+
+        e->n_cache_entries++;
+    }
+
+    /* Now update record */
+    c->record = avahi_record_ref(r);
+
+    /* Scedule the expiry time of this CacheEntry */
+    gettimeofday(&c->timestamp, NULL);
+    c->expiry = c->timestamp;
+    avahi_timeval_add(&c->expiry, r->ttl * 1000000);
+
+    if (c->time_event)
+        avahi_time_event_update(c->time_event, &c->expiry);
+    else
+        c->time_event = avahi_time_event_new(e->s->time_event_queue, &c->expiry, cache_entry_timeout, c);
+
+    finish:
+    if (new)
+        /* Whether the record is new or old we run callbacks for every update */
+        run_callbacks(e, idx, protocol, r, AVAHI_BROWSER_NEW);
+}
+
+/* Define callback function */
+static void query_callback(
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiRecord *r,
+    void *userdata) {
+
+    AvahiLLMNRLookup *lookup = userdata;
+    assert(AVAHI_IF_VALID(idx) && idx != -1);
+    assert(AVAHI_PROTO_VALID(protocol) && (protocol != AVAHI_PROTO_UNSPEC));
+
+    if (r)
+        /* Update cache */
+        update_cache(lookup->engine, idx, protocol, r);
+    /*else
+        This query was issued by 'lookup'. So call lookup->callback specifying that
+        on specified interface and protocol we have no records available
+        lookup->callback(lookup->engine, idx, protocol, AVAHI_BROWSER_FAILURE, AVAHI_LOOKUP_RESULT_LLMNR, NULL, lookup->userdata); */
+
+    /* We can't stop the lookup right away because we may have some more responses coming
+    up from more interfaces */
+    return;
+}
+
+/* Scan LLMNR cache */
+unsigned avahi_scan_llmnr_cache(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiKey *key,
+    AvahiLLMNRLookupCallback callback,
+    void *userdata) {
+
+    AvahiLLMNRCacheEntry *c;
+    AvahiKey *cname_key;
+    unsigned n = 0;
+
+    assert(e);
+    assert(key);
+    assert(callback);
+
+    assert(AVAHI_IF_VALID(idx));
+    assert(AVAHI_PROTO_VALID(protocol));
+
+    for (c = avahi_hashmap_lookup(e->cache_by_key, key); c; c = c->by_key_next)
+        if (((idx < 0) || (c->interface == idx)) &&
+            ((protocol < 0) || (c->protocol == protocol)) ) {
+                /* Call Callback Function */
+                callback(e,
+                         c->interface,
+                         c->protocol,
+                         AVAHI_BROWSER_NEW,
+                         AVAHI_LOOKUP_RESULT_CACHED | AVAHI_LOOKUP_RESULT_LLMNR,
+                         c->record,
+                         userdata);
+                /* Increase 'n'*/
+                n++;
+        }
+
+    if ((cname_key = avahi_key_new_cname(key))) {
+
+        for (c = avahi_hashmap_lookup(e->cache_by_key, cname_key); c; c = c->by_key_next)
+            if ( ( (idx < 0) || (c->interface == idx) ) &&
+             ( (protocol < 0) || (c->protocol == protocol) )) {
+                callback(e, c->interface, c->protocol, AVAHI_BROWSER_NEW, AVAHI_LOOKUP_RESULT_CACHED | AVAHI_LOOKUP_RESULT_LLMNR, c->record, userdata);
+                n++;
+        }
+
+        avahi_key_unref(cname_key);
+    }
+
+    return n;
+}
+
+/* Clear all cache entries belong to this interface */
+void avahi_llmnr_clear_cache(AvahiLLMNRLookupEngine *e, AvahiInterface *i) {
+    AvahiLLMNRCacheEntry *c;
+
+    assert(e);
+    assert(i);
+
+    for (c = e->cache; c; c = c->cache_next)
+        if (avahi_interface_match(i, c->interface, c->protocol))
+            /*Destroy this cache entry  */
+            destroy_cache_entry(c);
+}
+
+/* Cache dump */
+void avahi_llmnr_cache_dump(AvahiLLMNRLookupEngine *e, AvahiDumpCallback callback, void *userdata) {
+    AvahiLLMNRCacheEntry *c;
+
+    assert(e);
+    assert(callback);
+
+    callback(";;; LLMNR CACHE ;;;", userdata);
+
+    for (c = e->cache; c; c = c->cache_next) {
+        if (avahi_interface_is_relevant(avahi_interface_monitor_get_interface(c->engine->s->monitor, c->interface, c->protocol))) {
+            char *t = avahi_record_to_string(c->record);
+            callback(t, userdata);
+            avahi_free(t);
+        }
+    }
+}
+
+/* LLMNRLookupEngine functions */
+void avahi_llmnr_lookup_engine_cleanup(AvahiLLMNRLookupEngine *e) {
+    AvahiLLMNRLookup *l, *n;
+    assert(e);
+
+    while (e->cleanup_dead) {
+        e->cleanup_dead = 0;
+
+        for (l = e->lookups; l; l = n) {
+            n = l->lookups_next;
+
+            if (l->dead)
+                lookup_destroy(l);
+        }
+    }
+}
+
+/* The interface is new so issue query for all lookups those are not dead */
+void avahi_llmnr_lookup_engine_new_interface(AvahiLLMNRLookupEngine *e, AvahiInterface *i) {
+    AvahiLLMNRLookup *l;
+
+    assert(e);
+    assert(i);
+    for (l = e->lookups; l; l = l->lookups_next) {
+
+        if (l->dead || !l->callback)
+            continue;
+
+        if (l->queries_issued && avahi_interface_match(i, l->interface, l->protocol))
+            /* Issue LLMNR query */
+            avahi_llmnr_query_add(i, l->key, AVAHI_LLMNR_SIMPLE_QUERY, query_callback, l);
+    }
+}
+
+/* New lookup engine */
+AvahiLLMNRLookupEngine* avahi_llmnr_lookup_engine_new(AvahiServer *s) {
+    AvahiLLMNRLookupEngine *e;
+
+    assert(s);
+
+    e = avahi_new(AvahiLLMNRLookupEngine, 1);
+    e->s = s;
+    e->next_id = 0;
+    e->cleanup_dead = 0;
+    e->n_cache_entries = 0;
+
+    /* Queries and lookups */
+    e->lookups_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, (AvahiFreeFunc) avahi_key_unref, NULL);
+    e->queries_by_id = avahi_hashmap_new((AvahiHashFunc) avahi_int_hash, (AvahiEqualFunc) avahi_int_equal, NULL, NULL);
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNRLookup, e->lookups);
+
+    /* Cache*/
+    e->cache_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, (AvahiFreeFunc) avahi_key_unref, NULL);
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNRCacheEntry, e->cache);
+
+    return e;
+}
+
+void avahi_llmnr_lookup_engine_free(AvahiLLMNRLookupEngine *e) {
+    assert(e);
+
+    while (e->cache)
+        destroy_cache_entry(e->cache);
+
+    while (e->lookups)
+        lookup_destroy(e->lookups);
+
+    assert(e->n_cache_entries == 0);
+
+    /* Clear all hashmap's*/
+    avahi_hashmap_free(e->lookups_by_key);
+    avahi_hashmap_free(e->queries_by_id);
+    avahi_hashmap_free(e->cache_by_key);
+
+    avahi_free(e);
+}
diff --git a/avahi-core/llmnr-lookup.h b/avahi-core/llmnr-lookup.h
new file mode 100644
index 0000000..3fd417e
--- /dev/null
+++ b/avahi-core/llmnr-lookup.h
@@ -0,0 +1,127 @@
+#ifndef foollmnrlookuphbar
+#define foollmnrlookuphbar
+
+#include <avahi-common/llist.h>
+#include <avahi-common/address.h>
+
+#include "hashmap.h"
+#include "lookup.h"
+#include "rr.h"
+
+#include "llmnr-querier.h"
+
+#define LLMNR_CACHE_ENTRIES_MAX 500
+
+typedef struct AvahiLLMNRLookup AvahiLLMNRLookup;
+typedef struct AvahiLLMNRLookupEngine AvahiLLMNRLookupEngine;
+typedef struct AvahiLLMNRCacheEntry AvahiLLMNRCacheEntry;
+
+/* AvahiLLMNRLookup callback prototype */
+typedef void (*AvahiLLMNRLookupCallback)(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiBrowserEvent event,
+    AvahiLookupResultFlags flags,
+    AvahiRecord *r,
+    void *userdata);
+
+/* LLMNR Cache entry */
+struct AvahiLLMNRCacheEntry {
+    AvahiLLMNRLookupEngine *engine;
+
+    /* interface and protocol can't be
+    AVAHI_IF_UNSPEC and AVAHI_PROTO_UNSPEC resp.*/
+    AvahiIfIndex interface;
+    AvahiProtocol protocol;
+
+    AvahiRecord *record;
+
+    struct timeval timestamp;
+    struct timeval expiry;
+
+    AvahiTimeEvent *time_event;
+
+    AVAHI_LLIST_FIELDS(AvahiLLMNRCacheEntry, by_key);
+    AVAHI_LLIST_FIELDS(AvahiLLMNRCacheEntry, cache);
+};
+
+/* LLMNR Lookup object */
+struct AvahiLLMNRLookup {
+    AvahiLLMNRLookupEngine *engine;
+    int dead;
+
+    AvahiKey *key, *cname_key;
+    AvahiTimeEvent *time_event;
+
+    AvahiIfIndex interface;
+    AvahiProtocol protocol;
+
+    AvahiLLMNRLookupCallback callback;
+    void *userdata;
+
+    AVAHI_LLIST_FIELDS(AvahiLLMNRLookup, lookups);
+    AVAHI_LLIST_FIELDS(AvahiLLMNRLookup, by_key);
+
+    int queries_issued;
+
+    AVAHI_LLIST_HEAD(AvahiLLMNRQuery, queries);
+};
+
+
+/* LLMNR lookup engine */
+struct AvahiLLMNRLookupEngine {
+    AvahiServer *s;
+
+    /* For 'AvahiLLMNRQuery' object*/
+    uint16_t next_id;
+
+    /*lookups and queries */
+    AVAHI_LLIST_HEAD(AvahiLLMNRLookup, lookups);
+    AvahiHashmap *lookups_by_key;
+    AvahiHashmap *queries_by_id;
+
+    /* Cache */
+    AVAHI_LLIST_HEAD(AvahiLLMNRCacheEntry, cache);
+    AvahiHashmap *cache_by_key;
+    unsigned n_cache_entries;
+
+    int cleanup_dead;
+};
+
+/*** Engine functions ***/
+
+AvahiLLMNRLookupEngine* avahi_llmnr_lookup_engine_new(AvahiServer *sl);
+void avahi_llmnr_lookup_engine_free(AvahiLLMNRLookupEngine *e);
+void avahi_llmnr_lookup_engine_cleanup(AvahiLLMNRLookupEngine *e);
+
+/* when new interface come up, call this function to issue queries */
+void avahi_llmnr_lookup_engine_new_interface(AvahiLLMNRLookupEngine *e, AvahiInterface *i);
+
+/* remove all cache entries from this interface */
+void avahi_llmnr_clear_cache(AvahiLLMNRLookupEngine *e, AvahiInterface *i);
+
+/*** AvahiLLMNRLookup functions ***/
+
+AvahiLLMNRLookup* avahi_llmnr_lookup_new(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex interface,
+    AvahiProtocol protocol,
+    AvahiKey *key,
+    AvahiLLMNRLookupCallback callback,
+    void *userdata);
+
+void avahi_llmnr_lookup_free(AvahiLLMNRLookup *l);
+
+/*** Cache functions ***/
+void avahi_llmnr_cache_dump(AvahiLLMNRLookupEngine *e, AvahiDumpCallback callback, void *userdata);
+
+unsigned avahi_scan_llmnr_cache(
+    AvahiLLMNRLookupEngine *e,
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiKey *key,
+    AvahiLLMNRLookupCallback callback,
+    void *userdata
+);
+#endif /* foollmnrlookuphbar */
diff --git a/avahi-core/llmnr-querier.c b/avahi-core/llmnr-querier.c
new file mode 100644
index 0000000..b396da7
--- /dev/null
+++ b/avahi-core/llmnr-querier.c
@@ -0,0 +1,196 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <avahi-common/malloc.h>
+#include <avahi-common/timeval.h>
+#include <avahi-common/error.h>
+#include <avahi-common/domain.h>
+
+#include "log.h"
+
+#include "llmnr-querier.h"
+#include "llmnr-query-sched.h"
+#include "llmnr-lookup.h"
+
+static AvahiLLMNRQuery* find_query(AvahiLLMNRLookupEngine *e, uint16_t id) {
+    AvahiLLMNRQuery *lq;
+    /* Convert to 32 bit integer*/
+    uint32_t i = (uint32_t) id;
+
+    assert(e);
+
+    if (!(lq = avahi_hashmap_lookup(e->queries_by_id, &i)))
+        return NULL;
+
+    assert(lq->id == id);
+
+    if (lq->dead)
+        return NULL;
+
+    return lq;
+}
+
+AvahiLLMNRQuery* avahi_llmnr_query_add(AvahiInterface *i, AvahiKey *key, AvahiLLMNRQueryType type, AvahiLLMNRQueryCallback callback, void *userdata) {
+    AvahiLLMNRQuery *lq;
+    int c;
+
+    /* Engine maintains a hashmap of 'AvahiLLMNRQuery' objects by id */
+    AvahiLLMNRLookupEngine *e = i->monitor->server->llmnr.llmnr_lookup_engine;
+
+    assert(i);
+    assert(key);
+    assert(callback);
+
+    if (!(lq = avahi_new(AvahiLLMNRQuery, 1)))
+        return NULL;
+
+    /* Initialize parameters */
+    lq->dead = 0;
+    lq->key = avahi_key_ref(key);
+    lq->type = type;
+    lq->interface = i;
+    lq->callback = callback;
+    lq->post_id_valid = 0;
+    lq->post_id = 0;
+    lq->userdata = userdata;
+
+    /* Initialize record lists for this query object */
+    lq->c_bit_set = avahi_record_list_new();
+    lq->c_bit_clear = avahi_record_list_new();
+
+    c = avahi_record_list_is_empty(lq->c_bit_set);
+    assert(c);
+    assert(lq->c_bit_clear);
+
+    /* Set ID */
+    /* KEEP IT 32 BIT for HASHMAP */
+    for (;; e->next_id++)
+        if (!(find_query(e, e->next_id)))
+            break;
+
+    lq->id = e->next_id++;
+
+    /* AvahiLLMNRLookupEngine hashmap of queries by ID,
+    'engine-AvahiLLMNRQuery'. (lq->id and lq) */
+    avahi_hashmap_insert(e->queries_by_id, &(lq->id), lq);
+
+    /* Schedule this LLMNR query. This will create an
+    'AvahiLLMNRQueryJob' for this query and will issue
+    further queries there only. im0 */
+    if (!avahi_interface_post_llmnr_query(i, lq, 0))
+        return NULL;
+
+    return lq;
+
+}
+
+void avahi_llmnr_query_destroy(AvahiLLMNRQuery *lq) {
+    AvahiLLMNRLookupEngine *e;
+    e = lq->interface->monitor->server->llmnr.llmnr_lookup_engine;
+
+    assert(lq);
+
+    avahi_hashmap_remove(e->queries_by_id, &(lq->id));
+
+    avahi_key_unref(lq->key);
+    avahi_free(lq);
+
+    return;
+}
+
+void avahi_llmnr_query_remove(AvahiInterface *i, AvahiKey *key) {
+    /* First find for the AvahiLLMNRQueryJob object for this 'i' and 'key' */
+    AvahiLLMNRQueryJob *qj;
+
+    assert(i);
+    assert(key);
+
+    /* Interface is maintaing hashmap of AvahiLLMNRQueryJob's by key*/
+    if (!(qj = avahi_hashmap_lookup(i->llmnr.queryjobs_by_key, key)))
+        return;
+
+    /* get 'qj' -> destroy(s, qj) -> destroy(lq) */
+    avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+
+    return;
+}
+
+struct cbdata {
+    AvahiLLMNRQueryCallback callback;
+    AvahiKey *key;
+    void *userdata;
+};
+
+static void llmnr_query_add_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, void *userdata) {
+    struct cbdata *cbdata;
+
+    assert(m);
+    assert(i);
+    assert(userdata);
+
+    cbdata = (struct cbdata *)(userdata);
+
+    /* Issue AVAHI_LLMNR_SIMPLE_QUERY type Query*/
+    if (!avahi_llmnr_query_add( i, (AvahiKey*)(cbdata->key), AVAHI_LLMNR_SIMPLE_QUERY, cbdata->callback, cbdata->userdata))
+        /* set errno*/
+
+    return;
+}
+
+
+void avahi_llmnr_query_add_for_all(
+    AvahiServer *s,
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiKey *key,
+    AvahiLLMNRQueryCallback callback,
+    void *userdata) {
+
+    struct cbdata cbdata;
+
+    assert(s);
+    assert(callback);
+    assert(AVAHI_IF_VALID(idx));
+    assert(AVAHI_PROTO_VALID(protocol));
+    assert(key);
+
+    cbdata.callback = callback;
+    cbdata.key = key;
+    cbdata.userdata = userdata;
+
+    avahi_interface_monitor_walk(s->monitor, idx, protocol, llmnr_query_add_callback, &cbdata);
+}
+
+void avahi_llmnr_query_free(AvahiLLMNRQuery *lq) {
+    assert(lq);
+
+    avahi_llmnr_query_scheduler_withdraw_by_id(lq->interface->llmnr.query_scheduler, lq->post_id);
+}
+
+static void remove_llmnr_query_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, void *userdata) {
+
+    assert(m);
+    assert(i);
+    assert(userdata);
+
+    /* Remove Query */
+    avahi_llmnr_query_remove(i, (AvahiKey*) userdata);
+}
+
+void avahi_llmnr_query_remove_for_all(AvahiServer *s, AvahiIfIndex idx, AvahiProtocol protocol, AvahiKey *key) {
+
+    assert(s);
+    assert(AVAHI_IF_VALID(idx));
+    assert(AVAHI_PROTO_VALID(protocol));
+    assert(key);
+
+    avahi_interface_monitor_walk(s->monitor, idx, protocol, remove_llmnr_query_callback, key);
+}
+
+void avahi_llmnr_queries_free(AvahiInterface *i) {
+    AvahiLLMNRQueryJob *qj;
+    assert(i);
+
+    for (qj = i->llmnr.queryjobs; qj; qj = qj->jobs_by_interface_next)
+        avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+}
diff --git a/avahi-core/llmnr-querier.h b/avahi-core/llmnr-querier.h
new file mode 100644
index 0000000..080dd29
--- /dev/null
+++ b/avahi-core/llmnr-querier.h
@@ -0,0 +1,71 @@
+#ifndef foollmnrquerierbar
+#define foollmnrquerierbar
+
+typedef struct AvahiLLMNRQuery AvahiLLMNRQuery;
+
+#include <sys/types.h>
+
+#include <avahi-common/address.h>
+#include <avahi-common/defs.h>
+
+#include "core.h"
+#include "publish.h"
+#include "rrlist.h"
+#include "internal.h"
+
+typedef void (*AvahiLLMNRQueryCallback)(
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiRecord *r,
+    void *userdata);
+
+typedef enum {
+    AVAHI_LLMNR_SIMPLE_QUERY,
+    AVAHI_LLMNR_CONFLICT_QUERY,
+    AVAHI_LLMNR_UNIQUENESS_VERIFICATION_QUERY
+} AvahiLLMNRQueryType;
+
+
+struct AvahiLLMNRQuery{
+    int dead;
+
+    /* 'e = interface->monitor->server->llmnr->llmnr_lookup_engine'
+    maintains the hashmap for all queries by id. */
+    uint32_t id;
+
+    AvahiKey *key;
+    AvahiInterface *interface;
+    AvahiLLMNRQueryCallback callback;
+    AvahiLLMNRQueryType type;
+
+    AvahiRecordList *c_bit_set, *c_bit_clear;
+
+    /* 'AvahiLLMNRQueryScheduler' next_id */
+    unsigned post_id;
+    int post_id_valid;
+
+    void *userdata;
+};
+
+/* Issue an LLMNR Query on the specified interface and key*/
+AvahiLLMNRQuery* avahi_llmnr_query_add(AvahiInterface *i, AvahiKey *key, AvahiLLMNRQueryType type, AvahiLLMNRQueryCallback callback, void *userdata);
+
+/* Remove a scheduled LLMNR query for the specified key and interface*/
+void avahi_llmnr_query_remove(AvahiInterface *i, AvahiKey *key);
+
+/* Issue LLMNR queries for the specied key on all interfaces that match
+idx and protocol. In this case callback function will be 'callback' for
+all those queries. and it issues AVAHI_LLMNR_SIMPLE_QUERY type of query*/
+void avahi_llmnr_query_add_for_all(AvahiServer *s, AvahiIfIndex idx, AvahiProtocol protocol, AvahiKey *key, AvahiLLMNRQueryCallback callback, void *userdata);
+
+/* Remove LLMNR queries for the specified key on all interface that match*/
+void avahi_llmnr_query_remove_for_all(AvahiServer *s, AvahiIfIndex idx, AvahiProtocol protocol, AvahiKey *key);
+
+/* Remove specified query */
+void avahi_llmnr_query_free(AvahiLLMNRQuery *lq);
+void avahi_llmnr_query_destroy(AvahiLLMNRQuery *lq);
+
+/** Remove all queries from specified interface **/
+void avahi_llmnr_queries_free(AvahiInterface *i);
+
+#endif /* foollmnrquerierbar */
diff --git a/avahi-core/llmnr-query-sched.c b/avahi-core/llmnr-query-sched.c
new file mode 100644
index 0000000..d1b0e0b
--- /dev/null
+++ b/avahi-core/llmnr-query-sched.c
@@ -0,0 +1,318 @@
+#include <string.h>
+#include <stdio.h>
+
+#include <avahi-common/timeval.h>
+#include <avahi-common/malloc.h>
+
+#include "log.h"
+#include "rrlist.h"
+
+#include "llmnr-query-sched.h"
+#include "dns.h"
+#include "verify.h"
+
+AvahiLLMNRQueryScheduler *avahi_llmnr_query_scheduler_new(AvahiInterface *i) {
+    AvahiLLMNRQueryScheduler *s;
+    assert(i);
+
+    if (!(s = avahi_new(AvahiLLMNRQueryScheduler, 1)))
+        return NULL;
+
+    s->i = i;
+    s->time_event_queue = i->monitor->server->time_event_queue;
+    s->next_id = 1;
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNRQueryJob, s->jobs);
+
+    return s;
+}
+
+void avahi_llmnr_query_scheduler_free(AvahiLLMNRQueryScheduler *s) {
+    assert(s);
+
+    avahi_llmnr_query_scheduler_clear(s);
+    avahi_free(s);
+}
+
+void avahi_llmnr_query_scheduler_clear(AvahiLLMNRQueryScheduler *s) {
+    assert(s);
+
+    while (s->jobs)
+        avahi_llmnr_query_job_destroy(s, s->jobs);
+}
+
+void avahi_llmnr_query_job_destroy(AvahiLLMNRQueryScheduler *s, AvahiLLMNRQueryJob *qj) {
+    assert(s);
+    assert(qj);
+
+     /* Free lq */
+    avahi_llmnr_query_destroy(qj->lq);
+
+    /* Free dns packet and time_event */
+    if (qj->p)
+        avahi_dns_packet_free(qj->p);
+
+    if (qj->time_event)
+        avahi_time_event_free(qj->time_event);
+
+    /* Remove from the lists */
+    AVAHI_LLIST_REMOVE(AvahiLLMNRQueryJob, jobs_by_scheduler, s->jobs, qj);
+    AVAHI_LLIST_REMOVE(AvahiLLMNRQueryJob, jobs_by_interface, s->i->llmnr.queryjobs, qj);
+
+    avahi_free(qj);
+}
+
+static void avahi_prepare_llmnr_query_job_packet(AvahiLLMNRQueryJob *qj) {
+    assert(qj);
+
+    /* New Packet*/
+    qj->p = avahi_llmnr_packet_new_query(512 + AVAHI_DNS_PACKET_EXTRA_SIZE);
+
+    /* Set ID*/
+    avahi_dns_packet_set_field(qj->p, AVAHI_LLMNR_FIELD_ID, (uint16_t)(qj->lq->id));
+
+    /*Append Key*/
+    if (!avahi_llmnr_packet_append_key(qj->p, qj->lq->key))
+        return;
+
+    /* Set QDCOUNT */
+    avahi_dns_packet_set_field(qj->p, AVAHI_LLMNR_FIELD_QDCOUNT, 1);
+
+}
+
+static AvahiLLMNRQueryJob *job_new(AvahiLLMNRQueryScheduler *s, AvahiLLMNRQuery *lq) {
+    AvahiLLMNRQueryJob *qj;
+
+    assert(s);
+    assert(lq);
+
+    if (!(qj = avahi_new(AvahiLLMNRQueryJob, 1)))
+        return NULL;
+
+    qj->scheduler = s;
+    qj->lq = lq;
+
+    /* Set lq parameters */
+    lq->post_id_valid = 1;
+    lq->post_id = s->next_id++;
+
+    /* qj parameters */
+    qj->n_sent = 0;
+    qj->prev_scheduled = 0;
+    qj->time_event = NULL;
+
+    /* Prepend in Lists */
+    AVAHI_LLIST_PREPEND(AvahiLLMNRQueryJob, jobs_by_scheduler, s->jobs, qj);
+    AVAHI_LLIST_PREPEND(AvahiLLMNRQueryJob, jobs_by_interface, s->i->llmnr.queryjobs, qj);
+
+    /*Just prepare dns packet, don't send it */
+    avahi_prepare_llmnr_query_job_packet(qj);
+
+    return qj;
+}
+
+
+static void resend_llmnr_query(AvahiLLMNRQueryJob *qj) {
+    AvahiLLMNRQuery *lq = qj->lq;
+    struct timeval tv;
+    assert(qj);
+
+    if (lq->type == AVAHI_LLMNR_SIMPLE_QUERY || lq->type == AVAHI_LLMNR_UNIQUENESS_VERIFICATION_QUERY) {
+        /**Check whether we have already sent this query three times */
+        if (qj->n_sent >= 3) {
+            lq->callback(lq->interface->hardware->index, lq->interface->protocol, NULL, lq->userdata);
+            avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+            /* Free Timeevent */
+/*            avahi_time_event_free(qj->time_event);
+            qj->time_event = NULL;*/
+
+        } else {
+
+            /* Send packet */
+            avahi_interface_send_packet(lq->interface, qj->p, AVAHI_LLMNR);
+            (qj->n_sent)++;
+            /* Schedule further queries*/
+            avahi_elapse_time(&tv, AVAHI_LLMNR_INTERVAL, 0);
+            avahi_time_event_update(qj->time_event, &tv);
+        }
+
+    } else {
+
+        assert(lq->type == AVAHI_LLMNR_CONFLICT_QUERY);
+        assert(qj->n_sent == 1);
+
+        /* Destroy this query */
+        lq->callback(lq->interface->hardware->index, lq->interface->protocol, NULL, lq->userdata);
+        avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+    }
+
+    return;
+}
+
+static void reschedule_llmnr_query_job(AvahiLLMNRQueryJob *qj) {
+    struct timeval tv;
+
+    assert(qj);
+    assert(!avahi_record_list_is_empty(qj->lq->c_bit_clear));
+
+    if (!(qj->prev_scheduled)) {
+
+        qj->prev_scheduled = 1;
+        avahi_elapse_time(&tv, AVAHI_LLMNR_INTERVAL + AVAHI_LLMNR_JITTER, 0);
+        avahi_time_event_update(qj->time_event, &tv);
+
+    } else {
+        /* We have already waited but we still have not received any response/s
+        with 'c' bit clear. */
+        qj->lq->callback(qj->lq->interface->hardware->index, qj->lq->interface->protocol, NULL, qj->lq->userdata);
+        /*avahi_time_event_free(qj->time_event);
+        qj->time_event = NULL;*/
+        avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+    }
+    return;
+}
+
+static void call_llmnr_query_callback(AvahiLLMNRQuery *lq) {
+    AvahiRecord *r;
+
+    assert(lq);
+    assert(avahi_record_list_is_empty(lq->c_bit_set));
+
+    while ((r = avahi_record_list_next(lq->c_bit_clear, NULL, NULL, NULL)))
+        lq->callback(lq->interface->hardware->index, lq->interface->protocol, r, lq->userdata);
+
+    return;
+}
+
+static void send_conflict_query(AvahiLLMNRQueryJob *qj) {
+    /* Send the packet */
+    AvahiRecord *r;
+    AvahiLLMNRQuery *lq;
+    assert(qj);
+
+    /* We use the same lq */
+
+    /*1. Change 'lq->type' and reset 'n_sent' */
+    lq = qj->lq;
+    lq->callback(lq->interface->hardware->index, lq->interface->protocol, NULL, lq->userdata);
+    lq->type = AVAHI_LLMNR_CONFLICT_QUERY;
+    qj->n_sent = 0;
+
+    /* Reset 'c' bit in existing packet */
+    avahi_dns_packet_set_field(qj->p, AVAHI_LLMNR_FIELD_FLAGS, AVAHI_LLMNR_FLAGS(0, 0, 1, 0, 0, 0, 0));
+
+    /* Append records */
+    while ((r = avahi_record_list_next(lq->c_bit_clear, NULL, NULL, NULL))) {
+        /* Append Record TODO TTL*/
+        if (!(avahi_llmnr_packet_append_record(qj->p, r, AVAHI_DEFAULT_TTL)))
+        /* we send only those much of record which fits in */
+            break;
+        avahi_dns_packet_inc_field(qj->p, AVAHI_LLMNR_FIELD_ARCOUNT);
+    }
+
+    /* Send packet */
+    if (avahi_dns_packet_get_field(qj->p, AVAHI_LLMNR_FIELD_ARCOUNT) != 0)
+        avahi_interface_send_packet(lq->interface, qj->p, AVAHI_LLMNR);
+
+    /* Destroy this AvahiLLMNRQueryJob */
+    avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+
+    return;
+
+}
+
+static void elapse_timeout_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
+    AvahiLLMNRQueryJob *qj = userdata;
+    AvahiLLMNRQuery *lq = qj->lq;
+    int c_bit_set, c_bit_clear, counter;
+
+    c_bit_set = avahi_record_list_is_empty(lq->c_bit_set);
+    c_bit_clear = avahi_record_list_is_empty(lq->c_bit_clear);
+
+    counter = (2*(!c_bit_set)) + (!c_bit_clear);
+
+    switch (counter)/*TODO, clean it*/  {
+
+        case 0 :
+             /*We have not yet received any responses. Try to resend the same query*/
+            resend_llmnr_query(qj);
+            break;
+
+        case 1 :
+            /*We have received one or multiple reponse/s with 'c' bit clear
+            and none with 'c' bit set within AVAHI_LLMNR_TIMEOUT. It means
+            query has been replied. */
+            call_llmnr_query_callback(lq);
+            avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+            /*avahi_time_event_free(qj->time_event);
+            qj->time_event = NULL;*/
+            break;
+
+        case 2 :
+            /*We have received atleast one response with 'c' bit set but we didn't
+            receive any response with 'c' bit clear. We don't want to send this query
+            further but wait for atleast LLMNR_TIMEOUT + JITTER_INTERVAL to collect
+            more responses, if any */
+            reschedule_llmnr_query_job(qj);
+            break;
+
+        case 3 :
+            /*This is conflict. Let us send AVAHI_LLMNR_CONFLICT_QUERY (with c bit set
+            in query) along with responses*/
+            avahi_log_info("CONFLICT..CONFLICT..CONFLICT");
+            send_conflict_query(qj);
+            avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+            break;
+    }
+
+    return;
+}
+
+int avahi_llmnr_query_scheduler_post(AvahiLLMNRQueryScheduler *s, AvahiLLMNRQuery *lq, int immediately) {
+    AvahiLLMNRQueryJob *qj;
+    struct timeval tv;
+
+    assert(s);
+    assert(lq);
+
+    if (!(qj = job_new(s, lq)))
+        return 0;
+
+    qj->time_event = avahi_time_event_new(s->time_event_queue,
+                                          avahi_elapse_time(&tv, 0, immediately ? 0 : AVAHI_LLMNR_JITTER),
+                                          elapse_timeout_callback,
+                                          qj);
+
+    return 1;
+}
+
+int avahi_llmnr_query_scheduler_withdraw_by_id(AvahiLLMNRQueryScheduler *s, unsigned post_id) {
+    AvahiLLMNRQueryJob *qj;
+
+    assert(s);
+
+    for (qj = s->jobs; qj; qj = qj->jobs_by_scheduler_next) {
+        assert(!(qj->lq->dead));
+
+        if (qj->lq->post_id == post_id) {
+            avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+void avahi_llmnr_query_job_remove(AvahiInterface *i, AvahiKey *key) {
+    AvahiLLMNRQueryJob *qj;
+
+    assert(i);
+    assert(key);
+
+    if (!(qj = avahi_hashmap_lookup(i->llmnr.queryjobs_by_key, key)))
+    /* No AvahiLLMNRQueryJob object present for this key*/
+        return;
+
+    avahi_llmnr_query_job_destroy(qj->scheduler, qj);
+
+    return;
+}
diff --git a/avahi-core/llmnr-query-sched.h b/avahi-core/llmnr-query-sched.h
new file mode 100644
index 0000000..f944822
--- /dev/null
+++ b/avahi-core/llmnr-query-sched.h
@@ -0,0 +1,57 @@
+#ifndef foollmnrqueryschedhbar
+#define foollmnrqueryschedhbar
+
+typedef struct AvahiLLMNRQueryJob AvahiLLMNRQueryJob;
+typedef struct AvahiLLMNRQueryScheduler AvahiLLMNRQueryScheduler;
+
+#include "iface.h"
+
+#define AVAHI_LLMNR_INTERVAL 1000
+#define AVAHI_LLMNR_JITTER 100
+
+struct AvahiLLMNRQueryJob {
+    AvahiLLMNRQueryScheduler *scheduler;
+    AvahiLLMNRQuery *lq;
+
+    int n_sent, prev_scheduled;
+    AvahiDnsPacket *p;
+
+    AvahiTimeEvent *time_event;
+
+    /* List of jobs maintained by AvahiLLMNRQueryScheduler*/
+    AVAHI_LLIST_FIELDS(AvahiLLMNRQueryJob, jobs_by_scheduler);
+
+    /* List of jobs maintained by Interface. */
+    /* Both contain the same data. */
+    AVAHI_LLIST_FIELDS(AvahiLLMNRQueryJob, jobs_by_interface);
+};
+
+struct AvahiLLMNRQueryScheduler {
+    AvahiInterface *i;
+    AvahiTimeEventQueue *time_event_queue;
+
+    /* For 'lq' lq->post_id */
+    unsigned int next_id;
+
+    AVAHI_LLIST_HEAD(AvahiLLMNRQueryJob, jobs);
+};
+
+/* Add new query scheduler for specified Interface*/
+AvahiLLMNRQueryScheduler *avahi_llmnr_query_scheduler_new(AvahiInterface *i);
+
+/* This would destroy 'qj' as well as corresponding 'lq' object. */
+void avahi_llmnr_query_job_destroy(AvahiLLMNRQueryScheduler *s, AvahiLLMNRQueryJob *qj);
+
+void avahi_llmnr_query_scheduler_free(AvahiLLMNRQueryScheduler *s);
+void avahi_llmnr_query_scheduler_clear(AvahiLLMNRQueryScheduler *s);
+
+/* Issue an 'AvahiLLMNRQueryJob' for 'AvahiLLMNRQuery' object(lq) on specified scheduler */
+/* This would fill 'lq->post_id' */
+int avahi_llmnr_query_scheduler_post(AvahiLLMNRQueryScheduler *s, AvahiLLMNRQuery *lq, int immediately);
+
+/* Remove AvahiLLMNRQuery and AvahiLLMNRQueryJob for this id.
+(id == ls->post_id, which was created during avahi_llmnr_query_scheduler_post(s, lq, immediately)) */
+int avahi_llmnr_query_scheduler_withdraw_by_id(AvahiLLMNRQueryScheduler *s, unsigned id);
+void avahi_llmnr_query_job_remove(AvahiInterface *i, AvahiKey *key);
+
+#endif /*foollmnrquerychedhbar*/
diff --git a/avahi-core/llmnr-response.c b/avahi-core/llmnr-response.c
new file mode 100644
index 0000000..2f85f34
--- /dev/null
+++ b/avahi-core/llmnr-response.c
@@ -0,0 +1,109 @@
+#include <stdlib.h>
+#include <avahi-common/malloc.h>
+#include <avahi-core/log.h>
+
+#include "llmnr-response.h"
+
+AvahiLLMNRResponseScheduler *avahi_llmnr_response_scheduler_new(AvahiInterface *i) {
+    AvahiLLMNRResponseScheduler *s;
+
+    assert(i);
+
+    if (!(s = avahi_new(AvahiLLMNRResponseScheduler, 1)))
+        return NULL;
+
+    s->interface = i;
+    s->time_event_queue = i->monitor->server->time_event_queue;
+
+    AVAHI_LLIST_HEAD_INIT(AvahiLLMNRResponseJob, s->jobs);
+
+    return s;
+}
+
+static AvahiLLMNRResponseJob *job_new(
+    AvahiLLMNRResponseScheduler *s,
+    AvahiDnsPacket *p,
+    const AvahiAddress *a,
+    uint16_t port) {
+    AvahiLLMNRResponseJob *rj;
+
+    assert(a->proto == s->interface->protocol);
+
+    if (!(rj = avahi_new(AvahiLLMNRResponseJob, 1)))
+        return NULL;
+
+    rj->s = s;
+    rj->reply = p;
+    rj->address = *a;
+    rj->port = port;
+    rj->time_event = NULL;
+
+    AVAHI_LLIST_PREPEND(AvahiLLMNRResponseJob, jobs, s->jobs , rj);
+
+    return rj;
+}
+
+void avahi_llmnr_response_job_free(AvahiLLMNRResponseScheduler *s, AvahiLLMNRResponseJob *rj) {
+    assert(s);
+    assert(rj);
+
+    if (rj->time_event)
+        avahi_time_event_free(rj->time_event);
+
+    if (rj->reply)
+        avahi_dns_packet_free(rj->reply);
+
+    AVAHI_LLIST_REMOVE(AvahiLLMNRResponseJob, jobs, s->jobs, rj);
+
+    avahi_free(rj);
+}
+
+
+void avahi_llmnr_response_scheduler_clear(AvahiLLMNRResponseScheduler *s) {
+    assert(s);
+
+    while (s->jobs)
+        avahi_llmnr_response_job_free(s, s->jobs);
+}
+
+void avahi_llmnr_response_scheduler_free(AvahiLLMNRResponseScheduler *s) {
+    assert(s);
+
+    avahi_llmnr_response_scheduler_clear(s);
+    avahi_free(s);
+}
+
+static void elapse_response_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void *userdata) {
+    AvahiLLMNRResponseJob *rj = userdata;
+
+    assert(rj);
+
+    /* Send Packet */
+    avahi_interface_send_packet_unicast(rj->s->interface, rj->reply, &rj->address, rj->port, AVAHI_LLMNR);
+    avahi_llmnr_response_job_free(rj->s, rj);
+}
+
+int avahi_post_llmnr_response(AvahiLLMNRResponseScheduler *s, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port) {
+    AvahiLLMNRResponseJob *rj;
+    struct timeval tv;
+
+    assert(s);
+    assert(p);
+    assert(a);
+    assert(port);
+
+    assert(a->proto == s->interface->protocol);
+
+    if (!s->interface->llmnr.verifying)
+        return 0;
+
+    if (!(rj = job_new(s, p, a, port)))
+        return 0;
+
+    avahi_elapse_time(&tv, 0, AVAHI_LLMNR_JITTER);
+    rj->time_event = avahi_time_event_new(s->time_event_queue, &tv, elapse_response_callback, rj);
+
+    return 1;
+}
+
+
diff --git a/avahi-core/llmnr-response.h b/avahi-core/llmnr-response.h
new file mode 100644
index 0000000..f1d5023
--- /dev/null
+++ b/avahi-core/llmnr-response.h
@@ -0,0 +1,40 @@
+#ifndef foollmnrresponsehbar
+#define foollmnrresponsehbar
+
+typedef struct AvahiLLMNRResponseJob AvahiLLMNRResponseJob;
+typedef struct AvahiLLMNRResponseScheduler AvahiLLMNRResponseScheduler;
+
+#include <avahi-common/llist.h>
+#include <avahi-common/timeval.h>
+
+#include "iface.h"
+#include "dns.h"
+
+struct AvahiLLMNRResponseJob {
+    AvahiLLMNRResponseScheduler *s;
+
+    AvahiTimeEvent *time_event;
+    AvahiDnsPacket *reply;
+
+    AvahiAddress address;
+    uint16_t port;
+
+    AVAHI_LLIST_FIELDS(AvahiLLMNRResponseJob, jobs);
+};
+
+struct AvahiLLMNRResponseScheduler {
+    AvahiInterface *interface;
+    AvahiTimeEventQueue *time_event_queue;
+
+    AVAHI_LLIST_HEAD(AvahiLLMNRResponseJob, jobs);
+};
+
+AvahiLLMNRResponseScheduler *avahi_llmnr_response_scheduler_new(AvahiInterface *i);
+void avahi_llmnr_response_scheduler_free(AvahiLLMNRResponseScheduler *s);
+void avahi_llmnr_response_scheduler_clear(AvahiLLMNRResponseScheduler *s);
+
+int avahi_post_llmnr_response(AvahiLLMNRResponseScheduler *s, AvahiDnsPacket *p, const AvahiAddress *a, uint16_t port);
+void avahi_llmnr_response_job_free(AvahiLLMNRResponseScheduler *s, AvahiLLMNRResponseJob *rj);
+
+#endif
+
diff --git a/avahi-core/llmnr-server.c b/avahi-core/llmnr-server.c
new file mode 100644
index 0000000..22c6bdc
--- /dev/null
+++ b/avahi-core/llmnr-server.c
@@ -0,0 +1,535 @@
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+
+#include <avahi-common/domain.h>
+#include <avahi-common/timeval.h>
+#include <avahi-common/malloc.h>
+#include <avahi-common/error.h>
+#include <avahi-common/address.h>
+
+#include "iface.h"
+#include "socket.h"
+#include "log.h"
+#include "addr-util.h"
+#include "domain-util.h"
+#include "rr-util.h"
+#include "hashmap.h"
+
+#include "llmnr-querier.h"
+#include "llmnr-query-sched.h"
+#include "verify.h"
+#include "llmnr-response.h"
+#include "llmnr-lookup.h"
+#include "dns.h"
+
+/* Server methods */
+static void avahi_llmnr_server_prepare_response(AvahiServer *s, AvahiInterface *i, AvahiEntry *e) {
+    assert(s);
+    assert(i);
+    assert(e);
+    assert(e->type == AVAHI_ENTRY_LLMNR);
+
+    avahi_record_list_push(s->llmnr.record_list,
+                           e->record,
+                           e->flags & AVAHI_PUBLISH_UNIQUE,
+                           avahi_llmnr_entry_is_verifying(s, e, i),
+                           0);
+    assert(!avahi_record_list_is_empty(s->llmnr.record_list));
+}
+
+static void avahi_llmnr_server_prepare_matching_responses(AvahiServer *s, AvahiInterface *i, AvahiKey *key) {
+    assert(s);
+    assert(i);
+    assert(key);
+
+    /* ANY queries*/
+    if (avahi_key_is_pattern(key)) {
+        AvahiEntry *e;
+
+        for (e = s->llmnr.entries; e; e = e->entries_next)
+            if ((!e->dead && avahi_key_pattern_match(key, e->record->key) &&
+                (avahi_llmnr_entry_is_verifying(s, e, i) != -1)) )
+
+                avahi_llmnr_server_prepare_response(s, i, e);
+
+    } else {
+        AvahiEntry *e;
+
+        /* Other queries */
+
+        for (e = avahi_hashmap_lookup(s->llmnr.entries_by_key, key); e; e = e->by_key_next) {
+
+            if (!e->dead &&
+                (avahi_llmnr_entry_is_verifying(s, e, i) != -1) )
+                avahi_llmnr_server_prepare_response(s, i, e);
+        }
+    }
+}
+
+static void avahi_s_cleanup_dead_entries(AvahiServer *s) {
+    assert(s);
+
+    /* Cleanup dead groups (AvahiSEntryGroup) */
+    if (s->llmnr.need_group_cleanup) {
+        AvahiSEntryGroup *g;
+
+        for (g = s->llmnr.groups; g; g = g->groups_next) {
+            assert(g->type == AVAHI_GROUP_LLMNR);
+
+            if (g->dead)
+                avahi_entry_group_free(s, g);
+        }
+
+        s->llmnr.need_group_cleanup = 0;
+    }
+
+    if (s->llmnr.need_entry_cleanup) {
+        AvahiEntry *e;
+
+        for (e = s->llmnr.entries; e; e = e->entries_next)
+            if (e->dead)
+                avahi_entry_free(s, e);
+
+        s->llmnr.need_entry_cleanup = 0;
+    }
+}
+
+static void avahi_llmnr_server_generate_response(
+    AvahiServer *s,
+    AvahiDnsPacket *p,
+    AvahiInterface *i,
+    const AvahiAddress *address,
+    uint16_t port,
+    int empty_response) {
+
+    /* empty_response == 0 */
+    /* 1. If the query was for A/AAAA or PTR records we must have only single RR.
+    2. If the query was for ANY type we *should* have only single RR. If more than
+    single RR, we send them in different packets as what should be the value of 'c'
+    and 't' bit in case of multiple records in a single packet is not specified in RFC */
+
+    /* empty_response == 1 */
+    /* Ignore the RR's in sl->record_list, just send an empty RR */
+
+    AvahiDnsPacket *reply = NULL;
+    AvahiRecord *r;
+    int c, t, send_packet = 0;
+
+    if (!empty_response) {
+        /* Get a reply packet */
+        reply = avahi_llmnr_packet_new_reply(p, 512 + AVAHI_DNS_PACKET_EXTRA_SIZE, 1, 0);
+
+        while ((r = avahi_record_list_next(s->llmnr.record_list, &c, &t, NULL))) {
+
+            /* Append Record */
+            if (!avahi_llmnr_packet_append_record(reply, r, 30)) {
+
+                /*Send this packet*/
+                if (avahi_dns_packet_get_field(reply, AVAHI_LLMNR_FIELD_ANCOUNT != 0)) {
+                        send_packet = 1;
+                        /* If we send rest of the records in a new packet that will be discarded
+                           So there is no point sending that. We should have set the T bit and wait
+                           for the TCP query but we do not support TCP processing yet. Break*/
+                        /* TODO set errno*/
+                        break;
+                }
+
+            } else {
+                send_packet = 1;
+                /* Increment field */
+                avahi_dns_packet_inc_field(reply, AVAHI_LLMNR_FIELD_ANCOUNT);
+                avahi_record_unref(r);
+            }
+        }
+
+    } else {
+        reply = avahi_llmnr_packet_new_reply(p, 512 + AVAHI_DNS_PACKET_EXTRA_SIZE, 1, 0);
+        send_packet = 1;
+    }
+
+    avahi_record_list_flush(s->llmnr.record_list);
+
+    if (send_packet) {
+        assert(reply);
+        if (!avahi_schedule_llmnr_response_job(i->llmnr.response_scheduler, reply, address, port))
+            return;
+    }
+
+    return;
+}
+
+static void prepend_response_packet(int c_bit, AvahiLLMNRQuery *lq, AvahiDnsPacket *p) {
+    AvahiRecord *r = NULL;
+    AvahiKey *key;
+    int n_records;
+
+    assert(lq);
+    assert(p);
+
+    /*TODO Duplicate records*/
+    n_records = avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_ANCOUNT);
+
+    /* Consume Key first */
+    key = avahi_llmnr_packet_consume_key(p);
+
+    assert(avahi_key_equal(key, lq->key));
+
+    if (c_bit) {
+        /* Prepend in C cit set list */
+        for (; n_records ; n_records--) {
+            if (!(r = avahi_llmnr_packet_consume_record(p)))
+                return;
+
+            avahi_record_list_push(lq->c_bit_set, r, 1, 0, 0);
+        }
+
+    } else {
+        /* Prepend in C bit clear list*/
+        for (; n_records ; n_records--) {
+
+            if (!(r = avahi_llmnr_packet_consume_record(p)))
+                return;
+
+            avahi_record_list_push(lq->c_bit_clear, r, 0, 0, 0);
+        }
+    }
+}
+
+static void prepend_uniqueness_verification_packet(AvahiLLMNRQuery *lq, const AvahiAddress *src_address) {
+    AvahiVerifierData *vdata;
+
+    assert(lq);
+    assert(src_address);
+
+    vdata = (AvahiVerifierData *)(lq->userdata);
+
+    if (vdata->address)
+    {
+        assert((vdata->t_bit));
+        /* vdata->address is not NULL => we have already filled this field.    Since we
+        issue uniqueness verification query only for those entries that are meant to
+        be UNIQUE, this should either be a duplicate response or entry is not UNIQUE.
+        In any case we put AvahiLLMNREntryVerify object state into AVAHI_CONFLICT. */
+        if (avahi_address_cmp(vdata->address, src_address) == 0)
+            /* Addresses match, means a duplicate packet */
+            return;
+        else /* Address don't match =>     AVAHI_CONFLICT */
+            vdata->ev->state = AVAHI_CONFLICT;
+
+    } else {
+        /* Set 't' bit */
+        (vdata->t_bit) = 1;
+        vdata->address = src_address;
+    }
+
+    return;
+}
+
+static void handle_conflict_query (AvahiServer *s, AvahiDnsPacket *p, AvahiInterface *i) {
+    AvahiKey *key;
+
+    assert(s);
+    assert(p);
+    assert(i);
+
+    if (!(key = avahi_llmnr_packet_consume_key(p)))
+        return;
+
+    if (avahi_key_is_pattern(key)) {
+       AvahiEntry *e;
+
+       for (e = s->llmnr.entries; e; e = e->entries_next)
+            if ((!e->dead && avahi_key_pattern_match(key, e->record->key) &&
+                (avahi_llmnr_entry_is_verifying(s, e, i) == 0)) )
+                /* Reverify query */
+                avahi_reverify_entry(s, e);
+
+    } else {
+        AvahiEntry *e;
+        /* Other queries */
+        for (e = avahi_hashmap_lookup(s->llmnr.entries_by_key, key); e; e = e->by_key_next)
+            if (!e->dead && (avahi_llmnr_entry_is_verifying(s, e, i) == 0))
+                /* Reverify query */
+                avahi_reverify_entry(s, e);
+    }
+
+    return;
+}
+
+static void handle_response_packet (AvahiServer *s, AvahiDnsPacket *p, AvahiInterface *i, const AvahiAddress *src_address, uint16_t port) {
+    uint16_t flags;
+    uint32_t id;
+    AvahiLLMNRQuery *lq;
+
+    assert(s);
+    assert(i);
+    assert(p);
+    assert(src_address);
+    assert(port);
+
+    id = (uint32_t) (avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_ID));
+    flags = avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_FLAGS);
+
+    /* AvahiLLMNRQuery object that issued this query */
+    if ( !(lq = avahi_hashmap_lookup(s->llmnr.llmnr_lookup_engine->queries_by_id, &id)) ||
+        (lq->dead) )
+        goto finish;
+
+    assert(lq->type != AVAHI_LLMNR_CONFLICT_QUERY);
+
+    /* Check for the 'tc' bit */
+    if (flags & AVAHI_LLMNR_FLAG_TC) {
+        /*TODO: TCP Query processing .Not yet supported
+         * Not supported by vista machines either. ;)*/
+        /**    send_tcp_query(sl, i, p, src_address); **/
+        return;
+    }
+
+    switch(lq->type) {
+
+        case AVAHI_LLMNR_SIMPLE_QUERY :
+             /* Check for 't' bit. For simple queries should be clear*/
+            if ((flags & AVAHI_LLMNR_FLAG_T) == 1)
+                goto finish;
+            else
+                prepend_response_packet(flags & AVAHI_LLMNR_FLAG_C, lq, p);
+            break;
+
+        case AVAHI_LLMNR_UNIQUENESS_VERIFICATION_QUERY :
+            /* If 't' bit is clear, we will prepend in list according to 'c' bit
+            and will check at last whether there is already a conflict about this entry*/
+            if (!(flags & AVAHI_LLMNR_FLAG_T))
+                prepend_response_packet(flags & AVAHI_LLMNR_FLAG_C, lq, p);
+            else /* 't' bit is set => we are not concerned with 'c' bit now*/
+                prepend_uniqueness_verification_packet(lq, src_address);
+            break;
+
+        default :
+            break;
+    }
+    return;
+
+finish:
+    avahi_dns_packet_free(p);
+    return;
+}
+
+static void handle_query_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterface *i, const AvahiAddress *src_address, uint16_t port) {
+    AvahiKey *key, *new_key;
+
+    assert(s);
+    assert(i);
+    assert(p);
+    assert(src_address);
+    assert(port);
+    assert(avahi_record_list_is_empty(s->llmnr.record_list));
+
+    if (!(key = avahi_llmnr_packet_consume_key(p)))
+        return;
+
+    /* Fill sl->record_list with valid RR/'s, if any */
+    avahi_llmnr_server_prepare_matching_responses(s, i, key);
+
+    if (!avahi_record_list_is_empty(s->llmnr.record_list)) {
+        avahi_llmnr_server_generate_response(s, p, i, src_address, port, 0);
+        avahi_key_unref(key);
+
+    } else if (!(key->type == AVAHI_DNS_TYPE_ANY)) {
+
+        /* We don't have any valid verified record for this key.
+        Now we check for records with 'type = AVAHI_DNS_TYPE_ANY'
+        with same name to see if we are autoritative for that name
+        for another type of query. In that case we send an empty
+        response packet. */
+        new_key = avahi_key_new(key->name, key->clazz, AVAHI_DNS_TYPE_ANY);
+        avahi_llmnr_server_prepare_matching_responses(s, i, new_key);
+        avahi_key_unref(new_key);
+
+        if (!avahi_record_list_is_empty(s->llmnr.record_list))
+            /* We do have record for type ANY. Send an empty response */
+            avahi_llmnr_server_generate_response(s, p, i, src_address, port, 1);
+    }
+
+    return;
+}
+
+static int originates_from_local_iface(AvahiServer *s, AvahiIfIndex iface, const AvahiAddress *a, uint16_t port) {
+
+    assert(s);
+    assert(iface != AVAHI_IF_UNSPEC);
+    assert(a);
+
+    if (port != AVAHI_LLMNR_PORT)
+        return 0;
+
+    return avahi_interface_has_address(s->monitor, iface, a);
+}
+
+
+static int is_llmnr_mcast_address(const AvahiAddress *a) {
+    AvahiAddress b;
+    assert(a);
+
+    avahi_address_parse(a->proto == AVAHI_PROTO_INET ? AVAHI_IPV4_LLMNR_GROUP : AVAHI_IPV6_LLMNR_GROUP, a->proto, &b);
+
+    return avahi_address_cmp(a, &b) == 0;
+}
+
+static void dispatch_packet (
+    AvahiServer *s,
+    AvahiDnsPacket *p,
+    const AvahiAddress *src_address,
+    uint16_t port,
+    const AvahiAddress *dst_address,
+    AvahiIfIndex iface,
+    int ttl) {
+
+    /* Get Interface here*/
+    AvahiInterface *i;
+    uint16_t flags;
+
+    assert(s);
+    assert(p);
+    assert(src_address);
+    assert(dst_address);
+    assert(iface > 0);
+    assert(src_address->proto == dst_address->proto);
+
+
+    if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) || !i->llmnr.verifying)
+        return;
+
+    /* Discard our own packets */
+    if (originates_from_local_iface(s, iface, src_address, port))
+        return;
+
+    if (avahi_llmnr_packet_check_valid(p) < 0)
+        return;
+
+    flags = avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_FLAGS);
+
+    if (!(flags & AVAHI_LLMNR_FLAG_QR)) {
+
+        /* UDP queries should be multicast (Queries can be sent over any port)
+        So we don't check for the port here.*/
+        if (!(is_llmnr_mcast_address(dst_address)))
+            return;
+
+        /* Make sure 'tc' bit is clear. Ignore 'rcode' and 't' bitsTODO, TC bit set in Vista Packets*/
+        if ( (flags & AVAHI_LLMNR_FLAG_TC) ||
+            (avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_QDCOUNT) != 1 ) ||
+            (avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_ANCOUNT) != 0) ||
+            (avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_NSCOUNT) != 0) )
+                return;
+
+        /* Check for the 'c' bit */
+        if (!(flags & AVAHI_LLMNR_FLAG_C))
+        /* Simple_LLMNR_Query packet*/
+            handle_query_packet(s, p, i, src_address, port);
+
+        /* Received a conflict query. We don't respond to this query.
+        Rather start uniquness verification process.*/
+        else
+            handle_conflict_query(s, p, i);
+
+    } else /* Response packet */ {
+
+        /* Response must be unicast and must be sent through standard
+        LLMNR port*/
+        if ((is_llmnr_mcast_address(dst_address)) &&
+           (port != AVAHI_LLMNR_PORT))
+            return;
+
+        /* RCODE must be clear for LLMNR unicast UDP responses */
+        if ((flags & AVAHI_LLMNR_FLAG_RCODE))
+            return;
+
+        /* sl->server->config.check_response_ttl, same goes for LLMNR*/
+        if (ttl != 255 && s->config.check_response_ttl) {
+            avahi_log_warn("Received response with invalid TTL %u on interface '%s.%i'.", ttl, i->hardware->name, i->protocol);
+            return;
+        }
+
+        if (avahi_dns_packet_get_field(p, AVAHI_LLMNR_FIELD_QDCOUNT) != 1)
+            return;
+
+        handle_response_packet(s, p, i, src_address, port);
+    }
+
+    return;
+}
+
+
+static void llmnr_socket_event(AvahiWatch *w, int fd, AvahiWatchEvent event, void *userdata) {
+    AvahiServer *s = userdata;
+    AvahiAddress dest, src;
+    AvahiDnsPacket *p = NULL;
+    /* Pass the Interface Index from this function */
+    AvahiIfIndex iface;
+
+    uint16_t port;
+    uint8_t ttl;
+
+    assert(w);
+    assert(fd >= 0);
+    assert(event & AVAHI_WATCH_IN);
+
+    if (fd == s->llmnr.fd_ipv4) {
+        dest.proto = src.proto = AVAHI_PROTO_INET;
+        p = avahi_recv_dns_packet_ipv4(s->llmnr.fd_ipv4, &src.data.ipv4, &port, &dest.data.ipv4, &iface, &ttl);
+
+    } else {
+        assert(fd == s->llmnr.fd_ipv6) ;
+        dest.proto = src.proto = AVAHI_PROTO_INET6 ;
+        p = avahi_recv_dns_packet_ipv6(s->llmnr.fd_ipv6, &src.data.ipv6, &port, &dest.data.ipv6, &iface, &ttl);
+    }
+
+    if (p) {
+        /* Find Interface Index if iface == AVAHI_IF_UNSPEC presently with the help of dest address */
+        if (iface == AVAHI_IF_UNSPEC)
+            iface = avahi_find_interface_for_address(s->monitor, &dest);
+
+        /* we should have some specific value in iface otherwise we can't dispatch the packet */
+        if (iface != AVAHI_IF_UNSPEC)
+            dispatch_packet(s, p, &src, port, &dest, iface, ttl);
+        else
+            avahi_log_error("Invalid address");
+
+        avahi_dns_packet_free(p);
+
+        /* TODO clean-up */
+        avahi_s_cleanup_dead_entries(s);
+    }
+}
+
+int setup_llmnr_sockets(AvahiServer *s) {
+    assert(s);
+
+    s->llmnr.fd_ipv4 = s->config.use_ipv4 ? avahi_open_socket_ipv4(s->config.disallow_other_stacks, AVAHI_LLMNR) : -1;
+    s->llmnr.fd_ipv6 = s->config.use_ipv6 ? avahi_open_socket_ipv6(s->config.disallow_other_stacks, AVAHI_LLMNR) : -1;
+
+    if (s->llmnr.fd_ipv6 < 0 && s->llmnr.fd_ipv4 < 0)
+        return AVAHI_ERR_NO_NETWORK;
+
+    if (s->llmnr.fd_ipv4 < 0 && s->config.use_ipv4)
+        avahi_log_notice("Failed to create IPv4 LLMNR socket, proceeding in IPv6 only mode");
+    else if (s->llmnr.fd_ipv6 < 0 && s->config.use_ipv6)
+        avahi_log_notice("Failed to create IPv6 LLMNR socket, proceeding in IPv4 only mode");
+
+    s->llmnr.watch_ipv4 = s->llmnr.watch_ipv6 = NULL;
+
+    if (s->llmnr.fd_ipv4 >= 0)
+        s->llmnr.watch_ipv4 = s->poll_api->watch_new(s->poll_api, s->llmnr.fd_ipv4, AVAHI_WATCH_IN, llmnr_socket_event, s);
+    if (s->llmnr.fd_ipv6 >= 0)
+        s->llmnr.watch_ipv6 = s->poll_api->watch_new(s->poll_api, s->llmnr.fd_ipv6, AVAHI_WATCH_IN, llmnr_socket_event, s);
+
+    return 0;
+}
+
diff --git a/avahi-core/multicast-lookup.c b/avahi-core/multicast-lookup.c
index 75988bf..3ef2b53 100644
--- a/avahi-core/multicast-lookup.c
+++ b/avahi-core/multicast-lookup.c
@@ -230,10 +230,10 @@ static void scan_interface_callback(AvahiInterfaceMonitor *m, AvahiInterface *i,
 
     cbdata->interface = i;
 
-    avahi_cache_walk(i->cache, cbdata->key, scan_cache_callback, cbdata);
+    avahi_cache_walk(i->mdns.cache, cbdata->key, scan_cache_callback, cbdata);
 
     if (cbdata->cname_key)
-        avahi_cache_walk(i->cache, cbdata->cname_key, scan_cache_callback, cbdata);
+        avahi_cache_walk(i->mdns.cache, cbdata->cname_key, scan_cache_callback, cbdata);
 
     cbdata->interface = NULL;
 }
diff --git a/avahi-core/probe-sched.c b/avahi-core/probe-sched.c
index 1e63411..a4eb3d7 100644
--- a/avahi-core/probe-sched.c
+++ b/avahi-core/probe-sched.c
@@ -262,7 +262,7 @@ static void elapse_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void* data) {
         if (b) {
             avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_NSCOUNT, 1);
             avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_QDCOUNT, 1);
-            avahi_interface_send_packet(s->interface, p);
+            avahi_interface_send_packet(s->interface, p, AVAHI_MDNS);
         } else
             avahi_log_warn("Probe record too large, cannot send");
 
@@ -314,7 +314,7 @@ static void elapse_callback(AVAHI_GCC_UNUSED AvahiTimeEvent *e, void* data) {
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_NSCOUNT, n);
 
     /* Send it now */
-    avahi_interface_send_packet(s->interface, p);
+    avahi_interface_send_packet(s->interface, p, AVAHI_MDNS);
     avahi_dns_packet_free(p);
 }
 
diff --git a/avahi-core/publish.h b/avahi-core/publish.h
index 90797de..1090463 100644
--- a/avahi-core/publish.h
+++ b/avahi-core/publish.h
@@ -30,6 +30,7 @@
 typedef struct AvahiSEntryGroup AvahiSEntryGroup;
 
 #include <avahi-common/cdecl.h>
+#include <avahi-common/defs.h>
 #include <avahi-core/core.h>
 
 AVAHI_C_DECL_BEGIN
@@ -43,7 +44,7 @@ typedef void (*AvahiSEntryGroupCallback) (AvahiServer *s, AvahiSEntryGroup *g, A
  * the current iteration. It is not safe to call any other
  * avahi_server_xxx() function during the iteration. If the last entry
  * has been read, NULL is returned. */
-const AvahiRecord *avahi_server_iterate(AvahiServer *s, AvahiSEntryGroup *g, void **state);
+const AvahiRecord *avahi_server_iterate(AvahiServer *s, AvahiSEntryGroup *g, void **state, AvahiPublishProtocol proto);
 
 /** Create a new entry group. The specified callback function is
  * called whenever the state of the group changes. Use entry group
diff --git a/avahi-core/querier.c b/avahi-core/querier.c
index d9dc1fb..fb17093 100644
--- a/avahi-core/querier.c
+++ b/avahi-core/querier.c
@@ -52,8 +52,8 @@ struct AvahiQuerier {
 void avahi_querier_free(AvahiQuerier *q) {
     assert(q);
 
-    AVAHI_LLIST_REMOVE(AvahiQuerier, queriers, q->interface->queriers, q);
-    avahi_hashmap_remove(q->interface->queriers_by_key, q->key);
+    AVAHI_LLIST_REMOVE(AvahiQuerier, queriers, q->interface->mdns.queriers, q);
+    avahi_hashmap_remove(q->interface->mdns.queriers_by_key, q->key);
 
     avahi_key_unref(q->key);
     avahi_time_event_free(q->time_event);
@@ -102,7 +102,7 @@ void avahi_querier_add(AvahiInterface *i, AvahiKey *key, struct timeval *ret_cti
     assert(i);
     assert(key);
 
-    if ((q = avahi_hashmap_lookup(i->queriers_by_key, key))) {
+    if ((q = avahi_hashmap_lookup(i->mdns.queriers_by_key, key))) {
 
         /* Someone is already browsing for records of this RR key */
         q->n_used++;
@@ -133,8 +133,8 @@ void avahi_querier_add(AvahiInterface *i, AvahiKey *key, struct timeval *ret_cti
     /* Schedule next queries */
     q->time_event = avahi_time_event_new(i->monitor->server->time_event_queue, avahi_elapse_time(&tv, q->sec_delay*1000, 0), querier_elapse_callback, q);
 
-    AVAHI_LLIST_PREPEND(AvahiQuerier, queriers, i->queriers, q);
-    avahi_hashmap_insert(i->queriers_by_key, q->key, q);
+    AVAHI_LLIST_PREPEND(AvahiQuerier, queriers, i->mdns.queriers, q);
+    avahi_hashmap_insert(i->mdns.queriers_by_key, q->key, q);
 
     /* Return the creation time. This is used for generating the
      * ALL_FOR_NOW event one second after the querier was initially
@@ -148,7 +148,7 @@ void avahi_querier_remove(AvahiInterface *i, AvahiKey *key) {
 
     /* There was no querier for this RR key, or it wasn't referenced
      * by anyone. */
-    if (!(q = avahi_hashmap_lookup(i->queriers_by_key, key)) || q->n_used <= 0)
+    if (!(q = avahi_hashmap_lookup(i->mdns.queriers_by_key, key)) || q->n_used <= 0)
         return;
 
     if ((--q->n_used) <= 0) {
@@ -175,7 +175,7 @@ static void remove_querier_callback(AvahiInterfaceMonitor *m, AvahiInterface *i,
     assert(i);
     assert(userdata);
 
-    if (i->announcing)
+    if (i->mdns.announcing)
         avahi_querier_remove(i, (AvahiKey*) userdata);
 }
 
@@ -198,7 +198,7 @@ static void add_querier_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, vo
     assert(i);
     assert(cbdata);
 
-    if (i->announcing) {
+    if (i->mdns.announcing) {
         struct timeval tv;
         avahi_querier_add(i, cbdata->key, &tv);
 
@@ -230,7 +230,7 @@ int avahi_querier_shall_refresh_cache(AvahiInterface *i, AvahiKey *key) {
 
     /* Called by the cache maintainer */
 
-    if (!(q = avahi_hashmap_lookup(i->queriers_by_key, key)))
+    if (!(q = avahi_hashmap_lookup(i->mdns.queriers_by_key, key)))
         /* This key is currently not subscribed at all, so no cache
          * refresh is needed */
         return 0;
@@ -263,6 +263,6 @@ int avahi_querier_shall_refresh_cache(AvahiInterface *i, AvahiKey *key) {
 void avahi_querier_free_all(AvahiInterface *i) {
     assert(i);
 
-    while (i->queriers)
-        avahi_querier_free(i->queriers);
+    while (i->mdns.queriers)
+        avahi_querier_free(i->mdns.queriers);
 }
diff --git a/avahi-core/query-sched.c b/avahi-core/query-sched.c
index ff833f9..aafd52f 100644
--- a/avahi-core/query-sched.c
+++ b/avahi-core/query-sched.c
@@ -218,7 +218,7 @@ static int packet_add_query_job(AvahiQueryScheduler *s, AvahiDnsPacket *p, Avahi
         return 0;
 
     /* Add all matching known answers to the list */
-    avahi_cache_walk(s->interface->cache, qj->key, known_answer_walk_callback, s);
+    avahi_cache_walk(s->interface->mdns.cache, qj->key, known_answer_walk_callback, s);
 
     job_mark_done(s, qj);
 
@@ -250,7 +250,7 @@ static void append_known_answers_and_send(AvahiQueryScheduler *s, AvahiDnsPacket
 
             avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_FLAGS, avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_FLAGS) | AVAHI_DNS_FLAG_TC);
             avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ANCOUNT, n);
-            avahi_interface_send_packet(s->interface, p);
+            avahi_interface_send_packet(s->interface, p, AVAHI_MDNS);
             avahi_dns_packet_free(p);
 
             p = avahi_dns_packet_new_query(s->interface->hardware->mtu);
@@ -266,7 +266,7 @@ static void append_known_answers_and_send(AvahiQueryScheduler *s, AvahiDnsPacket
     }
 
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ANCOUNT, n);
-    avahi_interface_send_packet(s->interface, p);
+    avahi_interface_send_packet(s->interface, p, AVAHI_MDNS);
     avahi_dns_packet_free(p);
 }
 
diff --git a/avahi-core/resolve-address.c b/avahi-core/resolve-address.c
index dd4adbc..e603e45 100644
--- a/avahi-core/resolve-address.c
+++ b/avahi-core/resolve-address.c
@@ -30,7 +30,7 @@
 
 #include "browse.h"
 
-#define TIMEOUT_MSEC 5000
+#define TIMEOUT_MSEC 10000
 
 struct AvahiSAddressResolver {
     AvahiServer *server;
@@ -47,6 +47,8 @@ struct AvahiSAddressResolver {
     AvahiLookupResultFlags flags;
 
     int retry_with_multicast;
+    int retry_with_llmnr;
+    int llmnr_has_record;
     AvahiKey *key;
 
     AvahiTimeEvent *time_event;
@@ -114,6 +116,9 @@ static void record_browser_callback(
             assert(record);
             assert(record->key->type == AVAHI_DNS_TYPE_PTR);
 
+            if (flags & AVAHI_LOOKUP_RESULT_LLMNR)
+                r->llmnr_has_record = 1;
+
             if (r->interface > 0 && interface != r->interface)
                 return;
 
@@ -147,29 +152,36 @@ static void record_browser_callback(
                 avahi_s_record_browser_restart(r->record_browser);
                 start_timeout(r);
             }
-
             break;
 
         case AVAHI_BROWSER_CACHE_EXHAUSTED:
-        case AVAHI_BROWSER_ALL_FOR_NOW:
             break;
 
-        case AVAHI_BROWSER_FAILURE:
-
-            if (r->retry_with_multicast) {
+        case AVAHI_BROWSER_ALL_FOR_NOW:
+            /* when called by _LLMNR we trigger lookup by _MULTICAST*/
+            if ((flags & AVAHI_LOOKUP_RESULT_LLMNR) && (r->retry_with_multicast) && !r->llmnr_has_record) {
                 r->retry_with_multicast = 0;
-
                 avahi_s_record_browser_free(r->record_browser);
                 r->record_browser = avahi_s_record_browser_new(r->server, r->interface, r->protocol, r->key, AVAHI_LOOKUP_USE_MULTICAST, record_browser_callback, r);
 
+                 if (r->record_browser) {
+                    start_timeout(r);
+                    break;
+                 }
+            }
+            break;
+
+        case AVAHI_BROWSER_FAILURE:
+            if (r->retry_with_llmnr) {
+                r->retry_with_llmnr = 0;
+                avahi_s_record_browser_free(r->record_browser);
+                r->record_browser = avahi_s_record_browser_new(r->server, r->interface, r->protocol, r->key, AVAHI_LOOKUP_USE_LLMNR, record_browser_callback, r);
+
                 if (r->record_browser) {
                     start_timeout(r);
                     break;
                 }
             }
-
-            r->flags = flags;
-            finish(r, AVAHI_RESOLVER_FAILURE);
             break;
     }
 }
@@ -194,10 +206,9 @@ AvahiSAddressResolver *avahi_s_address_resolver_new(
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_PROTO_VALID(protocol), AVAHI_ERR_INVALID_PROTOCOL);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, address->proto == AVAHI_PROTO_INET || address->proto == AVAHI_PROTO_INET6, AVAHI_ERR_INVALID_PROTOCOL);
-    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
 
     avahi_reverse_lookup_name(address, n, sizeof(n));
-
     if (!(k = avahi_key_new(n, AVAHI_DNS_CLASS_IN, AVAHI_DNS_TYPE_PTR))) {
         avahi_server_set_errno(server, AVAHI_ERR_NO_MEMORY);
         return NULL;
@@ -218,6 +229,8 @@ AvahiSAddressResolver *avahi_s_address_resolver_new(
     r->protocol = protocol;
     r->flags = 0;
     r->retry_with_multicast = 0;
+    r->retry_with_llmnr = 0;
+    r->llmnr_has_record = 0;
     r->key = k;
 
     r->record_browser = NULL;
@@ -225,14 +238,15 @@ AvahiSAddressResolver *avahi_s_address_resolver_new(
 
     r->time_event = NULL;
 
-    if (!(flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA))) {
+    if (!(flags & (AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_LLMNR))) {
 
-        if (!server->wide_area_lookup_engine || !avahi_wide_area_has_servers(server->wide_area_lookup_engine))
-            flags |= AVAHI_LOOKUP_USE_MULTICAST;
+        if (!server->wide_area.wide_area_lookup_engine || !avahi_wide_area_has_servers(server->wide_area.wide_area_lookup_engine))
+            flags |= AVAHI_LOOKUP_USE_LLMNR;
         else {
             flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
-            r->retry_with_multicast = 1;
+            r->retry_with_llmnr = 1;
         }
+        r->retry_with_multicast = 1;
     }
 
     r->record_browser = avahi_s_record_browser_new(server, interface, protocol, k, flags, record_browser_callback, r);
diff --git a/avahi-core/resolve-host-name.c b/avahi-core/resolve-host-name.c
index 08f209b..ed689f2 100644
--- a/avahi-core/resolve-host-name.c
+++ b/avahi-core/resolve-host-name.c
@@ -220,9 +220,9 @@ AvahiSHostNameResolver *avahi_s_host_name_resolver_new(
 
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_IF_VALID(interface), AVAHI_ERR_INVALID_INTERFACE);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_PROTO_VALID(protocol), AVAHI_ERR_INVALID_PROTOCOL);
-    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, avahi_is_valid_fqdn(host_name), AVAHI_ERR_INVALID_HOST_NAME);
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, avahi_is_valid_domain_name(host_name), AVAHI_ERR_INVALID_HOST_NAME);
     AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_PROTO_VALID(aprotocol), AVAHI_ERR_INVALID_PROTOCOL);
-    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST), AVAHI_ERR_INVALID_FLAGS);
+    AVAHI_CHECK_VALIDITY_RETURN_NULL(server, AVAHI_FLAGS_VALID(flags, AVAHI_LOOKUP_USE_WIDE_AREA|AVAHI_LOOKUP_USE_MULTICAST|AVAHI_LOOKUP_USE_LLMNR), AVAHI_ERR_INVALID_FLAGS);
 
     if (!(r = avahi_new(AvahiSHostNameResolver, 1))) {
         avahi_server_set_errno(server, AVAHI_ERR_NO_MEMORY);
diff --git a/avahi-core/response-sched.c b/avahi-core/response-sched.c
index abac0a1..63a50e5 100644
--- a/avahi-core/response-sched.c
+++ b/avahi-core/response-sched.c
@@ -258,7 +258,7 @@ static void send_response_packet(AvahiResponseScheduler *s, AvahiResponseJob *rj
     }
 
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ANCOUNT, n);
-    avahi_interface_send_packet(s->interface, p);
+    avahi_interface_send_packet(s->interface, p, AVAHI_MDNS);
     avahi_dns_packet_free(p);
 }
 
diff --git a/avahi-core/server.c b/avahi-core/server.c
index 86fd4a5..64269c6 100644
--- a/avahi-core/server.c
+++ b/avahi-core/server.c
@@ -60,8 +60,9 @@ static void enum_aux_records(AvahiServer *s, AvahiInterface *i, const char *name
     if (type == AVAHI_DNS_TYPE_ANY) {
         AvahiEntry *e;
 
-        for (e = s->entries; e; e = e->entries_next)
+        for (e = s->mdns.entries; e; e = e->entries_next)
             if (!e->dead &&
+                e->type == AVAHI_ENTRY_MDNS &&
                 avahi_entry_is_registered(s, e, i) &&
                 e->record->key->clazz == AVAHI_DNS_CLASS_IN &&
                 avahi_domain_equal(name, e->record->key->name))
@@ -74,8 +75,8 @@ static void enum_aux_records(AvahiServer *s, AvahiInterface *i, const char *name
         if (!(k = avahi_key_new(name, AVAHI_DNS_CLASS_IN, type)))
             return; /** OOM */
 
-        for (e = avahi_hashmap_lookup(s->entries_by_key, k); e; e = e->by_key_next)
-            if (!e->dead && avahi_entry_is_registered(s, e, i))
+        for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, k); e; e = e->by_key_next)
+            if (!e->dead && e->type == AVAHI_ENTRY_MDNS && avahi_entry_is_registered(s, e, i))
                 callback(s, e->record, e->flags & AVAHI_PUBLISH_UNIQUE, userdata);
 
         avahi_key_unref(k);
@@ -106,8 +107,9 @@ void avahi_server_prepare_response(AvahiServer *s, AvahiInterface *i, AvahiEntry
     assert(s);
     assert(i);
     assert(e);
+    assert(e->type == AVAHI_ENTRY_MDNS);
 
-    avahi_record_list_push(s->record_list, e->record, e->flags & AVAHI_PUBLISH_UNIQUE, unicast_response, auxiliary);
+    avahi_record_list_push(s->mdns.record_list, e->record, e->flags & AVAHI_PUBLISH_UNIQUE, unicast_response, auxiliary);
 }
 
 void avahi_server_prepare_matching_responses(AvahiServer *s, AvahiInterface *i, AvahiKey *k, int unicast_response) {
@@ -122,7 +124,7 @@ void avahi_server_prepare_matching_responses(AvahiServer *s, AvahiInterface *i,
 
         /* Handle ANY query */
 
-        for (e = s->entries; e; e = e->entries_next)
+        for (e = s->mdns.entries; e; e = e->entries_next)
             if (!e->dead && avahi_key_pattern_match(k, e->record->key) && avahi_entry_is_registered(s, e, i))
                 avahi_server_prepare_response(s, i, e, unicast_response, 0);
 
@@ -131,7 +133,7 @@ void avahi_server_prepare_matching_responses(AvahiServer *s, AvahiInterface *i,
 
         /* Handle all other queries */
 
-        for (e = avahi_hashmap_lookup(s->entries_by_key, k); e; e = e->by_key_next)
+        for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, k); e; e = e->by_key_next)
             if (!e->dead && avahi_entry_is_registered(s, e, i))
                 avahi_server_prepare_response(s, i, e, unicast_response, 0);
     }
@@ -153,7 +155,7 @@ void avahi_server_prepare_matching_responses(AvahiServer *s, AvahiInterface *i,
 
 static void withdraw_entry(AvahiServer *s, AvahiEntry *e) {
     assert(s);
-    assert(e);
+    assert(e && e->type == AVAHI_ENTRY_MDNS);
 
     /* Withdraw the specified entry, and if is part of an entry group,
      * put that into COLLISION state */
@@ -164,13 +166,16 @@ static void withdraw_entry(AvahiServer *s, AvahiEntry *e) {
     if (e->group) {
         AvahiEntry *k;
 
-        for (k = e->group->entries; k; k = k->by_group_next)
+        assert(e->group->type == AVAHI_GROUP_MDNS);
+        for (k = e->group->entries; k; k = k->by_group_next) {
+            assert(k->type == AVAHI_ENTRY_MDNS);
             if (!k->dead) {
                 avahi_goodbye_entry(s, k, 0, 1);
                 k->dead = 1;
             }
+        }
 
-        e->group->n_probing = 0;
+        e->group->proto.mdns.n_probing = 0;
 
         avahi_s_entry_group_change_state(e->group, AVAHI_ENTRY_GROUP_COLLISION);
     } else {
@@ -178,7 +183,7 @@ static void withdraw_entry(AvahiServer *s, AvahiEntry *e) {
         e->dead = 1;
     }
 
-    s->need_entry_cleanup = 1;
+    s->mdns.need_entry_cleanup = 1;
 }
 
 static void withdraw_rrset(AvahiServer *s, AvahiKey *key) {
@@ -189,7 +194,7 @@ static void withdraw_rrset(AvahiServer *s, AvahiKey *key) {
 
     /* Withdraw an entry RRSset */
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, key); e; e = e->by_key_next)
+    for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, key); e; e = e->by_key_next)
         withdraw_entry(s, e);
 }
 
@@ -203,7 +208,7 @@ static void incoming_probe(AvahiServer *s, AvahiRecord *record, AvahiInterface *
 
     /* Handle incoming probes and check if they conflict our own probes */
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, record->key); e; e = n) {
+    for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, record->key); e; e = n) {
         int cmp;
         n = e->by_key_next;
 
@@ -248,7 +253,8 @@ static int handle_conflict(AvahiServer *s, AvahiInterface *i, AvahiRecord *recor
 
     /* Check whether an incoming record conflicts with one of our own */
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, record->key); e; e = n) {
+    for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, record->key); e; e = n) {
+        assert(e->type == AVAHI_ENTRY_MDNS);
         n = e->by_key_next;
 
         if (e->dead)
@@ -350,7 +356,7 @@ static void append_aux_callback(AvahiServer *s, AvahiRecord *r, int flush_cache,
     assert(r);
     assert(unicast_response);
 
-    avahi_record_list_push(s->record_list, r, flush_cache, *unicast_response, 1);
+    avahi_record_list_push(s->mdns.record_list, r, flush_cache, *unicast_response, 1);
 }
 
 static void append_aux_records_to_list(AvahiServer *s, AvahiInterface *i, AvahiRecord *r, int unicast_response) {
@@ -373,7 +379,7 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
         if (!(reply = avahi_dns_packet_new_reply(p, 512 + AVAHI_DNS_PACKET_EXTRA_SIZE /* unicast DNS maximum packet size is 512 */ , 1, 1)))
             return; /* OOM */
 
-        while ((r = avahi_record_list_next(s->record_list, NULL, NULL, NULL))) {
+        while ((r = avahi_record_list_next(s->mdns.record_list, NULL, NULL, NULL))) {
 
             append_aux_records_to_list(s, i, r, 0);
 
@@ -389,7 +395,7 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
         }
 
         if (avahi_dns_packet_get_field(reply, AVAHI_DNS_FIELD_ANCOUNT) != 0)
-            avahi_interface_send_packet_unicast(i, reply, a, port);
+            avahi_interface_send_packet_unicast(i, reply, a, port, /*for fd*/ AVAHI_MDNS);
 
         avahi_dns_packet_free(reply);
 
@@ -403,7 +409,7 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
         contained in later packets */
         int tc = p && !!(avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_FLAGS) & AVAHI_DNS_FLAG_TC);
 
-        while ((r = avahi_record_list_next(s->record_list, &flush_cache, &unicast_response, &auxiliary))) {
+        while ((r = avahi_record_list_next(s->mdns.record_list, &flush_cache, &unicast_response, &auxiliary))) {
 
             int im = immediately;
 
@@ -412,7 +418,7 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
              * packet AND it is not an auxiliary record AND all other
              * responses for this record are unique too. */
 
-            if (flush_cache && !tc && !auxiliary && avahi_record_list_all_flush_cache(s->record_list))
+            if (flush_cache && !tc && !auxiliary && avahi_record_list_all_flush_cache(s->mdns.record_list))
                 im = 1;
 
             if (!avahi_interface_post_response(i, r, flush_cache, a, im) && unicast_response) {
@@ -477,7 +483,7 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
                     }
 
                     /* Appending the record didn't succeeed, so let's send this packet, and create a new one */
-                    avahi_interface_send_packet_unicast(i, reply, a, port);
+                    avahi_interface_send_packet_unicast(i, reply, a, port, AVAHI_MDNS);
                     avahi_dns_packet_free(reply);
                     reply = NULL;
                 }
@@ -488,12 +494,12 @@ void avahi_server_generate_response(AvahiServer *s, AvahiInterface *i, AvahiDnsP
 
         if (reply) {
             if (avahi_dns_packet_get_field(reply, AVAHI_DNS_FIELD_ANCOUNT) != 0)
-                avahi_interface_send_packet_unicast(i, reply, a, port);
+                avahi_interface_send_packet_unicast(i, reply, a, port, AVAHI_MDNS);
             avahi_dns_packet_free(reply);
         }
     }
 
-    avahi_record_list_flush(s->record_list);
+    avahi_record_list_flush(s->mdns.record_list);
 }
 
 static void reflect_response(AvahiServer *s, AvahiInterface *i, AvahiRecord *r, int flush_cache) {
@@ -527,7 +533,7 @@ static void* reflect_cache_walk_callback(AvahiCache *c, AvahiKey *pattern, Avahi
             (r->data.aaaa.address.address[1] == 0x80))
       return NULL;
 
-    avahi_record_list_push(s->record_list, e->record, e->cache_flush, 0, 0);
+    avahi_record_list_push(s->mdns.record_list, e->record, e->cache_flush, 0, 0);
     return NULL;
 }
 
@@ -549,7 +555,7 @@ static void reflect_query(AvahiServer *s, AvahiInterface *i, AvahiKey *k) {
             /* Reply from caches of other network. This is needed to
              * "work around" known answer suppression. */
 
-            avahi_cache_walk(j->cache, k, reflect_cache_walk_callback, s);
+            avahi_cache_walk(j->mdns.cache, k, reflect_cache_walk_callback, s);
         }
 }
 
@@ -577,7 +583,7 @@ static void handle_query_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterfac
     assert(i);
     assert(a);
 
-    assert(avahi_record_list_is_empty(s->record_list));
+    assert(avahi_record_list_is_empty(s->mdns.record_list));
 
     is_probe = avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_NSCOUNT) > 0;
 
@@ -594,14 +600,14 @@ static void handle_query_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterfac
         if (!legacy_unicast && !from_local_iface) {
             reflect_query(s, i, key);
             if (!unicast_response)
-              avahi_cache_start_poof(i->cache, key, a);
+              avahi_cache_start_poof(i->mdns.cache, key, a);
         }
 
         if (avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_ANCOUNT) == 0 &&
             !(avahi_dns_packet_get_field(p, AVAHI_DNS_FIELD_FLAGS) & AVAHI_DNS_FLAG_TC))
             /* Allow our own queries to be suppressed by incoming
              * queries only when they do not include known answers */
-            avahi_query_scheduler_incoming(i->query_scheduler, key);
+            avahi_query_scheduler_incoming(i->mdns.query_scheduler, key);
 
         avahi_server_prepare_matching_responses(s, i, key, unicast_response);
         avahi_key_unref(key);
@@ -619,9 +625,9 @@ static void handle_query_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterfac
                 goto fail;
             }
 
-            avahi_response_scheduler_suppress(i->response_scheduler, record, a);
-            avahi_record_list_drop(s->record_list, record);
-            avahi_cache_stop_poof(i->cache, record, a);
+            avahi_response_scheduler_suppress(i->mdns.response_scheduler, record, a);
+            avahi_record_list_drop(s->mdns.record_list, record);
+            avahi_cache_stop_poof(i->mdns.cache, record, a);
 
             avahi_record_unref(record);
         }
@@ -646,13 +652,13 @@ static void handle_query_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterfac
         }
     }
 
-    if (!avahi_record_list_is_empty(s->record_list))
+    if (!avahi_record_list_is_empty(s->mdns.record_list))
         avahi_server_generate_response(s, i, p, a, port, legacy_unicast, is_probe);
 
     return;
 
 fail:
-    avahi_record_list_flush(s->record_list);
+    avahi_record_list_flush(s->mdns.record_list);
 }
 
 static void handle_response_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInterface *i, const AvahiAddress *a, int from_local_iface) {
@@ -678,8 +684,8 @@ static void handle_response_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInter
             if (handle_conflict(s, i, record, cache_flush)) {
                 if (!from_local_iface && !avahi_record_is_link_local_address(record))
                     reflect_response(s, i, record, cache_flush);
-                avahi_cache_update(i->cache, record, cache_flush, a);
-                avahi_response_scheduler_incoming(i->response_scheduler, record, cache_flush);
+                avahi_cache_update(i->mdns.cache, record, cache_flush, a);
+                avahi_response_scheduler_incoming(i->mdns.response_scheduler, record, cache_flush);
             }
         }
 
@@ -689,7 +695,7 @@ static void handle_response_packet(AvahiServer *s, AvahiDnsPacket *p, AvahiInter
     /* If the incoming response contained a conflicting record, some
        records have been scheduled for sending. We need to flush them
        here. */
-    if (!avahi_record_list_is_empty(s->record_list))
+    if (!avahi_record_list_is_empty(s->mdns.record_list))
         avahi_server_generate_response(s, i, NULL, NULL, 0, 0, 1);
 }
 
@@ -819,14 +825,14 @@ static void reflect_legacy_unicast_query_packet(AvahiServer *s, AvahiDnsPacket *
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ID, slot->id);
 
     for (j = s->monitor->interfaces; j; j = j->interface_next)
-        if (j->announcing &&
+        if (j->mdns.announcing &&
             j != i &&
             (s->config.reflect_ipv || j->protocol == i->protocol)) {
 
-            if (j->protocol == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {
-                avahi_send_dns_packet_ipv4(s->fd_legacy_unicast_ipv4, j->hardware->index, p, NULL, NULL, 0);
-            } else if (j->protocol == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0)
-                avahi_send_dns_packet_ipv6(s->fd_legacy_unicast_ipv6, j->hardware->index, p, NULL, NULL, 0);
+            if (j->protocol == AVAHI_PROTO_INET && s->mdns.fd_legacy_unicast_ipv4 >= 0) {
+                avahi_send_dns_packet_ipv4(s->mdns.fd_legacy_unicast_ipv4, j->hardware->index, p, NULL, NULL, 0, AVAHI_MDNS);
+            } else if (j->protocol == AVAHI_PROTO_INET6 && s->mdns.fd_legacy_unicast_ipv6 >= 0)
+                avahi_send_dns_packet_ipv6(s->mdns.fd_legacy_unicast_ipv6, j->hardware->index, p, NULL, NULL, 0, AVAHI_MDNS);
         }
 
     /* Reset the id */
@@ -844,22 +850,22 @@ static int originates_from_local_legacy_unicast_socket(AvahiServer *s, const Ava
     if (!avahi_address_is_local(s->monitor, address))
         return 0;
 
-    if (address->proto == AVAHI_PROTO_INET && s->fd_legacy_unicast_ipv4 >= 0) {
+    if (address->proto == AVAHI_PROTO_INET && s->mdns.fd_legacy_unicast_ipv4 >= 0) {
         struct sockaddr_in lsa;
         socklen_t l = sizeof(lsa);
 
-        if (getsockname(s->fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)
+        if (getsockname(s->mdns.fd_legacy_unicast_ipv4, (struct sockaddr*) &lsa, &l) != 0)
             avahi_log_warn("getsockname(): %s", strerror(errno));
         else
             return avahi_port_from_sockaddr((struct sockaddr*) &lsa) == port;
 
     }
 
-    if (address->proto == AVAHI_PROTO_INET6 && s->fd_legacy_unicast_ipv6 >= 0) {
+    if (address->proto == AVAHI_PROTO_INET6 && s->mdns.fd_legacy_unicast_ipv6 >= 0) {
         struct sockaddr_in6 lsa;
         socklen_t l = sizeof(lsa);
 
-        if (getsockname(s->fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)
+        if (getsockname(s->mdns.fd_legacy_unicast_ipv6, (struct sockaddr*) &lsa, &l) != 0)
             avahi_log_warn("getsockname(): %s", strerror(errno));
         else
             return avahi_port_from_sockaddr((struct sockaddr*) &lsa) == port;
@@ -900,7 +906,7 @@ static void dispatch_packet(AvahiServer *s, AvahiDnsPacket *p, const AvahiAddres
     assert(src_address->proto == dst_address->proto);
 
     if (!(i = avahi_interface_monitor_get_interface(s->monitor, iface, src_address->proto)) ||
-        !i->announcing) {
+        !i->mdns.announcing) {
         avahi_log_warn("Received packet from invalid interface.");
         return;
     }
@@ -1002,14 +1008,14 @@ static void dispatch_legacy_unicast_packet(AvahiServer *s, AvahiDnsPacket *p) {
     }
 
     if (!(j = avahi_interface_monitor_get_interface(s->monitor, slot->interface, slot->address.proto)) ||
-        !j->announcing)
+        !j->mdns.announcing)
         return;
 
     /* Patch the original ID into this response */
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ID, slot->original_id);
 
     /* Forward the response to the correct client */
-    avahi_interface_send_packet_unicast(j, p, &slot->address, slot->port);
+    avahi_interface_send_packet_unicast(j, p, &slot->address, slot->port, AVAHI_MDNS);
 
     /* Undo changes to packet */
     avahi_dns_packet_set_field(p, AVAHI_DNS_FIELD_ID, slot->id);
@@ -1027,13 +1033,13 @@ static void mcast_socket_event(AvahiWatch *w, int fd, AvahiWatchEvent events, vo
     assert(fd >= 0);
     assert(events & AVAHI_WATCH_IN);
 
-    if (fd == s->fd_ipv4) {
+    if (fd == s->mdns.fd_ipv4) {
         dest.proto = src.proto = AVAHI_PROTO_INET;
-        p = avahi_recv_dns_packet_ipv4(s->fd_ipv4, &src.data.ipv4, &port, &dest.data.ipv4, &iface, &ttl);
+        p = avahi_recv_dns_packet_ipv4(s->mdns.fd_ipv4, &src.data.ipv4, &port, &dest.data.ipv4, &iface, &ttl);
     } else {
-        assert(fd == s->fd_ipv6);
+        assert(fd == s->mdns.fd_ipv6);
         dest.proto = src.proto = AVAHI_PROTO_INET6;
-        p = avahi_recv_dns_packet_ipv6(s->fd_ipv6, &src.data.ipv6, &port, &dest.data.ipv6, &iface, &ttl);
+        p = avahi_recv_dns_packet_ipv6(s->mdns.fd_ipv6, &src.data.ipv6, &port, &dest.data.ipv6, &iface, &ttl);
     }
 
     if (p) {
@@ -1059,11 +1065,11 @@ static void legacy_unicast_socket_event(AvahiWatch *w, int fd, AvahiWatchEvent e
     assert(fd >= 0);
     assert(events & AVAHI_WATCH_IN);
 
-    if (fd == s->fd_legacy_unicast_ipv4)
-        p = avahi_recv_dns_packet_ipv4(s->fd_legacy_unicast_ipv4, NULL, NULL, NULL, NULL, NULL);
+    if (fd == s->mdns.fd_legacy_unicast_ipv4)
+        p = avahi_recv_dns_packet_ipv4(s->mdns.fd_legacy_unicast_ipv4, NULL, NULL, NULL, NULL, NULL);
     else {
-        assert(fd == s->fd_legacy_unicast_ipv6);
-        p = avahi_recv_dns_packet_ipv6(s->fd_legacy_unicast_ipv6, NULL, NULL, NULL, NULL, NULL);
+        assert(fd == s->mdns.fd_legacy_unicast_ipv6);
+        p = avahi_recv_dns_packet_ipv6(s->mdns.fd_legacy_unicast_ipv6, NULL, NULL, NULL, NULL, NULL);
     }
 
     if (p) {
@@ -1091,11 +1097,11 @@ static void server_set_state(AvahiServer *s, AvahiServerState state) {
 static void withdraw_host_rrs(AvahiServer *s) {
     assert(s);
 
-    if (s->hinfo_entry_group)
-        avahi_s_entry_group_reset(s->hinfo_entry_group);
+    if (s->mdns.hinfo_entry_group)
+        avahi_s_entry_group_reset(s->mdns.hinfo_entry_group);
 
-    if (s->browse_domain_entry_group)
-        avahi_s_entry_group_reset(s->browse_domain_entry_group);
+    if (s->mdns.browse_domain_entry_group)
+        avahi_s_entry_group_reset(s->mdns.browse_domain_entry_group);
 
     avahi_interface_monitor_update_rrs(s->monitor, 1);
     s->n_host_rr_pending = 0;
@@ -1106,24 +1112,26 @@ void avahi_server_decrease_host_rr_pending(AvahiServer *s) {
 
     assert(s->n_host_rr_pending > 0);
 
-    if (--s->n_host_rr_pending == 0)
+    if (--s->n_host_rr_pending == 0) {
         server_set_state(s, AVAHI_SERVER_RUNNING);
+        avahi_log_info("\nAll host RR's have been announced/verified : SERVER RUNNING");
+    }
 }
 
 void avahi_host_rr_entry_group_callback(AvahiServer *s, AvahiSEntryGroup *g, AvahiEntryGroupState state, AVAHI_GCC_UNUSED void *userdata) {
     assert(s);
     assert(g);
 
-    if (state == AVAHI_ENTRY_GROUP_REGISTERING &&
+    if ((state == AVAHI_ENTRY_GROUP_REGISTERING || state == AVAHI_ENTRY_GROUP_LLMNR_VERIFYING) &&
         s->state == AVAHI_SERVER_REGISTERING)
         s->n_host_rr_pending ++;
 
-    else if (state == AVAHI_ENTRY_GROUP_COLLISION &&
+    else if ((state == AVAHI_ENTRY_GROUP_COLLISION || state == AVAHI_ENTRY_GROUP_LLMNR_COLLISION) &&
         (s->state == AVAHI_SERVER_REGISTERING || s->state == AVAHI_SERVER_RUNNING)) {
         withdraw_host_rrs(s);
         server_set_state(s, AVAHI_SERVER_COLLISION);
 
-    } else if (state == AVAHI_ENTRY_GROUP_ESTABLISHED &&
+    } else if ((state == AVAHI_ENTRY_GROUP_ESTABLISHED || state == AVAHI_ENTRY_GROUP_LLMNR_ESTABLISHED) &&
                s->state == AVAHI_SERVER_REGISTERING)
         avahi_server_decrease_host_rr_pending(s);
 }
@@ -1137,12 +1145,12 @@ static void register_hinfo(AvahiServer *s) {
     if (!s->config.publish_hinfo)
         return;
 
-    if (s->hinfo_entry_group)
-        assert(avahi_s_entry_group_is_empty(s->hinfo_entry_group));
+    if (s->mdns.hinfo_entry_group)
+        assert(avahi_s_entry_group_is_empty(s->mdns.hinfo_entry_group));
     else
-        s->hinfo_entry_group = avahi_s_entry_group_new(s, avahi_host_rr_entry_group_callback, NULL);
+        s->mdns.hinfo_entry_group = avahi_s_entry_group_new(s, avahi_host_rr_entry_group_callback, NULL);
 
-    if (!s->hinfo_entry_group) {
+    if (!s->mdns.hinfo_entry_group) {
         avahi_log_warn("Failed to create HINFO entry group: %s", avahi_strerror(s->error));
         return;
     }
@@ -1159,7 +1167,7 @@ static void register_hinfo(AvahiServer *s) {
 
             avahi_log_info("Registering HINFO record with values '%s'/'%s'.", r->data.hinfo.cpu, r->data.hinfo.os);
 
-            if (avahi_server_add(s, s->hinfo_entry_group, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_UNIQUE, r) < 0) {
+            if (avahi_server_add(s, s->mdns.hinfo_entry_group, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_UNIQUE, r) < 0) {
                 avahi_log_warn("Failed to add HINFO RR: %s", avahi_strerror(s->error));
                 return;
             }
@@ -1168,7 +1176,7 @@ static void register_hinfo(AvahiServer *s) {
         avahi_record_unref(r);
     }
 
-    if (avahi_s_entry_group_commit(s->hinfo_entry_group) < 0)
+    if (avahi_s_entry_group_commit(s->mdns.hinfo_entry_group) < 0)
         avahi_log_warn("Failed to commit HINFO entry group: %s", avahi_strerror(s->error));
 
 }
@@ -1179,10 +1187,12 @@ static void register_localhost(AvahiServer *s) {
 
     /* Add localhost entries */
     avahi_address_parse("127.0.0.1", AVAHI_PROTO_INET, &a);
-    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_PROBE|AVAHI_PUBLISH_NO_ANNOUNCE, "localhost", &a);
+    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_PROBE|AVAHI_PUBLISH_NO_ANNOUNCE|AVAHI_PUBLISH_USE_MULTICAST, "localhost", &a);
+    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_VERIFY|AVAHI_PUBLISH_USE_LLMNR, "localhost", &a);
 
     avahi_address_parse("::1", AVAHI_PROTO_INET6, &a);
-    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_PROBE|AVAHI_PUBLISH_NO_ANNOUNCE, "ip6-localhost", &a);
+    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_PROBE|AVAHI_PUBLISH_NO_ANNOUNCE|AVAHI_PUBLISH_USE_MULTICAST, "ip6-localhost", &a);
+    avahi_server_add_address(s, NULL, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, AVAHI_PUBLISH_NO_VERIFY|AVAHI_PUBLISH_USE_LLMNR, "ip6-localhost", &a);
 }
 
 static void register_browse_domain(AvahiServer *s) {
@@ -1194,22 +1204,22 @@ static void register_browse_domain(AvahiServer *s) {
     if (avahi_domain_equal(s->domain_name, "local"))
         return;
 
-    if (s->browse_domain_entry_group)
-        assert(avahi_s_entry_group_is_empty(s->browse_domain_entry_group));
+    if (s->mdns.browse_domain_entry_group)
+        assert(avahi_s_entry_group_is_empty(s->mdns.browse_domain_entry_group));
     else
-        s->browse_domain_entry_group = avahi_s_entry_group_new(s, NULL, NULL);
+        s->mdns.browse_domain_entry_group = avahi_s_entry_group_new(s, NULL, NULL);
 
-    if (!s->browse_domain_entry_group) {
+    if (!s->mdns.browse_domain_entry_group) {
         avahi_log_warn("Failed to create browse domain entry group: %s", avahi_strerror(s->error));
         return;
     }
 
-    if (avahi_server_add_ptr(s, s->browse_domain_entry_group, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, 0, AVAHI_DEFAULT_TTL, "b._dns-sd._udp.local", s->domain_name) < 0) {
+    if (avahi_server_add_ptr(s, s->mdns.browse_domain_entry_group, AVAHI_IF_UNSPEC, AVAHI_PROTO_UNSPEC, 0, AVAHI_DEFAULT_TTL, "b._dns-sd._udp.local", s->domain_name) < 0) {
         avahi_log_warn("Failed to add browse domain RR: %s", avahi_strerror(s->error));
         return;
     }
 
-    if (avahi_s_entry_group_commit(s->browse_domain_entry_group) < 0)
+    if (avahi_s_entry_group_commit(s->mdns.browse_domain_entry_group) < 0)
         avahi_log_warn("Failed to commit browse domain entry group: %s", avahi_strerror(s->error));
 }
 
@@ -1325,34 +1335,34 @@ static int valid_server_config(const AvahiServerConfig *sc) {
 static int setup_sockets(AvahiServer *s) {
     assert(s);
 
-    s->fd_ipv4 = s->config.use_ipv4 ? avahi_open_socket_ipv4(s->config.disallow_other_stacks) : -1;
-    s->fd_ipv6 = s->config.use_ipv6 ? avahi_open_socket_ipv6(s->config.disallow_other_stacks) : -1;
+    s->mdns.fd_ipv4 = s->config.use_ipv4 ? avahi_open_socket_ipv4(s->config.disallow_other_stacks, AVAHI_MDNS) : -1;
+    s->mdns.fd_ipv6 = s->config.use_ipv6 ? avahi_open_socket_ipv6(s->config.disallow_other_stacks, AVAHI_MDNS) : -1;
 
-    if (s->fd_ipv6 < 0 && s->fd_ipv4 < 0)
+    if (s->mdns.fd_ipv6 < 0 && s->mdns.fd_ipv4 < 0)
         return AVAHI_ERR_NO_NETWORK;
 
-    if (s->fd_ipv4 < 0 && s->config.use_ipv4)
-        avahi_log_notice("Failed to create IPv4 socket, proceeding in IPv6 only mode");
-    else if (s->fd_ipv6 < 0 && s->config.use_ipv6)
-        avahi_log_notice("Failed to create IPv6 socket, proceeding in IPv4 only mode");
+    if (s->mdns.fd_ipv4 < 0 && s->config.use_ipv4)
+        avahi_log_notice("Failed to create IPv4 mDNS socket, proceeding in IPv6 only mode");
+    else if (s->mdns.fd_ipv6 < 0 && s->config.use_ipv6)
+        avahi_log_notice("Failed to create IPv6 mDNS socket, proceeding in IPv4 only mode");
 
-    s->fd_legacy_unicast_ipv4 = s->fd_ipv4 >= 0 && s->config.enable_reflector ? avahi_open_unicast_socket_ipv4() : -1;
-    s->fd_legacy_unicast_ipv6 = s->fd_ipv6 >= 0 && s->config.enable_reflector ? avahi_open_unicast_socket_ipv6() : -1;
+    s->mdns.fd_legacy_unicast_ipv4 = s->mdns.fd_ipv4 >= 0 && s->config.enable_reflector ? avahi_open_unicast_socket_ipv4() : -1;
+    s->mdns.fd_legacy_unicast_ipv6 = s->mdns.fd_ipv6 >= 0 && s->config.enable_reflector ? avahi_open_unicast_socket_ipv6() : -1;
 
-    s->watch_ipv4 =
-        s->watch_ipv6 =
-        s->watch_legacy_unicast_ipv4 =
-        s->watch_legacy_unicast_ipv6 = NULL;
+    s->mdns.watch_ipv4 =
+    s->mdns.watch_ipv6 =
+    s->mdns.watch_legacy_unicast_ipv4 =
+    s->mdns.watch_legacy_unicast_ipv6 = NULL;
 
-    if (s->fd_ipv4 >= 0)
-        s->watch_ipv4 = s->poll_api->watch_new(s->poll_api, s->fd_ipv4, AVAHI_WATCH_IN, mcast_socket_event, s);
-    if (s->fd_ipv6 >= 0)
-        s->watch_ipv6 = s->poll_api->watch_new(s->poll_api, s->fd_ipv6, AVAHI_WATCH_IN, mcast_socket_event, s);
+    if (s->mdns.fd_ipv4 >= 0)
+        s->mdns.watch_ipv4 = s->poll_api->watch_new(s->poll_api, s->mdns.fd_ipv4, AVAHI_WATCH_IN, mcast_socket_event, s);
+    if (s->mdns.fd_ipv6 >= 0)
+        s->mdns.watch_ipv6 = s->poll_api->watch_new(s->poll_api, s->mdns.fd_ipv6, AVAHI_WATCH_IN, mcast_socket_event, s);
 
-    if (s->fd_legacy_unicast_ipv4 >= 0)
-        s->watch_legacy_unicast_ipv4 = s->poll_api->watch_new(s->poll_api, s->fd_legacy_unicast_ipv4, AVAHI_WATCH_IN, legacy_unicast_socket_event, s);
-    if (s->fd_legacy_unicast_ipv6 >= 0)
-        s->watch_legacy_unicast_ipv6 = s->poll_api->watch_new(s->poll_api, s->fd_legacy_unicast_ipv6, AVAHI_WATCH_IN, legacy_unicast_socket_event, s);
+    if (s->mdns.fd_legacy_unicast_ipv4 >= 0)
+        s->mdns.watch_legacy_unicast_ipv4 = s->poll_api->watch_new(s->poll_api, s->mdns.fd_legacy_unicast_ipv4, AVAHI_WATCH_IN, legacy_unicast_socket_event, s);
+    if (s->mdns.fd_legacy_unicast_ipv6 >= 0)
+        s->mdns.watch_legacy_unicast_ipv6 = s->poll_api->watch_new(s->poll_api, s->mdns.fd_legacy_unicast_ipv6, AVAHI_WATCH_IN, legacy_unicast_socket_event, s);
 
     return 0;
 }
@@ -1391,13 +1401,25 @@ AvahiServer *avahi_server_new(const AvahiPoll *poll_api, const AvahiServerConfig
         return NULL;
     }
 
+    if ((e = setup_llmnr_sockets(s)) < 0) {
+        if (error)
+            *error = e;
+
+        avahi_server_config_free(&s->config);
+        avahi_free(s);
+
+        return NULL;
+    }
+
     s->n_host_rr_pending = 0;
-    s->need_entry_cleanup = 0;
-    s->need_group_cleanup = 0;
+    s->mdns.need_entry_cleanup = 0;
+    s->mdns.need_group_cleanup = 0;
+    s->llmnr.need_entry_cleanup = 0;
+    s->llmnr.need_group_cleanup = 0;
     s->need_browser_cleanup = 0;
     s->cleanup_time_event = NULL;
-    s->hinfo_entry_group = NULL;
-    s->browse_domain_entry_group = NULL;
+    s->mdns.hinfo_entry_group = NULL;
+    s->mdns.browse_domain_entry_group = NULL;
     s->error = AVAHI_OK;
     s->state = AVAHI_SERVER_INVALID;
 
@@ -1406,9 +1428,14 @@ AvahiServer *avahi_server_new(const AvahiPoll *poll_api, const AvahiServerConfig
 
     s->time_event_queue = avahi_time_event_queue_new(poll_api);
 
-    s->entries_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
-    AVAHI_LLIST_HEAD_INIT(AvahiEntry, s->entries);
-    AVAHI_LLIST_HEAD_INIT(AvahiGroup, s->groups);
+    s->mdns.entries_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
+    s->llmnr.entries_by_key = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
+
+    AVAHI_LLIST_HEAD_INIT(AvahiEntry, s->mdns.entries);
+    AVAHI_LLIST_HEAD_INIT(AvahiEntry, s->llmnr.entries);
+
+    AVAHI_LLIST_HEAD_INIT(AvahiGroup, s->mdns.groups);
+    AVAHI_LLIST_HEAD_INIT(AvahiGroup, s->llmnr.groups);
 
     s->record_browser_hashmap = avahi_hashmap_new((AvahiHashFunc) avahi_key_hash, (AvahiEqualFunc) avahi_key_equal, NULL, NULL);
     AVAHI_LLIST_HEAD_INIT(AvahiSRecordBrowser, s->record_browsers);
@@ -1423,7 +1450,8 @@ AvahiServer *avahi_server_new(const AvahiPoll *poll_api, const AvahiServerConfig
     s->legacy_unicast_reflect_slots = NULL;
     s->legacy_unicast_reflect_id = 0;
 
-    s->record_list = avahi_record_list_new();
+    s->mdns.record_list = avahi_record_list_new();
+    s->llmnr.record_list = avahi_record_list_new();
 
     /* Get host name */
     s->host_name = s->config.host_name ? avahi_normalize_name_strdup(s->config.host_name) : avahi_get_host_name_strdup();
@@ -1437,12 +1465,13 @@ AvahiServer *avahi_server_new(const AvahiPoll *poll_api, const AvahiServerConfig
     } while (s->local_service_cookie == AVAHI_SERVICE_COOKIE_INVALID);
 
     if (s->config.enable_wide_area) {
-        s->wide_area_lookup_engine = avahi_wide_area_engine_new(s);
-        avahi_wide_area_set_servers(s->wide_area_lookup_engine, s->config.wide_area_servers, s->config.n_wide_area_servers);
+        s->wide_area.wide_area_lookup_engine = avahi_wide_area_engine_new(s);
+        avahi_wide_area_set_servers(s->wide_area.wide_area_lookup_engine, s->config.wide_area_servers, s->config.n_wide_area_servers);
     } else
-        s->wide_area_lookup_engine = NULL;
+        s->wide_area.wide_area_lookup_engine = NULL;
 
-    s->multicast_lookup_engine = avahi_multicast_lookup_engine_new(s);
+    s->mdns.multicast_lookup_engine = avahi_multicast_lookup_engine_new(s);
+    s->llmnr.llmnr_lookup_engine = avahi_llmnr_lookup_engine_new(s);
 
     s->monitor = avahi_interface_monitor_new(s);
     avahi_interface_monitor_sync(s->monitor);
@@ -1477,23 +1506,28 @@ void avahi_server_free(AvahiServer* s) {
 
     /* Remove all locally rgeistered stuff */
 
-    while(s->entries)
-        avahi_entry_free(s, s->entries);
+    while (s->mdns.entries)
+        avahi_entry_free(s, s->mdns.entries);
+
+    while (s->llmnr.entries)
+        avahi_entry_free(s, s->llmnr.entries);
 
     avahi_interface_monitor_free(s->monitor);
+    free_slots(s);
 
-    while (s->groups)
-        avahi_entry_group_free(s, s->groups);
+    avahi_hashmap_free(s->mdns.entries_by_key);
+    avahi_hashmap_free(s->llmnr.entries_by_key);
 
-    free_slots(s);
+    avahi_record_list_free(s->mdns.record_list);
+    avahi_record_list_free(s->llmnr.record_list);
 
-    avahi_hashmap_free(s->entries_by_key);
-    avahi_record_list_free(s->record_list);
     avahi_hashmap_free(s->record_browser_hashmap);
 
-    if (s->wide_area_lookup_engine)
-        avahi_wide_area_engine_free(s->wide_area_lookup_engine);
-    avahi_multicast_lookup_engine_free(s->multicast_lookup_engine);
+    if (s->wide_area.wide_area_lookup_engine)
+        avahi_wide_area_engine_free(s->wide_area.wide_area_lookup_engine);
+
+    avahi_multicast_lookup_engine_free(s->mdns.multicast_lookup_engine);
+    avahi_llmnr_lookup_engine_free(s->llmnr.llmnr_lookup_engine);
 
     if (s->cleanup_time_event)
         avahi_time_event_free(s->cleanup_time_event);
@@ -1502,27 +1536,37 @@ void avahi_server_free(AvahiServer* s) {
 
     /* Free watches */
 
-    if (s->watch_ipv4)
-        s->poll_api->watch_free(s->watch_ipv4);
-    if (s->watch_ipv6)
-        s->poll_api->watch_free(s->watch_ipv6);
+    if (s->mdns.watch_ipv4)
+        s->poll_api->watch_free(s->mdns.watch_ipv4);
+    if (s->mdns.watch_ipv6)
+        s->poll_api->watch_free(s->mdns.watch_ipv6);
+
+    if (s->mdns.watch_legacy_unicast_ipv4)
+        s->poll_api->watch_free(s->mdns.watch_legacy_unicast_ipv4);
+    if (s->mdns.watch_legacy_unicast_ipv6)
+        s->poll_api->watch_free(s->mdns.watch_legacy_unicast_ipv6);
 
-    if (s->watch_legacy_unicast_ipv4)
-        s->poll_api->watch_free(s->watch_legacy_unicast_ipv4);
-    if (s->watch_legacy_unicast_ipv6)
-        s->poll_api->watch_free(s->watch_legacy_unicast_ipv6);
+    if (s->llmnr.watch_ipv4)
+        s->poll_api->watch_free(s->llmnr.watch_ipv4);
+    if (s->llmnr.watch_ipv6)
+        s->poll_api->watch_free(s->llmnr.watch_ipv6);
 
     /* Free sockets */
 
-    if (s->fd_ipv4 >= 0)
-        close(s->fd_ipv4);
-    if (s->fd_ipv6 >= 0)
-        close(s->fd_ipv6);
+    if (s->mdns.fd_ipv4 >= 0)
+        close(s->mdns.fd_ipv4);
+    if (s->mdns.fd_ipv6 >= 0)
+        close(s->mdns.fd_ipv6);
+
+    if (s->mdns.fd_legacy_unicast_ipv4 >= 0)
+        close(s->mdns.fd_legacy_unicast_ipv4);
+    if (s->mdns.fd_legacy_unicast_ipv6 >= 0)
+        close(s->mdns.fd_legacy_unicast_ipv6);
 
-    if (s->fd_legacy_unicast_ipv4 >= 0)
-        close(s->fd_legacy_unicast_ipv4);
-    if (s->fd_legacy_unicast_ipv6 >= 0)
-        close(s->fd_legacy_unicast_ipv6);
+    if (s->llmnr.fd_ipv4 >= 0)
+        close(s->llmnr.fd_ipv4);
+    if (s->llmnr.fd_ipv6 >= 0)
+        close(s->mdns.fd_ipv6);
 
     /* Free other stuff */
 
@@ -1687,13 +1731,15 @@ static AvahiEntry *find_entry(AvahiServer *s, AvahiIfIndex interface, AvahiProto
     assert(s);
     assert(key);
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, key); e; e = e->by_key_next)
+    for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, key); e; e = e->by_key_next) {
 
+        assert(e->type == AVAHI_ENTRY_MDNS);
         if ((e->interface == interface || e->interface <= 0 || interface <= 0) &&
             (e->protocol == protocol || e->protocol == AVAHI_PROTO_UNSPEC || protocol == AVAHI_PROTO_UNSPEC) &&
             (!e->group || e->group->state == AVAHI_ENTRY_GROUP_ESTABLISHED || e->group->state == AVAHI_ENTRY_GROUP_REGISTERING))
 
             return e;
+    }
 
     return NULL;
 }
@@ -1760,13 +1806,15 @@ int avahi_server_is_record_local(AvahiServer *s, AvahiIfIndex interface, AvahiPr
     assert(s);
     assert(record);
 
-    for (e = avahi_hashmap_lookup(s->entries_by_key, record->key); e; e = e->by_key_next)
+    for (e = avahi_hashmap_lookup(s->mdns.entries_by_key, record->key); e; e = e->by_key_next) {
 
+        assert(e->type == AVAHI_ENTRY_MDNS);
         if ((e->interface == interface || e->interface <= 0 || interface <= 0) &&
             (e->protocol == protocol || e->protocol == AVAHI_PROTO_UNSPEC || protocol == AVAHI_PROTO_UNSPEC) &&
             (!e->group || e->group->state == AVAHI_ENTRY_GROUP_ESTABLISHED || e->group->state == AVAHI_ENTRY_GROUP_REGISTERING) &&
             avahi_record_equal_no_ttl(record, e->record))
             return 1;
+    }
 
     return 0;
 }
@@ -1775,10 +1823,10 @@ int avahi_server_is_record_local(AvahiServer *s, AvahiIfIndex interface, AvahiPr
 int avahi_server_set_wide_area_servers(AvahiServer *s, const AvahiAddress *a, unsigned n) {
     assert(s);
 
-    if (!s->wide_area_lookup_engine)
+    if (!s->wide_area.wide_area_lookup_engine)
         return avahi_server_set_errno(s, AVAHI_ERR_INVALID_CONFIG);
 
-    avahi_wide_area_set_servers(s->wide_area_lookup_engine, a, n);
+    avahi_wide_area_set_servers(s->wide_area.wide_area_lookup_engine, a, n);
     return AVAHI_OK;
 }
 
diff --git a/avahi-core/socket.c b/avahi-core/socket.c
index 17ab6e5..b3328db 100644
--- a/avahi-core/socket.c
+++ b/avahi-core/socket.c
@@ -64,22 +64,22 @@
 #endif
 #endif
 
-static void mdns_mcast_group_ipv4(struct sockaddr_in *ret_sa) {
+static void mcast_group_ipv4(struct sockaddr_in *ret_sa, AvahiPublishProtocol proto) {
     assert(ret_sa);
 
     memset(ret_sa, 0, sizeof(struct sockaddr_in));
     ret_sa->sin_family = AF_INET;
-    ret_sa->sin_port = htons(AVAHI_MDNS_PORT);
-    inet_pton(AF_INET, AVAHI_IPV4_MCAST_GROUP, &ret_sa->sin_addr);
+    ret_sa->sin_port = htons(proto == AVAHI_LLMNR ? AVAHI_LLMNR_PORT : AVAHI_MDNS_PORT );
+    inet_pton(AF_INET, proto == AVAHI_LLMNR ? AVAHI_IPV4_LLMNR_GROUP : AVAHI_IPV4_MCAST_GROUP, &ret_sa->sin_addr);
 }
 
-static void mdns_mcast_group_ipv6(struct sockaddr_in6 *ret_sa) {
+static void mcast_group_ipv6(struct sockaddr_in6 *ret_sa, AvahiPublishProtocol proto) {
     assert(ret_sa);
 
     memset(ret_sa, 0, sizeof(struct sockaddr_in6));
     ret_sa->sin6_family = AF_INET6;
-    ret_sa->sin6_port = htons(AVAHI_MDNS_PORT);
-    inet_pton(AF_INET6, AVAHI_IPV6_MCAST_GROUP, &ret_sa->sin6_addr);
+    ret_sa->sin6_port = htons(proto == AVAHI_LLMNR ? AVAHI_LLMNR_PORT : AVAHI_MDNS_PORT );
+    inet_pton(AF_INET6, proto == AVAHI_LLMNR ? AVAHI_IPV6_LLMNR_GROUP : AVAHI_IPV6_MCAST_GROUP , &ret_sa->sin6_addr);
 }
 
 static void ipv4_address_to_sockaddr(struct sockaddr_in *ret_sa, const AvahiIPv4Address *a, uint16_t port) {
@@ -104,7 +104,7 @@ static void ipv6_address_to_sockaddr(struct sockaddr_in6 *ret_sa, const AvahiIPv
     memcpy(&ret_sa->sin6_addr, a, sizeof(AvahiIPv6Address));
 }
 
-int avahi_mdns_mcast_join_ipv4(int fd, const AvahiIPv4Address *a, int idx, int join) {
+int avahi_mcast_join_ipv4(int fd, const AvahiIPv4Address *a, int idx, int join, AvahiPublishProtocol proto) {
 #ifdef HAVE_STRUCT_IP_MREQN
     struct ip_mreqn mreq;
 #else
@@ -118,12 +118,20 @@ int avahi_mdns_mcast_join_ipv4(int fd, const AvahiIPv4Address *a, int idx, int j
 
     memset(&mreq, 0, sizeof(mreq));
 #ifdef HAVE_STRUCT_IP_MREQN
+/*
+    imr_ifindex and imr_address will remain same 
+    for both of the multicsat groups.
+*/
     mreq.imr_ifindex = idx;
     mreq.imr_address.s_addr = a->address;
 #else
     mreq.imr_interface.s_addr = a->address;
 #endif
-    mdns_mcast_group_ipv4(&sa);
+/*
+    send proto for 'sa' to joing appropiate 
+    multicast group.
+*/
+    mcast_group_ipv4(&sa, proto);
     mreq.imr_multiaddr = sa.sin_addr;
 
     /* Some network drivers have issues with dropping membership of
@@ -140,7 +148,7 @@ int avahi_mdns_mcast_join_ipv4(int fd, const AvahiIPv4Address *a, int idx, int j
     return 0;
 }
 
-int avahi_mdns_mcast_join_ipv6(int fd, const AvahiIPv6Address *a, int idx, int join) {
+int avahi_mcast_join_ipv6(int fd, const AvahiIPv6Address *a, int idx, int join, AvahiPublishProtocol proto) {
     struct ipv6_mreq mreq6;
     struct sockaddr_in6 sa6;
 
@@ -149,7 +157,11 @@ int avahi_mdns_mcast_join_ipv6(int fd, const AvahiIPv6Address *a, int idx, int j
     assert(a);
 
     memset(&mreq6, 0, sizeof(mreq6));
-    mdns_mcast_group_ipv6 (&sa6);
+/*
+    send proto for 'sa6' to join appropiate
+    multicast group
+*/
+    mcast_group_ipv6 (&sa6, proto);
     mreq6.ipv6mr_multiaddr = sa6.sin6_addr;
     mreq6.ipv6mr_interface = idx;
 
@@ -197,8 +209,8 @@ static int bind_with_warn(int fd, const struct sockaddr *sa, socklen_t l) {
             return -1;
         }
 
-        avahi_log_warn("*** WARNING: Detected another %s mDNS stack running on this host. This makes mDNS unreliable and is thus not recommended. ***",
-                       sa->sa_family == AF_INET ? "IPv4" : "IPv6");
+        avahi_log_warn("*** WARNING: Detected another %s %s stack running on this host. This makes mDNS unreliable and is thus not recommended. ***",
+                       sa->sa_family == AF_INET ? "IPv4" : "IPv6","mDNS/LLMNR");
 
         /* Try again, this time with SO_REUSEADDR set */
         if (reuseaddr(fd) < 0)
@@ -211,7 +223,7 @@ static int bind_with_warn(int fd, const struct sockaddr *sa, socklen_t l) {
     } else {
 
         /* We enable SO_REUSEADDR afterwards, to make sure that the
-         * user may run other mDNS implementations if he really
+         * user may run other mDNS/LLMNR implementations if he really
          * wants. */
 
         if (reuseaddr(fd) < 0)
@@ -307,7 +319,7 @@ static int ipv6_pktinfo(int fd) {
     return 0;
 }
 
-int avahi_open_socket_ipv4(int no_reuse) {
+int avahi_open_socket_ipv4(int no_reuse,AvahiPublishProtocol proto) {
     struct sockaddr_in local;
     int fd = -1, r, ittl;
     uint8_t ttl, cyes;
@@ -337,7 +349,14 @@ int avahi_open_socket_ipv4(int no_reuse) {
 
     memset(&local, 0, sizeof(local));
     local.sin_family = AF_INET;
-    local.sin_port = htons(AVAHI_MDNS_PORT);
+/*
+    Here we define only port of local structure because this 
+    socket is used by AvahiServer and is used to join multicast 
+    group. we pick the address further from local interface
+    and joing the group.(ip_mreqn)
+    avahi_mcast_join_ipv4()/6
+*/
+    local.sin_port = htons(proto == AVAHI_LLMNR ? AVAHI_LLMNR_PORT : AVAHI_MDNS_PORT);
 
     if (no_reuse)
         r = bind(fd, (struct sockaddr*) &local, sizeof(local));
@@ -369,12 +388,12 @@ fail:
     return -1;
 }
 
-int avahi_open_socket_ipv6(int no_reuse) {
+int avahi_open_socket_ipv6(int no_reuse,AvahiPublishProtocol proto) {
     struct sockaddr_in6 sa, local;
     int fd = -1, yes, r;
     int ttl;
 
-    mdns_mcast_group_ipv6(&sa);
+    mcast_group_ipv6(&sa, proto);
 
     if ((fd = socket(AF_INET6, SOCK_DGRAM, 0)) < 0) {
         avahi_log_warn("socket() failed: %s", strerror(errno));
@@ -407,7 +426,7 @@ int avahi_open_socket_ipv6(int no_reuse) {
 
     memset(&local, 0, sizeof(local));
     local.sin6_family = AF_INET6;
-    local.sin6_port = htons(AVAHI_MDNS_PORT);
+    local.sin6_port = htons(proto == AVAHI_LLMNR ? AVAHI_LLMNR_PORT : AVAHI_MDNS_PORT);
 
     if (no_reuse)
         r = bind(fd, (struct sockaddr*) &local, sizeof(local));
@@ -473,7 +492,8 @@ int avahi_send_dns_packet_ipv4(
         AvahiDnsPacket *p,
         const AvahiIPv4Address *src_address,
         const AvahiIPv4Address *dst_address,
-        uint16_t dst_port) {
+        uint16_t dst_port,
+        AvahiPublishProtocol proto) {
 
     struct sockaddr_in sa;
     struct msghdr msg;
@@ -491,9 +511,10 @@ int avahi_send_dns_packet_ipv4(
     assert(avahi_dns_packet_check_valid(p) >= 0);
     assert(!dst_address || dst_port > 0);
 
-    if (!dst_address)
-        mdns_mcast_group_ipv4(&sa);
-    else
+    if (!dst_address) {
+        assert(proto != AVAHI_WIDE_AREA);
+        mcast_group_ipv4(&sa, proto);
+    } else 
         ipv4_address_to_sockaddr(&sa, dst_address, dst_port);
 
     memset(&io, 0, sizeof(io));
@@ -567,7 +588,8 @@ int avahi_send_dns_packet_ipv6(
         AvahiDnsPacket *p,
         const AvahiIPv6Address *src_address,
         const AvahiIPv6Address *dst_address,
-        uint16_t dst_port) {
+        uint16_t dst_port,
+        AvahiPublishProtocol proto) {
 
     struct sockaddr_in6 sa;
     struct msghdr msg;
@@ -580,9 +602,10 @@ int avahi_send_dns_packet_ipv6(
     assert(avahi_dns_packet_check_valid(p) >= 0);
     assert(!dst_address || dst_port > 0);
 
-    if (!dst_address)
-        mdns_mcast_group_ipv6(&sa);
-    else
+    if (!dst_address) {
+        assert(proto != AVAHI_WIDE_AREA);
+        mcast_group_ipv6(&sa, proto);
+    } else 
         ipv6_address_to_sockaddr(&sa, dst_address, dst_port);
 
     memset(&io, 0, sizeof(io));
diff --git a/avahi-core/socket.h b/avahi-core/socket.h
index 92f12d7..6dd3c26 100644
--- a/avahi-core/socket.h
+++ b/avahi-core/socket.h
@@ -22,26 +22,30 @@
 
 #include <inttypes.h>
 
+#include <avahi-common/defs.h>
 #include "dns.h"
 
 #define AVAHI_MDNS_PORT 5353
 #define AVAHI_DNS_PORT 53
 #define AVAHI_IPV4_MCAST_GROUP "224.0.0.251"
 #define AVAHI_IPV6_MCAST_GROUP "ff02::fb"
+#define AVAHI_LLMNR_PORT 5355
+#define AVAHI_IPV4_LLMNR_GROUP "224.0.0.252"
+#define AVAHI_IPV6_LLMNR_GROUP "ff02:0:0:0:0:0:1:3"
 
-int avahi_open_socket_ipv4(int no_reuse);
-int avahi_open_socket_ipv6(int no_reuse);
+int avahi_open_socket_ipv4(int no_reuse, AvahiPublishProtocol proto);
+int avahi_open_socket_ipv6(int no_reuse, AvahiPublishProtocol proto);
 
 int avahi_open_unicast_socket_ipv4(void);
 int avahi_open_unicast_socket_ipv6(void);
 
-int avahi_send_dns_packet_ipv4(int fd, AvahiIfIndex iface, AvahiDnsPacket *p, const AvahiIPv4Address *src_address, const AvahiIPv4Address *dst_address, uint16_t dst_port);
-int avahi_send_dns_packet_ipv6(int fd, AvahiIfIndex iface, AvahiDnsPacket *p, const AvahiIPv6Address *src_address, const AvahiIPv6Address *dst_address, uint16_t dst_port);
+int avahi_send_dns_packet_ipv4(int fd, AvahiIfIndex iface, AvahiDnsPacket *p, const AvahiIPv4Address *src_address, const AvahiIPv4Address *dst_address, uint16_t dst_port, AvahiPublishProtocol proto);
+int avahi_send_dns_packet_ipv6(int fd, AvahiIfIndex iface, AvahiDnsPacket *p, const AvahiIPv6Address *src_address, const AvahiIPv6Address *dst_address, uint16_t dst_port, AvahiPublishProtocol proto);
 
 AvahiDnsPacket *avahi_recv_dns_packet_ipv4(int fd, AvahiIPv4Address *ret_src_address, uint16_t *ret_src_port, AvahiIPv4Address *ret_dst_address, AvahiIfIndex *ret_iface, uint8_t *ret_ttl);
 AvahiDnsPacket *avahi_recv_dns_packet_ipv6(int fd, AvahiIPv6Address *ret_src_address, uint16_t *ret_src_port, AvahiIPv6Address *ret_dst_address, AvahiIfIndex *ret_iface, uint8_t *ret_ttl);
 
-int avahi_mdns_mcast_join_ipv4(int fd, const AvahiIPv4Address *local_address, int iface, int join);
-int avahi_mdns_mcast_join_ipv6(int fd, const AvahiIPv6Address *local_address, int iface, int join);
+int avahi_mcast_join_ipv4(int fd, const AvahiIPv4Address *local_address, int iface, int join, AvahiPublishProtocol proto);
+int avahi_mcast_join_ipv6(int fd, const AvahiIPv6Address *local_address, int iface, int join, AvahiPublishProtocol proto);
 
 #endif
diff --git a/avahi-core/verify.c b/avahi-core/verify.c
new file mode 100644
index 0000000..0aa8c4f
--- /dev/null
+++ b/avahi-core/verify.c
@@ -0,0 +1,489 @@
+#include <string.h>
+#include <stdio.h>
+
+#include <avahi-common/timeval.h>
+#include <avahi-common/malloc.h>
+
+#include "log.h"
+#include "rr-util.h"
+
+#include "verify.h"
+
+static void check_established (AvahiSEntryGroup *group) {
+    assert(group);
+    assert(group->type == AVAHI_GROUP_LLMNR);
+
+    /* Check for the state */
+    if (group->proto.llmnr.n_verifying == 0) 
+        avahi_s_entry_group_change_state(group, AVAHI_ENTRY_GROUP_LLMNR_ESTABLISHED);
+}
+
+/* Decrease the n_verifying counter and free the 'lq' object */
+static void decrease_n_verify(AvahiLLMNREntryVerify *ev) {
+    assert(ev);
+    assert(ev->e->group->type == AVAHI_GROUP_LLMNR);
+
+    /* 
+     * 1. Group is new and presently the state is verifying and decreasing the counter
+     *    may enter the group in established state.
+     * 2. Group is already established and we are registering a new entry, we should have 
+     *    n_verifying greater than zero 
+     */
+    assert((ev->e->group->state == AVAHI_ENTRY_GROUP_LLMNR_VERIFYING) ||
+           (ev->e->group->proto.llmnr.n_verifying > 0));
+
+    --ev->e->group->proto.llmnr.n_verifying;
+    check_established(ev->e->group);
+}
+
+static void withdraw_llmnr_entry(AvahiServer *s, AvahiEntry *e) {
+    assert(s);
+    assert(e);
+    assert(e->type == AVAHI_ENTRY_LLMNR);
+
+    /* Withdraw the specified entry, and if is part of an entry group,
+     * put that into LLMNR_COLLISION state */
+    if (e->dead) 
+        return;
+
+    if (e->group) {
+        AvahiEntry *k;       
+        assert(e->group->type == AVAHI_GROUP_LLMNR);
+
+        /* Withdraw all entries of that group */
+        for (k = e->group->entries; k; k = k->by_group_next) {
+            assert(k->type == AVAHI_ENTRY_LLMNR);
+            if (!k->dead) 
+                k->dead = 1;
+            }
+
+            e->group->proto.llmnr.n_verifying = 0;
+            avahi_s_entry_group_change_state(e->group, AVAHI_ENTRY_GROUP_LLMNR_COLLISION);
+        } else 
+            e->dead = 1;
+
+    s->llmnr.need_entry_cleanup = 1;
+    return;
+}
+
+/* This function is called when 'AvahiLLMNRQuery' has been processed completely.
+Based on the data we get in 'userdata', state of the 'AvahiLLMNREntryVerifier' is decided*/
+static void query_callback(
+    AvahiIfIndex idx,
+    AvahiProtocol protocol,
+    AvahiRecord *r,
+    void *userdata) {
+    /* Get AvahiLLMNREntryVerify object, responder address and 'T' bit info, if any*/
+
+    AvahiVerifierData *vdata = userdata;
+    int win, t_bit ;
+
+    AvahiLLMNREntryVerify *ev;
+    const AvahiAddress *address;
+
+    win = 0;
+    ev = (vdata->ev);
+    address = (vdata->address);
+    t_bit = (vdata->t_bit);
+
+    /* May be by the time we come back in this function due to conflict in some other entry
+    of the group this entry belongs to, this entry has already been put up in the dead state.*/
+    if (ev->e->dead) 
+        return;
+
+    assert(AVAHI_IF_VALID(idx));
+    assert(AVAHI_PROTO_VALID(protocol));
+    assert(userdata);
+    assert(ev->e->type == AVAHI_ENTRY_LLMNR);
+    assert(!ev->e->dead);
+
+    /* Start comparing values.*/
+    if (ev->state == AVAHI_CONFLICT) {
+        /* Set by handle_response function*/
+        /* There is already a conflict about this key or name is not UNIQUE */
+        /* Withdraw this Entry*/
+        withdraw_llmnr_entry(ev->s, ev->e);
+    } else {
+        if (!r && !address) {
+            /* No record found for this key. Our name is unique. */
+            /*char *t;
+            t = avahi_record_to_string(ev->e->record);
+            avahi_log_info("LLMNR Entry Verified\n %s on interface index (%d) and protocol : %s",
+                t, 
+                ev->interface->hardware->index, 
+                avahi_proto_to_string(ev->interface->protocol));*/
+
+            ev->state = AVAHI_VERIFIED;
+
+            if (ev->e->group) 
+                decrease_n_verify(ev);
+        } else {
+            /* We may have two cases now !r && address || r && !address
+            r && !address when T bit is clear
+            !r && address when T bit is set */
+
+            /*  So check 'T' bit first*/
+            if (!(t_bit)) {
+		static uint64_t decreased[2] = {0, 0};
+                AvahiInterface *i;
+                int n;
+                /* Assert that we had a response for this key */
+                assert(r);
+
+                /* Check for any matches on this system */
+                for (i = ev->s->monitor->interfaces; i; i = i->interface_next) {
+                    if (r->key->type == AVAHI_DNS_TYPE_A) {
+                        if ((memcmp(&(i->llmnr.local_llmnr_address.data.ipv4.address), &(r->data.a.address.address), sizeof(AvahiIPv4Address))) == 0)
+                            break;
+                    }
+                    else if (r->key->type == AVAHI_DNS_TYPE_AAAA) {
+                        if ((memcmp(&(i->llmnr.local_llmnr_address.data.ipv6.address), &(r->data.aaaa.address.address), sizeof(AvahiIPv6Address))) == 0)
+                            break;
+                    }
+                    n++;
+                }
+                if (i) {
+                    /* Found a local match, so we're okay. */
+                    n = ev->interface->hardware->index;
+                    if (!(decreased[0] & (1<<n))) {
+			decreased[0] |= (1<<n);
+                        if (ev->e->group)
+                            decrease_n_verify(ev);
+                    }
+                    else if (!(decreased[1] & (1<<n))) {
+			decreased[1] |= (1<<n);
+                        if (ev->e->group)
+                            decrease_n_verify(ev);
+                    }
+                }
+                else
+                {
+                    /* Another host has already claimed for this name and is using it.*/
+                    ev->state = AVAHI_CONFLICT;
+
+                    /* withdraw this entry */
+                    withdraw_llmnr_entry(ev->s, ev->e);
+                }
+            } else {
+                /* 'T' bit is set. Now we compare two IP addresses lexicographically*/
+                assert(protocol == address->proto);
+
+                /* Source IP address = which is being used by interface to join LLMNR group
+                We compare that address and responder address */
+                assert(ev->interface->llmnr.llmnr_joined);
+
+                if ( (protocol == AVAHI_PROTO_INET) && 
+                    (memcmp(&(ev->interface->llmnr.local_llmnr_address.data.ipv4.address), &(address->data.ipv4.address), sizeof(AvahiIPv4Address))) )
+                    win = 1;
+                else /*( protocol == AVAHI_PROTO_INET6) */
+                    if (memcmp(&(ev->interface->llmnr.local_llmnr_address.data.ipv6.address), &(address->data.ipv6.address), sizeof(AvahiIPv6Address)))
+                    win = 1;
+
+                if (win) {
+                    /* We can claim this name */
+                    ev->state = AVAHI_ESTABLISHED;
+                    decrease_n_verify(ev);
+                } else {
+                    ev->state = AVAHI_CONFLICT;
+                    withdraw_llmnr_entry(ev->s, ev->e);
+                }
+            }
+        }
+    }
+
+    ev->lq = NULL;
+    return;
+}
+
+static void remove_verifier(AvahiServer *s, AvahiLLMNREntryVerify *ev) {
+    assert(s);
+    assert(ev);
+    assert(ev->e->type == AVAHI_ENTRY_LLMNR);
+
+    if (ev->lq)
+        avahi_llmnr_query_scheduler_withdraw_by_id(ev->interface->llmnr.query_scheduler, ev->lq->post_id);
+
+    AVAHI_LLIST_REMOVE(AvahiLLMNREntryVerify, by_interface, ev->interface->llmnr.verifiers, ev);
+    AVAHI_LLIST_REMOVE(AvahiLLMNREntryVerify, by_entry, ev->e->proto.llmnr.verifiers, ev);
+
+    avahi_free(ev);
+}
+
+static AvahiLLMNREntryVerify *get_verifier(AvahiServer *s, AvahiInterface *i, AvahiEntry *e) {
+    AvahiLLMNREntryVerify *ev;
+
+    assert(s);
+    assert(i);
+    assert(e);
+    assert(e->type == AVAHI_ENTRY_LLMNR);
+
+    for (ev = e->proto.llmnr.verifiers; ev; ev = ev->by_entry_next) {
+        if (ev->interface == i) 
+            return ev;
+    }
+
+    return NULL;
+}
+
+static void set_state(AvahiLLMNREntryVerify *ev) {
+    AvahiEntry *e;
+    assert(ev);
+
+    e = ev->e;
+    assert(e->type == AVAHI_ENTRY_LLMNR);
+
+    if ((e->flags & AVAHI_PUBLISH_UNIQUE) && !(e->flags & AVAHI_PUBLISH_NO_VERIFY))
+        ev->state = AVAHI_VERIFYING;
+    else
+        ev->state = AVAHI_ESTABLISHED;
+
+    if (ev->state == AVAHI_VERIFYING) {
+        /* Structure to send in AvahiLLMNRQuery*/
+        struct AvahiVerifierData *vdata;
+
+        vdata = avahi_new(AvahiVerifierData, 1);
+        /* Fill AvahiLLMNREntryVerify*/
+        vdata->ev = ev;
+
+        /* Both these fields are filled by handle_response*/
+        vdata->address = NULL;
+
+        /* If we get the response with t bit clear we don't touch this entry*/
+        /* If we get the response with t bit set we set it so bt edfault keep it zero.*/
+        vdata->t_bit = 0;
+
+        /* Initiate Query */
+        ev->lq = avahi_llmnr_query_add(ev->interface, e->record->key, AVAHI_LLMNR_UNIQUENESS_VERIFICATION_QUERY, query_callback, vdata);
+
+        /* Increase n_verify */
+        if (e->group) {
+            assert(e->group->type == AVAHI_GROUP_LLMNR);
+            e->group->proto.llmnr.n_verifying++;
+        }
+
+    } else { /*ev->state == AVAHI_ESTABLISHED */
+        if (ev->e->group)
+            check_established(ev->e->group);
+    }
+}
+
+static void new_verifier(AvahiServer *s, AvahiInterface *i, AvahiEntry *e) {
+    AvahiLLMNREntryVerify *ev;
+
+    assert(s);
+    assert(i);
+    assert(e);
+    assert(!e->dead);
+    assert(e->type == AVAHI_ENTRY_LLMNR);  
+
+    if ( !avahi_interface_match (i, e->interface, e->protocol) || 
+        !i->llmnr.verifying || 
+        !avahi_entry_is_commited(e) )
+        /* start verifying rr's only when group has been commited */
+        return;
+
+    if (get_verifier(s, i, e))
+        return;
+
+    if (!(ev = avahi_new(AvahiLLMNREntryVerify, 1)))
+        return;
+
+    ev->s= s;
+    ev->interface = i;
+    ev->e = e;
+    ev->lq = NULL;
+
+    AVAHI_LLIST_PREPEND(AvahiLLMNREntryVerify, by_interface, i->llmnr.verifiers, ev);
+    AVAHI_LLIST_PREPEND(AvahiLLMNREntryVerify, by_entry, e->proto.llmnr.verifiers, ev);
+
+    set_state(ev);
+}
+
+void avahi_verify_interface(AvahiServer *s, AvahiInterface *i) {   
+    AvahiEntry *e;
+
+    assert(s);
+    assert(i);
+
+    if (!i->llmnr.verifying)
+        return;
+
+    for (e = s->llmnr.entries; e;e =  e->entries_next)
+        if (!e->dead)
+            new_verifier(s, i, e);
+}
+
+static void verify_entry_walk_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, void * userdata) {
+    AvahiEntry *e = userdata;
+
+    assert(m);
+    assert(i);  
+    assert(e);
+    assert(!e->dead);
+
+    new_verifier(m->server, i, e);
+}
+
+void avahi_verify_entry(AvahiServer *s, AvahiEntry *e) {
+    assert(s);
+    assert(e);
+    assert((!e->dead) && (e->type == AVAHI_ENTRY_LLMNR));
+
+    avahi_interface_monitor_walk(s->monitor, e->interface, e->protocol, verify_entry_walk_callback, e);
+}
+
+void avahi_verify_group(AvahiServer *s, AvahiSEntryGroup *g) {
+    AvahiEntry *e;
+
+    assert(s);
+    assert(g);
+    assert(g->type == AVAHI_GROUP_LLMNR);
+
+    for (e = g->entries; e; e = e->by_group_next) {
+        if (!e->dead)
+            avahi_verify_entry(s, e);
+    }
+}
+
+int avahi_llmnr_entry_is_verifying(AvahiServer *s, AvahiEntry *e, AvahiInterface *i) { 
+    AvahiLLMNREntryVerify *ev;
+
+    assert(s);
+    assert(e);
+    assert(i);
+    assert((!e->dead) && (e->type == AVAHI_ENTRY_LLMNR));
+
+    if ( !(ev = get_verifier(s, i, e)) ||
+        (ev->state == AVAHI_CONFLICT))
+        return -1;
+
+    if (ev->state == AVAHI_VERIFYING)
+        return 1;
+
+    assert(ev->state == AVAHI_VERIFIED);
+
+    return 0;
+}
+
+void avahi_llmnr_entry_return_to_initial_state(AvahiServer *s, AvahiEntry *e, AvahiInterface *i) {
+    AvahiLLMNREntryVerify *ev;
+
+    assert(s);
+    assert(e);
+    assert(i);
+    assert((!e->dead) && (e->type == AVAHI_ENTRY_LLMNR));
+
+    if (!(ev = get_verifier(s, i, e)))
+        return;
+
+    if (ev->state == AVAHI_VERIFYING) {
+        if (ev->e->group) {
+            avahi_llmnr_query_destroy(ev->lq);
+            ev->lq = NULL;
+
+            assert(ev->e->group->type == AVAHI_GROUP_LLMNR);
+            ev->e->group->proto.llmnr.n_verifying--;
+        }
+    }
+
+    set_state(ev);
+}
+
+static void avahi_reverify(AvahiLLMNREntryVerify *ev) {
+    AvahiEntry *e;
+    AvahiVerifierData *vdata;
+
+    assert(ev);
+
+    if (!(vdata = avahi_new(AvahiVerifierData, 1)))
+        return;
+
+    e = ev->e;
+
+    if (e->group)
+        assert(e->group->type == AVAHI_GROUP_LLMNR);
+
+    /* Group has not been commited yet, nothing to reverify*/
+    if (e->group && (e->group->state = AVAHI_ENTRY_GROUP_LLMNR_UNCOMMITED || e->group->state == AVAHI_ENTRY_GROUP_LLMNR_COLLISION))
+        return;
+
+    /* STATE == AVAHI_VERIFYING : Free the lq object and if entry belongs to
+    a group decrease the n_verifying counter. NEW STATE : _VERIFYING*/
+    if (ev->state == AVAHI_VERIFYING) {
+        if (e->group)
+            e->group->proto.llmnr.n_verifying--;
+
+    } else if ((ev->state == AVAHI_LLMNR_ESTABLISHED) && (e->flags & AVAHI_PUBLISH_UNIQUE) && !(e->flags & AVAHI_PUBLISH_NO_VERIFY))
+        /* _ESTABLISHED but _VERIFY again*/
+        ev->state = AVAHI_VERIFYING;
+
+    else
+        ev->state = AVAHI_ESTABLISHED;
+
+    /* New state has been decided */
+
+    if (ev->state == AVAHI_VERIFYING) {
+
+        vdata->ev = ev;
+        vdata->address = NULL;
+        vdata->t_bit = 0;
+
+        /* Start the queries */
+        avahi_llmnr_query_add(ev->interface, e->record->key, AVAHI_LLMNR_UNIQUENESS_VERIFICATION_QUERY, query_callback, vdata);
+
+        /* Increase the counter if it belongs to a group */
+        if (e->group) 
+            e->group->proto.llmnr.n_verifying++;
+
+    } else 
+        if (e->group)
+            check_established(e->group);
+}
+
+static void reannounce_walk_callback(AvahiInterfaceMonitor *m, AvahiInterface *i, void* userdata) {
+    AvahiEntry *e = userdata;
+    AvahiLLMNREntryVerify *ev;
+
+    assert(m);
+    assert(i);
+    assert(e);
+    assert((!e->dead) && (e->type == AVAHI_ENTRY_LLMNR));
+
+    if (!(ev = get_verifier(m->server, i, e)))
+        return;
+
+    avahi_reverify(ev);
+}
+
+void avahi_reverify_entry(AvahiServer *s, AvahiEntry *e) {
+
+    assert(s);
+    assert(e);
+    assert(!e->dead && e->type == AVAHI_ENTRY_LLMNR);
+
+    avahi_interface_monitor_walk(s->monitor, e->interface, e->protocol, reannounce_walk_callback, e);
+}
+
+void avahi_remove_verifiers(AvahiServer *s, AvahiEntry *e) {
+    assert(s);
+    assert(e);
+    assert(e->type == AVAHI_ENTRY_LLMNR);
+
+    while (e->proto.llmnr.verifiers)
+        remove_verifier(s, e->proto.llmnr.verifiers);
+}
+
+AvahiLLMNREntryVerifyState avahi_llmnr_entry_verify_state(AvahiLLMNREntryVerify *ev) {
+    assert(ev);
+
+    return (ev->state);
+}
+
+void avahi_remove_interface_verifiers(AvahiServer *s, AvahiInterface *i) {
+    assert(s);
+    assert(i);
+
+    while (i->llmnr.verifiers)
+        remove_verifier(s, i->llmnr.verifiers);
+}
+
diff --git a/avahi-core/verify.h b/avahi-core/verify.h
new file mode 100644
index 0000000..d1b0624
--- /dev/null
+++ b/avahi-core/verify.h
@@ -0,0 +1,57 @@
+#ifndef fooverifyhbar
+#define fooverifyhbar
+
+typedef struct AvahiLLMNREntryVerify AvahiLLMNREntryVerify;
+typedef struct AvahiVerifierData AvahiVerifierData;
+
+#include <avahi-common/address.h>
+
+#include "internal.h"
+#include "publish.h"
+
+/* State of the verifier */
+typedef enum {
+    AVAHI_VERIFYING,
+    AVAHI_CONFLICT,
+    AVAHI_VERIFIED,
+    AVAHI_LLMNR_ESTABLISHED
+} AvahiLLMNREntryVerifyState;
+
+/* AvahiLLMNREntryVerify */
+struct AvahiLLMNREntryVerify {
+    AvahiServer *s; 
+    AvahiInterface *interface; 
+    AvahiEntry *e;
+
+    AvahiLLMNRQuery *lq;
+    AvahiLLMNREntryVerifyState state;
+
+    AVAHI_LLIST_FIELDS(AvahiLLMNREntryVerify, by_interface);
+    AVAHI_LLIST_FIELDS(AvahiLLMNREntryVerify, by_entry);
+};
+
+/* This structure is passed as userdata in AvahiLLMNRQuery */
+struct AvahiVerifierData {
+    AvahiLLMNREntryVerify *ev;
+    const AvahiAddress *address;
+    int t_bit;
+};
+
+void avahi_verify_interface(AvahiServer *s, AvahiInterface *i);
+void avahi_verify_entry(AvahiServer *s, AvahiEntry *e);
+void avahi_verify_group(AvahiServer *s, AvahiSEntryGroup *g);
+
+void avahi_llmnr_entry_return_to_initial_state(AvahiServer *s, AvahiEntry *e, AvahiInterface *i);
+
+/* returns -1 if there is no verifier or state is AVAHI_CONFLICT for this entry */
+/* returns 1 if state is AVAHI_VERFYING */
+/* return 0 if state is AVHAI_VERIFIED */
+int avahi_llmnr_entry_is_verifying(AvahiServer *s, AvahiEntry *e, AvahiInterface *i);
+/* AvahiLLMNREntryVerify* get_verifier(AvahiSLLMNR *sl, AvahiInterface *i, AvahiEntry *e)*/
+
+void avahi_reverify_entry(AvahiServer *s, AvahiEntry *e);
+AvahiLLMNREntryVerifyState avahi_llmnr_entry_verify_state(AvahiLLMNREntryVerify *ev);
+void avahi_remove_verifiers(AvahiServer *s, AvahiEntry *e);
+void avahi_remove_interface_verifiers(AvahiServer *s, AvahiInterface *i);
+
+#endif /* fooverifyhbar */
diff --git a/avahi-core/wide-area.c b/avahi-core/wide-area.c
index d5e64e5..e582b39 100644
--- a/avahi-core/wide-area.c
+++ b/avahi-core/wide-area.c
@@ -139,7 +139,7 @@ static int send_to_dns_server(AvahiWideAreaLookup *l, AvahiDnsPacket *p) {
         if (l->engine->fd_ipv4 < 0)
             return -1;
 
-        return avahi_send_dns_packet_ipv4(l->engine->fd_ipv4, AVAHI_IF_UNSPEC, p, NULL, &a->data.ipv4, AVAHI_DNS_PORT);
+        return avahi_send_dns_packet_ipv4(l->engine->fd_ipv4, AVAHI_IF_UNSPEC, p, NULL, &a->data.ipv4, AVAHI_DNS_PORT, AVAHI_WIDE_AREA);
 
     } else {
         assert(a->proto == AVAHI_PROTO_INET6);
@@ -147,7 +147,7 @@ static int send_to_dns_server(AvahiWideAreaLookup *l, AvahiDnsPacket *p) {
         if (l->engine->fd_ipv6 < 0)
             return -1;
 
-        return avahi_send_dns_packet_ipv6(l->engine->fd_ipv6, AVAHI_IF_UNSPEC, p, NULL, &a->data.ipv6, AVAHI_DNS_PORT);
+        return avahi_send_dns_packet_ipv6(l->engine->fd_ipv6, AVAHI_IF_UNSPEC, p, NULL, &a->data.ipv6, AVAHI_DNS_PORT, AVAHI_WIDE_AREA);
     }
 }
 
diff --git a/avahi-daemon/hosts b/avahi-daemon/hosts
index 4483340..89d11b5 100644
--- a/avahi-daemon/hosts
+++ b/avahi-daemon/hosts
@@ -17,11 +17,19 @@
 
 # This file contains static ip address <-> host name mappings.  These
 # can be useful to publish services on behalf of a non-avahi enabled
-# device. Please bear in mind that host names are expected to be
-# fully qualified domain names, i.e. ending in .local!
+# device. 
 
+# <address> <host name> <publish protocol : UNSPEC/mDNS/LLMNR>
+# UNSPEC : If you don't know what to do.
+# mDNS : If you want to publish host name using mDNS protocol, Please 
+# bear in mind that host names published using mDNS are expected to be 
+# fully qualified domain names, i.e. ending in .local!
+# LLMNR : If you want to publish name using LLMNR protocol. In this case
+# host name could be a single label name or FQDN.
 # See avahi.hosts(5) for more information on this configuration file!
 
 # Examples:
-# 192.168.0.1 router.local
-# 2001::81:1 test.local
+#10.1.147.1 orange.local mDNS
+#10.1.147.2 mango LLMNR
+#10.1.147.2 router.local UNSPEC
+#2001::81:1 test.local UNSPEC
diff --git a/avahi-daemon/static-hosts.c b/avahi-daemon/static-hosts.c
index 34f531f..9d67d19 100644
--- a/avahi-daemon/static-hosts.c
+++ b/avahi-daemon/static-hosts.c
@@ -42,6 +42,7 @@ struct StaticHost {
 
     char *host;
     AvahiAddress address;
+    int publish_proto;	/*0/mDNS/LLMNR*/
 
     AVAHI_LLIST_FIELDS(StaticHost, hosts);
 };
@@ -107,14 +108,15 @@ static void static_host_free(StaticHost *s) {
     avahi_free(s);
 }
 
-static StaticHost *static_host_find(const char *host, const AvahiAddress *a) {
+static StaticHost *static_host_find(const char *host, const AvahiAddress *a, int publish_proto) {
     StaticHost *h;
 
     assert(host);
     assert(a);
 
     for (h = hosts; h; h = h->hosts_next)
-        if (!strcmp(h->host, host) && !avahi_address_cmp(a, &h->address))
+        if (!strcmp(h->host, host) && !avahi_address_cmp(a, &h->address) &&
+            (h->publish_proto == 0 || h->publish_proto == publish_proto))
             return h;
 
     return NULL;
@@ -138,7 +140,7 @@ static void add_static_host_to_server(StaticHost *h)
         p = (h->address.proto == AVAHI_PROTO_INET && config->publish_a_on_ipv6) ||
             (h->address.proto == AVAHI_PROTO_INET6 && config->publish_aaaa_on_ipv4) ? AVAHI_PROTO_UNSPEC : h->address.proto;
 
-        if ((err = avahi_server_add_address(avahi_server, h->group, AVAHI_IF_UNSPEC, p, 0, h->host, &h->address)) < 0) {
+        if ((err = avahi_server_add_address(avahi_server, h->group, AVAHI_IF_UNSPEC, p, h->publish_proto, h->host, &h->address)) < 0) {
             avahi_log_error ("Static host name %s: avahi_server_add_address failure: %s", h->host, avahi_strerror(err));
             return;
         }
@@ -153,6 +155,24 @@ static void remove_static_host_from_server(StaticHost *h)
         avahi_s_entry_group_reset (h->group);
 }
 
+static int avahi_proto_to_value(char *publish_proto, int *value) {
+    assert(publish_proto);
+
+    if (!strcmp(publish_proto, "mDNS"))
+        *value = AVAHI_PUBLISH_USE_MULTICAST;
+
+    else if (!strcmp(publish_proto, "LLMNR"))
+        *value = AVAHI_PUBLISH_USE_LLMNR;
+
+    else if (!strcmp(publish_proto, "UNSPEC"))
+        *value = 0;
+
+    else
+        return 0;
+
+    return 1;
+}
+
 void static_hosts_add_to_server(void) {
     StaticHost *h;
 
@@ -184,8 +204,9 @@ void static_hosts_load(int in_chroot) {
     while (!feof(f)) {
         unsigned int len;
         char ln[256], *s;
-        char *host, *ip;
+        char *host, *ip, *publish_proto;
         AvahiAddress a;
+        int publish_proto_value;
 
         if (!fgets(ln, sizeof (ln), f))
             break;
@@ -208,7 +229,7 @@ void static_hosts_load(int in_chroot) {
         /* Skip past it */
         s += len;
 
-        /* Find the next token */
+        /* Find the next token i.e host */
         s += strspn(s, " \t");
         len = strcspn(s, " \t");
         host = avahi_strndup(s, len);
@@ -224,6 +245,23 @@ void static_hosts_load(int in_chroot) {
         /* Skip over the host */
         s += len;
 
+        /* Find the next token i.e protocol */
+        s += strspn(s, " \t");
+        len = strcspn(s, " \t");
+        publish_proto = avahi_strndup(s, len);
+
+        if (*publish_proto == 0)
+        {
+            avahi_log_error("%s:%d: Error, unexpected end of line!", filename, line);
+            avahi_free(publish_proto);
+            avahi_free(host);
+            avahi_free(ip);
+            goto fail;
+        }
+
+        /* Skip over the proto */
+        s += len;
+
         /* Skip past any more spaces */
         s += strspn(s, " \t");
 
@@ -237,6 +275,7 @@ void static_hosts_load(int in_chroot) {
 
         if (!avahi_address_parse(ip, AVAHI_PROTO_UNSPEC, &a)) {
             avahi_log_error("Static host name %s: failed to parse address %s", host, ip);
+            avahi_free(publish_proto);
             avahi_free(host);
             avahi_free(ip);
             goto fail;
@@ -244,12 +283,22 @@ void static_hosts_load(int in_chroot) {
 
         avahi_free(ip);
 
-        if ((h = static_host_find(host, &a)))
+        if(!avahi_proto_to_value(publish_proto, &publish_proto_value)) {
+            avahi_log_error("Static host name %s: failed to parse publish protocol %s", host, ip);
+            avahi_free(publish_proto);
+            avahi_free(host);
+            avahi_free(ip);
+            goto fail;
+        }
+        avahi_free(publish_proto);
+
+        if ((h = static_host_find(host, &a, publish_proto_value)))
             avahi_free(host);
         else {
             h = static_host_new();
             h->host = host;
             h->address = a;
+            h->publish_proto = publish_proto_value;
 
             avahi_log_info("Loading new static hostname %s.", h->host);
         }
-- 
1.7.4.4
--- a/avahi-core/iface-pfroute.c	2010-08-25 17:51:38.987153000 -0700
+++ b/avahi-core/iface-pfroute.c	2012-05-03 19:40:54.960262868 -0700
@@ -104,7 +104,8 @@ static void rtm_info(struct rt_msghdr *r
 /* 		    hw->flags_ok); */
 /*   } */
 
-  avahi_hw_interface_check_relevant(hw);
+  avahi_hw_interface_check_relevant(hw, AVAHI_MDNS);
+  avahi_hw_interface_check_relevant(hw, AVAHI_LLMNR);
   avahi_hw_interface_update_rrs(hw, 0);
 }
 
@@ -230,7 +231,8 @@ static void rtm_addr(struct rt_msghdr *r
       avahi_interface_address_free(addriface);
     }
 
-  avahi_interface_check_relevant(iface);
+  avahi_interface_check_relevant(iface, AVAHI_MDNS);
+  avahi_interface_check_relevant(iface, AVAHI_LLMNR);
   avahi_interface_update_rrs(iface, 0);
 }
 
@@ -444,7 +446,8 @@ static void if_add_interface(struct lifr
 
     addriface->global_scope = 1;
 
-    avahi_hw_interface_check_relevant(hw);
+    avahi_hw_interface_check_relevant(hw, AVAHI_MDNS);
+    avahi_hw_interface_check_relevant(hw, AVAHI_LLMNR);
     avahi_hw_interface_update_rrs(hw, 0);
 }
 #endif
@@ -532,7 +535,8 @@ void avahi_interface_monitor_sync(AvahiI
         lifreq++;
     }
     m->list_complete = 1;
-    avahi_interface_monitor_check_relevant(m);
+    avahi_interface_monitor_check_relevant(m, AVAHI_MDNS);
+    avahi_interface_monitor_check_relevant(m, AVAHI_LLMNR);
     avahi_interface_monitor_update_rrs(m, 0);
 end:
     close(sockfd);
